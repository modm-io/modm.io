{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"modm: a barebone embedded library generator \u00b6 modm (pronounced like dial-up \"modem\") is a toolbox for building custom C++17 libraries tailored to your embedded device. modm generates startup code, HALs and their implementations, communication protocols, drivers for external devices, BSPs, etc\u2026 in a modular, customizable process that you can fine-tune to your needs. Check out our install instructions and our getting started guide . Feast your eyes on lots of working examples . Our CI checks every contribution for regressions: We care about testing modm . This project also has a technical blog to document larger design concepts. You found a bug? Open up an issue, we don't bite . You want to contribute? Read the contribution guidelines and open a pull request . modm is optimized for the harsh requirements of the Eurobot competition , where our robots need to run reliably and completely autonomously for the game's 100 second duration. Our robots contain a lot of different microcontrollers, some without a lot of resources, so modm needs to fulfill a diverse set of objectives, like small code size with small memory consumption, predictable program flow, extreme portability. The source code is freely available under the MPLv2 license, so feel free to fork this project and adapt it to your needs. The only thing we ask of you is to contribute your changes back so everyone benefits. Please clone modm recursively, you will need all the submodules. git clone --recurse-submodules https://github.com/modm-io/modm.git Features \u00b6 Efficient and fast object-oriented C++17 API. Support for hundreds of AVR and ARM Cortex-M microcontrollers from Atmel and ST. Build system agnostic: We use SCons by default, but you don't have to. Data-driven HAL generation using the library-builder engine. No memory allocations in HAL with very low overall RAM consumption. Highly-configurable modules with sensible defaults and lots of documentation. Cross platform peripheral interfaces incl. bit banging: GPIO and GPIO expanders. ADC and Analog. UART, I 2 C, SPI, CAN. Interfaces and drivers for many external I 2 C and SPI sensors and devices. Debug/logging system with IOStream interface. Lightweight, stackless threads and resumable functions using cooperative multitasking. Useful filter, interpolation and geometric algorithms. Lightweight unit testing system (suitable for AVRs). Graphical user interface for small binary and color displays. Hundreds of tests to ensure correct functionality. Targets \u00b6 modm can generate code for 76 AVR and 917 STM32 devices, however, there are different levels of support and testing. Device Family Support Device Family Support Device Family Support AVR \u2605\u2605\u2605 STM32F2 \u2605\u2605\u2605 STM32F7 \u2605\u2605\u2605\u2605 STM32F0 \u2605\u2605\u2605\u2605 STM32F3 \u2605\u2605\u2605\u2605\u2605 STM32L4 \u2605\u2605\u2605\u2605 STM32F1 \u2605\u2605\u2605\u2605 STM32F4 \u2605\u2605\u2605\u2605\u2605 STM32G0 \u2605\u2605\u2605\u2605 All of these targets are compiling and booting correctly (\u2605) and have GPIO and UART working (\u2605\u2605). Most targets have support for basic peripherals, like I2C, SPI and ADC (\u2605\u2605\u2605) as well as complicated peripherals, like Timers, CAN and external memory (\u2605\u2605\u2605\u2605). We also use a few targets in everyday development, which are very well tested (\u2605\u2605\u2605\u2605\u2605). We are only a small team of developers and are limited in the amount of targets we can support and test in hardware. We have prepared, but currently not finished support for STM32F2, STM32L0 and STM32L1. Open an issue to ask if your specific target is supported out-of-the-box and what you can do if it's not. Boards \u00b6 We have out-of-box support for several development boards including documentation. AL-AVREB-CAN Arduino NANO Arduino UNO Black Pill Blue Pill DISCO-F051R8 DISCO-F072RB DISCO-F100RB DISCO-F303VC DISCO-F407VG DISCO-F429ZI DISCO-F469NI DISCO-F746NG DISCO-F769NI DISCO-L476VG NUCLEO-F031K6 NUCLEO-F042K6 NUCLEO-F103RB NUCLEO-F303K8 NUCLEO-F401RE NUCLEO-F411RE NUCLEO-F429ZI NUCLEO-G071RB NUCLEO-L432KC NUCLEO-L476RG OLIMEXINO-STM32 STM32F030F4P6-DEMO Drivers \u00b6 We also have a number of completely target-independent drivers for external devices connected via I 2 C, SPI, UART, BitBang, etc. Most of these also give you access to the entire device so you can easily configure them for you specific needs. AD7280A AD7928 ADNS9800 ADS7843 AMS5915 SPI-FLASH BME280 BMP085 DRV832X DS1302 DS1631 DS18B20 EA-DOG FT245 FT6X06 HCLAx HD44780 HMC58x HMC6343 I2C-EEPROM ITG3200 L3GD20 LAWICEL LIS302DL LIS3DSH LM75 LSM303A LTC2984 MAX6966 MAX7219 MCP23X17 MCP2515 NOKIA5110 NRF24 TFT-DISPLAY PAT9125EL PCA8574 PCA9535 PCA9548A PCA9685 SIEMENS-S65 SIEMENS-S75 SSD1306 TCS3414 TCS3472 TMP102 TMP175 VL53L0 VL6180 WS2812 Examples \u00b6 We have a huge number of examples which are always up-to-date and compilable as enforced by our CI. AVR: 1-wire/ds18b20 AVR: adc/basic AVR: adc/oversample AVR: app_can2usb AVR: assert AVR: block_device_mirror AVR: can/mcp2515 AVR: can/mcp2515_uart AVR: display/dogm128/benchmark AVR: display/dogm128/caged_ball AVR: display/dogm128/draw AVR: display/dogm128/image AVR: display/dogm128/text AVR: display/dogm128/touch AVR: display/dogm132 AVR: display/dogm163 AVR: display/hd44780 AVR: display/siemens_s65 AVR: flash AVR: gpio/basic AVR: gpio/blinking AVR: gpio/button_group AVR: logger AVR: ports AVR: protothread AVR: pwm/pca9685 AVR: sab/master AVR: sab/slave AVR: timeout AVR: uart/basic AVR: uart/basic_mega8 AVR: uart/extended AVR: xpcc/receiver AVR: xpcc/sender Arduino UNO: basic/analog_read_serial Arduino UNO: basic/blink Arduino UNO: basic/digital_read_serial Arduino UNO: basic/read_analog_voltage Generic: blinky Generic: i2c_multiplex Generic: resumable Generic: ros/can_bridge Generic: ros/environment Generic: ros/sub_pub Generic: rtc_ds1302 Linux: assert Linux: block_device/file Linux: block_device/mirror Linux: block_device/ram Linux: build_info Linux: can_debugger Linux: git Linux: gui/basic Linux: logger Linux: printf Linux: serial_interface Linux: static_serial_interface Linux: threads Linux: xpcc/basic NUCLEO-F031K6: blink NUCLEO-F042K6: adc NUCLEO-F042K6: blink NUCLEO-F103RB: blink NUCLEO-F103RB: rtos NUCLEO-F303K8: blink NUCLEO-F303K8: rtos NUCLEO-F401RE: blink NUCLEO-F401RE: distance_vl53l0 NUCLEO-F411RE: blink NUCLEO-F411RE: rtos NUCLEO-F411RE: ws2812b NUCLEO-F429ZI: blink NUCLEO-F429ZI: pat9125el NUCLEO-F429ZI: spi_flash NUCLEO-G071RB: blink NUCLEO-G071RB: rtos NUCLEO-L432KC: blink NUCLEO-L432KC: comp NUCLEO-L432KC: gyroscope NUCLEO-L432KC: pwm NUCLEO-L432KC: pwm_advanced NUCLEO-L432KC: uart_spi NUCLEO-L476RG: adc NUCLEO-L476RG: blink NUCLEO-L476RG: i2c_test OLIMEXINO-STM32: blink STM32F0-DISCOVERY: blink STM32F0-DISCOVERY: logger STM32F030F4P6-DEMO-BOARD: blink STM32F072-DISCOVERY: blink STM32F072-DISCOVERY: can STM32F072-DISCOVERY: hard_fault STM32F072-DISCOVERY: rotation STM32F072-DISCOVERY: tmp102 STM32F072-DISCOVERY: uart STM32F072-DISCOVERY: unaligned_access STM32F1-DISCOVERY: blink STM32F1-DISCOVERY: logger STM32F103C8T6-Black Pill: blink STM32F103C8T6-Blue Pill: adns_9800 STM32F103C8T6-Blue Pill: blink STM32F103C8T6-Blue Pill: blink.cmake STM32F103C8T6-Blue Pill: can STM32F103C8T6-Blue Pill: environment STM32F103C8T6-Blue Pill: logger STM32F3-DISCOVERY: accelerometer STM32F3-DISCOVERY: adc/continous STM32F3-DISCOVERY: adc/interrupt STM32F3-DISCOVERY: adc/simple STM32F3-DISCOVERY: blink STM32F3-DISCOVERY: can STM32F3-DISCOVERY: comp STM32F3-DISCOVERY: ft245 STM32F3-DISCOVERY: gdb STM32F3-DISCOVERY: hard_fault STM32F3-DISCOVERY: rotation STM32F3-DISCOVERY: timer/basic STM32F3-DISCOVERY: uart/hal STM32F3-DISCOVERY: uart/logger STM32F4-DISCOVERY: accelerometer STM32F4-DISCOVERY: adc/interrupt STM32F4-DISCOVERY: adc/oversample STM32F4-DISCOVERY: adc/simple STM32F4-DISCOVERY: app_uart_sniffer STM32F4-DISCOVERY: barometer_bmp085_bmp180 STM32F4-DISCOVERY: blink STM32F4-DISCOVERY: can STM32F4-DISCOVERY: can2 STM32F4-DISCOVERY: colour_tcs3414 STM32F4-DISCOVERY: display/hd44780 STM32F4-DISCOVERY: display/nokia_5110 STM32F4-DISCOVERY: display/ssd1306 STM32F4-DISCOVERY: distance_vl6180 STM32F4-DISCOVERY: exti STM32F4-DISCOVERY: fpu STM32F4-DISCOVERY: fsmc STM32F4-DISCOVERY: hard_fault STM32F4-DISCOVERY: led_matrix_display STM32F4-DISCOVERY: open407v-d/gui STM32F4-DISCOVERY: open407v-d/touchscreen STM32F4-DISCOVERY: pressure_ams5915 STM32F4-DISCOVERY: protothreads STM32F4-DISCOVERY: radio/nrf24-basic-comm STM32F4-DISCOVERY: radio/nrf24-data/rx STM32F4-DISCOVERY: radio/nrf24-data/tx STM32F4-DISCOVERY: radio/nrf24-phy-test STM32F4-DISCOVERY: radio/nrf24-scanner STM32F4-DISCOVERY: sab2 STM32F4-DISCOVERY: spi STM32F4-DISCOVERY: temperature_ltc2984 STM32F4-DISCOVERY: timer STM32F4-DISCOVERY: timer_test STM32F4-DISCOVERY: uart STM32F4-DISCOVERY: uart_spi STM32F429-DISCOVERY: blink STM32F429-DISCOVERY: logger STM32F469-DISCOVERY: assert STM32F469-DISCOVERY: blink STM32F469-DISCOVERY: can STM32F469-DISCOVERY: display STM32F469-DISCOVERY: game_of_life STM32F469-DISCOVERY: ports STM32F469-DISCOVERY: tlsf-allocator STM32F469-DISCOVERY: touchscreen STM32F746G-DISCOVERY: adc_ad7928 STM32F746G-DISCOVERY: blink STM32F746G-DISCOVERY: rtos STM32F746G-DISCOVERY: tmp102 STM32F769I-DISCOVERY: blink STM32L476-DISCOVERY: blink Windows: build_info ZMQ: 1_stm32 ZMQ: 2_zmq_gateway ZMQ: 3_zmq_app ZMQ: 4_zmq_backtoback","title":"Introduction"},{"location":"#modm-a-barebone-embedded-library-generator","text":"modm (pronounced like dial-up \"modem\") is a toolbox for building custom C++17 libraries tailored to your embedded device. modm generates startup code, HALs and their implementations, communication protocols, drivers for external devices, BSPs, etc\u2026 in a modular, customizable process that you can fine-tune to your needs. Check out our install instructions and our getting started guide . Feast your eyes on lots of working examples . Our CI checks every contribution for regressions: We care about testing modm . This project also has a technical blog to document larger design concepts. You found a bug? Open up an issue, we don't bite . You want to contribute? Read the contribution guidelines and open a pull request . modm is optimized for the harsh requirements of the Eurobot competition , where our robots need to run reliably and completely autonomously for the game's 100 second duration. Our robots contain a lot of different microcontrollers, some without a lot of resources, so modm needs to fulfill a diverse set of objectives, like small code size with small memory consumption, predictable program flow, extreme portability. The source code is freely available under the MPLv2 license, so feel free to fork this project and adapt it to your needs. The only thing we ask of you is to contribute your changes back so everyone benefits. Please clone modm recursively, you will need all the submodules. git clone --recurse-submodules https://github.com/modm-io/modm.git","title":"modm: a barebone embedded library generator"},{"location":"#features","text":"Efficient and fast object-oriented C++17 API. Support for hundreds of AVR and ARM Cortex-M microcontrollers from Atmel and ST. Build system agnostic: We use SCons by default, but you don't have to. Data-driven HAL generation using the library-builder engine. No memory allocations in HAL with very low overall RAM consumption. Highly-configurable modules with sensible defaults and lots of documentation. Cross platform peripheral interfaces incl. bit banging: GPIO and GPIO expanders. ADC and Analog. UART, I 2 C, SPI, CAN. Interfaces and drivers for many external I 2 C and SPI sensors and devices. Debug/logging system with IOStream interface. Lightweight, stackless threads and resumable functions using cooperative multitasking. Useful filter, interpolation and geometric algorithms. Lightweight unit testing system (suitable for AVRs). Graphical user interface for small binary and color displays. Hundreds of tests to ensure correct functionality.","title":"Features"},{"location":"#targets","text":"modm can generate code for 76 AVR and 917 STM32 devices, however, there are different levels of support and testing. Device Family Support Device Family Support Device Family Support AVR \u2605\u2605\u2605 STM32F2 \u2605\u2605\u2605 STM32F7 \u2605\u2605\u2605\u2605 STM32F0 \u2605\u2605\u2605\u2605 STM32F3 \u2605\u2605\u2605\u2605\u2605 STM32L4 \u2605\u2605\u2605\u2605 STM32F1 \u2605\u2605\u2605\u2605 STM32F4 \u2605\u2605\u2605\u2605\u2605 STM32G0 \u2605\u2605\u2605\u2605 All of these targets are compiling and booting correctly (\u2605) and have GPIO and UART working (\u2605\u2605). Most targets have support for basic peripherals, like I2C, SPI and ADC (\u2605\u2605\u2605) as well as complicated peripherals, like Timers, CAN and external memory (\u2605\u2605\u2605\u2605). We also use a few targets in everyday development, which are very well tested (\u2605\u2605\u2605\u2605\u2605). We are only a small team of developers and are limited in the amount of targets we can support and test in hardware. We have prepared, but currently not finished support for STM32F2, STM32L0 and STM32L1. Open an issue to ask if your specific target is supported out-of-the-box and what you can do if it's not.","title":"Targets"},{"location":"#boards","text":"We have out-of-box support for several development boards including documentation. AL-AVREB-CAN Arduino NANO Arduino UNO Black Pill Blue Pill DISCO-F051R8 DISCO-F072RB DISCO-F100RB DISCO-F303VC DISCO-F407VG DISCO-F429ZI DISCO-F469NI DISCO-F746NG DISCO-F769NI DISCO-L476VG NUCLEO-F031K6 NUCLEO-F042K6 NUCLEO-F103RB NUCLEO-F303K8 NUCLEO-F401RE NUCLEO-F411RE NUCLEO-F429ZI NUCLEO-G071RB NUCLEO-L432KC NUCLEO-L476RG OLIMEXINO-STM32 STM32F030F4P6-DEMO","title":"Boards"},{"location":"#drivers","text":"We also have a number of completely target-independent drivers for external devices connected via I 2 C, SPI, UART, BitBang, etc. Most of these also give you access to the entire device so you can easily configure them for you specific needs. AD7280A AD7928 ADNS9800 ADS7843 AMS5915 SPI-FLASH BME280 BMP085 DRV832X DS1302 DS1631 DS18B20 EA-DOG FT245 FT6X06 HCLAx HD44780 HMC58x HMC6343 I2C-EEPROM ITG3200 L3GD20 LAWICEL LIS302DL LIS3DSH LM75 LSM303A LTC2984 MAX6966 MAX7219 MCP23X17 MCP2515 NOKIA5110 NRF24 TFT-DISPLAY PAT9125EL PCA8574 PCA9535 PCA9548A PCA9685 SIEMENS-S65 SIEMENS-S75 SSD1306 TCS3414 TCS3472 TMP102 TMP175 VL53L0 VL6180 WS2812","title":"Drivers"},{"location":"#examples","text":"We have a huge number of examples which are always up-to-date and compilable as enforced by our CI. AVR: 1-wire/ds18b20 AVR: adc/basic AVR: adc/oversample AVR: app_can2usb AVR: assert AVR: block_device_mirror AVR: can/mcp2515 AVR: can/mcp2515_uart AVR: display/dogm128/benchmark AVR: display/dogm128/caged_ball AVR: display/dogm128/draw AVR: display/dogm128/image AVR: display/dogm128/text AVR: display/dogm128/touch AVR: display/dogm132 AVR: display/dogm163 AVR: display/hd44780 AVR: display/siemens_s65 AVR: flash AVR: gpio/basic AVR: gpio/blinking AVR: gpio/button_group AVR: logger AVR: ports AVR: protothread AVR: pwm/pca9685 AVR: sab/master AVR: sab/slave AVR: timeout AVR: uart/basic AVR: uart/basic_mega8 AVR: uart/extended AVR: xpcc/receiver AVR: xpcc/sender Arduino UNO: basic/analog_read_serial Arduino UNO: basic/blink Arduino UNO: basic/digital_read_serial Arduino UNO: basic/read_analog_voltage Generic: blinky Generic: i2c_multiplex Generic: resumable Generic: ros/can_bridge Generic: ros/environment Generic: ros/sub_pub Generic: rtc_ds1302 Linux: assert Linux: block_device/file Linux: block_device/mirror Linux: block_device/ram Linux: build_info Linux: can_debugger Linux: git Linux: gui/basic Linux: logger Linux: printf Linux: serial_interface Linux: static_serial_interface Linux: threads Linux: xpcc/basic NUCLEO-F031K6: blink NUCLEO-F042K6: adc NUCLEO-F042K6: blink NUCLEO-F103RB: blink NUCLEO-F103RB: rtos NUCLEO-F303K8: blink NUCLEO-F303K8: rtos NUCLEO-F401RE: blink NUCLEO-F401RE: distance_vl53l0 NUCLEO-F411RE: blink NUCLEO-F411RE: rtos NUCLEO-F411RE: ws2812b NUCLEO-F429ZI: blink NUCLEO-F429ZI: pat9125el NUCLEO-F429ZI: spi_flash NUCLEO-G071RB: blink NUCLEO-G071RB: rtos NUCLEO-L432KC: blink NUCLEO-L432KC: comp NUCLEO-L432KC: gyroscope NUCLEO-L432KC: pwm NUCLEO-L432KC: pwm_advanced NUCLEO-L432KC: uart_spi NUCLEO-L476RG: adc NUCLEO-L476RG: blink NUCLEO-L476RG: i2c_test OLIMEXINO-STM32: blink STM32F0-DISCOVERY: blink STM32F0-DISCOVERY: logger STM32F030F4P6-DEMO-BOARD: blink STM32F072-DISCOVERY: blink STM32F072-DISCOVERY: can STM32F072-DISCOVERY: hard_fault STM32F072-DISCOVERY: rotation STM32F072-DISCOVERY: tmp102 STM32F072-DISCOVERY: uart STM32F072-DISCOVERY: unaligned_access STM32F1-DISCOVERY: blink STM32F1-DISCOVERY: logger STM32F103C8T6-Black Pill: blink STM32F103C8T6-Blue Pill: adns_9800 STM32F103C8T6-Blue Pill: blink STM32F103C8T6-Blue Pill: blink.cmake STM32F103C8T6-Blue Pill: can STM32F103C8T6-Blue Pill: environment STM32F103C8T6-Blue Pill: logger STM32F3-DISCOVERY: accelerometer STM32F3-DISCOVERY: adc/continous STM32F3-DISCOVERY: adc/interrupt STM32F3-DISCOVERY: adc/simple STM32F3-DISCOVERY: blink STM32F3-DISCOVERY: can STM32F3-DISCOVERY: comp STM32F3-DISCOVERY: ft245 STM32F3-DISCOVERY: gdb STM32F3-DISCOVERY: hard_fault STM32F3-DISCOVERY: rotation STM32F3-DISCOVERY: timer/basic STM32F3-DISCOVERY: uart/hal STM32F3-DISCOVERY: uart/logger STM32F4-DISCOVERY: accelerometer STM32F4-DISCOVERY: adc/interrupt STM32F4-DISCOVERY: adc/oversample STM32F4-DISCOVERY: adc/simple STM32F4-DISCOVERY: app_uart_sniffer STM32F4-DISCOVERY: barometer_bmp085_bmp180 STM32F4-DISCOVERY: blink STM32F4-DISCOVERY: can STM32F4-DISCOVERY: can2 STM32F4-DISCOVERY: colour_tcs3414 STM32F4-DISCOVERY: display/hd44780 STM32F4-DISCOVERY: display/nokia_5110 STM32F4-DISCOVERY: display/ssd1306 STM32F4-DISCOVERY: distance_vl6180 STM32F4-DISCOVERY: exti STM32F4-DISCOVERY: fpu STM32F4-DISCOVERY: fsmc STM32F4-DISCOVERY: hard_fault STM32F4-DISCOVERY: led_matrix_display STM32F4-DISCOVERY: open407v-d/gui STM32F4-DISCOVERY: open407v-d/touchscreen STM32F4-DISCOVERY: pressure_ams5915 STM32F4-DISCOVERY: protothreads STM32F4-DISCOVERY: radio/nrf24-basic-comm STM32F4-DISCOVERY: radio/nrf24-data/rx STM32F4-DISCOVERY: radio/nrf24-data/tx STM32F4-DISCOVERY: radio/nrf24-phy-test STM32F4-DISCOVERY: radio/nrf24-scanner STM32F4-DISCOVERY: sab2 STM32F4-DISCOVERY: spi STM32F4-DISCOVERY: temperature_ltc2984 STM32F4-DISCOVERY: timer STM32F4-DISCOVERY: timer_test STM32F4-DISCOVERY: uart STM32F4-DISCOVERY: uart_spi STM32F429-DISCOVERY: blink STM32F429-DISCOVERY: logger STM32F469-DISCOVERY: assert STM32F469-DISCOVERY: blink STM32F469-DISCOVERY: can STM32F469-DISCOVERY: display STM32F469-DISCOVERY: game_of_life STM32F469-DISCOVERY: ports STM32F469-DISCOVERY: tlsf-allocator STM32F469-DISCOVERY: touchscreen STM32F746G-DISCOVERY: adc_ad7928 STM32F746G-DISCOVERY: blink STM32F746G-DISCOVERY: rtos STM32F746G-DISCOVERY: tmp102 STM32F769I-DISCOVERY: blink STM32L476-DISCOVERY: blink Windows: build_info ZMQ: 1_stm32 ZMQ: 2_zmq_gateway ZMQ: 3_zmq_app ZMQ: 4_zmq_backtoback","title":"Examples"},{"location":"how-modm-works/","text":"How modm works \u00b6 modm is an umbrella project for a handful of stand-alone projects and acts as a curated toolbox for creating custom C++ libraries for embedded targets. Three of these projects form the heart of modm: modm-devices contains hardware descriptions like memories, peripherals and pins of many devices. modm provides configurable modules to translate this data into code, tests and documentation. lbuild links these two together using the Jinja2 template engine in Python to create a custom library for your target. As a developer you can use lbuild to explore the modm modules, configure them specifically for your targets and needs and generate a custom library. You can generate more than just code, in this example, lbuild also generates a build system which then compiles and links the application into a executable. We've also put a lot of thought into modm-devices, about what data to extract, how to format and store it. We automated the entire process to get the high quality data we use to build our library. You can read all about modm-devices in this blog post . modm is highly modular \u00b6 modm's modules are kept small in scope on purpose and declare their dependencies, so that lbuild can build a minimal library from the initial modules you specified. So if you only want to use our UART drivers for example, lbuild will only include code from that module and its dependencies. This makes it easier to understand what parts of modm you actually use, either by looking at the dependency graph before, or by inspecting the generated code after calling lbuild, and gives you the opportunity to only use the parts of modm you really like. A lbuild module is just a few lines of Python code. Here we can see the code for the modm:platform:uart module from the example above. It declares its name, its dependencies and then which files it wants to generate where to using the data from modm-devices, by just setting the env.substitutions to the device's properties and calling env.template with the input and output file names. def init ( module ): module . name = \":platform:uart\" module . description = \"UART driver\" def prepare ( module , options ): module . depends ( \":architecture:interrupt\" , \":architecture:register\" , \":architecture:atomic\" , \":architecture:uart\" , \":platform:gpio\" ) return True def build ( env ): device = env [ \":target\" ] env . substitutions = device . properties env . outbasepath = \"src/modm/platform/uart\" for instance in device . get_driver ( \"uart:stm32*\" )[ \"instance\" ]: env . template ( \"uart.hpp.in\" , \"uart_{}.hpp\" . format ( instance )) env . template ( \"uart.cpp.in\" , \"uart_{}.cpp\" . format ( instance )) The input template then can access all the devices properties, and generate the correct code for this device. Here the template on left is passed to the Jinja2 engine which outputs the code on the right. void {{ name }}::write(uint8_t data) { %% if \"extended\" in driver[\"type\"] {{ peripheral }}->TDR = data; %% else {{ peripheral }}->DR = data; %% endif } void Uart4 :: write ( uint8_t data ) { UART4 -> DR = data ; } This example is simple, but since it's based on Python, anything more complicated is possible . Looking at the data excerpt from a STM32 device the above module will generate a only three classes of this type for this target. However, a similar driver will generate classes for the four USART peripherals. ... <driver name= \"uart\" type= \"stm32\" > <instance value= \"4\" /> <instance value= \"5\" /> <instance value= \"7\" /> </driver> <driver name= \"usart\" type= \"stm32\" > <instance value= \"1\" /> <instance value= \"2\" /> <instance value= \"3\" /> <instance value= \"6\" /> </driver> ... With these techiques we can generate a target specific HAL for hundreds of devices. Don't believe us? Check out our CI doing just that . modm asserts at compile-time \u00b6 modm stands out for its extensive use of generated static C++ (template) classes. Consider this data from the GPIO peripheral, which shows the signal map for the PA0 pin on a STM32 device. ... <driver name= \"gpio\" type= \"stm32\" > <gpio port= \"a\" pin= \"0\" > <signal driver= \"adc\" instance= \"1\" name= \"in0\" /> <signal driver= \"adc\" instance= \"2\" name= \"in0\" /> <signal driver= \"adc\" instance= \"3\" name= \"in0\" /> <signal af= \"1\" driver= \"tim\" instance= \"2\" name= \"ch1\" /> <signal af= \"2\" driver= \"tim\" instance= \"5\" name= \"ch1\" /> <signal af= \"8\" driver= \"uart\" instance= \"4\" name= \"tx\" /> ... We use this data in the modm:platform:gpio module to generate type-safe signal connections, which will then assert that the signal you want to connect actually exists on this pin and even gives you a helpful (!) error message at compile time. class GpioA0 { ... template < Peripheral peripheral > struct Tx { static_assert ( ( peripheral == Peripheral :: Uart4 ), \"GpioA0::Tx only connects to Uart4!\" ); }; template < Peripheral peripheral > struct Ch1 { static_assert ( ( peripheral == Peripheral :: Tim2 ) || ( peripheral == Peripheral :: Tim5 ), \"GpioA0::Ch1 only connects to Tim2 or Tim5!\" ); }; template < Peripheral peripheral > struct In0 { static_assert ( ( peripheral == Peripheral :: Adc1 ) || ( peripheral == Peripheral :: Adc2 ) || ( peripheral == Peripheral :: Adc3 ), \"GpioA0::In0 only connects to Adc1 or Adc2 or Adc3!\" ); }; ... }; Continuing with this technique, we can even check if your signal groups are conflict free of overlaps or invalid configurations and again give you a helpful error message! Uart4 :: connect < GpioA0 :: Tx > (); Adc1 :: connect < GpioA0 :: In0 , GpioA1 :: In1 > (); Tim2 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Tim5 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Maps to GpioA0::setAlternateFunction(8); Maps to GpioAx::setAnalogInput(); Each pin in group called with their respective Alternate Function ID Same API, but for Timer5 different Alternate Function IDs are used Uart4 :: connect < GpioA0 :: Rx > (); error: 'Rx' is not a member of 'GpioA0' Uart4 :: connect < GpioA2 :: Tx > (); error: GpioA2::Tx only connects to Usart2! Usart1 :: connect < GpioA9 :: Tx , GpioB7 :: Rx > (); error: This pin set contains conflicting remap groups! Available groups for Usart1 are: Usart1 | 0 | 1 --------|----|---- A9 | Tx | A10 | Rx | B6 | | Tx B7 | | Rx We use a similar technique to compute baudrates at compile time and make sure the resulting baudrates remains within the specified error tolerances. In addition the executable now only contains prescaler values which are written directly to the hardware without any computation required. This is very helpful for keeping code size in check on very resource constrained targets, like the AVRs. Uart4 :: connect < GpioA0 :: Tx , GpioA1 :: Rx > ( Gpio :: InputType :: PullUp ); // pull-up in RX pin Uart4 :: initialize < Board :: SystemClock , 115 ' 200 _Bd > (); // Within 1% default tolerance Uart4 :: initialize < Board :: SystemClock , 115.2 _kBd , 0 _pct > (); // error: The closest available baudrate exceeds the tolerance of the requested baudrate! modm is fast and usable \u00b6 modm's APIs are kept simple and fast by splitting up functionality into separate, small, static functions, which implement the same behavior on all platforms. And with our code generation capabilities, we can hide the crazy implementation details of the hardware without compromising on performance. For example, on different AVRs, simple things like enabling the internal pull-up resistor, dealing with external interrupts or even just toggling a pin is done quite dissimilarly in hardware, yet we can wrap this in the same API for every target. Since we\u2018re using static inlined functions that often just compile to a handful of instructions we can call our GPIOs at ludicrous speed . // All pin functions follow a common naming scheme using Led = GpioB1 ; Led :: setOutput (); Led :: set (); Led :: reset (); Led :: toggle (); using Button = GpioA0 ; Button :: setInput (); bool state = Button :: read (); // Depending on your targets, additional functions are available Led :: setOutput ( Gpio :: OutputType :: OpenDrain ); Button :: setInput ( Gpio :: InputType :: PullUp ); Button :: setInputTrigger ( Gpio :: InputTrigger :: RisingEdge ); Button :: enableExternalInterrupt (); Button :: acknowledgeExternalInterruptFlag (); You can use these GPIOs as building blocks for more complex drivers and peripherals and still maintain access speed without sacrificing usability: // Create a hardware accelerated port of 4 bit width. using Port4 = GpioPort < GpioC0 , 4 > ; // MSB -> C3, C2, C1, C0 <- LSB using ReadWrite = GpioC4 ; // \"name\" your GPIOs. using Reset = GpioOutputC5 ; using Enable = GpioOutputC6 ; // Build a super fast character display driver using these inlined GPIOs. modm :: Hd44780 < Port4 , ReadWrite , Reset , Enable > display ; display . initialize (); // driver knows to initialize for a 4 bit bus! display << \"Hello World!\" << modm :: endl ; // Yes, ostreams. Deal with it. display . printf ( \"You don't really have to use %s!\" , \"OStreams\" ); All drivers in modm follow the same principle of building up your hardware drivers from other parts of the HAL by passing them as template parameters. This works surprisingly well to reduce both code size and execution time. For example, here is how you assemble and initialize a driver for the MCP23x17 GPIO expander and then use its pins. using Transport = modm :: Mcp23TransportSpi < SpiMaster1 , GpioA0 > ; using GpioExpander = modm :: Mcp23x17 < Transport > ; GpioExpander expander ; // Connect and initialize the peripherals SpiMaster1 :: connect < GpioA0 :: Sck , GpioA1 :: Mosi , GpioA2 :: Miso > (); SpiMaster1 :: initialize < Board :: SystemClock , 1 _MHz > (); expander . initialize (); // Bind the expander pins to a simpler name using Pin0 = GpioExpander :: P0 < expander > ; using Pin1 = GpioExpander :: P1 < expander > ; // Oh, look, same API Pin0 :: setOutput (); Pin0 :: toggle (); Pin1 :: setInput (); bool state = Pin1 :: read (); modm is memory-efficient \u00b6 Our HAL does not allocate memory dynamically \u2013 everything is either statically allocated or must explicitly be allocated by the user. This is a strong requirement for running modm on AVRs, which have little if any memory to spare for dynamic allocations. We took great care to make sure this constraint remains usable, making configuration options first-class citizens in lbuild for you to easily discover and safely change. When we do need to allocate static memory, we choose a sensible default size for its purpose. $ lbuild discover-module-options ... modm:platform:cortex-m:main_stack_size = 3040 [256 ... 65536] Minimum size of the application main stack ... modm:platform:uart:1:buffer.rx = 16 [1 ... 65534] modm:platform:uart:1:buffer.tx = 250 [1 ... 65534] We transparently show you how much static memory your application is using, so you get an idea of how much certain functionality costs you in resources. This is the size of the accelerometer example on the STM32F4 discovery board: $ cd examples/stm32f4_discovery/accelerometer $ scons ... Memory usage\u00b7\u00b7\u00b7 build/stm32f4_discovery/accelerometer/project.elf Program: 8144B (0.8% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3464B (1.7% used) = 424B static (0.2%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197240B (98.3% available) (.heap0 + .heap1 + .heap2 + .heap5) modm does multitasking \u00b6 modm uses stackless cooperative multitasking, for which we have ported protothreads to C++ and extended them with resumable functions. This enables you to split up your application into separate tasks, and use synchronous APIs in all of them, without sacrificing overall responsiveness. This works on even the most resource restricted AVRs, since each task only requires 2 bytes of static RAM! All our IC drivers are implemented using resumable functions, which can be called from within protothreads or explicitly blocking outside of them. Here is an example of reading out the accelerometer : class ReaderThread : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // The driver does several I2C transfer here to initialize and configure the // external sensor. The CPU is free to do other things while this happens though. PT_CALL ( accelerometer . configure ( accelerometer . Scale :: G2 )); while ( true ) // this feels quite similar to regular threads { // this resumable function will defer execution back to other protothreads PT_CALL ( accelerometer . readAcceleration ()); // smooth out the acceleration data a little bit averageX . update ( accelerometer . getData (). getX ()); averageY . update ( accelerometer . getData (). getY ()); // set the boards LEDs depending on the acceleration values LedUp :: set ( averageX . getValue () < - 0.2 ); LedDown :: set ( averageX . getValue () > 0.2 ); LedLeft :: set ( averageY . getValue () < - 0.2 ); LedRight :: set ( averageY . getValue () > 0.2 ); // defer back to other protothreads until the timer fires PT_WAIT_UNTIL ( timer . execute ()); } PT_END (); } private : // This accelerometer is connected via I2C. modm :: Lis3dsh < modm :: Lis3TransportI2c < I2cMaster > > accelerometer ; modm :: PeriodicTimer timer = modm :: PeriodicTimer ( 5 ); // 5ms periodic timer. modm :: filter :: MovingAverage < float , 25 > averageX ; modm :: filter :: MovingAverage < float , 25 > averageY ; }; ReaderThread reader ; // Protothread is statically allocated! int main () // Execution entry point. { while ( true ) { // the main loop with implicit round robin cooperative scheduling. reader . run (); otherProtothreads . run (); } return 0 ; }","title":"How modm works"},{"location":"how-modm-works/#how-modm-works","text":"modm is an umbrella project for a handful of stand-alone projects and acts as a curated toolbox for creating custom C++ libraries for embedded targets. Three of these projects form the heart of modm: modm-devices contains hardware descriptions like memories, peripherals and pins of many devices. modm provides configurable modules to translate this data into code, tests and documentation. lbuild links these two together using the Jinja2 template engine in Python to create a custom library for your target. As a developer you can use lbuild to explore the modm modules, configure them specifically for your targets and needs and generate a custom library. You can generate more than just code, in this example, lbuild also generates a build system which then compiles and links the application into a executable. We've also put a lot of thought into modm-devices, about what data to extract, how to format and store it. We automated the entire process to get the high quality data we use to build our library. You can read all about modm-devices in this blog post .","title":"How modm works"},{"location":"how-modm-works/#modm-is-highly-modular","text":"modm's modules are kept small in scope on purpose and declare their dependencies, so that lbuild can build a minimal library from the initial modules you specified. So if you only want to use our UART drivers for example, lbuild will only include code from that module and its dependencies. This makes it easier to understand what parts of modm you actually use, either by looking at the dependency graph before, or by inspecting the generated code after calling lbuild, and gives you the opportunity to only use the parts of modm you really like. A lbuild module is just a few lines of Python code. Here we can see the code for the modm:platform:uart module from the example above. It declares its name, its dependencies and then which files it wants to generate where to using the data from modm-devices, by just setting the env.substitutions to the device's properties and calling env.template with the input and output file names. def init ( module ): module . name = \":platform:uart\" module . description = \"UART driver\" def prepare ( module , options ): module . depends ( \":architecture:interrupt\" , \":architecture:register\" , \":architecture:atomic\" , \":architecture:uart\" , \":platform:gpio\" ) return True def build ( env ): device = env [ \":target\" ] env . substitutions = device . properties env . outbasepath = \"src/modm/platform/uart\" for instance in device . get_driver ( \"uart:stm32*\" )[ \"instance\" ]: env . template ( \"uart.hpp.in\" , \"uart_{}.hpp\" . format ( instance )) env . template ( \"uart.cpp.in\" , \"uart_{}.cpp\" . format ( instance )) The input template then can access all the devices properties, and generate the correct code for this device. Here the template on left is passed to the Jinja2 engine which outputs the code on the right. void {{ name }}::write(uint8_t data) { %% if \"extended\" in driver[\"type\"] {{ peripheral }}->TDR = data; %% else {{ peripheral }}->DR = data; %% endif } void Uart4 :: write ( uint8_t data ) { UART4 -> DR = data ; } This example is simple, but since it's based on Python, anything more complicated is possible . Looking at the data excerpt from a STM32 device the above module will generate a only three classes of this type for this target. However, a similar driver will generate classes for the four USART peripherals. ... <driver name= \"uart\" type= \"stm32\" > <instance value= \"4\" /> <instance value= \"5\" /> <instance value= \"7\" /> </driver> <driver name= \"usart\" type= \"stm32\" > <instance value= \"1\" /> <instance value= \"2\" /> <instance value= \"3\" /> <instance value= \"6\" /> </driver> ... With these techiques we can generate a target specific HAL for hundreds of devices. Don't believe us? Check out our CI doing just that .","title":"modm is highly modular"},{"location":"how-modm-works/#modm-asserts-at-compile-time","text":"modm stands out for its extensive use of generated static C++ (template) classes. Consider this data from the GPIO peripheral, which shows the signal map for the PA0 pin on a STM32 device. ... <driver name= \"gpio\" type= \"stm32\" > <gpio port= \"a\" pin= \"0\" > <signal driver= \"adc\" instance= \"1\" name= \"in0\" /> <signal driver= \"adc\" instance= \"2\" name= \"in0\" /> <signal driver= \"adc\" instance= \"3\" name= \"in0\" /> <signal af= \"1\" driver= \"tim\" instance= \"2\" name= \"ch1\" /> <signal af= \"2\" driver= \"tim\" instance= \"5\" name= \"ch1\" /> <signal af= \"8\" driver= \"uart\" instance= \"4\" name= \"tx\" /> ... We use this data in the modm:platform:gpio module to generate type-safe signal connections, which will then assert that the signal you want to connect actually exists on this pin and even gives you a helpful (!) error message at compile time. class GpioA0 { ... template < Peripheral peripheral > struct Tx { static_assert ( ( peripheral == Peripheral :: Uart4 ), \"GpioA0::Tx only connects to Uart4!\" ); }; template < Peripheral peripheral > struct Ch1 { static_assert ( ( peripheral == Peripheral :: Tim2 ) || ( peripheral == Peripheral :: Tim5 ), \"GpioA0::Ch1 only connects to Tim2 or Tim5!\" ); }; template < Peripheral peripheral > struct In0 { static_assert ( ( peripheral == Peripheral :: Adc1 ) || ( peripheral == Peripheral :: Adc2 ) || ( peripheral == Peripheral :: Adc3 ), \"GpioA0::In0 only connects to Adc1 or Adc2 or Adc3!\" ); }; ... }; Continuing with this technique, we can even check if your signal groups are conflict free of overlaps or invalid configurations and again give you a helpful error message! Uart4 :: connect < GpioA0 :: Tx > (); Adc1 :: connect < GpioA0 :: In0 , GpioA1 :: In1 > (); Tim2 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Tim5 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Maps to GpioA0::setAlternateFunction(8); Maps to GpioAx::setAnalogInput(); Each pin in group called with their respective Alternate Function ID Same API, but for Timer5 different Alternate Function IDs are used Uart4 :: connect < GpioA0 :: Rx > (); error: 'Rx' is not a member of 'GpioA0' Uart4 :: connect < GpioA2 :: Tx > (); error: GpioA2::Tx only connects to Usart2! Usart1 :: connect < GpioA9 :: Tx , GpioB7 :: Rx > (); error: This pin set contains conflicting remap groups! Available groups for Usart1 are: Usart1 | 0 | 1 --------|----|---- A9 | Tx | A10 | Rx | B6 | | Tx B7 | | Rx We use a similar technique to compute baudrates at compile time and make sure the resulting baudrates remains within the specified error tolerances. In addition the executable now only contains prescaler values which are written directly to the hardware without any computation required. This is very helpful for keeping code size in check on very resource constrained targets, like the AVRs. Uart4 :: connect < GpioA0 :: Tx , GpioA1 :: Rx > ( Gpio :: InputType :: PullUp ); // pull-up in RX pin Uart4 :: initialize < Board :: SystemClock , 115 ' 200 _Bd > (); // Within 1% default tolerance Uart4 :: initialize < Board :: SystemClock , 115.2 _kBd , 0 _pct > (); // error: The closest available baudrate exceeds the tolerance of the requested baudrate!","title":"modm asserts at compile-time"},{"location":"how-modm-works/#modm-is-fast-and-usable","text":"modm's APIs are kept simple and fast by splitting up functionality into separate, small, static functions, which implement the same behavior on all platforms. And with our code generation capabilities, we can hide the crazy implementation details of the hardware without compromising on performance. For example, on different AVRs, simple things like enabling the internal pull-up resistor, dealing with external interrupts or even just toggling a pin is done quite dissimilarly in hardware, yet we can wrap this in the same API for every target. Since we\u2018re using static inlined functions that often just compile to a handful of instructions we can call our GPIOs at ludicrous speed . // All pin functions follow a common naming scheme using Led = GpioB1 ; Led :: setOutput (); Led :: set (); Led :: reset (); Led :: toggle (); using Button = GpioA0 ; Button :: setInput (); bool state = Button :: read (); // Depending on your targets, additional functions are available Led :: setOutput ( Gpio :: OutputType :: OpenDrain ); Button :: setInput ( Gpio :: InputType :: PullUp ); Button :: setInputTrigger ( Gpio :: InputTrigger :: RisingEdge ); Button :: enableExternalInterrupt (); Button :: acknowledgeExternalInterruptFlag (); You can use these GPIOs as building blocks for more complex drivers and peripherals and still maintain access speed without sacrificing usability: // Create a hardware accelerated port of 4 bit width. using Port4 = GpioPort < GpioC0 , 4 > ; // MSB -> C3, C2, C1, C0 <- LSB using ReadWrite = GpioC4 ; // \"name\" your GPIOs. using Reset = GpioOutputC5 ; using Enable = GpioOutputC6 ; // Build a super fast character display driver using these inlined GPIOs. modm :: Hd44780 < Port4 , ReadWrite , Reset , Enable > display ; display . initialize (); // driver knows to initialize for a 4 bit bus! display << \"Hello World!\" << modm :: endl ; // Yes, ostreams. Deal with it. display . printf ( \"You don't really have to use %s!\" , \"OStreams\" ); All drivers in modm follow the same principle of building up your hardware drivers from other parts of the HAL by passing them as template parameters. This works surprisingly well to reduce both code size and execution time. For example, here is how you assemble and initialize a driver for the MCP23x17 GPIO expander and then use its pins. using Transport = modm :: Mcp23TransportSpi < SpiMaster1 , GpioA0 > ; using GpioExpander = modm :: Mcp23x17 < Transport > ; GpioExpander expander ; // Connect and initialize the peripherals SpiMaster1 :: connect < GpioA0 :: Sck , GpioA1 :: Mosi , GpioA2 :: Miso > (); SpiMaster1 :: initialize < Board :: SystemClock , 1 _MHz > (); expander . initialize (); // Bind the expander pins to a simpler name using Pin0 = GpioExpander :: P0 < expander > ; using Pin1 = GpioExpander :: P1 < expander > ; // Oh, look, same API Pin0 :: setOutput (); Pin0 :: toggle (); Pin1 :: setInput (); bool state = Pin1 :: read ();","title":"modm is fast and usable"},{"location":"how-modm-works/#modm-is-memory-efficient","text":"Our HAL does not allocate memory dynamically \u2013 everything is either statically allocated or must explicitly be allocated by the user. This is a strong requirement for running modm on AVRs, which have little if any memory to spare for dynamic allocations. We took great care to make sure this constraint remains usable, making configuration options first-class citizens in lbuild for you to easily discover and safely change. When we do need to allocate static memory, we choose a sensible default size for its purpose. $ lbuild discover-module-options ... modm:platform:cortex-m:main_stack_size = 3040 [256 ... 65536] Minimum size of the application main stack ... modm:platform:uart:1:buffer.rx = 16 [1 ... 65534] modm:platform:uart:1:buffer.tx = 250 [1 ... 65534] We transparently show you how much static memory your application is using, so you get an idea of how much certain functionality costs you in resources. This is the size of the accelerometer example on the STM32F4 discovery board: $ cd examples/stm32f4_discovery/accelerometer $ scons ... Memory usage\u00b7\u00b7\u00b7 build/stm32f4_discovery/accelerometer/project.elf Program: 8144B (0.8% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3464B (1.7% used) = 424B static (0.2%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197240B (98.3% available) (.heap0 + .heap1 + .heap2 + .heap5)","title":"modm is memory-efficient"},{"location":"how-modm-works/#modm-does-multitasking","text":"modm uses stackless cooperative multitasking, for which we have ported protothreads to C++ and extended them with resumable functions. This enables you to split up your application into separate tasks, and use synchronous APIs in all of them, without sacrificing overall responsiveness. This works on even the most resource restricted AVRs, since each task only requires 2 bytes of static RAM! All our IC drivers are implemented using resumable functions, which can be called from within protothreads or explicitly blocking outside of them. Here is an example of reading out the accelerometer : class ReaderThread : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // The driver does several I2C transfer here to initialize and configure the // external sensor. The CPU is free to do other things while this happens though. PT_CALL ( accelerometer . configure ( accelerometer . Scale :: G2 )); while ( true ) // this feels quite similar to regular threads { // this resumable function will defer execution back to other protothreads PT_CALL ( accelerometer . readAcceleration ()); // smooth out the acceleration data a little bit averageX . update ( accelerometer . getData (). getX ()); averageY . update ( accelerometer . getData (). getY ()); // set the boards LEDs depending on the acceleration values LedUp :: set ( averageX . getValue () < - 0.2 ); LedDown :: set ( averageX . getValue () > 0.2 ); LedLeft :: set ( averageY . getValue () < - 0.2 ); LedRight :: set ( averageY . getValue () > 0.2 ); // defer back to other protothreads until the timer fires PT_WAIT_UNTIL ( timer . execute ()); } PT_END (); } private : // This accelerometer is connected via I2C. modm :: Lis3dsh < modm :: Lis3TransportI2c < I2cMaster > > accelerometer ; modm :: PeriodicTimer timer = modm :: PeriodicTimer ( 5 ); // 5ms periodic timer. modm :: filter :: MovingAverage < float , 25 > averageX ; modm :: filter :: MovingAverage < float , 25 > averageY ; }; ReaderThread reader ; // Protothread is statically allocated! int main () // Execution entry point. { while ( true ) { // the main loop with implicit round robin cooperative scheduling. reader . run (); otherProtothreads . run (); } return 0 ; }","title":"modm does multitasking"},{"location":"who-we-are/","text":"Who we are \u00b6 The modm project is maintained by Niklas Hauser ( \\@salkinium ) with significant contributions from Sascha Schade ( \\@strongly-typed ), Fabian Greif ( \\@dergraaf ), Kevin L\u00e4ufer ( \\@ekiwi ), Martin Rosekeit ( \\@thundernail ), Daniel Krebs ( \\@daniel-k ), Georgi Grinshpun ( \\@georgi-g ) and 20 more contributors . History of modm \u00b6 In the mid-2000s the Roboterclub Aachen e.V. has developed a software library called XPCC for communication among components that are distributed on PCs and microcontrollers. This library was initially used only in autonomous robots for the Eurobot competition . In 2009, XPCC became a separate project and over the years grew from a communication library to a general purpose framework (called lowercase xpcc, 'cos #namingthings) suitable for all kinds of embedded applications. Between 2016 and 2018, Niklas and Fabian refactored xpcc into modm by completely rewriting the way the library generates its HAL. This also gave us the tools to fix some larger architectural issues in xpcc's HAL as well as significantly improve customizability of the HAL and its documentation. All xpcc authors agreed to relicense their contributions from BSD to MPLv2 in modm. Eurobot and Team RCA \u00b6 Most of our contributors are or used to be members of the Roboterclub Aachen e.V. . We've been building robots for the Eurobot competition for many years now and all of them have been running xpcc or modm successfully as their only OS on dozens of different AVR and STM32 targets each. So modm is truly battle-tested in real-world conditions and has passed through the scrutiny of many capable engineers over the years. Check out how we're competing in the quarter finals of the Eurobot 2015 competition.","title":"Who we are"},{"location":"who-we-are/#who-we-are","text":"The modm project is maintained by Niklas Hauser ( \\@salkinium ) with significant contributions from Sascha Schade ( \\@strongly-typed ), Fabian Greif ( \\@dergraaf ), Kevin L\u00e4ufer ( \\@ekiwi ), Martin Rosekeit ( \\@thundernail ), Daniel Krebs ( \\@daniel-k ), Georgi Grinshpun ( \\@georgi-g ) and 20 more contributors .","title":"Who we are"},{"location":"who-we-are/#history-of-modm","text":"In the mid-2000s the Roboterclub Aachen e.V. has developed a software library called XPCC for communication among components that are distributed on PCs and microcontrollers. This library was initially used only in autonomous robots for the Eurobot competition . In 2009, XPCC became a separate project and over the years grew from a communication library to a general purpose framework (called lowercase xpcc, 'cos #namingthings) suitable for all kinds of embedded applications. Between 2016 and 2018, Niklas and Fabian refactored xpcc into modm by completely rewriting the way the library generates its HAL. This also gave us the tools to fix some larger architectural issues in xpcc's HAL as well as significantly improve customizability of the HAL and its documentation. All xpcc authors agreed to relicense their contributions from BSD to MPLv2 in modm.","title":"History of modm"},{"location":"who-we-are/#eurobot-and-team-rca","text":"Most of our contributors are or used to be members of the Roboterclub Aachen e.V. . We've been building robots for the Eurobot competition for many years now and all of them have been running xpcc or modm successfully as their only OS on dozens of different AVR and STM32 targets each. So modm is truly battle-tested in real-world conditions and has passed through the scrutiny of many capable engineers over the years. Check out how we're competing in the quarter finals of the Eurobot 2015 competition.","title":"Eurobot and Team RCA"},{"location":"guide/cookbook/","text":"Cookbook \u00b6 Here are a few snippets of code we use frequently. We assume using namespace modm::platform; to make the code more readable. All modm code is either placed in the modm namespace or prefixed with modm_ or MODM_ to avoid clashes with other code. The platform specific code is placed in the modm::platform namespace and is the only place that contains target specific code. Check the examples Have a look at the modm/examples/ folder for more advanced use cases. GPIO \u00b6 using Led = GpioOutputB0 ; Led :: setOutput (); Led :: set (); // 1 instruction on AVR Led :: reset (); // 3 instructions on Cortex-M Led :: toggle (); using Button = GpioInputB0 ; Button :: setInput ( Gpio :: InputType :: PullUp ); bool state = Button :: read (); Buffered UART \u00b6 using Uart = Uart0 ; // connect both pins with a pullup on the Rx Uart :: connect < GpioOutputD1 :: Tx , GpioInputD0 :: Rx > ( Gpio :: InputType :: PullUp ); // initialize to 115.2kBaud from the BSP clock configuration Uart :: initialize < Board :: SystemClock , 115200 _Bd > (); Uart :: write ( 'H' ); // Ohai there Uart :: write ( 'i' ); uint8_t buffer ; while ( 1 ) { // create a simple loopback if ( Uart :: read ( buffer )) { Uart :: write ( buffer ); } } IOStream \u00b6 using Uart = Uart0 ; // Create a IODevice with the Uart modm :: IODeviceWrapper < Uart > device ; modm :: IOStream stream ( device ); Uart :: connect < GpioOutputD1 :: Tx > (); Uart :: initialize < Board :: SystemClock , 115200 _Bd > (); // similar to std::ostream but without formatting features stream << 42 << \" is a nice number!\" << modm :: endl ; // printf has the most common formatting features stream . printf ( \"%d is a %s number! \\n \" , 42 , \"nice\" ); Software Timers \u00b6 using Led = GpioOutputB0 ; modm :: Timeout timeout ( 10000 ); // 10s timeout modm :: PeriodicTimer timer ( 250 ); // 250ms period Led :: setOutput ( modm :: Gpio :: High ); while ( 1 ) { if ( timeout . execute ()) { // executes just once timer . stop (); Led :: reset (); } if ( timer . execute ()) { // executes once per period Led :: toggle (); } }","title":"Cookbook"},{"location":"guide/cookbook/#cookbook","text":"Here are a few snippets of code we use frequently. We assume using namespace modm::platform; to make the code more readable. All modm code is either placed in the modm namespace or prefixed with modm_ or MODM_ to avoid clashes with other code. The platform specific code is placed in the modm::platform namespace and is the only place that contains target specific code. Check the examples Have a look at the modm/examples/ folder for more advanced use cases.","title":"Cookbook"},{"location":"guide/cookbook/#gpio","text":"using Led = GpioOutputB0 ; Led :: setOutput (); Led :: set (); // 1 instruction on AVR Led :: reset (); // 3 instructions on Cortex-M Led :: toggle (); using Button = GpioInputB0 ; Button :: setInput ( Gpio :: InputType :: PullUp ); bool state = Button :: read ();","title":"GPIO"},{"location":"guide/cookbook/#buffered-uart","text":"using Uart = Uart0 ; // connect both pins with a pullup on the Rx Uart :: connect < GpioOutputD1 :: Tx , GpioInputD0 :: Rx > ( Gpio :: InputType :: PullUp ); // initialize to 115.2kBaud from the BSP clock configuration Uart :: initialize < Board :: SystemClock , 115200 _Bd > (); Uart :: write ( 'H' ); // Ohai there Uart :: write ( 'i' ); uint8_t buffer ; while ( 1 ) { // create a simple loopback if ( Uart :: read ( buffer )) { Uart :: write ( buffer ); } }","title":"Buffered UART"},{"location":"guide/cookbook/#iostream","text":"using Uart = Uart0 ; // Create a IODevice with the Uart modm :: IODeviceWrapper < Uart > device ; modm :: IOStream stream ( device ); Uart :: connect < GpioOutputD1 :: Tx > (); Uart :: initialize < Board :: SystemClock , 115200 _Bd > (); // similar to std::ostream but without formatting features stream << 42 << \" is a nice number!\" << modm :: endl ; // printf has the most common formatting features stream . printf ( \"%d is a %s number! \\n \" , 42 , \"nice\" );","title":"IOStream"},{"location":"guide/cookbook/#software-timers","text":"using Led = GpioOutputB0 ; modm :: Timeout timeout ( 10000 ); // 10s timeout modm :: PeriodicTimer timer ( 250 ); // 250ms period Led :: setOutput ( modm :: Gpio :: High ); while ( 1 ) { if ( timeout . execute ()) { // executes just once timer . stop (); Led :: reset (); } if ( timer . execute ()) { // executes once per period Led :: toggle (); } }","title":"Software Timers"},{"location":"guide/getting-started/","text":"Getting Started \u00b6 The easiest way for you to learn about modm's APIs is to look at and experiment with our examples , especially if you have a development board that modm supports out-of-box. Make sure you've installed all tools required for building modm . TL;DR \u00b6 lbuild build # generate modm library (call only once) scons program # compile and upload to your development board To debug with GDB in TUI mode: scons program profile=debug # compile and upload debug profile scons gdb profile=debug # launch OpenOCD and GDB for debugging To generate your target specific Doxygen documentation: (cd modm/docs && doxygen doxyfile.cfg) # may take a minute or two # open modm/docs/html/index.html To remove it all: scons -c # removes build artifacts lbuild clean # removes generated files Quickstart \u00b6 To generate the modm library for the specific example target, call lbuild build You can then look at the generated modm code in the local modm/src/modm folder. Most of our examples compile with SCons by default, however you can generate a CMake build script by including the CMake build script generator module . lbuild build -m \"::cmake\" To compile the example and modm, call SCons or CMake: scons # or for CMake make cmake # call just once make build-release To upload the example to your development board: scons program # or for CMake make upload-release You can also debug your examples. Make sure you've compiled and uploaded the debug profile first, because debugging a release profile is annoying: scons program profile=debug # or for CMake make upload-debug Then just do this to open up GDB in TUI mode: scons gdb profile=debug # or for CMake make openocd # open another shell to this location make gdb Interesting Examples \u00b6 We have a lot of examples, 175 to be exact, but here are some of our favorite examples for our supported development boards: Arduino Uno: Blinky , Button & Serial , Analog & Serial . NUCLEO-F031K6: Blinky & Serial . NUCLEO-F103RB: Blinky & Serial . STM32F072 Discovery: Blinky , CAN , Gyroscope . STM32F3 Discovery: Blinky , CAN , Accelerometer , Gyroscope . STM32F4 Discovery: Blinky , CAN , Accelerometer , Timer & LED Animations , Debugging hard faults . STM32F469 Discovery: Blinky , Drawing on display , Touchscreen inputs , Multi-heap with external 16MB memory , Game of Life in Color with Multitouch STM32F769 Discovery: FPU with double precision Here are some additional examples of displays and sensors we like: SSD1306 OLED display : Draws text and graphics onto I2C display. BMP085/BMP180 barometer : Reads atmospheric pressure and temperature from I2C sensor. BMP180/BME280 barometer : Reads atmospheric pressure and temperature from multiple I2C sensors. VL6180 time-of-flight distance sensor : Reads distance and ambient light from I2C sensor. VL53L0 time-of-flight distance sensor : Much improved version of the VL6180 sensor. ADNS9800 motion sensor : Reads 2D motion from SPI sensor used in gaming mice. TCS3414 color sensor : Reads RGB color from I2C sensor. HD44780 over I2C-GPIO expander : Draws text via native GPIO port or I2C-GPIO expander port onto character display. Your own Project \u00b6 To generate a modm library for your own project, you need to define a project.xml file, which contains the path to where modm is, as well as repository and module options and of course which modules you want to have generated. Even though modm will generate a library that is self-contained, we still recommend adding modm as a git submodule for reproducibility. Using a Board Support Package \u00b6 To build on a BSP, inherit from an existing project configuration using the <extends> element. You can discover the available configuration aliases using lbuild : $ lbuild --repository ../modm/repo.lb discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../modm) modm: a barebone embedded library generator \u251c\u2500\u2500 Configuration(modm:arduino-uno) Arduino UNO \u251c\u2500\u2500 Configuration(modm:blue-pill) Blue Pill \u251c\u2500\u2500 Configuration(modm:disco-f469ni) STM32F469IDISCOVERY \u251c\u2500\u2500 Configuration(modm:nucleo-f401re) NUCLEO-F401RE \u251c\u2500\u2500 Configuration(modm:olimexino-stm32) Olimexino STM32 \u2570\u2500\u2500 Configuration(modm:stm32f030_demo) STM32F030 Demo Board Our BSPs declare a minimal set of modules as dependencies as well as pre-define several important options for this board. You can then add all the modules you need and configure them as you want. <library> <repositories> <!-- path to modm repository --> <repository> <path> ../modm/repo.lb </path> </repository> </repositories> <!-- extend this board configuration --> <extends> modm:disco-f469ni </extends> <options> <!-- give this project a custom name --> <option name= \"modm:build:project.name\" > test </option> </options> <modules> <!-- include the SCons build module --> <module> modm:build:scons </module> </modules> </library> Choose a build system Our BSPs do not specify a build system generator, so you need to add the module yourself if you want. Here we use the SCons build system generator, but you can choose others as well . Our board support packages provide their configuration in the Board namespace, which you can use to initialize the target and several board subsystems. If a serial connection is available on the board, you can directly use the modm logging functions. #include <modm/board.hpp> int main () { Board :: initialize (); Board :: Leds :: setOutput (); while ( 1 ) { Board :: Leds :: toggle (); modm :: delayMilliseconds ( Board :: Button :: read () ? 250 : 500 ); #ifdef MODM_BOARD_HAS_LOGGER static uint32_t counter ( 0 ); MODM_LOG_INFO << \"Loop counter: \" << ( counter ++ ) << modm :: endl ; #endif } return 0 ; } Discovering modm \u00b6 To generate your custom library, modm uses the Library Builder , which is the interface to discover available modules and their configuration options. $ lbuild --repository ../modm/repo.lb discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../modm) modm: a barebone embedded library generator \u2570\u2500\u2500 EnumerationOption(target) = REQUIRED in [at90can128, at90can32, at90can64, ... This gives you an overview of the repositories and their options. In this case the modm:target repository option is required, so let's check that out: $ lbuild -r ../modm/repo.lb discover-options modm:target = REQUIRED in [at90can128, at90can32, at90can64, at90pwm1, at90pwm161, at90pwm2, ... a really long list ... stm32l4s9vit, stm32l4s9zij, stm32l4s9zit, stm32l4s9ziy] Meta-HAL target device You can then choose this repository option and discover the available modules for this specific repository option: $ lbuild -r ../modm/repo.lb --option modm:target=stm32f407vgt discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../modm) modm: a barebone embedded library generator \u251c\u2500\u2500 EnumerationOption(target) = stm32f407vgt in [at90can128, at90can32, at90can64, ...] \u251c\u2500\u2500 Configuration(modm:disco-f407vg) STM32F4DISCOVERY \u251c\u2500\u2500 Module(modm:board) Board Support Packages \u2502 \u2570\u2500\u2500 Module(modm:board:disco-f407vg) STM32F4DISCOVERY \u251c\u2500\u2500 Module(modm:build) Build System Generators \u2502 \u251c\u2500\u2500 Option(build.path) = build/parent-folder in [String] \u2502 \u251c\u2500\u2500 Option(project.name) = parent-folder in [String] \u2502 \u2570\u2500\u2500 Module(modm:build:scons) SCons Build Script Generator \u2502 \u251c\u2500\u2500 BooleanOption(info.build) = False in [True, False] \u2502 \u2570\u2500\u2500 EnumerationOption(info.git) = Disabled in [Disabled, Info, Info+Status] \u251c\u2500\u2500 Module(modm:platform) Platform HAL \u2502 \u251c\u2500\u2500 Module(modm:platform:can) Controller Area Network (CAN) \u2502 \u2502 \u2570\u2500\u2500 Module(modm:platform:can:1) Instance 1 \u2502 \u2502 \u251c\u2500\u2500 NumericOption(buffer.rx) = 32 in [1 .. 32 .. 65534] \u2502 \u2502 \u2570\u2500\u2500 NumericOption(buffer.tx) = 32 in [1 .. 32 .. 65534] \u2502 \u251c\u2500\u2500 Module(modm:platform:core) ARM Cortex-M Core \u2502 \u2502 \u251c\u2500\u2500 EnumerationOption(allocator) = newlib in [block, newlib, tlsf] \u2502 \u2502 \u251c\u2500\u2500 NumericOption(main_stack_size) = 3040 in [256 .. 3040 .. 65536] \u2502 \u2502 \u2570\u2500\u2500 EnumerationOption(vector_table_location) = rom in [ram, rom] You can now discover all module options in more detail: $ lbuild -r ../modm/repo.lb -D modm:target=stm32f407vgt discover-options modm:target = stm32f407vgt in [at90can128, at90can32, at90can64, ...] Meta-HAL target device modm:build:build.path = build/parent-folder in [String] Path to the build folder modm:build:project.name = parent-folder in [String] Project name for executable Or check out specific module and option descriptions: $ lbuild -r ../modm/repo.lb -D modm:target=stm32f407vgt discover -n :build >> modm:build [Module] # Build System Generators This parent module defines a common set of functionality that is independent of the specific build system generator implementation. >>>> modm:build:project.name [StringOption] # Project Name The project name defaults to the folder name you're calling lbuild from. Value: parent-folder Inputs: [String] >>>> modm:build:build.path [StringOption] # Build Path The build path is defaulted to `build/{modm:build:project.name}`. Value: build/parent-folder Inputs: [String] The complete lbuild command line interface is available with lbuild -h . Options are checked lbuild checks all your project options against the possible values in the module and outputs an error if they are incorrect. Visualize your dependencies Create a dependency graph with lbuild dependencies -m \"modm:module\" | dot -Tsvg -Grankdir=BT -o dependencies.svg to help you understand what code is pulled in when you generate your library. Custom Configuration \u00b6 In case modm doesn't have a BSP for your board or the BSP uses the hardware in ways you don't like, you can define your own completely custom configuration. Here a completely minimal library is generated for a STM32F469NIH device only with the Cortex-M, GPIO and time modules and their dependencies. Since no build system generator module is specified, you will only get the raw source code. <library> <repositories> <repository><path> ../modm/repo.lb </path></repository> </repositories> <options> <option name= \"modm:target\" > stm32f469nih </option> </options> <modules> <module> modm:platform:clock </module> <module> modm:platform:core </module> <module> modm:platform:gpio </module> </modules> </library> Check your repository path Make sure you've set the correct path to the modm repo.lb file, otherwise lbuild cannot help you much. This is especially important when copying from our examples, which have the repository path set in the inherited common configuration file located in modm/examples/lbuild.xml ! A minimal main.cpp for this configuration would look like this: #include <modm/platform.hpp> using namespace modm :: platform ; int main () { GpioA0 :: setOutput (); while ( 1 ) { GpioA0 :: toggle (); modm :: delayMilliseconds ( 500 ); } } We recommend to start your custom projects with a known-good configuration from one of our examples and then work your way into your specialization. Generate and Compile \u00b6 Once you have your project.xml set up, you can call lbuild build , which generates the target and configuration specific library from modm. This will create a few files and folders: $ ls main.cpp project.xml $ lbuild build $ ls SConstruct main.cpp modm project.xml project.xml.log You can add these folders and files to your .gitignore file, however, we recommend eventually committing these files (yes, all these files) into your project repository so that you don't have issues reproducing the build. Generate custom documentation Include the modm:docs module (or execute lbuild build --module \"modm:docs\" ), then call doxygen doxyfile inside the generated modm/docs folder. The documentation for your target and configuration will then be available in modm/docs/html/index.html . For this project we included the modm:build:scons generator, so we can just call scons build size , which will compile the entire source code and output the resource consumption: $ scons build size scons: Reading SConscript files ... scons: done reading SConscript files. scons: Building targets ... Compiling C++\u00b7\u00b7 build/main.o ... Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/project.elf Memory usage\u00b7\u00b7\u00b7 build/project.elf Program: 3612B (0.3% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3184B (1.6% used) = 144B static (0.1%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197520B (98.4% available) (.heap0 + .heap1 + .heap2 + .heap5) You can program your target by calling scons program . Additional tools are documented in SCons module documentation . If you have any questions, open an issue or ping @salkinium .","title":"Getting Started"},{"location":"guide/getting-started/#getting-started","text":"The easiest way for you to learn about modm's APIs is to look at and experiment with our examples , especially if you have a development board that modm supports out-of-box. Make sure you've installed all tools required for building modm .","title":"Getting Started"},{"location":"guide/getting-started/#tldr","text":"lbuild build # generate modm library (call only once) scons program # compile and upload to your development board To debug with GDB in TUI mode: scons program profile=debug # compile and upload debug profile scons gdb profile=debug # launch OpenOCD and GDB for debugging To generate your target specific Doxygen documentation: (cd modm/docs && doxygen doxyfile.cfg) # may take a minute or two # open modm/docs/html/index.html To remove it all: scons -c # removes build artifacts lbuild clean # removes generated files","title":"TL;DR"},{"location":"guide/getting-started/#quickstart","text":"To generate the modm library for the specific example target, call lbuild build You can then look at the generated modm code in the local modm/src/modm folder. Most of our examples compile with SCons by default, however you can generate a CMake build script by including the CMake build script generator module . lbuild build -m \"::cmake\" To compile the example and modm, call SCons or CMake: scons # or for CMake make cmake # call just once make build-release To upload the example to your development board: scons program # or for CMake make upload-release You can also debug your examples. Make sure you've compiled and uploaded the debug profile first, because debugging a release profile is annoying: scons program profile=debug # or for CMake make upload-debug Then just do this to open up GDB in TUI mode: scons gdb profile=debug # or for CMake make openocd # open another shell to this location make gdb","title":"Quickstart"},{"location":"guide/getting-started/#interesting-examples","text":"We have a lot of examples, 175 to be exact, but here are some of our favorite examples for our supported development boards: Arduino Uno: Blinky , Button & Serial , Analog & Serial . NUCLEO-F031K6: Blinky & Serial . NUCLEO-F103RB: Blinky & Serial . STM32F072 Discovery: Blinky , CAN , Gyroscope . STM32F3 Discovery: Blinky , CAN , Accelerometer , Gyroscope . STM32F4 Discovery: Blinky , CAN , Accelerometer , Timer & LED Animations , Debugging hard faults . STM32F469 Discovery: Blinky , Drawing on display , Touchscreen inputs , Multi-heap with external 16MB memory , Game of Life in Color with Multitouch STM32F769 Discovery: FPU with double precision Here are some additional examples of displays and sensors we like: SSD1306 OLED display : Draws text and graphics onto I2C display. BMP085/BMP180 barometer : Reads atmospheric pressure and temperature from I2C sensor. BMP180/BME280 barometer : Reads atmospheric pressure and temperature from multiple I2C sensors. VL6180 time-of-flight distance sensor : Reads distance and ambient light from I2C sensor. VL53L0 time-of-flight distance sensor : Much improved version of the VL6180 sensor. ADNS9800 motion sensor : Reads 2D motion from SPI sensor used in gaming mice. TCS3414 color sensor : Reads RGB color from I2C sensor. HD44780 over I2C-GPIO expander : Draws text via native GPIO port or I2C-GPIO expander port onto character display.","title":"Interesting Examples"},{"location":"guide/getting-started/#your-own-project","text":"To generate a modm library for your own project, you need to define a project.xml file, which contains the path to where modm is, as well as repository and module options and of course which modules you want to have generated. Even though modm will generate a library that is self-contained, we still recommend adding modm as a git submodule for reproducibility.","title":"Your own Project"},{"location":"guide/getting-started/#using-a-board-support-package","text":"To build on a BSP, inherit from an existing project configuration using the <extends> element. You can discover the available configuration aliases using lbuild : $ lbuild --repository ../modm/repo.lb discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../modm) modm: a barebone embedded library generator \u251c\u2500\u2500 Configuration(modm:arduino-uno) Arduino UNO \u251c\u2500\u2500 Configuration(modm:blue-pill) Blue Pill \u251c\u2500\u2500 Configuration(modm:disco-f469ni) STM32F469IDISCOVERY \u251c\u2500\u2500 Configuration(modm:nucleo-f401re) NUCLEO-F401RE \u251c\u2500\u2500 Configuration(modm:olimexino-stm32) Olimexino STM32 \u2570\u2500\u2500 Configuration(modm:stm32f030_demo) STM32F030 Demo Board Our BSPs declare a minimal set of modules as dependencies as well as pre-define several important options for this board. You can then add all the modules you need and configure them as you want. <library> <repositories> <!-- path to modm repository --> <repository> <path> ../modm/repo.lb </path> </repository> </repositories> <!-- extend this board configuration --> <extends> modm:disco-f469ni </extends> <options> <!-- give this project a custom name --> <option name= \"modm:build:project.name\" > test </option> </options> <modules> <!-- include the SCons build module --> <module> modm:build:scons </module> </modules> </library> Choose a build system Our BSPs do not specify a build system generator, so you need to add the module yourself if you want. Here we use the SCons build system generator, but you can choose others as well . Our board support packages provide their configuration in the Board namespace, which you can use to initialize the target and several board subsystems. If a serial connection is available on the board, you can directly use the modm logging functions. #include <modm/board.hpp> int main () { Board :: initialize (); Board :: Leds :: setOutput (); while ( 1 ) { Board :: Leds :: toggle (); modm :: delayMilliseconds ( Board :: Button :: read () ? 250 : 500 ); #ifdef MODM_BOARD_HAS_LOGGER static uint32_t counter ( 0 ); MODM_LOG_INFO << \"Loop counter: \" << ( counter ++ ) << modm :: endl ; #endif } return 0 ; }","title":"Using a Board Support Package"},{"location":"guide/getting-started/#discovering-modm","text":"To generate your custom library, modm uses the Library Builder , which is the interface to discover available modules and their configuration options. $ lbuild --repository ../modm/repo.lb discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../modm) modm: a barebone embedded library generator \u2570\u2500\u2500 EnumerationOption(target) = REQUIRED in [at90can128, at90can32, at90can64, ... This gives you an overview of the repositories and their options. In this case the modm:target repository option is required, so let's check that out: $ lbuild -r ../modm/repo.lb discover-options modm:target = REQUIRED in [at90can128, at90can32, at90can64, at90pwm1, at90pwm161, at90pwm2, ... a really long list ... stm32l4s9vit, stm32l4s9zij, stm32l4s9zit, stm32l4s9ziy] Meta-HAL target device You can then choose this repository option and discover the available modules for this specific repository option: $ lbuild -r ../modm/repo.lb --option modm:target=stm32f407vgt discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../modm) modm: a barebone embedded library generator \u251c\u2500\u2500 EnumerationOption(target) = stm32f407vgt in [at90can128, at90can32, at90can64, ...] \u251c\u2500\u2500 Configuration(modm:disco-f407vg) STM32F4DISCOVERY \u251c\u2500\u2500 Module(modm:board) Board Support Packages \u2502 \u2570\u2500\u2500 Module(modm:board:disco-f407vg) STM32F4DISCOVERY \u251c\u2500\u2500 Module(modm:build) Build System Generators \u2502 \u251c\u2500\u2500 Option(build.path) = build/parent-folder in [String] \u2502 \u251c\u2500\u2500 Option(project.name) = parent-folder in [String] \u2502 \u2570\u2500\u2500 Module(modm:build:scons) SCons Build Script Generator \u2502 \u251c\u2500\u2500 BooleanOption(info.build) = False in [True, False] \u2502 \u2570\u2500\u2500 EnumerationOption(info.git) = Disabled in [Disabled, Info, Info+Status] \u251c\u2500\u2500 Module(modm:platform) Platform HAL \u2502 \u251c\u2500\u2500 Module(modm:platform:can) Controller Area Network (CAN) \u2502 \u2502 \u2570\u2500\u2500 Module(modm:platform:can:1) Instance 1 \u2502 \u2502 \u251c\u2500\u2500 NumericOption(buffer.rx) = 32 in [1 .. 32 .. 65534] \u2502 \u2502 \u2570\u2500\u2500 NumericOption(buffer.tx) = 32 in [1 .. 32 .. 65534] \u2502 \u251c\u2500\u2500 Module(modm:platform:core) ARM Cortex-M Core \u2502 \u2502 \u251c\u2500\u2500 EnumerationOption(allocator) = newlib in [block, newlib, tlsf] \u2502 \u2502 \u251c\u2500\u2500 NumericOption(main_stack_size) = 3040 in [256 .. 3040 .. 65536] \u2502 \u2502 \u2570\u2500\u2500 EnumerationOption(vector_table_location) = rom in [ram, rom] You can now discover all module options in more detail: $ lbuild -r ../modm/repo.lb -D modm:target=stm32f407vgt discover-options modm:target = stm32f407vgt in [at90can128, at90can32, at90can64, ...] Meta-HAL target device modm:build:build.path = build/parent-folder in [String] Path to the build folder modm:build:project.name = parent-folder in [String] Project name for executable Or check out specific module and option descriptions: $ lbuild -r ../modm/repo.lb -D modm:target=stm32f407vgt discover -n :build >> modm:build [Module] # Build System Generators This parent module defines a common set of functionality that is independent of the specific build system generator implementation. >>>> modm:build:project.name [StringOption] # Project Name The project name defaults to the folder name you're calling lbuild from. Value: parent-folder Inputs: [String] >>>> modm:build:build.path [StringOption] # Build Path The build path is defaulted to `build/{modm:build:project.name}`. Value: build/parent-folder Inputs: [String] The complete lbuild command line interface is available with lbuild -h . Options are checked lbuild checks all your project options against the possible values in the module and outputs an error if they are incorrect. Visualize your dependencies Create a dependency graph with lbuild dependencies -m \"modm:module\" | dot -Tsvg -Grankdir=BT -o dependencies.svg to help you understand what code is pulled in when you generate your library.","title":"Discovering modm"},{"location":"guide/getting-started/#custom-configuration","text":"In case modm doesn't have a BSP for your board or the BSP uses the hardware in ways you don't like, you can define your own completely custom configuration. Here a completely minimal library is generated for a STM32F469NIH device only with the Cortex-M, GPIO and time modules and their dependencies. Since no build system generator module is specified, you will only get the raw source code. <library> <repositories> <repository><path> ../modm/repo.lb </path></repository> </repositories> <options> <option name= \"modm:target\" > stm32f469nih </option> </options> <modules> <module> modm:platform:clock </module> <module> modm:platform:core </module> <module> modm:platform:gpio </module> </modules> </library> Check your repository path Make sure you've set the correct path to the modm repo.lb file, otherwise lbuild cannot help you much. This is especially important when copying from our examples, which have the repository path set in the inherited common configuration file located in modm/examples/lbuild.xml ! A minimal main.cpp for this configuration would look like this: #include <modm/platform.hpp> using namespace modm :: platform ; int main () { GpioA0 :: setOutput (); while ( 1 ) { GpioA0 :: toggle (); modm :: delayMilliseconds ( 500 ); } } We recommend to start your custom projects with a known-good configuration from one of our examples and then work your way into your specialization.","title":"Custom Configuration"},{"location":"guide/getting-started/#generate-and-compile","text":"Once you have your project.xml set up, you can call lbuild build , which generates the target and configuration specific library from modm. This will create a few files and folders: $ ls main.cpp project.xml $ lbuild build $ ls SConstruct main.cpp modm project.xml project.xml.log You can add these folders and files to your .gitignore file, however, we recommend eventually committing these files (yes, all these files) into your project repository so that you don't have issues reproducing the build. Generate custom documentation Include the modm:docs module (or execute lbuild build --module \"modm:docs\" ), then call doxygen doxyfile inside the generated modm/docs folder. The documentation for your target and configuration will then be available in modm/docs/html/index.html . For this project we included the modm:build:scons generator, so we can just call scons build size , which will compile the entire source code and output the resource consumption: $ scons build size scons: Reading SConscript files ... scons: done reading SConscript files. scons: Building targets ... Compiling C++\u00b7\u00b7 build/main.o ... Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/project.elf Memory usage\u00b7\u00b7\u00b7 build/project.elf Program: 3612B (0.3% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3184B (1.6% used) = 144B static (0.1%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197520B (98.4% available) (.heap0 + .heap1 + .heap2 + .heap5) You can program your target by calling scons program . Additional tools are documented in SCons module documentation . If you have any questions, open an issue or ping @salkinium .","title":"Generate and Compile"},{"location":"guide/installation/","text":"Installation \u00b6 This is the required software for generating, compiling and programming projects with modm: Python 3 Software Construct Library Builder AVR toolchain: avr-gcc and avrdude ARM toolchain: gcc-arm-toolchain and OpenOCD . Doxygen Note that the modm examples use the SCons build system by default, however, you are not required to use it. See the reference manual for additional build system documentation. Use GCC 7 or newer modm uses C++17, so you need at least GCC 7. Beware of AVRs We strongly discourage using AVRs for new designs, due to a significant lack of commitment from Atmel on keeping their AVR toolchain up-to-date. Check your Locale If you get a UnicodeEncodeError when calling lbuild , you may need to add export LC_ALL=C.UTF-8 to your .bashrc . Consult the internet until python3 -c \"import sys; print(sys.stdout.encoding)\" returns UTF-8 . Please help us keep these instructions up-to-date ! macOS \u00b6 We will use Homebrew to install the minimal build system: brew install python3 scons git doxygen pip3 install --user modm pip install --user pathlib pyelftools Install the AVR toolchain from source : brew tap osx-cross/avr brew install avr-gcc And the pre-built ARM toolchain as well: brew tap osx-cross/arm brew install arm-gcc-bin brew install openocd --HEAD To compile modm for macOS you need to install these libraries: brew install boost gtkmm sdl zmqpp gcc Linux \u00b6 For Ubuntu 18.04LTS, these commands install the basic build system: sudo apt-get install python3 python3-pip scons git sudo apt-get --no-install-recommends install doxygen pip3 install --user modm pip install --user pathlib pyelftools Install the AVR toochain: sudo apt-get install gcc-avr binutils-avr avr-libc avrdude avr-gcc on Ubuntu Ubuntu does not provide a more recent avr-gcc than v4.9, which does not support C++17 (not even C++14). For our CI we've created a precompiled version of avr-gcc 7 for Ubuntu . Use at your own risk. And the official ARM toolchain as well: sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa sudo apt-get update sudo apt-get install gcc-arm-embedded openocd Manual installation on 64-bit Linux You can also download a precompiled version of the toolchain for 64-bit Linux and manually add the /bin directory to your path. Use this if your distro does not provide you with an up-to-date ARM toolchain. To compile modm for Linux you need to install these packages: sudo apt-get install gcc build-essential libboost-all-dev libzmqpp-dev \\ libsdl1.2-dev libsdl-image1.2-dev libgtkmm-2.4-dev Windows \u00b6 We will use Anaconda to create a new Python 3 environment and install all necessary packages: conda create --name modm python=3 pip activate modm conda install -c conda-forge git pip install jinja2 scons future pyelftools lbuild For ARM development install the Windows 32-bit build of the GNU Arm Embedded Toolchain . For programming and debugging ARM Cortex-M devices install the pre-build OpenOCD binaries . You'll need to add both /bin paths to your PATH variable manually. For non-English speakers For now project and build paths containing non-ASCII characters are not parsed correctly. Dear Windows users We don't regularly use Windows with modm, so we rely on YOU to keep these install instructions working and up-to-date. Please open a PR with improvements .","title":"Installation"},{"location":"guide/installation/#installation","text":"This is the required software for generating, compiling and programming projects with modm: Python 3 Software Construct Library Builder AVR toolchain: avr-gcc and avrdude ARM toolchain: gcc-arm-toolchain and OpenOCD . Doxygen Note that the modm examples use the SCons build system by default, however, you are not required to use it. See the reference manual for additional build system documentation. Use GCC 7 or newer modm uses C++17, so you need at least GCC 7. Beware of AVRs We strongly discourage using AVRs for new designs, due to a significant lack of commitment from Atmel on keeping their AVR toolchain up-to-date. Check your Locale If you get a UnicodeEncodeError when calling lbuild , you may need to add export LC_ALL=C.UTF-8 to your .bashrc . Consult the internet until python3 -c \"import sys; print(sys.stdout.encoding)\" returns UTF-8 . Please help us keep these instructions up-to-date !","title":"Installation"},{"location":"guide/installation/#macos","text":"We will use Homebrew to install the minimal build system: brew install python3 scons git doxygen pip3 install --user modm pip install --user pathlib pyelftools Install the AVR toolchain from source : brew tap osx-cross/avr brew install avr-gcc And the pre-built ARM toolchain as well: brew tap osx-cross/arm brew install arm-gcc-bin brew install openocd --HEAD To compile modm for macOS you need to install these libraries: brew install boost gtkmm sdl zmqpp gcc","title":"macOS"},{"location":"guide/installation/#linux","text":"For Ubuntu 18.04LTS, these commands install the basic build system: sudo apt-get install python3 python3-pip scons git sudo apt-get --no-install-recommends install doxygen pip3 install --user modm pip install --user pathlib pyelftools Install the AVR toochain: sudo apt-get install gcc-avr binutils-avr avr-libc avrdude avr-gcc on Ubuntu Ubuntu does not provide a more recent avr-gcc than v4.9, which does not support C++17 (not even C++14). For our CI we've created a precompiled version of avr-gcc 7 for Ubuntu . Use at your own risk. And the official ARM toolchain as well: sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa sudo apt-get update sudo apt-get install gcc-arm-embedded openocd Manual installation on 64-bit Linux You can also download a precompiled version of the toolchain for 64-bit Linux and manually add the /bin directory to your path. Use this if your distro does not provide you with an up-to-date ARM toolchain. To compile modm for Linux you need to install these packages: sudo apt-get install gcc build-essential libboost-all-dev libzmqpp-dev \\ libsdl1.2-dev libsdl-image1.2-dev libgtkmm-2.4-dev","title":"Linux"},{"location":"guide/installation/#windows","text":"We will use Anaconda to create a new Python 3 environment and install all necessary packages: conda create --name modm python=3 pip activate modm conda install -c conda-forge git pip install jinja2 scons future pyelftools lbuild For ARM development install the Windows 32-bit build of the GNU Arm Embedded Toolchain . For programming and debugging ARM Cortex-M devices install the pre-build OpenOCD binaries . You'll need to add both /bin paths to your PATH variable manually. For non-English speakers For now project and build paths containing non-ASCII characters are not parsed correctly. Dear Windows users We don't regularly use Windows with modm, so we rely on YOU to keep these install instructions working and up-to-date. Please open a PR with improvements .","title":"Windows"},{"location":"guide/testing/","text":"Testing modm \u00b6 modm includes a large number of example as well as an extensive unit test suite which can be compiled and execute on hosted and embedded targets. We\u2018ve written our own small test harness to be able to fit the tests onto very small devices like AVRs. As part of our Continuous Integration checks, all examples are compiled and hundreds of unit tests are executed to help us catch regressions. However, there is room for improvement in both our test coverage, as well as our test execution. For example, while most important platform-independent code is covered in our unit tests, the HAL is not tested systematically but only manually whenever a developer executes an example on their hardware or works on the HAL. Nevertheless, the quality is still fairly high, mostly due to the relative simplicity of our HAL driver code. Here are some guidelines and tips on how to make the best of what testing abilities we have available today. Manual Tests \u00b6 There is plenty of opportunity to customize modm, either using lbuild\u2018s module options or simply by using the HAL on your specific hardware. This means the more examples we have of different configurations and use-cases the better we can debug existing problems and prevent new ones. So when working on a fix or a new feature, make sure to create a simple example, so that others have an idea of the environment in which it was developed. Test your new code on real hardware with the compiler toolchain we use and make sure to document any caveats you discover. You can compile all examples locally using our helper script. $ cd examples $ ../tools/scripts/examples_compile.py . Add your example to our CI If you created a new folder inside modm/examples , you need to add it to one of the jobs in .circleci/config.yml : - run: name: Examples YOUR TARGET command: | ( cd examples && ../tools/scripts/examples_compile.py new_folder ) Unit Tests \u00b6 Our unit tests are located in the modm/test directory and are generated using lbuild as well. They are all submodules of modm:test and are all platform independent. We\u2018ve written a small Makefile for the most commonly used commands. $ cd tests # generates, compiles and executes the unit tests for hosted targets $ make run-hosted-linux $ make run-hosted-darwin # generates and compiles the unit tests for embedded targets $ make compile-nucleo-f411 $ make compile-nucleo-f103 $ make compile-al-avreb-can # executes the unit tests on the embedded targets $ make run-nucleo-f411 $ make run-nucleo-f103 $ make run-al-avreb-can Monitor the serial output The embedded test targets all use the modm::Board interface to initialize the targets and output unit tests results via the default serial connection. The unit test library we use is located in modm/src/unittest which is the modm:unittest modules. See the existing unit tests for example on how to write your own. Running unit tests on small targets Fitting all unit tests into one executable image is not possible on smaller AVR and STM32 targets. For these targets only a subset of unit tests must be selected in the project.xml file and multiple images must be executed manually. We would like to automate this in the future. Test all Targets \u00b6 Apart from unit tests, we also generate the HAL (all modules in modm:platform:** ) for ALL targets we support and compile it with a simple GPIO example. This doesn't catch everything, but it does make sure that these modules are at least compilable, which is particularly interesting when writing new peripheral drivers which may have different implementations on other targets. You may call $ cd test/all $ make run-avr # run for all AVRs $ make run-stm32 # run for all STM32, this may take a while $ python3 run_all.py stm32f4 o stm32f410t8y 75 .9s o stm32f410cbt 81 .9s ... o stm32f479zgt 19 .7s o stm32f479ngh 20 .3s SUCCESS 209 FAIL 0 ------------------ Total: 209 $ make run-failed # only run those that failed the last test Target Compilation Logs The individual compilation logs are all saved as artifacts, so that when something fails, it\u2018s easy to understand why. You can access them in the Artifacts tab of a build . Continuous Integration \u00b6 modm uses CircleCI as a Continuous Integration service . It compiles all the examples and executes the unit tests on Linux, then generates and compiles the full library for a blinky example for all targets that we support. In the future we would like to execute the unit tests as well as the examples automatically on the target hardware as well. However, there isn\u2018t any third-party framework to make that easy, so we probably have to write our own.","title":"Testing"},{"location":"guide/testing/#testing-modm","text":"modm includes a large number of example as well as an extensive unit test suite which can be compiled and execute on hosted and embedded targets. We\u2018ve written our own small test harness to be able to fit the tests onto very small devices like AVRs. As part of our Continuous Integration checks, all examples are compiled and hundreds of unit tests are executed to help us catch regressions. However, there is room for improvement in both our test coverage, as well as our test execution. For example, while most important platform-independent code is covered in our unit tests, the HAL is not tested systematically but only manually whenever a developer executes an example on their hardware or works on the HAL. Nevertheless, the quality is still fairly high, mostly due to the relative simplicity of our HAL driver code. Here are some guidelines and tips on how to make the best of what testing abilities we have available today.","title":"Testing modm"},{"location":"guide/testing/#manual-tests","text":"There is plenty of opportunity to customize modm, either using lbuild\u2018s module options or simply by using the HAL on your specific hardware. This means the more examples we have of different configurations and use-cases the better we can debug existing problems and prevent new ones. So when working on a fix or a new feature, make sure to create a simple example, so that others have an idea of the environment in which it was developed. Test your new code on real hardware with the compiler toolchain we use and make sure to document any caveats you discover. You can compile all examples locally using our helper script. $ cd examples $ ../tools/scripts/examples_compile.py . Add your example to our CI If you created a new folder inside modm/examples , you need to add it to one of the jobs in .circleci/config.yml : - run: name: Examples YOUR TARGET command: | ( cd examples && ../tools/scripts/examples_compile.py new_folder )","title":"Manual Tests"},{"location":"guide/testing/#unit-tests","text":"Our unit tests are located in the modm/test directory and are generated using lbuild as well. They are all submodules of modm:test and are all platform independent. We\u2018ve written a small Makefile for the most commonly used commands. $ cd tests # generates, compiles and executes the unit tests for hosted targets $ make run-hosted-linux $ make run-hosted-darwin # generates and compiles the unit tests for embedded targets $ make compile-nucleo-f411 $ make compile-nucleo-f103 $ make compile-al-avreb-can # executes the unit tests on the embedded targets $ make run-nucleo-f411 $ make run-nucleo-f103 $ make run-al-avreb-can Monitor the serial output The embedded test targets all use the modm::Board interface to initialize the targets and output unit tests results via the default serial connection. The unit test library we use is located in modm/src/unittest which is the modm:unittest modules. See the existing unit tests for example on how to write your own. Running unit tests on small targets Fitting all unit tests into one executable image is not possible on smaller AVR and STM32 targets. For these targets only a subset of unit tests must be selected in the project.xml file and multiple images must be executed manually. We would like to automate this in the future.","title":"Unit Tests"},{"location":"guide/testing/#test-all-targets","text":"Apart from unit tests, we also generate the HAL (all modules in modm:platform:** ) for ALL targets we support and compile it with a simple GPIO example. This doesn't catch everything, but it does make sure that these modules are at least compilable, which is particularly interesting when writing new peripheral drivers which may have different implementations on other targets. You may call $ cd test/all $ make run-avr # run for all AVRs $ make run-stm32 # run for all STM32, this may take a while $ python3 run_all.py stm32f4 o stm32f410t8y 75 .9s o stm32f410cbt 81 .9s ... o stm32f479zgt 19 .7s o stm32f479ngh 20 .3s SUCCESS 209 FAIL 0 ------------------ Total: 209 $ make run-failed # only run those that failed the last test Target Compilation Logs The individual compilation logs are all saved as artifacts, so that when something fails, it\u2018s easy to understand why. You can access them in the Artifacts tab of a build .","title":"Test all Targets"},{"location":"guide/testing/#continuous-integration","text":"modm uses CircleCI as a Continuous Integration service . It compiles all the examples and executes the unit tests on Linux, then generates and compiles the full library for a blinky example for all targets that we support. In the future we would like to execute the unit tests as well as the examples automatically on the target hardware as well. However, there isn\u2018t any third-party framework to make that easy, so we probably have to write our own.","title":"Continuous Integration"},{"location":"reference/build-systems/","text":"Build Systems \u00b6 Before modm our HAL code generation was done as a SCons tool during compilation. This worked for us, however, made it very difficult to include our code into other build systems. We therefore made the code generation a separate step with lbuild. There are two build script generators shipping with modm, which in cooperation with the parent modm:build module provide compilation, uploading and debugging functionality. SCons \u00b6 The modm:build:scons module extends the default SCons build system with many custom utilities for a smooth integration of embedded tools. Read the module documentation for all the details . CMake \u00b6 The modm:build:cmake module configures CMake for compiling modm for STM32 targets. This module ships with a Makefile that wraps all of the CMake commands. Read the module documentation for all the details .","title":"Build Systems"},{"location":"reference/build-systems/#build-systems","text":"Before modm our HAL code generation was done as a SCons tool during compilation. This worked for us, however, made it very difficult to include our code into other build systems. We therefore made the code generation a separate step with lbuild. There are two build script generators shipping with modm, which in cooperation with the parent modm:build module provide compilation, uploading and debugging functionality.","title":"Build Systems"},{"location":"reference/build-systems/#scons","text":"The modm:build:scons module extends the default SCons build system with many custom utilities for a smooth integration of embedded tools. Read the module documentation for all the details .","title":"SCons"},{"location":"reference/build-systems/#cmake","text":"The modm:build:cmake module configures CMake for compiling modm for STM32 targets. This module ships with a Makefile that wraps all of the CMake commands. Read the module documentation for all the details .","title":"CMake"},{"location":"reference/module/modm-architecture-1-wire/","text":"These module docs are in beta and may be incomplete. modm:architecture:1-wire: 1-Wire \u00b6 1-Wire is a device communications bus system designed by Dallas Semiconductor Corp. that provides low-speed data, signaling and power over a single signal. 1-Wire is similar in concept to I\u00b2C, but with lower data rates and longer range. It is typically used to communicate with small inexpensive devices such as digital thermometers and weather instruments. One distinctive feature of the bus is the possibility to use only two wires: data and ground. To accomplish this, 1-wire devices include an 800 pF capacitor to store charge, and power the device during periods where the data line is used for data. Content \u00b6 // Enum enum RomCommand ; Dependencies \u00b6 modm:architecture:1-wire modm_architecture_1_wire modm: architecture: 1-wire modm_architecture modm: architecture modm_architecture_1_wire->modm_architecture modm_driver_ds18b20 modm: driver: ds18b20 modm_driver_ds18b20->modm_architecture_1_wire modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_architecture_1_wire","title":"modm:architecture:1-wire"},{"location":"reference/module/modm-architecture-1-wire/#modmarchitecture1-wire-1-wire","text":"1-Wire is a device communications bus system designed by Dallas Semiconductor Corp. that provides low-speed data, signaling and power over a single signal. 1-Wire is similar in concept to I\u00b2C, but with lower data rates and longer range. It is typically used to communicate with small inexpensive devices such as digital thermometers and weather instruments. One distinctive feature of the bus is the possibility to use only two wires: data and ground. To accomplish this, 1-wire devices include an 800 pF capacitor to store charge, and power the device during periods where the data line is used for data.","title":"modm:architecture:1-wire: 1-Wire"},{"location":"reference/module/modm-architecture-1-wire/#content","text":"// Enum enum RomCommand ;","title":"Content"},{"location":"reference/module/modm-architecture-1-wire/#dependencies","text":"modm:architecture:1-wire modm_architecture_1_wire modm: architecture: 1-wire modm_architecture modm: architecture modm_architecture_1_wire->modm_architecture modm_driver_ds18b20 modm: driver: ds18b20 modm_driver_ds18b20->modm_architecture_1_wire modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_architecture_1_wire","title":"Dependencies"},{"location":"reference/module/modm-architecture-accessor/","text":"These module docs are in beta and may be incomplete. modm:architecture:accessor: Memory Accessors \u00b6 Content \u00b6 // Class class modm :: accessor :: Flash < typename T > ; class modm :: accessor :: Ram < typename T > ; // Function inline :: modm :: accessor :: Flash < T > modm :: accessor :: asFlash ( const T * ptr ); modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < T > ptr ); static modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < char > ptr ); volatile T & modm :: accessor :: asVolatile ( T & value ); // Define #define EXTERN_FLASH_STORAGE(var) #define EXTERN_FLASH_STORAGE_STRING(s) #define FLASH_STORAGE(var) #define FLASH_STORAGE_STRING(s) #define IFSS(s) Dependencies \u00b6 modm:architecture:accessor modm_architecture_accessor modm: architecture: accessor modm_architecture modm: architecture modm_architecture_accessor->modm_architecture modm_io modm: io modm_architecture_accessor->modm_io modm_io->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_architecture_assert->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_architecture_atomic->modm_architecture_accessor modm_communication_sab modm: communication: sab modm_communication_sab->modm_architecture_accessor modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_architecture_accessor modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_accessor modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_architecture_accessor modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_accessor modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_architecture_accessor modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_accessor modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_architecture_accessor modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_accessor modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_accessor modm_processing_scheduler modm: processing: scheduler modm_processing_scheduler->modm_architecture_accessor modm_ui_display modm: ui: display modm_ui_display->modm_architecture_accessor modm_ui_led modm: ui: led modm_ui_led->modm_architecture_accessor modm_ui_time modm: ui: time modm_ui_time->modm_architecture_accessor modm_unittest modm: unittest modm_unittest->modm_architecture_accessor","title":"modm:architecture:accessor"},{"location":"reference/module/modm-architecture-accessor/#modmarchitectureaccessor-memory-accessors","text":"","title":"modm:architecture:accessor: Memory Accessors"},{"location":"reference/module/modm-architecture-accessor/#content","text":"// Class class modm :: accessor :: Flash < typename T > ; class modm :: accessor :: Ram < typename T > ; // Function inline :: modm :: accessor :: Flash < T > modm :: accessor :: asFlash ( const T * ptr ); modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < T > ptr ); static modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < char > ptr ); volatile T & modm :: accessor :: asVolatile ( T & value ); // Define #define EXTERN_FLASH_STORAGE(var) #define EXTERN_FLASH_STORAGE_STRING(s) #define FLASH_STORAGE(var) #define FLASH_STORAGE_STRING(s) #define IFSS(s)","title":"Content"},{"location":"reference/module/modm-architecture-accessor/#dependencies","text":"modm:architecture:accessor modm_architecture_accessor modm: architecture: accessor modm_architecture modm: architecture modm_architecture_accessor->modm_architecture modm_io modm: io modm_architecture_accessor->modm_io modm_io->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_architecture_assert->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_architecture_atomic->modm_architecture_accessor modm_communication_sab modm: communication: sab modm_communication_sab->modm_architecture_accessor modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_architecture_accessor modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_accessor modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_architecture_accessor modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_accessor modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_architecture_accessor modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_accessor modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_architecture_accessor modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_accessor modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_accessor modm_processing_scheduler modm: processing: scheduler modm_processing_scheduler->modm_architecture_accessor modm_ui_display modm: ui: display modm_ui_display->modm_architecture_accessor modm_ui_led modm: ui: led modm_ui_led->modm_architecture_accessor modm_ui_time modm: ui: time modm_ui_time->modm_architecture_accessor modm_unittest modm: unittest modm_unittest->modm_architecture_accessor","title":"Dependencies"},{"location":"reference/module/modm-architecture-adc/","text":"These module docs are in beta and may be incomplete. modm:architecture:adc: Analog-to-Digital Converters \u00b6 Content \u00b6 // Class class modm :: Adc ; class modm :: AdcInterrupt ; Dependencies \u00b6 modm:architecture:adc modm_architecture_adc modm: architecture: adc modm_architecture modm: architecture modm_architecture_adc->modm_architecture modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_architecture_adc modm_platform_adc modm: platform: adc modm_platform_adc->modm_architecture_adc","title":"modm:architecture:adc"},{"location":"reference/module/modm-architecture-adc/#modmarchitectureadc-analog-to-digital-converters","text":"","title":"modm:architecture:adc: Analog-to-Digital Converters"},{"location":"reference/module/modm-architecture-adc/#content","text":"// Class class modm :: Adc ; class modm :: AdcInterrupt ;","title":"Content"},{"location":"reference/module/modm-architecture-adc/#dependencies","text":"modm:architecture:adc modm_architecture_adc modm: architecture: adc modm_architecture modm: architecture modm_architecture_adc->modm_architecture modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_architecture_adc modm_platform_adc modm: platform: adc modm_platform_adc->modm_architecture_adc","title":"Dependencies"},{"location":"reference/module/modm-architecture-assert/","text":"These module docs are in beta and may be incomplete. modm:architecture:assert: Assertions \u00b6 These functions allow you to assert a condition at runtime and define failure handlers in your application that can decide what to do with this assertion and provide custom functionality. Each assertion has the form modm_assert(condition, module, location, failure) , where the condition is a boolean and rest are strings, so that a simple string compare can be used to match for module, location or failure. For example, the identifier \"can\", \"init\", \"timeout\" describes a timeout failure in the CAN initializer function. The assert modm_assert_debug(condition, module, location, failure) is only available on debug builds and is removed from the code for a release build. The user can define one or multiple assertion handlers in any part of the application using the MODM_ASSERTION_HANDLER(function) macro. All assertion handlers will be executed when an assertion fails anywhere in the code and get passed the identifier string. Note The order of assertion handler execution is undefined and must not been relied upon for any functionality! Warning Assertion handlers may be executed in interrupt context! Depending on the information in the failure identifier, the assertion handler returns Abandonment::DontCare if the failure is not of interest, or Abandonment::Ignore for recoverable failures, or Abandonment::Fail for failures that do not allow normal program continuation. The program is aborted, if any assertion handler returns Abandonment::Fail , all assertion handlers return Abandonment::DontCare or no assertion handlers have been defined in the application. Only if one or many assertion handlers return Abandonment::Ignore and the remainder returns Abandonment::DontCare , only then is the assertion ignored. Note It is intended that the assertion handlers do not block (forever), so that all assertion handlers can get called. On program abandonment modm_abandon(module, location, failure) is called, which exits the program silently by default. Only on hosted an formatted error string is output by default. It is therefore recommended to overwrite this function on embedded targets for custom behavior like blinking an LED and printing to a serial connection. Warning The abandonment handler may also be executed in interrupt context! Content \u00b6 // Function bool modm_assert ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); void modm_abandon ( const char * module , const char * location , const char * failure , uintptr_t context ) modm_weak ; // Enum enum Abandonment ; // Typedef using modm :: AssertionHandler = typedef Abandonment ( * )( const char * module , const char * location , const char * failure , uintptr_t context ); // Define #define MODM_ASSERTION_HANDLER(handler) Dependencies \u00b6 modm:architecture:assert modm_architecture_assert modm: architecture: assert modm_architecture modm: architecture modm_architecture_assert->modm_architecture modm_architecture_accessor modm: architecture: accessor modm_architecture_assert->modm_architecture_accessor modm_math_utils modm: math: utils modm_architecture_assert->modm_math_utils modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_assert modm_freertos modm: freertos modm_freertos->modm_architecture_assert modm_platform_can modm: platform: can modm_platform_can->modm_architecture_assert modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_assert modm_processing_resumable modm: processing: resumable modm_processing_resumable->modm_architecture_assert","title":"modm:architecture:assert"},{"location":"reference/module/modm-architecture-assert/#modmarchitectureassert-assertions","text":"These functions allow you to assert a condition at runtime and define failure handlers in your application that can decide what to do with this assertion and provide custom functionality. Each assertion has the form modm_assert(condition, module, location, failure) , where the condition is a boolean and rest are strings, so that a simple string compare can be used to match for module, location or failure. For example, the identifier \"can\", \"init\", \"timeout\" describes a timeout failure in the CAN initializer function. The assert modm_assert_debug(condition, module, location, failure) is only available on debug builds and is removed from the code for a release build. The user can define one or multiple assertion handlers in any part of the application using the MODM_ASSERTION_HANDLER(function) macro. All assertion handlers will be executed when an assertion fails anywhere in the code and get passed the identifier string. Note The order of assertion handler execution is undefined and must not been relied upon for any functionality! Warning Assertion handlers may be executed in interrupt context! Depending on the information in the failure identifier, the assertion handler returns Abandonment::DontCare if the failure is not of interest, or Abandonment::Ignore for recoverable failures, or Abandonment::Fail for failures that do not allow normal program continuation. The program is aborted, if any assertion handler returns Abandonment::Fail , all assertion handlers return Abandonment::DontCare or no assertion handlers have been defined in the application. Only if one or many assertion handlers return Abandonment::Ignore and the remainder returns Abandonment::DontCare , only then is the assertion ignored. Note It is intended that the assertion handlers do not block (forever), so that all assertion handlers can get called. On program abandonment modm_abandon(module, location, failure) is called, which exits the program silently by default. Only on hosted an formatted error string is output by default. It is therefore recommended to overwrite this function on embedded targets for custom behavior like blinking an LED and printing to a serial connection. Warning The abandonment handler may also be executed in interrupt context!","title":"modm:architecture:assert: Assertions"},{"location":"reference/module/modm-architecture-assert/#content","text":"// Function bool modm_assert ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); void modm_abandon ( const char * module , const char * location , const char * failure , uintptr_t context ) modm_weak ; // Enum enum Abandonment ; // Typedef using modm :: AssertionHandler = typedef Abandonment ( * )( const char * module , const char * location , const char * failure , uintptr_t context ); // Define #define MODM_ASSERTION_HANDLER(handler)","title":"Content"},{"location":"reference/module/modm-architecture-assert/#dependencies","text":"modm:architecture:assert modm_architecture_assert modm: architecture: assert modm_architecture modm: architecture modm_architecture_assert->modm_architecture modm_architecture_accessor modm: architecture: accessor modm_architecture_assert->modm_architecture_accessor modm_math_utils modm: math: utils modm_architecture_assert->modm_math_utils modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_assert modm_freertos modm: freertos modm_freertos->modm_architecture_assert modm_platform_can modm: platform: can modm_platform_can->modm_architecture_assert modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_assert modm_processing_resumable modm: processing: resumable modm_processing_resumable->modm_architecture_assert","title":"Dependencies"},{"location":"reference/module/modm-architecture-atomic/","text":"These module docs are in beta and may be incomplete. modm:architecture:atomic: Atomic Operations and Containers \u00b6 Content \u00b6 // Class class modm :: atomic :: Container < typename T > ; class modm :: atomic :: Flag ; class modm :: atomic :: Lock ; class modm :: atomic :: Queue < typename T , std :: size_t N > ; class modm :: atomic :: Unlock ; Dependencies \u00b6 modm:architecture:atomic modm_architecture_atomic modm: architecture: atomic modm_architecture modm: architecture modm_architecture_atomic->modm_architecture modm_architecture_accessor modm: architecture: accessor modm_architecture_atomic->modm_architecture_accessor modm_utils modm: utils modm_architecture_atomic->modm_utils modm_platform_can modm: platform: can modm_platform_can->modm_architecture_atomic modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_atomic modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_atomic modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_atomic modm_processing_scheduler modm: processing: scheduler modm_processing_scheduler->modm_architecture_atomic modm_ui_button modm: ui: button modm_ui_button->modm_architecture_atomic","title":"modm:architecture:atomic"},{"location":"reference/module/modm-architecture-atomic/#modmarchitectureatomic-atomic-operations-and-containers","text":"","title":"modm:architecture:atomic: Atomic Operations and Containers"},{"location":"reference/module/modm-architecture-atomic/#content","text":"// Class class modm :: atomic :: Container < typename T > ; class modm :: atomic :: Flag ; class modm :: atomic :: Lock ; class modm :: atomic :: Queue < typename T , std :: size_t N > ; class modm :: atomic :: Unlock ;","title":"Content"},{"location":"reference/module/modm-architecture-atomic/#dependencies","text":"modm:architecture:atomic modm_architecture_atomic modm: architecture: atomic modm_architecture modm: architecture modm_architecture_atomic->modm_architecture modm_architecture_accessor modm: architecture: accessor modm_architecture_atomic->modm_architecture_accessor modm_utils modm: utils modm_architecture_atomic->modm_utils modm_platform_can modm: platform: can modm_platform_can->modm_architecture_atomic modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_atomic modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_atomic modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_atomic modm_processing_scheduler modm: processing: scheduler modm_processing_scheduler->modm_architecture_atomic modm_ui_button modm: ui: button modm_ui_button->modm_architecture_atomic","title":"Dependencies"},{"location":"reference/module/modm-architecture-block-device/","text":"These module docs are in beta and may be incomplete. modm:architecture:block.device: Block Devices \u00b6 Content \u00b6 // Class class modm :: BlockDevice ; Dependencies \u00b6 modm:architecture:block.device modm_architecture_block_device modm: architecture: block.device modm_architecture modm: architecture modm_architecture_block_device->modm_architecture modm_processing_resumable modm: processing: resumable modm_architecture_block_device->modm_processing_resumable modm_driver_block_device_heap modm: driver: block.device: heap modm_driver_block_device_heap->modm_architecture_block_device modm_driver_block_device_mirror modm: driver: block.device: mirror modm_driver_block_device_mirror->modm_architecture_block_device modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_architecture_block_device","title":"modm:architecture:block.device"},{"location":"reference/module/modm-architecture-block-device/#modmarchitectureblockdevice-block-devices","text":"","title":"modm:architecture:block.device: Block Devices"},{"location":"reference/module/modm-architecture-block-device/#content","text":"// Class class modm :: BlockDevice ;","title":"Content"},{"location":"reference/module/modm-architecture-block-device/#dependencies","text":"modm:architecture:block.device modm_architecture_block_device modm: architecture: block.device modm_architecture modm: architecture modm_architecture_block_device->modm_architecture modm_processing_resumable modm: processing: resumable modm_architecture_block_device->modm_processing_resumable modm_driver_block_device_heap modm: driver: block.device: heap modm_driver_block_device_heap->modm_architecture_block_device modm_driver_block_device_mirror modm: driver: block.device: mirror modm_driver_block_device_mirror->modm_architecture_block_device modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_architecture_block_device","title":"Dependencies"},{"location":"reference/module/modm-architecture-can/","text":"These module docs are in beta and may be incomplete. modm:architecture:can: Controller Area Network \u00b6 Controller\u2013area network (CAN or CAN-bus) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other within a vehicle without a host computer. CAN is a message based protocol, designed specifically for automotive applications but now also used in other areas such as industrial automation and medical equipment. Content \u00b6 // Class class modm :: Can ; // Struct struct modm :: can :: Message :: Flags ; struct modm :: can :: Message ; // Function modm :: IOStream & modm :: can :: operator << ( modm :: IOStream & s , const modm :: can :: Message m ); modm :: IOStream & modm :: operator << ( modm :: IOStream & stream , const Can :: BusState state ); Dependencies \u00b6 modm:architecture:can modm_architecture_can modm: architecture: can modm_architecture modm: architecture modm_architecture_can->modm_architecture modm_io modm: io modm_architecture_can->modm_io modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_architecture_can modm_driver_lawicel modm: driver: lawicel modm_driver_lawicel->modm_architecture_can modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_can modm_platform_can modm: platform: can modm_platform_can->modm_architecture_can","title":"modm:architecture:can"},{"location":"reference/module/modm-architecture-can/#modmarchitecturecan-controller-area-network","text":"Controller\u2013area network (CAN or CAN-bus) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other within a vehicle without a host computer. CAN is a message based protocol, designed specifically for automotive applications but now also used in other areas such as industrial automation and medical equipment.","title":"modm:architecture:can: Controller Area Network"},{"location":"reference/module/modm-architecture-can/#content","text":"// Class class modm :: Can ; // Struct struct modm :: can :: Message :: Flags ; struct modm :: can :: Message ; // Function modm :: IOStream & modm :: can :: operator << ( modm :: IOStream & s , const modm :: can :: Message m ); modm :: IOStream & modm :: operator << ( modm :: IOStream & stream , const Can :: BusState state );","title":"Content"},{"location":"reference/module/modm-architecture-can/#dependencies","text":"modm:architecture:can modm_architecture_can modm: architecture: can modm_architecture modm: architecture modm_architecture_can->modm_architecture modm_io modm: io modm_architecture_can->modm_io modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_architecture_can modm_driver_lawicel modm: driver: lawicel modm_driver_lawicel->modm_architecture_can modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_can modm_platform_can modm: platform: can modm_platform_can->modm_architecture_can","title":"Dependencies"},{"location":"reference/module/modm-architecture-clock/","text":"These module docs are in beta and may be incomplete. modm:architecture:clock: System Tick \u00b6 Content \u00b6 // Class class modm :: Clock ; Dependencies \u00b6 modm:architecture:clock modm_architecture_clock modm: architecture: clock modm_architecture modm: architecture modm_architecture_clock->modm_architecture modm_processing_timer modm: processing: timer modm_architecture_clock->modm_processing_timer modm_processing_timer->modm_architecture_clock modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_architecture_clock modm_communication_ros modm: communication: ros modm_communication_ros->modm_architecture_clock modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_clock modm_platform_can modm: platform: can modm_platform_can->modm_architecture_clock modm_platform_can_common modm: platform: can.common modm_platform_can_common->modm_architecture_clock modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_clock modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_architecture_clock modm_platform_systick modm: platform: systick modm_platform_systick->modm_architecture_clock modm_ui_animation modm: ui: animation modm_ui_animation->modm_architecture_clock modm_ui_led modm: ui: led modm_ui_led->modm_architecture_clock","title":"modm:architecture:clock"},{"location":"reference/module/modm-architecture-clock/#modmarchitectureclock-system-tick","text":"","title":"modm:architecture:clock: System Tick"},{"location":"reference/module/modm-architecture-clock/#content","text":"// Class class modm :: Clock ;","title":"Content"},{"location":"reference/module/modm-architecture-clock/#dependencies","text":"modm:architecture:clock modm_architecture_clock modm: architecture: clock modm_architecture modm: architecture modm_architecture_clock->modm_architecture modm_processing_timer modm: processing: timer modm_architecture_clock->modm_processing_timer modm_processing_timer->modm_architecture_clock modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_architecture_clock modm_communication_ros modm: communication: ros modm_communication_ros->modm_architecture_clock modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_clock modm_platform_can modm: platform: can modm_platform_can->modm_architecture_clock modm_platform_can_common modm: platform: can.common modm_platform_can_common->modm_architecture_clock modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_clock modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_architecture_clock modm_platform_systick modm: platform: systick modm_platform_systick->modm_architecture_clock modm_ui_animation modm: ui: animation modm_ui_animation->modm_architecture_clock modm_ui_led modm: ui: led modm_ui_led->modm_architecture_clock","title":"Dependencies"},{"location":"reference/module/modm-architecture-delay/","text":"These module docs are in beta and may be incomplete. modm:architecture:delay: Blocking Delays \u00b6 These functions allow you to spin for a short time using only the CPU. You should always prefer Software Timers (see modm:processing:timer ) over these blocking delay functions. However, when modm::Clock is not set up yet, or when you need very small delays (for example to bit-bang a protocol), you need to use these delay functions. The only guarantee given to you is to delay for at least the specified time. Note that invocation of interrupts during spinning may add delay too. No real-time guarantees! You must not rely on delay functions for ANY time-keeping! Delay functions work at any CPU clock speed, even if changed dynamically and are available very early in the startup process at hardware-init time. Use the largest time unit possible! Correct behavior is not guaranteed for delays over 1000ns, us or ms! Content \u00b6 // Function void modm :: delayMicroseconds ( uint16_t us ); void modm :: delayMilliseconds ( uint16_t ms ); void modm :: delayNanoseconds ( uint16_t ns ); Dependencies \u00b6 modm:architecture:delay modm_architecture_delay modm: architecture: delay modm_architecture modm: architecture modm_architecture_delay->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_architecture_delay modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_architecture_delay modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_delay modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_architecture_delay modm_driver_ads7843 modm: driver: ads7843 modm_driver_ads7843->modm_architecture_delay modm_driver_ds1302 modm: driver: ds1302 modm_driver_ds1302->modm_architecture_delay modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_architecture_delay modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_architecture_delay modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_architecture_delay modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_delay modm_driver_memory_bus modm: driver: memory_bus modm_driver_memory_bus->modm_architecture_delay modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_architecture_delay modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_driver_parallel_tft_display->modm_architecture_delay modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_architecture_delay modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_architecture_delay modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_architecture_delay modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_architecture_delay modm_platform_can modm: platform: can modm_platform_can->modm_architecture_delay modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_delay modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_architecture_delay modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_architecture_delay","title":"modm:architecture:delay"},{"location":"reference/module/modm-architecture-delay/#modmarchitecturedelay-blocking-delays","text":"These functions allow you to spin for a short time using only the CPU. You should always prefer Software Timers (see modm:processing:timer ) over these blocking delay functions. However, when modm::Clock is not set up yet, or when you need very small delays (for example to bit-bang a protocol), you need to use these delay functions. The only guarantee given to you is to delay for at least the specified time. Note that invocation of interrupts during spinning may add delay too. No real-time guarantees! You must not rely on delay functions for ANY time-keeping! Delay functions work at any CPU clock speed, even if changed dynamically and are available very early in the startup process at hardware-init time. Use the largest time unit possible! Correct behavior is not guaranteed for delays over 1000ns, us or ms!","title":"modm:architecture:delay: Blocking Delays"},{"location":"reference/module/modm-architecture-delay/#content","text":"// Function void modm :: delayMicroseconds ( uint16_t us ); void modm :: delayMilliseconds ( uint16_t ms ); void modm :: delayNanoseconds ( uint16_t ns );","title":"Content"},{"location":"reference/module/modm-architecture-delay/#dependencies","text":"modm:architecture:delay modm_architecture_delay modm: architecture: delay modm_architecture modm: architecture modm_architecture_delay->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_architecture_delay modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_architecture_delay modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_delay modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_architecture_delay modm_driver_ads7843 modm: driver: ads7843 modm_driver_ads7843->modm_architecture_delay modm_driver_ds1302 modm: driver: ds1302 modm_driver_ds1302->modm_architecture_delay modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_architecture_delay modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_architecture_delay modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_architecture_delay modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_architecture_delay modm_driver_memory_bus modm: driver: memory_bus modm_driver_memory_bus->modm_architecture_delay modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_architecture_delay modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_driver_parallel_tft_display->modm_architecture_delay modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_architecture_delay modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_architecture_delay modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_architecture_delay modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_architecture_delay modm_platform_can modm: platform: can modm_platform_can->modm_architecture_delay modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_delay modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_architecture_delay modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_architecture_delay","title":"Dependencies"},{"location":"reference/module/modm-architecture-gpio-expander/","text":"These module docs are in beta and may be incomplete. modm:architecture:gpio.expander: GPIO Expanders \u00b6 Content \u00b6 // Class class modm :: GpioExpander ; class modm :: GpioExpanderPin < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin pin > ; class modm :: GpioExpanderPort < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin StartPin , uint8_t Width , GpioPort :: DataOrder DataOrder = GpioPort :: DataOrder :: Normal > ; Dependencies \u00b6 modm:architecture:gpio.expander modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture modm: architecture modm_architecture_gpio_expander->modm_architecture modm_architecture_gpio modm: architecture: gpio modm_architecture_gpio_expander->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_architecture_gpio_expander->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_gpio_expander->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_gpio_expander->modm_processing_resumable modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_gpio_expander modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_architecture_gpio_expander modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_architecture_gpio_expander","title":"modm:architecture:gpio.expander"},{"location":"reference/module/modm-architecture-gpio-expander/#modmarchitecturegpioexpander-gpio-expanders","text":"","title":"modm:architecture:gpio.expander: GPIO Expanders"},{"location":"reference/module/modm-architecture-gpio-expander/#content","text":"// Class class modm :: GpioExpander ; class modm :: GpioExpanderPin < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin pin > ; class modm :: GpioExpanderPort < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin StartPin , uint8_t Width , GpioPort :: DataOrder DataOrder = GpioPort :: DataOrder :: Normal > ;","title":"Content"},{"location":"reference/module/modm-architecture-gpio-expander/#dependencies","text":"modm:architecture:gpio.expander modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture modm: architecture modm_architecture_gpio_expander->modm_architecture modm_architecture_gpio modm: architecture: gpio modm_architecture_gpio_expander->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_architecture_gpio_expander->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_gpio_expander->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_gpio_expander->modm_processing_resumable modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_gpio_expander modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_architecture_gpio_expander modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_architecture_gpio_expander","title":"Dependencies"},{"location":"reference/module/modm-architecture-gpio/","text":"These module docs are in beta and may be incomplete. modm:architecture:gpio: General Purpose Input/Output \u00b6 GPIOs are modeled as individual classes with an interface consisting out of a common set of static methods. Using GPIOs \u00b6 These classes are used to create architecture independent definitions for hardware pins which then can be used as template parameters for miscellaneous device drivers. Example of a platform-independent blinking light: #include <modm/platform.hpp> using Led = GpioOutputB0 ; Led :: setOutput (); Led :: set (); while ( 1 ) { Led :: toggle (); modm :: delayMilliseconds ( 500 ); } You can use the common definitions of modm::Gpio to express your intention for setting a pin. However, you can also use anything that casts to bool . Led :: set ( modm :: Gpio :: High ); // Turns Led on Led :: set ( modm :: Gpio :: Low ); // Turns Led off Led :: set ( true ); Led :: set ( false ); Led :: set ( 1 ); Led :: set ( 0 ); Led :: set (); Led :: reset (); Initialize your GPIOs Call Gpio::setInput() or Gpio::setOutput() before the first use, otherwise the GPIO state may be undefined! Content \u00b6 // Class class modm :: GpioExpander ; class modm :: GpioExpanderPin < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin pin > ; class modm :: GpioExpanderPort < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin StartPin , uint8_t Width , GpioPort :: DataOrder DataOrder = GpioPort :: DataOrder :: Normal > ; class modm :: GpioIO ; class modm :: GpioInput ; class modm :: GpioOutput ; class modm :: GpioPort ; // Struct struct modm :: Gpio ; Dependencies \u00b6 modm:architecture:gpio modm_architecture_gpio modm: architecture: gpio modm_architecture modm: architecture modm_architecture_gpio->modm_architecture modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_architecture_gpio modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_architecture_gpio modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_architecture_gpio modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_gpio modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_architecture_gpio modm_driver_ds1302 modm: driver: ds1302 modm_driver_ds1302->modm_architecture_gpio modm_driver_ft245 modm: driver: ft245 modm_driver_ft245->modm_architecture_gpio modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_architecture_gpio modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_architecture_gpio modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_architecture_gpio modm_driver_memory_bus modm: driver: memory_bus modm_driver_memory_bus->modm_architecture_gpio modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_architecture_gpio modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio_common->modm_architecture_gpio modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_architecture_gpio","title":"modm:architecture:gpio"},{"location":"reference/module/modm-architecture-gpio/#modmarchitecturegpio-general-purpose-inputoutput","text":"GPIOs are modeled as individual classes with an interface consisting out of a common set of static methods.","title":"modm:architecture:gpio: General Purpose Input/Output"},{"location":"reference/module/modm-architecture-gpio/#using-gpios","text":"These classes are used to create architecture independent definitions for hardware pins which then can be used as template parameters for miscellaneous device drivers. Example of a platform-independent blinking light: #include <modm/platform.hpp> using Led = GpioOutputB0 ; Led :: setOutput (); Led :: set (); while ( 1 ) { Led :: toggle (); modm :: delayMilliseconds ( 500 ); } You can use the common definitions of modm::Gpio to express your intention for setting a pin. However, you can also use anything that casts to bool . Led :: set ( modm :: Gpio :: High ); // Turns Led on Led :: set ( modm :: Gpio :: Low ); // Turns Led off Led :: set ( true ); Led :: set ( false ); Led :: set ( 1 ); Led :: set ( 0 ); Led :: set (); Led :: reset (); Initialize your GPIOs Call Gpio::setInput() or Gpio::setOutput() before the first use, otherwise the GPIO state may be undefined!","title":"Using GPIOs"},{"location":"reference/module/modm-architecture-gpio/#content","text":"// Class class modm :: GpioExpander ; class modm :: GpioExpanderPin < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin pin > ; class modm :: GpioExpanderPort < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin StartPin , uint8_t Width , GpioPort :: DataOrder DataOrder = GpioPort :: DataOrder :: Normal > ; class modm :: GpioIO ; class modm :: GpioInput ; class modm :: GpioOutput ; class modm :: GpioPort ; // Struct struct modm :: Gpio ;","title":"Content"},{"location":"reference/module/modm-architecture-gpio/#dependencies","text":"modm:architecture:gpio modm_architecture_gpio modm: architecture: gpio modm_architecture modm: architecture modm_architecture_gpio->modm_architecture modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_architecture_gpio modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_architecture_gpio modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_architecture_gpio modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_gpio modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_architecture_gpio modm_driver_ds1302 modm: driver: ds1302 modm_driver_ds1302->modm_architecture_gpio modm_driver_ft245 modm: driver: ft245 modm_driver_ft245->modm_architecture_gpio modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_architecture_gpio modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_architecture_gpio modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_architecture_gpio modm_driver_memory_bus modm: driver: memory_bus modm_driver_memory_bus->modm_architecture_gpio modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_architecture_gpio modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio_common->modm_architecture_gpio modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_architecture_gpio","title":"Dependencies"},{"location":"reference/module/modm-architecture-heap/","text":"These module docs are in beta and may be incomplete. modm:architecture:heap: Memory Allocators \u00b6 Content \u00b6 // Class class modm :: BlockAllocator < typename T , unsigned int BLOCK_SIZE > ; Dependencies \u00b6 modm:architecture:heap modm_architecture_heap modm: architecture: heap modm_architecture modm: architecture modm_architecture_heap->modm_architecture modm_utils modm: utils modm_architecture_heap->modm_utils modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_heap","title":"modm:architecture:heap"},{"location":"reference/module/modm-architecture-heap/#modmarchitectureheap-memory-allocators","text":"","title":"modm:architecture:heap: Memory Allocators"},{"location":"reference/module/modm-architecture-heap/#content","text":"// Class class modm :: BlockAllocator < typename T , unsigned int BLOCK_SIZE > ;","title":"Content"},{"location":"reference/module/modm-architecture-heap/#dependencies","text":"modm:architecture:heap modm_architecture_heap modm: architecture: heap modm_architecture modm: architecture modm_architecture_heap->modm_architecture modm_utils modm: utils modm_architecture_heap->modm_utils modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_heap","title":"Dependencies"},{"location":"reference/module/modm-architecture-i2c-device/","text":"These module docs are in beta and may be incomplete. modm:architecture:i2c.device: I\u00b2C Devices \u00b6 Content \u00b6 // Class class modm :: I2cDevice < class I2cMaster , uint8_t NestingLevels = 10 , class Transaction = I2cWriteReadTransaction > ; Dependencies \u00b6 modm:architecture:i2c.device modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture modm: architecture modm_architecture_i2c_device->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_device->modm_architecture_i2c modm_processing_resumable modm: processing: resumable modm_architecture_i2c_device->modm_processing_resumable modm_driver_ams5915 modm: driver: ams5915 modm_driver_ams5915->modm_architecture_i2c_device modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_architecture_i2c_device modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_architecture_i2c_device modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_architecture_i2c_device modm_driver_ft6x06 modm: driver: ft6x06 modm_driver_ft6x06->modm_architecture_i2c_device modm_driver_hclax modm: driver: hclax modm_driver_hclax->modm_architecture_i2c_device modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_architecture_i2c_device modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_architecture_i2c_device modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_driver_i2c_eeprom->modm_architecture_i2c_device modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_architecture_i2c_device modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_architecture_i2c_device modm_driver_lm75 modm: driver: lm75 modm_driver_lm75->modm_architecture_i2c_device modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_i2c_device modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_architecture_i2c_device modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_architecture_i2c_device modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_architecture_i2c_device modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_architecture_i2c_device modm_driver_pca9685 modm: driver: pca9685 modm_driver_pca9685->modm_architecture_i2c_device modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_architecture_i2c_device modm_driver_tcs3414 modm: driver: tcs3414 modm_driver_tcs3414->modm_architecture_i2c_device modm_driver_tcs3472 modm: driver: tcs3472 modm_driver_tcs3472->modm_architecture_i2c_device modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_architecture_i2c_device modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_architecture_i2c_device modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_architecture_i2c_device modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_i2c_device","title":"modm:architecture:i2c.device"},{"location":"reference/module/modm-architecture-i2c-device/#modmarchitecturei2cdevice-i2c-devices","text":"","title":"modm:architecture:i2c.device: I\u00b2C Devices"},{"location":"reference/module/modm-architecture-i2c-device/#content","text":"// Class class modm :: I2cDevice < class I2cMaster , uint8_t NestingLevels = 10 , class Transaction = I2cWriteReadTransaction > ;","title":"Content"},{"location":"reference/module/modm-architecture-i2c-device/#dependencies","text":"modm:architecture:i2c.device modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture modm: architecture modm_architecture_i2c_device->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_device->modm_architecture_i2c modm_processing_resumable modm: processing: resumable modm_architecture_i2c_device->modm_processing_resumable modm_driver_ams5915 modm: driver: ams5915 modm_driver_ams5915->modm_architecture_i2c_device modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_architecture_i2c_device modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_architecture_i2c_device modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_architecture_i2c_device modm_driver_ft6x06 modm: driver: ft6x06 modm_driver_ft6x06->modm_architecture_i2c_device modm_driver_hclax modm: driver: hclax modm_driver_hclax->modm_architecture_i2c_device modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_architecture_i2c_device modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_architecture_i2c_device modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_driver_i2c_eeprom->modm_architecture_i2c_device modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_architecture_i2c_device modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_architecture_i2c_device modm_driver_lm75 modm: driver: lm75 modm_driver_lm75->modm_architecture_i2c_device modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_i2c_device modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_architecture_i2c_device modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_architecture_i2c_device modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_architecture_i2c_device modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_architecture_i2c_device modm_driver_pca9685 modm: driver: pca9685 modm_driver_pca9685->modm_architecture_i2c_device modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_architecture_i2c_device modm_driver_tcs3414 modm: driver: tcs3414 modm_driver_tcs3414->modm_architecture_i2c_device modm_driver_tcs3472 modm: driver: tcs3472 modm_driver_tcs3472->modm_architecture_i2c_device modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_architecture_i2c_device modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_architecture_i2c_device modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_architecture_i2c_device modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_i2c_device","title":"Dependencies"},{"location":"reference/module/modm-architecture-i2c-multiplexer/","text":"These module docs are in beta and may be incomplete. modm:architecture:i2c.multiplexer: I\u00b2C Multiplexer \u00b6 Content \u00b6 // Class class modm :: I2cMultiplexer < class I2cMaster , class I2cMultiplexerDevice > ; class modm :: I2cMultiplexerChannel < auto & multiplexer , typename std :: remove_reference_t < decltype ( multiplexer ) >:: Channel channel > ; // Struct struct modm :: i2cMultiplexer ; Dependencies \u00b6 modm:architecture:i2c.multiplexer modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture modm: architecture modm_architecture_i2c_multiplexer->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_multiplexer->modm_architecture_i2c modm_architecture_register modm: architecture: register modm_architecture_i2c_multiplexer->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_i2c_multiplexer->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_i2c_multiplexer->modm_processing_resumable modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_architecture_i2c_multiplexer","title":"modm:architecture:i2c.multiplexer"},{"location":"reference/module/modm-architecture-i2c-multiplexer/#modmarchitecturei2cmultiplexer-i2c-multiplexer","text":"","title":"modm:architecture:i2c.multiplexer: I\u00b2C Multiplexer"},{"location":"reference/module/modm-architecture-i2c-multiplexer/#content","text":"// Class class modm :: I2cMultiplexer < class I2cMaster , class I2cMultiplexerDevice > ; class modm :: I2cMultiplexerChannel < auto & multiplexer , typename std :: remove_reference_t < decltype ( multiplexer ) >:: Channel channel > ; // Struct struct modm :: i2cMultiplexer ;","title":"Content"},{"location":"reference/module/modm-architecture-i2c-multiplexer/#dependencies","text":"modm:architecture:i2c.multiplexer modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture modm: architecture modm_architecture_i2c_multiplexer->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_multiplexer->modm_architecture_i2c modm_architecture_register modm: architecture: register modm_architecture_i2c_multiplexer->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_i2c_multiplexer->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_i2c_multiplexer->modm_processing_resumable modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_architecture_i2c_multiplexer","title":"Dependencies"},{"location":"reference/module/modm-architecture-i2c/","text":"These module docs are in beta and may be incomplete. modm:architecture:i2c: Inter-Integrated Circuit (I\u00b2C) \u00b6 Content \u00b6 // Class class modm :: I2cDevice < class I2cMaster , uint8_t NestingLevels = 10 , class Transaction = I2cWriteReadTransaction > ; class modm :: I2cMaster ; class modm :: I2cMultiplexer < class I2cMaster , class I2cMultiplexerDevice > ; class modm :: I2cMultiplexerChannel < auto & multiplexer , typename std :: remove_reference_t < decltype ( multiplexer ) >:: Channel channel > ; class modm :: I2cReadTransaction ; class modm :: I2cTransaction ; class modm :: I2cWriteReadTransaction ; class modm :: I2cWriteTransaction ; // Struct struct modm :: I2c ; struct modm :: I2cTransaction :: Reading ; struct modm :: I2cTransaction :: Starting ; struct modm :: I2cTransaction :: Writing ; struct modm :: i2cMultiplexer ; // Function modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: Operation op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterRead op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterStart op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterWrite op ); Dependencies \u00b6 modm:architecture:i2c modm_architecture_i2c modm: architecture: i2c modm_architecture modm: architecture modm_architecture_i2c->modm_architecture modm_architecture_delay modm: architecture: delay modm_architecture_i2c->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_architecture_i2c->modm_architecture_gpio modm_io modm: io modm_architecture_i2c->modm_io modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c_device->modm_architecture_i2c modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_architecture_i2c modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_i2c modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_architecture_i2c","title":"modm:architecture:i2c"},{"location":"reference/module/modm-architecture-i2c/#modmarchitecturei2c-inter-integrated-circuit-i2c","text":"","title":"modm:architecture:i2c: Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-architecture-i2c/#content","text":"// Class class modm :: I2cDevice < class I2cMaster , uint8_t NestingLevels = 10 , class Transaction = I2cWriteReadTransaction > ; class modm :: I2cMaster ; class modm :: I2cMultiplexer < class I2cMaster , class I2cMultiplexerDevice > ; class modm :: I2cMultiplexerChannel < auto & multiplexer , typename std :: remove_reference_t < decltype ( multiplexer ) >:: Channel channel > ; class modm :: I2cReadTransaction ; class modm :: I2cTransaction ; class modm :: I2cWriteReadTransaction ; class modm :: I2cWriteTransaction ; // Struct struct modm :: I2c ; struct modm :: I2cTransaction :: Reading ; struct modm :: I2cTransaction :: Starting ; struct modm :: I2cTransaction :: Writing ; struct modm :: i2cMultiplexer ; // Function modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: Operation op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterRead op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterStart op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterWrite op );","title":"Content"},{"location":"reference/module/modm-architecture-i2c/#dependencies","text":"modm:architecture:i2c modm_architecture_i2c modm: architecture: i2c modm_architecture modm: architecture modm_architecture_i2c->modm_architecture modm_architecture_delay modm: architecture: delay modm_architecture_i2c->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_architecture_i2c->modm_architecture_gpio modm_io modm: io modm_architecture_i2c->modm_io modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c_device->modm_architecture_i2c modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_architecture_i2c modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_i2c modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_architecture_i2c","title":"Dependencies"},{"location":"reference/module/modm-architecture-interrupt/","text":"These module docs are in beta and may be incomplete. modm:architecture:interrupt: Interrupt Service Routines \u00b6 Content \u00b6 // Define #define MODM_ISR(vector, ...) #define MODM_ISR_CALL(vector) #define MODM_ISR_DECL(vector) #define MODM_ISR_NAME(vector) Dependencies \u00b6 modm:architecture:interrupt modm_architecture_interrupt modm: architecture: interrupt modm_architecture modm: architecture modm_architecture_interrupt->modm_architecture modm_platform_can modm: platform: can modm_platform_can->modm_architecture_interrupt modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_interrupt modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_interrupt modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_interrupt","title":"modm:architecture:interrupt"},{"location":"reference/module/modm-architecture-interrupt/#modmarchitectureinterrupt-interrupt-service-routines","text":"","title":"modm:architecture:interrupt: Interrupt Service Routines"},{"location":"reference/module/modm-architecture-interrupt/#content","text":"// Define #define MODM_ISR(vector, ...) #define MODM_ISR_CALL(vector) #define MODM_ISR_DECL(vector) #define MODM_ISR_NAME(vector)","title":"Content"},{"location":"reference/module/modm-architecture-interrupt/#dependencies","text":"modm:architecture:interrupt modm_architecture_interrupt modm: architecture: interrupt modm_architecture modm: architecture modm_architecture_interrupt->modm_architecture modm_platform_can modm: platform: can modm_platform_can->modm_architecture_interrupt modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_interrupt modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_architecture_interrupt modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_interrupt","title":"Dependencies"},{"location":"reference/module/modm-architecture-memory/","text":"These module docs are in beta and may be incomplete. modm:architecture:memory: Memory Traits \u00b6 Content \u00b6 // Function void * operator new ( size_t size , modm :: MemoryTraits traits ) noexcept ; void * operator new []( size_t size , modm :: MemoryTraits traits ) noexcept ; // Enum enum MemoryTrait ; // Variable constexpr MemoryTraits modm :: MemoryBackup = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeNonVolatile ); constexpr MemoryTraits modm :: MemoryDMA = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA ); constexpr MemoryTraits modm :: MemoryDMA2D = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA2D ); constexpr MemoryTraits modm :: MemoryDefault = MemoryDMA ; constexpr MemoryTraits modm :: MemoryExternal = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeExternal ); constexpr MemoryTraits modm :: MemoryFastCode = ( MemoryTrait :: AccessIBus | MemoryTrait :: TypeCoreCoupled ); constexpr MemoryTraits modm :: MemoryFastData = ( MemoryTrait :: AccessDBus | MemoryTrait :: TypeCoreCoupled ); // Typedef using modm :: MemoryTraits = typedef Flags16 < MemoryTrait > ; Dependencies \u00b6 modm:architecture:memory modm_architecture_memory modm: architecture: memory modm_architecture modm: architecture modm_architecture_memory->modm_architecture modm_architecture_register modm: architecture: register modm_architecture_memory->modm_architecture_register modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_architecture_memory modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_memory","title":"modm:architecture:memory"},{"location":"reference/module/modm-architecture-memory/#modmarchitecturememory-memory-traits","text":"","title":"modm:architecture:memory: Memory Traits"},{"location":"reference/module/modm-architecture-memory/#content","text":"// Function void * operator new ( size_t size , modm :: MemoryTraits traits ) noexcept ; void * operator new []( size_t size , modm :: MemoryTraits traits ) noexcept ; // Enum enum MemoryTrait ; // Variable constexpr MemoryTraits modm :: MemoryBackup = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeNonVolatile ); constexpr MemoryTraits modm :: MemoryDMA = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA ); constexpr MemoryTraits modm :: MemoryDMA2D = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA2D ); constexpr MemoryTraits modm :: MemoryDefault = MemoryDMA ; constexpr MemoryTraits modm :: MemoryExternal = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeExternal ); constexpr MemoryTraits modm :: MemoryFastCode = ( MemoryTrait :: AccessIBus | MemoryTrait :: TypeCoreCoupled ); constexpr MemoryTraits modm :: MemoryFastData = ( MemoryTrait :: AccessDBus | MemoryTrait :: TypeCoreCoupled ); // Typedef using modm :: MemoryTraits = typedef Flags16 < MemoryTrait > ;","title":"Content"},{"location":"reference/module/modm-architecture-memory/#dependencies","text":"modm:architecture:memory modm_architecture_memory modm: architecture: memory modm_architecture modm: architecture modm_architecture_memory->modm_architecture modm_architecture_register modm: architecture: register modm_architecture_memory->modm_architecture_register modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_architecture_memory modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_memory","title":"Dependencies"},{"location":"reference/module/modm-architecture-register/","text":"These module docs are in beta and may be incomplete. modm:architecture:register: General Purpose Registers \u00b6 Data structures to provide a native register abstraction. These data structures are used to describe the relationship of single bits, bit groups and bit configurations in registers with type-safe access. Registers can be made up of three things: Bits: a single bit (position N), Configurations: a combination of bits where the meaning does not correspond to its numeric value (position [N, M]) Values: a numeric value (position [N, M]) Example of an 8-bit register called Control 7 6 5 4 3 2 1 0 | EN | FS | PRE1 | PRE0 | DEL2 | DEL1 | DEL0 | | Bit 7: Enable Bit 6: Full Scale Configuration [5, 4]: Prescaler 00: Divide by 1 01: Divide by 2 10: Divide by 4 11: Divide by 8 Value [3, 1]: Start-Up Delay in ms Register Bits \u00b6 The bits can be modelled using strongly-typed enums and the Flags template class as follows: enum class Control : uint8_t { EN = Bit7 , ///< bit documentation FS = Bit6 , PRE1 = Bit5 , PRE0 = Bit4 , DEL2 = Bit3 , DEL1 = Bit2 , DEL0 = Bit1 , }; MODM_FLAGS8 ( Control ); // expands to // typedef modm::Flags8< Control > Control_t; // and some enum operator overloading magic You can handle all its register bits as you would expect: Control_t control = Control :: EN ; control = Control :: EN | Control :: FS ; control &= ~ Control :: FS ; control |= Control :: FS ; control ^= Control :: PRE1 ; bool isSet = control & Control :: FS ; control . reset ( Control :: PRE1 | Control :: PRE0 ); control . set ( Control :: DEL0 ); bool noneSet = control . none ( Control :: PRE1 | Control :: PRE0 ); bool allSet = control . all ( Control :: EN | Control :: FS ); You still get raw access if you really need it: uint8_t raw = control . value ; // the underlying type control . value = 0x24 ; The access is type-safe, you cannot use bits from two different registers: enum class Control2 : uint8_t { DIS = Bit4 , HS = Bit3 , }; MODM_FLAGS8 ( Control2 ); auto control = Control :: EN | Control2 :: HS ; // compile error You can even overload functions on argument type now: void write ( Control_t control ); void write ( Control2_t control ); write ( Control :: EN | Control :: FS ); // calls #1 write ( Control2 :: DIS ); // calls #2 Register Configurations \u00b6 Configurations are also described as a strongly-typed enum and then wrapped into the Configuration template class. enum class Prescaler : uint8_t { Div1 = 0 , ///< configuration documentation Div2 = int ( Control :: PRE0 ), Div4 = int ( Control :: PRE1 ), Div8 = int ( Control :: PRE1 ) | int ( Control :: PRE0 ), }; typedef Configuration < Control_t , Prescaler , ( Bit5 | Bit4 ) > Prescaler_t ; The Prescaler enum values are already shifted in this example (hence the (Bit5 | Bit4) mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it: enum class Prescaler : uint8_t { Div1 = 0 , Div2 = 1 , Div4 = 2 , Div8 = 3 , }; typedef Configuration < Control_t , Prescaler , 0 b11 , 4 > Prescaler_t ; Why? If you have two or more configurations with the same selections in the same register, you can simply add another one: typedef Configuration < Control_t , Prescaler , 0 b11 , 6 > Prescaler2_t ; Configurations can be used inline: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ); Control_t control &= ~ Prescaler_t :: mask (); But do not have to: Prescaler_t :: set ( control , Prescaler :: Div2 ); Prescaler_t :: reset ( control ); Prescaler prescaler = Prescaler_t :: get ( control ); Register Values \u00b6 Values are described using the Value template class which masks and shifts the value as required. In our example the value has a width of 3 bits and needs to be shifted 1 bit: typedef Value < Control_t , 3 , 1 > Delay_t ; This can be used the same way as the Configuration: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ) | Delay_t ( 4 ); Control_t control &= ~ Delay_t :: mask (); Delay_t :: set ( control , 7 ); Delay_t :: reset ( control ); uint8_t delay = Delay_t :: get ( control ); See Typesafe Register Access in C++ for a more detailed background on this implementation. Content \u00b6 // Struct struct modm :: Configuration < typename Parent , typename Enum , typename Parent :: UnderlyingType Mask , typename Parent :: UnderlyingType Position = 0 > ; struct modm :: Flags < typename Enum , typename T > ; struct modm :: FlagsGroup < T ... > ; struct modm :: FlagsOperators < typename Enum , typename T > ; struct modm :: Register < typename T > ; struct modm :: Value < typename Parent , typename Parent :: UnderlyingType Width , typename Parent :: UnderlyingType Position = 0 > ; // Typedef using modm :: Flags16 = typedef Flags < Enum , uint16_t > ; using modm :: Flags32 = typedef Flags < Enum , uint32_t > ; using modm :: Flags8 = typedef Flags < Enum , uint8_t > ; using modm :: Register16 = typedef Register < uint16_t > ; using modm :: Register32 = typedef Register < uint32_t > ; using modm :: Register8 = typedef Register < uint8_t > ; // Define #define MODM_FLAGS16(Enum) #define MODM_FLAGS32(Enum) #define MODM_FLAGS8(Enum) #define MODM_TYPE_FLAGS(Parent) Dependencies \u00b6 modm:architecture:register modm_architecture_register modm: architecture: register modm_architecture modm: architecture modm_architecture_register->modm_architecture modm_io modm: io modm_architecture_register->modm_io modm_math_utils modm: math: utils modm_architecture_register->modm_math_utils modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_architecture_register modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_architecture_register modm_architecture_memory modm: architecture: memory modm_architecture_memory->modm_architecture_register modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_register modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_architecture_register modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_architecture_register modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_architecture_register modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_architecture_register modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_architecture_register modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_architecture_register modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_architecture_register modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_architecture_register modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_architecture_register modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_lm75->modm_architecture_register modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_architecture_register modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_architecture_register modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_register modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_architecture_register modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_architecture_register modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_architecture_register modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_architecture_register modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_architecture_register modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_architecture_register modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_register modm_platform_adc modm: platform: adc modm_platform_adc->modm_architecture_register modm_platform_spi modm: platform: spi modm_platform_spi->modm_architecture_register modm_platform_timer modm: platform: timer modm_platform_timer->modm_architecture_register modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_register","title":"modm:architecture:register"},{"location":"reference/module/modm-architecture-register/#modmarchitectureregister-general-purpose-registers","text":"Data structures to provide a native register abstraction. These data structures are used to describe the relationship of single bits, bit groups and bit configurations in registers with type-safe access. Registers can be made up of three things: Bits: a single bit (position N), Configurations: a combination of bits where the meaning does not correspond to its numeric value (position [N, M]) Values: a numeric value (position [N, M]) Example of an 8-bit register called Control 7 6 5 4 3 2 1 0 | EN | FS | PRE1 | PRE0 | DEL2 | DEL1 | DEL0 | | Bit 7: Enable Bit 6: Full Scale Configuration [5, 4]: Prescaler 00: Divide by 1 01: Divide by 2 10: Divide by 4 11: Divide by 8 Value [3, 1]: Start-Up Delay in ms","title":"modm:architecture:register: General Purpose Registers"},{"location":"reference/module/modm-architecture-register/#register-bits","text":"The bits can be modelled using strongly-typed enums and the Flags template class as follows: enum class Control : uint8_t { EN = Bit7 , ///< bit documentation FS = Bit6 , PRE1 = Bit5 , PRE0 = Bit4 , DEL2 = Bit3 , DEL1 = Bit2 , DEL0 = Bit1 , }; MODM_FLAGS8 ( Control ); // expands to // typedef modm::Flags8< Control > Control_t; // and some enum operator overloading magic You can handle all its register bits as you would expect: Control_t control = Control :: EN ; control = Control :: EN | Control :: FS ; control &= ~ Control :: FS ; control |= Control :: FS ; control ^= Control :: PRE1 ; bool isSet = control & Control :: FS ; control . reset ( Control :: PRE1 | Control :: PRE0 ); control . set ( Control :: DEL0 ); bool noneSet = control . none ( Control :: PRE1 | Control :: PRE0 ); bool allSet = control . all ( Control :: EN | Control :: FS ); You still get raw access if you really need it: uint8_t raw = control . value ; // the underlying type control . value = 0x24 ; The access is type-safe, you cannot use bits from two different registers: enum class Control2 : uint8_t { DIS = Bit4 , HS = Bit3 , }; MODM_FLAGS8 ( Control2 ); auto control = Control :: EN | Control2 :: HS ; // compile error You can even overload functions on argument type now: void write ( Control_t control ); void write ( Control2_t control ); write ( Control :: EN | Control :: FS ); // calls #1 write ( Control2 :: DIS ); // calls #2","title":"Register Bits"},{"location":"reference/module/modm-architecture-register/#register-configurations","text":"Configurations are also described as a strongly-typed enum and then wrapped into the Configuration template class. enum class Prescaler : uint8_t { Div1 = 0 , ///< configuration documentation Div2 = int ( Control :: PRE0 ), Div4 = int ( Control :: PRE1 ), Div8 = int ( Control :: PRE1 ) | int ( Control :: PRE0 ), }; typedef Configuration < Control_t , Prescaler , ( Bit5 | Bit4 ) > Prescaler_t ; The Prescaler enum values are already shifted in this example (hence the (Bit5 | Bit4) mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it: enum class Prescaler : uint8_t { Div1 = 0 , Div2 = 1 , Div4 = 2 , Div8 = 3 , }; typedef Configuration < Control_t , Prescaler , 0 b11 , 4 > Prescaler_t ; Why? If you have two or more configurations with the same selections in the same register, you can simply add another one: typedef Configuration < Control_t , Prescaler , 0 b11 , 6 > Prescaler2_t ; Configurations can be used inline: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ); Control_t control &= ~ Prescaler_t :: mask (); But do not have to: Prescaler_t :: set ( control , Prescaler :: Div2 ); Prescaler_t :: reset ( control ); Prescaler prescaler = Prescaler_t :: get ( control );","title":"Register Configurations"},{"location":"reference/module/modm-architecture-register/#register-values","text":"Values are described using the Value template class which masks and shifts the value as required. In our example the value has a width of 3 bits and needs to be shifted 1 bit: typedef Value < Control_t , 3 , 1 > Delay_t ; This can be used the same way as the Configuration: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ) | Delay_t ( 4 ); Control_t control &= ~ Delay_t :: mask (); Delay_t :: set ( control , 7 ); Delay_t :: reset ( control ); uint8_t delay = Delay_t :: get ( control ); See Typesafe Register Access in C++ for a more detailed background on this implementation.","title":"Register Values"},{"location":"reference/module/modm-architecture-register/#content","text":"// Struct struct modm :: Configuration < typename Parent , typename Enum , typename Parent :: UnderlyingType Mask , typename Parent :: UnderlyingType Position = 0 > ; struct modm :: Flags < typename Enum , typename T > ; struct modm :: FlagsGroup < T ... > ; struct modm :: FlagsOperators < typename Enum , typename T > ; struct modm :: Register < typename T > ; struct modm :: Value < typename Parent , typename Parent :: UnderlyingType Width , typename Parent :: UnderlyingType Position = 0 > ; // Typedef using modm :: Flags16 = typedef Flags < Enum , uint16_t > ; using modm :: Flags32 = typedef Flags < Enum , uint32_t > ; using modm :: Flags8 = typedef Flags < Enum , uint8_t > ; using modm :: Register16 = typedef Register < uint16_t > ; using modm :: Register32 = typedef Register < uint32_t > ; using modm :: Register8 = typedef Register < uint8_t > ; // Define #define MODM_FLAGS16(Enum) #define MODM_FLAGS32(Enum) #define MODM_FLAGS8(Enum) #define MODM_TYPE_FLAGS(Parent)","title":"Content"},{"location":"reference/module/modm-architecture-register/#dependencies","text":"modm:architecture:register modm_architecture_register modm: architecture: register modm_architecture modm: architecture modm_architecture_register->modm_architecture modm_io modm: io modm_architecture_register->modm_io modm_math_utils modm: math: utils modm_architecture_register->modm_math_utils modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_architecture_register modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_architecture_register modm_architecture_memory modm: architecture: memory modm_architecture_memory->modm_architecture_register modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_register modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_architecture_register modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_architecture_register modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_architecture_register modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_architecture_register modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_architecture_register modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_architecture_register modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_architecture_register modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_architecture_register modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_architecture_register modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_lm75->modm_architecture_register modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_architecture_register modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_architecture_register modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_register modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_architecture_register modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_architecture_register modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_architecture_register modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_architecture_register modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_architecture_register modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_architecture_register modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_register modm_platform_adc modm: platform: adc modm_platform_adc->modm_architecture_register modm_platform_spi modm: platform: spi modm_platform_spi->modm_architecture_register modm_platform_timer modm: platform: timer modm_platform_timer->modm_architecture_register modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_register","title":"Dependencies"},{"location":"reference/module/modm-architecture-spi-device/","text":"These module docs are in beta and may be incomplete. modm:architecture:spi.device: SPI Devices \u00b6 Content \u00b6 // Class class modm :: SpiDevice < class SpiMaster > ; Dependencies \u00b6 modm:architecture:spi.device modm_architecture_spi_device modm: architecture: spi.device modm_architecture modm: architecture modm_architecture_spi_device->modm_architecture modm_architecture_spi modm: architecture: spi modm_architecture_spi_device->modm_architecture_spi modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_spi_device modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_architecture_spi_device modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_architecture_spi_device modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_architecture_spi_device modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_architecture_spi_device modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_spi_device","title":"modm:architecture:spi.device"},{"location":"reference/module/modm-architecture-spi-device/#modmarchitecturespidevice-spi-devices","text":"","title":"modm:architecture:spi.device: SPI Devices"},{"location":"reference/module/modm-architecture-spi-device/#content","text":"// Class class modm :: SpiDevice < class SpiMaster > ;","title":"Content"},{"location":"reference/module/modm-architecture-spi-device/#dependencies","text":"modm:architecture:spi.device modm_architecture_spi_device modm: architecture: spi.device modm_architecture modm: architecture modm_architecture_spi_device->modm_architecture modm_architecture_spi modm: architecture: spi modm_architecture_spi_device->modm_architecture_spi modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_architecture_spi_device modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_architecture_spi_device modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_architecture_spi_device modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_architecture_spi_device modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_architecture_spi_device modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_architecture_spi_device","title":"Dependencies"},{"location":"reference/module/modm-architecture-spi/","text":"These module docs are in beta and may be incomplete. modm:architecture:spi: Serial Peripheral Interface (SPI) \u00b6 Content \u00b6 // Class class modm :: SpiDevice < class SpiMaster > ; class modm :: SpiMaster ; // Struct struct modm :: Spi ; Dependencies \u00b6 modm:architecture:spi modm_architecture_spi modm: architecture: spi modm_architecture modm: architecture modm_architecture_spi->modm_architecture modm_processing_resumable modm: processing: resumable modm_architecture_spi->modm_processing_resumable modm_architecture_spi_device modm: architecture: spi.device modm_architecture_spi_device->modm_architecture_spi modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_architecture_spi modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_architecture_spi modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_architecture_spi modm_driver_max7219 modm: driver: max7219 modm_driver_max7219->modm_architecture_spi modm_driver_nokia5110 modm: driver: nokia5110 modm_driver_nokia5110->modm_architecture_spi modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_architecture_spi modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_architecture_spi modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_architecture_spi modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_architecture_spi modm_platform_spi modm: platform: spi modm_platform_spi->modm_architecture_spi modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_architecture_spi modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_architecture_spi","title":"modm:architecture:spi"},{"location":"reference/module/modm-architecture-spi/#modmarchitecturespi-serial-peripheral-interface-spi","text":"","title":"modm:architecture:spi: Serial Peripheral Interface (SPI)"},{"location":"reference/module/modm-architecture-spi/#content","text":"// Class class modm :: SpiDevice < class SpiMaster > ; class modm :: SpiMaster ; // Struct struct modm :: Spi ;","title":"Content"},{"location":"reference/module/modm-architecture-spi/#dependencies","text":"modm:architecture:spi modm_architecture_spi modm: architecture: spi modm_architecture modm: architecture modm_architecture_spi->modm_architecture modm_processing_resumable modm: processing: resumable modm_architecture_spi->modm_processing_resumable modm_architecture_spi_device modm: architecture: spi.device modm_architecture_spi_device->modm_architecture_spi modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_architecture_spi modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_architecture_spi modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_architecture_spi modm_driver_max7219 modm: driver: max7219 modm_driver_max7219->modm_architecture_spi modm_driver_nokia5110 modm: driver: nokia5110 modm_driver_nokia5110->modm_architecture_spi modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_architecture_spi modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_architecture_spi modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_architecture_spi modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_architecture_spi modm_platform_spi modm: platform: spi modm_platform_spi->modm_architecture_spi modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_architecture_spi modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_architecture_spi","title":"Dependencies"},{"location":"reference/module/modm-architecture-uart/","text":"These module docs are in beta and may be incomplete. modm:architecture:uart: Universal Asynchronous Receiver/Transmitter (UART) \u00b6 Content \u00b6 // Class class modm :: Uart ; Dependencies \u00b6 modm:architecture:uart modm_architecture_uart modm: architecture: uart modm_architecture modm: architecture modm_architecture_uart->modm_architecture modm_communication_ros modm: communication: ros modm_communication_ros->modm_architecture_uart modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_uart","title":"modm:architecture:uart"},{"location":"reference/module/modm-architecture-uart/#modmarchitectureuart-universal-asynchronous-receivertransmitter-uart","text":"","title":"modm:architecture:uart: Universal Asynchronous Receiver/Transmitter (UART)"},{"location":"reference/module/modm-architecture-uart/#content","text":"// Class class modm :: Uart ;","title":"Content"},{"location":"reference/module/modm-architecture-uart/#dependencies","text":"modm:architecture:uart modm_architecture_uart modm: architecture: uart modm_architecture modm: architecture modm_architecture_uart->modm_architecture modm_communication_ros modm: communication: ros modm_communication_ros->modm_architecture_uart modm_platform_uart modm: platform: uart modm_platform_uart->modm_architecture_uart","title":"Dependencies"},{"location":"reference/module/modm-architecture-unaligned/","text":"These module docs are in beta and may be incomplete. modm:architecture:unaligned: Unaligned Memory Accessor \u00b6 Content \u00b6 // Struct struct modm :: unaligned_t < typename T > ; // Function unaligned_t < T >* modm :: asUnaligned ( U * value ); Dependencies \u00b6 modm:architecture:unaligned modm_architecture_unaligned modm: architecture: unaligned modm_architecture modm: architecture modm_architecture_unaligned->modm_architecture modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_unaligned modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_unaligned","title":"modm:architecture:unaligned"},{"location":"reference/module/modm-architecture-unaligned/#modmarchitectureunaligned-unaligned-memory-accessor","text":"","title":"modm:architecture:unaligned: Unaligned Memory Accessor"},{"location":"reference/module/modm-architecture-unaligned/#content","text":"// Struct struct modm :: unaligned_t < typename T > ; // Function unaligned_t < T >* modm :: asUnaligned ( U * value );","title":"Content"},{"location":"reference/module/modm-architecture-unaligned/#dependencies","text":"modm:architecture:unaligned modm_architecture_unaligned modm: architecture: unaligned modm_architecture modm: architecture modm_architecture_unaligned->modm_architecture modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_architecture_unaligned modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_architecture_unaligned","title":"Dependencies"},{"location":"reference/module/modm-architecture/","text":"These module docs are in beta and may be incomplete. modm:architecture: Architecture Interfaces \u00b6 All hardware peripherals with common interfaces. Content \u00b6 // Class class modm :: Adc ; class modm :: AdcInterrupt ; class modm :: BlockAllocator < typename T , unsigned int BLOCK_SIZE > ; class modm :: BlockDevice ; class modm :: Can ; class modm :: Clock ; class modm :: GpioExpander ; class modm :: GpioExpanderPin < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin pin > ; class modm :: GpioExpanderPort < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin StartPin , uint8_t Width , GpioPort :: DataOrder DataOrder = GpioPort :: DataOrder :: Normal > ; class modm :: GpioIO ; class modm :: GpioInput ; class modm :: GpioOutput ; class modm :: GpioPort ; class modm :: I2cDevice < class I2cMaster , uint8_t NestingLevels = 10 , class Transaction = I2cWriteReadTransaction > ; class modm :: I2cMaster ; class modm :: I2cMultiplexer < class I2cMaster , class I2cMultiplexerDevice > ; class modm :: I2cMultiplexerChannel < auto & multiplexer , typename std :: remove_reference_t < decltype ( multiplexer ) >:: Channel channel > ; class modm :: I2cReadTransaction ; class modm :: I2cTransaction ; class modm :: I2cWriteReadTransaction ; class modm :: I2cWriteTransaction ; class modm :: PeripheralDriver ; class modm :: SpiDevice < class SpiMaster > ; class modm :: SpiMaster ; class modm :: Uart ; class modm :: accessor :: Flash < typename T > ; class modm :: accessor :: Ram < typename T > ; class modm :: atomic :: Container < typename T > ; class modm :: atomic :: Flag ; class modm :: atomic :: Lock ; class modm :: atomic :: Queue < typename T , std :: size_t N > ; class modm :: atomic :: Unlock ; // Struct struct modm :: Configuration < typename Parent , typename Enum , typename Parent :: UnderlyingType Mask , typename Parent :: UnderlyingType Position = 0 > ; struct modm :: Flags < typename Enum , typename T > ; struct modm :: FlagsGroup < T ... > ; struct modm :: FlagsOperators < typename Enum , typename T > ; struct modm :: Gpio ; struct modm :: I2c ; struct modm :: I2cTransaction :: Reading ; struct modm :: I2cTransaction :: Starting ; struct modm :: I2cTransaction :: Writing ; struct modm :: Register < typename T > ; struct modm :: Spi ; struct modm :: Value < typename Parent , typename Parent :: UnderlyingType Width , typename Parent :: UnderlyingType Position = 0 > ; struct modm :: can :: Message :: Flags ; struct modm :: can :: Message ; struct modm :: i2cMultiplexer ; struct modm :: unaligned_t < typename T > ; // Function bool modm_assert ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); inline :: modm :: accessor :: Flash < T > modm :: accessor :: asFlash ( const T * ptr ); modm :: IOStream & modm :: can :: operator << ( modm :: IOStream & s , const modm :: can :: Message m ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: Operation op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterRead op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterStart op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterWrite op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & stream , const Can :: BusState state ); modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < T > ptr ); static modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < char > ptr ); unaligned_t < T >* modm :: asUnaligned ( U * value ); void modm :: delayMicroseconds ( uint16_t us ); void modm :: delayMilliseconds ( uint16_t ms ); void modm :: delayNanoseconds ( uint16_t ns ); void modm_abandon ( const char * module , const char * location , const char * failure , uintptr_t context ) modm_weak ; void * operator new ( size_t size , modm :: MemoryTraits traits ) noexcept ; void * operator new []( size_t size , modm :: MemoryTraits traits ) noexcept ; volatile T & modm :: accessor :: asVolatile ( T & value ); // Enum enum Abandonment ; enum MemoryTrait ; enum RomCommand ; // Variable constexpr MemoryTraits modm :: MemoryBackup = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeNonVolatile ); constexpr MemoryTraits modm :: MemoryDMA = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA ); constexpr MemoryTraits modm :: MemoryDMA2D = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA2D ); constexpr MemoryTraits modm :: MemoryDefault = MemoryDMA ; constexpr MemoryTraits modm :: MemoryExternal = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeExternal ); constexpr MemoryTraits modm :: MemoryFastCode = ( MemoryTrait :: AccessIBus | MemoryTrait :: TypeCoreCoupled ); constexpr MemoryTraits modm :: MemoryFastData = ( MemoryTrait :: AccessDBus | MemoryTrait :: TypeCoreCoupled ); // Typedef using modm :: AssertionHandler = typedef Abandonment ( * )( const char * module , const char * location , const char * failure , uintptr_t context ); using modm :: Flags16 = typedef Flags < Enum , uint16_t > ; using modm :: Flags32 = typedef Flags < Enum , uint32_t > ; using modm :: Flags8 = typedef Flags < Enum , uint8_t > ; using modm :: MemoryTraits = typedef Flags16 < MemoryTrait > ; using modm :: Register16 = typedef Register < uint16_t > ; using modm :: Register32 = typedef Register < uint32_t > ; using modm :: Register8 = typedef Register < uint8_t > ; // Define #define EXTERN_FLASH_STORAGE(var) #define EXTERN_FLASH_STORAGE_STRING(s) #define FLASH_STORAGE(var) #define FLASH_STORAGE_STRING(s) #define IFSS(s) #define MODM_ALIGNMENT #define MODM_ARRAY_SIZE(x) #define MODM_ASSERTION_HANDLER(handler) #define MODM_BYTE_ORDER #define MODM_COMPILER_GCC #define MODM_COMPILER_MSVC #define MODM_COMPILER_STRING #define MODM_CONCAT(a, b) #define MODM_CONCAT3(a, b, c) #define MODM_CONCAT4(a, b, c, d) #define MODM_CONCAT5(a, b, c, d, e) #define MODM_CPU_ARM #define MODM_CPU_ARM7TDMI #define MODM_CPU_ATMEGA #define MODM_CPU_ATTINY #define MODM_CPU_ATXMEGA #define MODM_CPU_AVR #define MODM_CPU_CORTEX_M0 #define MODM_CPU_CORTEX_M3 #define MODM_CPU_CORTEX_M4 #define MODM_CPU_STRING #define MODM_FLAGS16(Enum) #define MODM_FLAGS32(Enum) #define MODM_FLAGS8(Enum) #define MODM_ISR(vector, ...) #define MODM_ISR_CALL(vector) #define MODM_ISR_DECL(vector) #define MODM_ISR_NAME(vector) #define MODM_IS_BIG_ENDIAN #define MODM_IS_LITTLE_ENDIAN #define MODM_ORDER_BIG_ENDIAN #define MODM_ORDER_LITTLE_ENDIAN #define MODM_ORDER_PDP_ENDIAN #define MODM_OS_HOSTED #define MODM_OS_HOSTED_64 #define MODM_OS_LINUX #define MODM_OS_OSX #define MODM_OS_STRING #define MODM_OS_UNIX #define MODM_OS_WIN32 #define MODM_OS_WIN64 #define MODM_SIZEOF_POINTER #define MODM_STRINGIFY(s) #define MODM_TYPE_FLAGS(Parent) #define modm_aligned(n) #define modm_always_inline #define modm_fastcode #define modm_fastdata #define modm_likely(x) #define modm_packed #define modm_section(s) #define modm_unlikely(x) #define modm_unused #define modm_weak Dependencies \u00b6 modm:architecture modm_architecture modm: architecture modm_math_units modm: math: units modm_architecture->modm_math_units modm_math_units->modm_architecture modm_architecture_1_wire modm: architecture: 1-wire modm_architecture_1_wire->modm_architecture modm_architecture_accessor modm: architecture: accessor modm_architecture_accessor->modm_architecture modm_architecture_adc modm: architecture: adc modm_architecture_adc->modm_architecture modm_architecture_assert modm: architecture: assert modm_architecture_assert->modm_architecture modm_architecture_atomic modm: architecture: atomic modm_architecture_atomic->modm_architecture modm_architecture_block_device modm: architecture: block.device modm_architecture_block_device->modm_architecture modm_architecture_can modm: architecture: can modm_architecture_can->modm_architecture modm_architecture_clock modm: architecture: clock modm_architecture_clock->modm_architecture modm_architecture_delay modm: architecture: delay modm_architecture_delay->modm_architecture modm_architecture_gpio modm: architecture: gpio modm_architecture_gpio->modm_architecture modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_architecture modm_architecture_heap modm: architecture: heap modm_architecture_heap->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_architecture modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c_device->modm_architecture modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_architecture modm_architecture_interrupt modm: architecture: interrupt modm_architecture_interrupt->modm_architecture modm_architecture_memory modm: architecture: memory modm_architecture_memory->modm_architecture modm_architecture_register modm: architecture: register modm_architecture_register->modm_architecture modm_architecture_spi modm: architecture: spi modm_architecture_spi->modm_architecture modm_architecture_spi_device modm: architecture: spi.device modm_architecture_spi_device->modm_architecture modm_architecture_uart modm: architecture: uart modm_architecture_uart->modm_architecture modm_architecture_unaligned modm: architecture: unaligned modm_architecture_unaligned->modm_architecture modm_container modm: container modm_container->modm_architecture modm_debug modm: debug modm_debug->modm_architecture modm_math_filter modm: math: filter modm_math_filter->modm_architecture modm_math_geometry modm: math: geometry modm_math_geometry->modm_architecture modm_math_utils modm: math: utils modm_math_utils->modm_architecture modm_processing_protothread modm: processing: protothread modm_processing_protothread->modm_architecture modm_utils modm: utils modm_utils->modm_architecture","title":"modm:architecture"},{"location":"reference/module/modm-architecture/#modmarchitecture-architecture-interfaces","text":"All hardware peripherals with common interfaces.","title":"modm:architecture: Architecture Interfaces"},{"location":"reference/module/modm-architecture/#content","text":"// Class class modm :: Adc ; class modm :: AdcInterrupt ; class modm :: BlockAllocator < typename T , unsigned int BLOCK_SIZE > ; class modm :: BlockDevice ; class modm :: Can ; class modm :: Clock ; class modm :: GpioExpander ; class modm :: GpioExpanderPin < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin pin > ; class modm :: GpioExpanderPort < typename GpioExpander , GpioExpander & expander , typename GpioExpander :: Pin StartPin , uint8_t Width , GpioPort :: DataOrder DataOrder = GpioPort :: DataOrder :: Normal > ; class modm :: GpioIO ; class modm :: GpioInput ; class modm :: GpioOutput ; class modm :: GpioPort ; class modm :: I2cDevice < class I2cMaster , uint8_t NestingLevels = 10 , class Transaction = I2cWriteReadTransaction > ; class modm :: I2cMaster ; class modm :: I2cMultiplexer < class I2cMaster , class I2cMultiplexerDevice > ; class modm :: I2cMultiplexerChannel < auto & multiplexer , typename std :: remove_reference_t < decltype ( multiplexer ) >:: Channel channel > ; class modm :: I2cReadTransaction ; class modm :: I2cTransaction ; class modm :: I2cWriteReadTransaction ; class modm :: I2cWriteTransaction ; class modm :: PeripheralDriver ; class modm :: SpiDevice < class SpiMaster > ; class modm :: SpiMaster ; class modm :: Uart ; class modm :: accessor :: Flash < typename T > ; class modm :: accessor :: Ram < typename T > ; class modm :: atomic :: Container < typename T > ; class modm :: atomic :: Flag ; class modm :: atomic :: Lock ; class modm :: atomic :: Queue < typename T , std :: size_t N > ; class modm :: atomic :: Unlock ; // Struct struct modm :: Configuration < typename Parent , typename Enum , typename Parent :: UnderlyingType Mask , typename Parent :: UnderlyingType Position = 0 > ; struct modm :: Flags < typename Enum , typename T > ; struct modm :: FlagsGroup < T ... > ; struct modm :: FlagsOperators < typename Enum , typename T > ; struct modm :: Gpio ; struct modm :: I2c ; struct modm :: I2cTransaction :: Reading ; struct modm :: I2cTransaction :: Starting ; struct modm :: I2cTransaction :: Writing ; struct modm :: Register < typename T > ; struct modm :: Spi ; struct modm :: Value < typename Parent , typename Parent :: UnderlyingType Width , typename Parent :: UnderlyingType Position = 0 > ; struct modm :: can :: Message :: Flags ; struct modm :: can :: Message ; struct modm :: i2cMultiplexer ; struct modm :: unaligned_t < typename T > ; // Function bool modm_assert ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure ); bool modm_assert_debug ( bool condition , const char * module , const char * location , const char * failure , uintptr_t context ); inline :: modm :: accessor :: Flash < T > modm :: accessor :: asFlash ( const T * ptr ); modm :: IOStream & modm :: can :: operator << ( modm :: IOStream & s , const modm :: can :: Message m ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: Operation op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterRead op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterStart op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: I2c :: OperationAfterWrite op ); modm :: IOStream & modm :: operator << ( modm :: IOStream & stream , const Can :: BusState state ); modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < T > ptr ); static modm :: IOStream & operator << ( modm :: IOStream & os , modm :: accessor :: Flash < char > ptr ); unaligned_t < T >* modm :: asUnaligned ( U * value ); void modm :: delayMicroseconds ( uint16_t us ); void modm :: delayMilliseconds ( uint16_t ms ); void modm :: delayNanoseconds ( uint16_t ns ); void modm_abandon ( const char * module , const char * location , const char * failure , uintptr_t context ) modm_weak ; void * operator new ( size_t size , modm :: MemoryTraits traits ) noexcept ; void * operator new []( size_t size , modm :: MemoryTraits traits ) noexcept ; volatile T & modm :: accessor :: asVolatile ( T & value ); // Enum enum Abandonment ; enum MemoryTrait ; enum RomCommand ; // Variable constexpr MemoryTraits modm :: MemoryBackup = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeNonVolatile ); constexpr MemoryTraits modm :: MemoryDMA = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA ); constexpr MemoryTraits modm :: MemoryDMA2D = ( MemoryTrait :: AccessSBus | MemoryTrait :: AccessDMA2D ); constexpr MemoryTraits modm :: MemoryDefault = MemoryDMA ; constexpr MemoryTraits modm :: MemoryExternal = ( MemoryTrait :: AccessSBus | MemoryTrait :: TypeExternal ); constexpr MemoryTraits modm :: MemoryFastCode = ( MemoryTrait :: AccessIBus | MemoryTrait :: TypeCoreCoupled ); constexpr MemoryTraits modm :: MemoryFastData = ( MemoryTrait :: AccessDBus | MemoryTrait :: TypeCoreCoupled ); // Typedef using modm :: AssertionHandler = typedef Abandonment ( * )( const char * module , const char * location , const char * failure , uintptr_t context ); using modm :: Flags16 = typedef Flags < Enum , uint16_t > ; using modm :: Flags32 = typedef Flags < Enum , uint32_t > ; using modm :: Flags8 = typedef Flags < Enum , uint8_t > ; using modm :: MemoryTraits = typedef Flags16 < MemoryTrait > ; using modm :: Register16 = typedef Register < uint16_t > ; using modm :: Register32 = typedef Register < uint32_t > ; using modm :: Register8 = typedef Register < uint8_t > ; // Define #define EXTERN_FLASH_STORAGE(var) #define EXTERN_FLASH_STORAGE_STRING(s) #define FLASH_STORAGE(var) #define FLASH_STORAGE_STRING(s) #define IFSS(s) #define MODM_ALIGNMENT #define MODM_ARRAY_SIZE(x) #define MODM_ASSERTION_HANDLER(handler) #define MODM_BYTE_ORDER #define MODM_COMPILER_GCC #define MODM_COMPILER_MSVC #define MODM_COMPILER_STRING #define MODM_CONCAT(a, b) #define MODM_CONCAT3(a, b, c) #define MODM_CONCAT4(a, b, c, d) #define MODM_CONCAT5(a, b, c, d, e) #define MODM_CPU_ARM #define MODM_CPU_ARM7TDMI #define MODM_CPU_ATMEGA #define MODM_CPU_ATTINY #define MODM_CPU_ATXMEGA #define MODM_CPU_AVR #define MODM_CPU_CORTEX_M0 #define MODM_CPU_CORTEX_M3 #define MODM_CPU_CORTEX_M4 #define MODM_CPU_STRING #define MODM_FLAGS16(Enum) #define MODM_FLAGS32(Enum) #define MODM_FLAGS8(Enum) #define MODM_ISR(vector, ...) #define MODM_ISR_CALL(vector) #define MODM_ISR_DECL(vector) #define MODM_ISR_NAME(vector) #define MODM_IS_BIG_ENDIAN #define MODM_IS_LITTLE_ENDIAN #define MODM_ORDER_BIG_ENDIAN #define MODM_ORDER_LITTLE_ENDIAN #define MODM_ORDER_PDP_ENDIAN #define MODM_OS_HOSTED #define MODM_OS_HOSTED_64 #define MODM_OS_LINUX #define MODM_OS_OSX #define MODM_OS_STRING #define MODM_OS_UNIX #define MODM_OS_WIN32 #define MODM_OS_WIN64 #define MODM_SIZEOF_POINTER #define MODM_STRINGIFY(s) #define MODM_TYPE_FLAGS(Parent) #define modm_aligned(n) #define modm_always_inline #define modm_fastcode #define modm_fastdata #define modm_likely(x) #define modm_packed #define modm_section(s) #define modm_unlikely(x) #define modm_unused #define modm_weak","title":"Content"},{"location":"reference/module/modm-architecture/#dependencies","text":"modm:architecture modm_architecture modm: architecture modm_math_units modm: math: units modm_architecture->modm_math_units modm_math_units->modm_architecture modm_architecture_1_wire modm: architecture: 1-wire modm_architecture_1_wire->modm_architecture modm_architecture_accessor modm: architecture: accessor modm_architecture_accessor->modm_architecture modm_architecture_adc modm: architecture: adc modm_architecture_adc->modm_architecture modm_architecture_assert modm: architecture: assert modm_architecture_assert->modm_architecture modm_architecture_atomic modm: architecture: atomic modm_architecture_atomic->modm_architecture modm_architecture_block_device modm: architecture: block.device modm_architecture_block_device->modm_architecture modm_architecture_can modm: architecture: can modm_architecture_can->modm_architecture modm_architecture_clock modm: architecture: clock modm_architecture_clock->modm_architecture modm_architecture_delay modm: architecture: delay modm_architecture_delay->modm_architecture modm_architecture_gpio modm: architecture: gpio modm_architecture_gpio->modm_architecture modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_architecture modm_architecture_heap modm: architecture: heap modm_architecture_heap->modm_architecture modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_architecture modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c_device->modm_architecture modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_architecture modm_architecture_interrupt modm: architecture: interrupt modm_architecture_interrupt->modm_architecture modm_architecture_memory modm: architecture: memory modm_architecture_memory->modm_architecture modm_architecture_register modm: architecture: register modm_architecture_register->modm_architecture modm_architecture_spi modm: architecture: spi modm_architecture_spi->modm_architecture modm_architecture_spi_device modm: architecture: spi.device modm_architecture_spi_device->modm_architecture modm_architecture_uart modm: architecture: uart modm_architecture_uart->modm_architecture modm_architecture_unaligned modm: architecture: unaligned modm_architecture_unaligned->modm_architecture modm_container modm: container modm_container->modm_architecture modm_debug modm: debug modm_debug->modm_architecture modm_math_filter modm: math: filter modm_math_filter->modm_architecture modm_math_geometry modm: math: geometry modm_math_geometry->modm_architecture modm_math_utils modm: math: utils modm_math_utils->modm_architecture modm_processing_protothread modm: processing: protothread modm_processing_protothread->modm_architecture modm_utils modm: utils modm_utils->modm_architecture","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f469ni/","text":"These module docs are in beta and may be incomplete. modm:board:disco-f469ni: STM32F469IDISCOVERY \u00b6 Discovery kit with STM32F469NI MCU. This BSPs Board::initialize() sets the board up with these settings: 180MHz CPU clock frequency in overdrive mode. 90MHz APB2 and 45MHz APB1 clock frequency. MODM_LOGGER initialized at 115.2kBaud outputting on STLink. 16MB SDRAM initialized for heap. Disables the display by default. You can enable and use the on-board display in two ways: Use the modm::GraphicDisplay returned by Board::getDisplay() , which initializes the display on first call and allocates the framebuffer in the external SDRAM. This is the simplest option. Call Board::initializeDisplay() and then provide your own display buffer with Board::setDisplayBuffer(void*) . Caveats No double-buffering is implemented, so you may notice some tearing if you update the display fast enough. Access to the capacitive touchscreen is provided in the Board::ft6 namespace. Call Board::initializeTouchscreen() to setup the peripherals. Product Link: http://www.st.com/en/evaluation-tools/32f469idiscovery.html Content \u00b6 // Struct struct Board :: SystemClock ; // Function modm :: GraphicDisplay & Board :: getDisplay (); void Board :: initialize (); void Board :: initializeDisplay (); void Board :: initializeTouchscreen (); void Board :: setDisplayBuffer ( void * buffer ); void * Board :: getDisplayBuffer (); // Typedef using Board :: A0 = typedef GpioB1 ; using Board :: A1 = typedef GpioC2 ; using Board :: A2 = typedef GpioC3 ; using Board :: A3 = typedef GpioC4 ; using Board :: A4 = typedef GpioC5 ; using Board :: A5 = typedef GpioA4 ; using Board :: Button = typedef GpioInputA0 ; using Board :: D0 = typedef GpioG9 ; using Board :: D1 = typedef GpioG14 ; using Board :: D10 = typedef GpioH6 ; using Board :: D11 = typedef GpioB15 ; using Board :: D12 = typedef GpioB14 ; using Board :: D13 = typedef GpioD3 ; using Board :: D14 = typedef GpioB9 ; using Board :: D15 = typedef GpioB8 ; using Board :: D2 = typedef GpioG13 ; using Board :: D3 = typedef GpioA1 ; using Board :: D4 = typedef GpioG12 ; using Board :: D5 = typedef GpioA2 ; using Board :: D6 = typedef GpioA6 ; using Board :: D7 = typedef GpioG11 ; using Board :: D8 = typedef GpioG10 ; using Board :: D9 = typedef GpioA7 ; using Board :: DisplayReset = typedef GpioOutputH7 ; using Board :: LedBlue = typedef GpioInverted < GpioOutputK3 > ; using Board :: LedD13 = typedef GpioOutputD3 ; using Board :: LedGreen = typedef GpioInverted < GpioOutputG6 > ; using Board :: LedOrange = typedef GpioInverted < GpioOutputD4 > ; using Board :: LedRed = typedef GpioInverted < GpioOutputD5 > ; using Board :: LedUsb = typedef GpioInverted < GpioOutputB7 > ; using Board :: Leds = typedef SoftwareGpioPort < LedBlue , LedRed , LedOrange , LedGreen > ; using Board :: LoggerDevice = typedef modm :: IODeviceWrapper < stlink :: Uart , modm :: IOBuffer :: BlockIfFull > ; using Board :: ft6 :: I2cMaster = typedef I2cMaster1 ; using Board :: ft6 :: Int = typedef GpioInputJ5 ; using Board :: ft6 :: Scl = typedef GpioB8 ; using Board :: ft6 :: Sda = typedef GpioB9 ; using Board :: ft6 :: Touch = typedef modm :: Ft6x06 < I2cMaster > ; using Board :: stlink :: Rx = typedef GpioInputB11 ; using Board :: stlink :: Tx = typedef GpioOutputB10 ; using Board :: stlink :: Uart = typedef Usart3 ; // Define #define MODM_BOARD_HAS_LOGGER Dependencies \u00b6 modm:board:disco-f469ni modm_board_disco_f469ni modm: board: disco-f469ni modm_architecture_clock modm: architecture: clock modm_board_disco_f469ni->modm_architecture_clock modm_architecture_memory modm: architecture: memory modm_board_disco_f469ni->modm_architecture_memory modm_board modm: board modm_board_disco_f469ni->modm_board modm_debug modm: debug modm_board_disco_f469ni->modm_debug modm_driver_ft6x06 modm: driver: ft6x06 modm_board_disco_f469ni->modm_driver_ft6x06 modm_math_utils modm: math: utils modm_board_disco_f469ni->modm_math_utils modm_platform_clock modm: platform: clock modm_board_disco_f469ni->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f469ni->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f469ni->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f469ni->modm_platform_i2c_1 modm_platform_rcc modm: platform: rcc modm_board_disco_f469ni->modm_platform_rcc modm_platform_uart_3 modm: platform: uart: 3 modm_board_disco_f469ni->modm_platform_uart_3 modm_ui_display modm: ui: display modm_board_disco_f469ni->modm_ui_display","title":"modm:board:disco-f469ni"},{"location":"reference/module/modm-board-disco-f469ni/#modmboarddisco-f469ni-stm32f469idiscovery","text":"Discovery kit with STM32F469NI MCU. This BSPs Board::initialize() sets the board up with these settings: 180MHz CPU clock frequency in overdrive mode. 90MHz APB2 and 45MHz APB1 clock frequency. MODM_LOGGER initialized at 115.2kBaud outputting on STLink. 16MB SDRAM initialized for heap. Disables the display by default. You can enable and use the on-board display in two ways: Use the modm::GraphicDisplay returned by Board::getDisplay() , which initializes the display on first call and allocates the framebuffer in the external SDRAM. This is the simplest option. Call Board::initializeDisplay() and then provide your own display buffer with Board::setDisplayBuffer(void*) . Caveats No double-buffering is implemented, so you may notice some tearing if you update the display fast enough. Access to the capacitive touchscreen is provided in the Board::ft6 namespace. Call Board::initializeTouchscreen() to setup the peripherals. Product Link: http://www.st.com/en/evaluation-tools/32f469idiscovery.html","title":"modm:board:disco-f469ni: STM32F469IDISCOVERY"},{"location":"reference/module/modm-board-disco-f469ni/#content","text":"// Struct struct Board :: SystemClock ; // Function modm :: GraphicDisplay & Board :: getDisplay (); void Board :: initialize (); void Board :: initializeDisplay (); void Board :: initializeTouchscreen (); void Board :: setDisplayBuffer ( void * buffer ); void * Board :: getDisplayBuffer (); // Typedef using Board :: A0 = typedef GpioB1 ; using Board :: A1 = typedef GpioC2 ; using Board :: A2 = typedef GpioC3 ; using Board :: A3 = typedef GpioC4 ; using Board :: A4 = typedef GpioC5 ; using Board :: A5 = typedef GpioA4 ; using Board :: Button = typedef GpioInputA0 ; using Board :: D0 = typedef GpioG9 ; using Board :: D1 = typedef GpioG14 ; using Board :: D10 = typedef GpioH6 ; using Board :: D11 = typedef GpioB15 ; using Board :: D12 = typedef GpioB14 ; using Board :: D13 = typedef GpioD3 ; using Board :: D14 = typedef GpioB9 ; using Board :: D15 = typedef GpioB8 ; using Board :: D2 = typedef GpioG13 ; using Board :: D3 = typedef GpioA1 ; using Board :: D4 = typedef GpioG12 ; using Board :: D5 = typedef GpioA2 ; using Board :: D6 = typedef GpioA6 ; using Board :: D7 = typedef GpioG11 ; using Board :: D8 = typedef GpioG10 ; using Board :: D9 = typedef GpioA7 ; using Board :: DisplayReset = typedef GpioOutputH7 ; using Board :: LedBlue = typedef GpioInverted < GpioOutputK3 > ; using Board :: LedD13 = typedef GpioOutputD3 ; using Board :: LedGreen = typedef GpioInverted < GpioOutputG6 > ; using Board :: LedOrange = typedef GpioInverted < GpioOutputD4 > ; using Board :: LedRed = typedef GpioInverted < GpioOutputD5 > ; using Board :: LedUsb = typedef GpioInverted < GpioOutputB7 > ; using Board :: Leds = typedef SoftwareGpioPort < LedBlue , LedRed , LedOrange , LedGreen > ; using Board :: LoggerDevice = typedef modm :: IODeviceWrapper < stlink :: Uart , modm :: IOBuffer :: BlockIfFull > ; using Board :: ft6 :: I2cMaster = typedef I2cMaster1 ; using Board :: ft6 :: Int = typedef GpioInputJ5 ; using Board :: ft6 :: Scl = typedef GpioB8 ; using Board :: ft6 :: Sda = typedef GpioB9 ; using Board :: ft6 :: Touch = typedef modm :: Ft6x06 < I2cMaster > ; using Board :: stlink :: Rx = typedef GpioInputB11 ; using Board :: stlink :: Tx = typedef GpioOutputB10 ; using Board :: stlink :: Uart = typedef Usart3 ; // Define #define MODM_BOARD_HAS_LOGGER","title":"Content"},{"location":"reference/module/modm-board-disco-f469ni/#dependencies","text":"modm:board:disco-f469ni modm_board_disco_f469ni modm: board: disco-f469ni modm_architecture_clock modm: architecture: clock modm_board_disco_f469ni->modm_architecture_clock modm_architecture_memory modm: architecture: memory modm_board_disco_f469ni->modm_architecture_memory modm_board modm: board modm_board_disco_f469ni->modm_board modm_debug modm: debug modm_board_disco_f469ni->modm_debug modm_driver_ft6x06 modm: driver: ft6x06 modm_board_disco_f469ni->modm_driver_ft6x06 modm_math_utils modm: math: utils modm_board_disco_f469ni->modm_math_utils modm_platform_clock modm: platform: clock modm_board_disco_f469ni->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f469ni->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f469ni->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f469ni->modm_platform_i2c_1 modm_platform_rcc modm: platform: rcc modm_board_disco_f469ni->modm_platform_rcc modm_platform_uart_3 modm: platform: uart: 3 modm_board_disco_f469ni->modm_platform_uart_3 modm_ui_display modm: ui: display modm_board_disco_f469ni->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-board/","text":"These module docs are in beta and may be incomplete. modm:board: Board Support Packages \u00b6 Content \u00b6 // Struct struct Board :: SystemClock ; // Function modm :: GraphicDisplay & Board :: getDisplay (); void Board :: initialize (); void Board :: initializeDisplay (); void Board :: initializeTouchscreen (); void Board :: setDisplayBuffer ( void * buffer ); void * Board :: getDisplayBuffer (); // Typedef using Board :: A0 = typedef GpioB1 ; using Board :: A1 = typedef GpioC2 ; using Board :: A2 = typedef GpioC3 ; using Board :: A3 = typedef GpioC4 ; using Board :: A4 = typedef GpioC5 ; using Board :: A5 = typedef GpioA4 ; using Board :: Button = typedef GpioInputA0 ; using Board :: D0 = typedef GpioG9 ; using Board :: D1 = typedef GpioG14 ; using Board :: D10 = typedef GpioH6 ; using Board :: D11 = typedef GpioB15 ; using Board :: D12 = typedef GpioB14 ; using Board :: D13 = typedef GpioD3 ; using Board :: D14 = typedef GpioB9 ; using Board :: D15 = typedef GpioB8 ; using Board :: D2 = typedef GpioG13 ; using Board :: D3 = typedef GpioA1 ; using Board :: D4 = typedef GpioG12 ; using Board :: D5 = typedef GpioA2 ; using Board :: D6 = typedef GpioA6 ; using Board :: D7 = typedef GpioG11 ; using Board :: D8 = typedef GpioG10 ; using Board :: D9 = typedef GpioA7 ; using Board :: DisplayReset = typedef GpioOutputH7 ; using Board :: LedBlue = typedef GpioInverted < GpioOutputK3 > ; using Board :: LedD13 = typedef GpioOutputD3 ; using Board :: LedGreen = typedef GpioInverted < GpioOutputG6 > ; using Board :: LedOrange = typedef GpioInverted < GpioOutputD4 > ; using Board :: LedRed = typedef GpioInverted < GpioOutputD5 > ; using Board :: LedUsb = typedef GpioInverted < GpioOutputB7 > ; using Board :: Leds = typedef SoftwareGpioPort < LedBlue , LedRed , LedOrange , LedGreen > ; using Board :: LoggerDevice = typedef modm :: IODeviceWrapper < stlink :: Uart , modm :: IOBuffer :: BlockIfFull > ; using Board :: ft6 :: I2cMaster = typedef I2cMaster1 ; using Board :: ft6 :: Int = typedef GpioInputJ5 ; using Board :: ft6 :: Scl = typedef GpioB8 ; using Board :: ft6 :: Sda = typedef GpioB9 ; using Board :: ft6 :: Touch = typedef modm :: Ft6x06 < I2cMaster > ; using Board :: instead = typedef SystemClock ; using Board :: stlink :: Rx = typedef GpioInputB11 ; using Board :: stlink :: Tx = typedef GpioOutputB10 ; using Board :: stlink :: Uart = typedef Usart3 ; // Define #define MODM_BOARD_HAS_LOGGER Dependencies \u00b6 modm:board modm_board modm: board modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_board","title":"modm:board"},{"location":"reference/module/modm-board/#modmboard-board-support-packages","text":"","title":"modm:board: Board Support Packages"},{"location":"reference/module/modm-board/#content","text":"// Struct struct Board :: SystemClock ; // Function modm :: GraphicDisplay & Board :: getDisplay (); void Board :: initialize (); void Board :: initializeDisplay (); void Board :: initializeTouchscreen (); void Board :: setDisplayBuffer ( void * buffer ); void * Board :: getDisplayBuffer (); // Typedef using Board :: A0 = typedef GpioB1 ; using Board :: A1 = typedef GpioC2 ; using Board :: A2 = typedef GpioC3 ; using Board :: A3 = typedef GpioC4 ; using Board :: A4 = typedef GpioC5 ; using Board :: A5 = typedef GpioA4 ; using Board :: Button = typedef GpioInputA0 ; using Board :: D0 = typedef GpioG9 ; using Board :: D1 = typedef GpioG14 ; using Board :: D10 = typedef GpioH6 ; using Board :: D11 = typedef GpioB15 ; using Board :: D12 = typedef GpioB14 ; using Board :: D13 = typedef GpioD3 ; using Board :: D14 = typedef GpioB9 ; using Board :: D15 = typedef GpioB8 ; using Board :: D2 = typedef GpioG13 ; using Board :: D3 = typedef GpioA1 ; using Board :: D4 = typedef GpioG12 ; using Board :: D5 = typedef GpioA2 ; using Board :: D6 = typedef GpioA6 ; using Board :: D7 = typedef GpioG11 ; using Board :: D8 = typedef GpioG10 ; using Board :: D9 = typedef GpioA7 ; using Board :: DisplayReset = typedef GpioOutputH7 ; using Board :: LedBlue = typedef GpioInverted < GpioOutputK3 > ; using Board :: LedD13 = typedef GpioOutputD3 ; using Board :: LedGreen = typedef GpioInverted < GpioOutputG6 > ; using Board :: LedOrange = typedef GpioInverted < GpioOutputD4 > ; using Board :: LedRed = typedef GpioInverted < GpioOutputD5 > ; using Board :: LedUsb = typedef GpioInverted < GpioOutputB7 > ; using Board :: Leds = typedef SoftwareGpioPort < LedBlue , LedRed , LedOrange , LedGreen > ; using Board :: LoggerDevice = typedef modm :: IODeviceWrapper < stlink :: Uart , modm :: IOBuffer :: BlockIfFull > ; using Board :: ft6 :: I2cMaster = typedef I2cMaster1 ; using Board :: ft6 :: Int = typedef GpioInputJ5 ; using Board :: ft6 :: Scl = typedef GpioB8 ; using Board :: ft6 :: Sda = typedef GpioB9 ; using Board :: ft6 :: Touch = typedef modm :: Ft6x06 < I2cMaster > ; using Board :: instead = typedef SystemClock ; using Board :: stlink :: Rx = typedef GpioInputB11 ; using Board :: stlink :: Tx = typedef GpioOutputB10 ; using Board :: stlink :: Uart = typedef Usart3 ; // Define #define MODM_BOARD_HAS_LOGGER","title":"Content"},{"location":"reference/module/modm-board/#dependencies","text":"modm:board modm_board modm: board modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_board","title":"Dependencies"},{"location":"reference/module/modm-build-cmake/","text":"These module docs are in beta and may be incomplete. modm:build:cmake: CMake Build Script Generator \u00b6 CMake is a widely used build tool supported by almost every IDE. This module generates two files: a top-level CMakeLists.txt : configures CMake to build modm and your application. a top-level Makefile : provides a convenience wrapper for calling CMake from the command line. This module is intended to be used for integration with IDEs that natively only support CMake. It therefore only provides the bare minimum of features and can only be used to compile for ARM Cortex-M targets. The modm:build:scons module is the preferred build system for modm. Make Methods \u00b6 The Makefile wrapper provides these convenience methods. make cmake \u00b6 Generates the CMake build folders and initializes the build system. $ make cmake ... -- Project : blink_cmake -- Platform: stm32 -- Compiler: gcc -- Part : stm32f103c8t -- Family : f1 -- Core : cortex-m3 -- Path : build/{project.name} -- Configuring done -- Generating done -- Build files have been written to: build/{project.name}/cmake-build-release ... -- Build files have been written to: build/{project.name}/cmake-build-debug You must call this once before you can build! If you forget to call this first, the build will fail with this error message: $ make build-release Error: build/cmake-build-release is not a directory make: *** [build-release] Error 1 make build-release \u00b6 make build-debug \u00b6 Compiles your application into an executable using the release or debug profile. $ make build-release Scanning dependencies of target blink_cmake [ 3%] Building C object CMakeFiles/blink_cmake.dir/modm/ext/cmsis/device/peripherals.c.o [ 7%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/architecture/driver/atomic/flag.cpp.o [ 19%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/board/board.cpp.o ... [ 96%] Building CXX object CMakeFiles/blink_cmake.dir/main.cpp.o [100%] Linking CXX executable blink_cmake.elf text data bss dec hex filename 1596 52 20468 22116 5664 blink_cmake.elf [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss make upload-release \u00b6 make upload-debug \u00b6 Writes the executable onto your target via OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. $ make upload-release [100%] Built target blink_cmake [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.171034 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x20036410 Info : flash size = 64kbytes ... wrote 2048 bytes from file build/cmake-build-release/blink_cmake.elf in 0.187893s (10.644 KiB/s) ** Programming Finished ** ** Verify Started ** verified 1652 bytes in 0.104584s (15.426 KiB/s) ** Verified OK ** shutdown command invoked make gdb \u00b6 make gdb-release \u00b6 Launches GDB with the debug or release executable. This is just a convenience wrapper for the debug functionality defined in the modm:build module. OpenOCD must already be running in the background . Launch it by manually calling it in another terminal: openocd -f modm/openocd.cfg make clean \u00b6 Removes the CMake build artifacts. make cleanall \u00b6 Removes the entire build folders. You must then first call make cmake before being able to build again Options \u00b6 include_makefile \u00b6 Generate a wrapper Makefile: True \u2208 { True, False } This overwrites any top-level Makefile file! Dependencies \u00b6 modm:build:cmake modm_build_cmake modm: build: cmake modm_build modm: build modm_build_cmake->modm_build","title":"modm:build:cmake"},{"location":"reference/module/modm-build-cmake/#modmbuildcmake-cmake-build-script-generator","text":"CMake is a widely used build tool supported by almost every IDE. This module generates two files: a top-level CMakeLists.txt : configures CMake to build modm and your application. a top-level Makefile : provides a convenience wrapper for calling CMake from the command line. This module is intended to be used for integration with IDEs that natively only support CMake. It therefore only provides the bare minimum of features and can only be used to compile for ARM Cortex-M targets. The modm:build:scons module is the preferred build system for modm.","title":"modm:build:cmake: CMake Build Script Generator"},{"location":"reference/module/modm-build-cmake/#make-methods","text":"The Makefile wrapper provides these convenience methods.","title":"Make Methods"},{"location":"reference/module/modm-build-cmake/#make-cmake","text":"Generates the CMake build folders and initializes the build system. $ make cmake ... -- Project : blink_cmake -- Platform: stm32 -- Compiler: gcc -- Part : stm32f103c8t -- Family : f1 -- Core : cortex-m3 -- Path : build/{project.name} -- Configuring done -- Generating done -- Build files have been written to: build/{project.name}/cmake-build-release ... -- Build files have been written to: build/{project.name}/cmake-build-debug You must call this once before you can build! If you forget to call this first, the build will fail with this error message: $ make build-release Error: build/cmake-build-release is not a directory make: *** [build-release] Error 1","title":"make cmake"},{"location":"reference/module/modm-build-cmake/#make-build-release","text":"","title":"make build-release"},{"location":"reference/module/modm-build-cmake/#make-build-debug","text":"Compiles your application into an executable using the release or debug profile. $ make build-release Scanning dependencies of target blink_cmake [ 3%] Building C object CMakeFiles/blink_cmake.dir/modm/ext/cmsis/device/peripherals.c.o [ 7%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/architecture/driver/atomic/flag.cpp.o [ 19%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/board/board.cpp.o ... [ 96%] Building CXX object CMakeFiles/blink_cmake.dir/main.cpp.o [100%] Linking CXX executable blink_cmake.elf text data bss dec hex filename 1596 52 20468 22116 5664 blink_cmake.elf [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss","title":"make build-debug"},{"location":"reference/module/modm-build-cmake/#make-upload-release","text":"","title":"make upload-release"},{"location":"reference/module/modm-build-cmake/#make-upload-debug","text":"Writes the executable onto your target via OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. $ make upload-release [100%] Built target blink_cmake [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.171034 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x20036410 Info : flash size = 64kbytes ... wrote 2048 bytes from file build/cmake-build-release/blink_cmake.elf in 0.187893s (10.644 KiB/s) ** Programming Finished ** ** Verify Started ** verified 1652 bytes in 0.104584s (15.426 KiB/s) ** Verified OK ** shutdown command invoked","title":"make upload-debug"},{"location":"reference/module/modm-build-cmake/#make-gdb","text":"","title":"make gdb"},{"location":"reference/module/modm-build-cmake/#make-gdb-release","text":"Launches GDB with the debug or release executable. This is just a convenience wrapper for the debug functionality defined in the modm:build module. OpenOCD must already be running in the background . Launch it by manually calling it in another terminal: openocd -f modm/openocd.cfg","title":"make gdb-release"},{"location":"reference/module/modm-build-cmake/#make-clean","text":"Removes the CMake build artifacts.","title":"make clean"},{"location":"reference/module/modm-build-cmake/#make-cleanall","text":"Removes the entire build folders. You must then first call make cmake before being able to build again","title":"make cleanall"},{"location":"reference/module/modm-build-cmake/#options","text":"","title":"Options"},{"location":"reference/module/modm-build-cmake/#include_makefile","text":"Generate a wrapper Makefile: True \u2208 { True, False } This overwrites any top-level Makefile file!","title":"include_makefile"},{"location":"reference/module/modm-build-cmake/#dependencies","text":"modm:build:cmake modm_build_cmake modm: build: cmake modm_build modm: build modm_build_cmake->modm_build","title":"Dependencies"},{"location":"reference/module/modm-build-scons/","text":"These module docs are in beta and may be incomplete. modm:build:scons: SCons Build Script Generator \u00b6 SCons is a software construction build system written in Python. For a better embedded experience, we've extended it with a custom build tools by the DLR as well as our own modm-specific build tools. This module generates two files: a modm/SConscript file: configures all required SCons tools with the right settings (also using information from the modm:build module) to compile the modm library. a top-level SConstruct file: configures additional, optional tools and sets up all the relevant SCons functions for your target. The SConscript file is self contained and does not depend on anything outside of the modm/ directory. This allows it to be combined with SConscript of other projects without clashing. In fact, if you look at your generated SConstruct file, you'll notice that it doesn't contain a lot of logic or specific data, it is only meant for calling the right SCons tool with the right arguments. We do not intend to serve every possible use-case with this module. If you need something special, write your own SConstruct file, maybe starting by modifying ours. Remember to set modm:build:scons:include_sconstruct to False , so that your custom SConstruct does not get overwritten. See the instructions inside our generated default SConstruct . SCons Methods \u00b6 This module generates these SCons methods depending on the target. scons \u00b6 Defaults to scons build . You can add these arguments to any of the scons commands: verbose=1 : gives a more verbose output, so you can, for example, check what options the compiler is called with. profile=release : Compile project with the release profile options (default). profile=debug : Compile project with the debug profile options. For a description of the release and debug profiles, see the modm:build module documentation. Debug Profile When working with the debug profile, make sure to add profile=debug to all commands, especially scons program profile=debug and scons gdb profile=debug ! scons build \u00b6 Compiles your application into an executable. Example for a STM32 target: $ scons build Compiling C++\u00b7\u00b7 build/release/main.o Compiling C\u00b7\u00b7\u00b7\u00b7 build/release/modm/ext/tlsf/tlsf.o ... Compiling C++\u00b7\u00b7 build/release/modm/src/modm/ui/display/virtual_graphic_display.o Compiling C++\u00b7\u00b7 build/release/modm/src/modm/utils/dummy.o Create Library\u00b7 build/release/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/release/modm/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/release/game_of_life.elf scons size \u00b6 Displays the static Flash and RAM consumption of your target. (* only STM32 targets ) Example for a STM32 target with 16MB external heap: $ scons size Memory usage:.. build/release/game_of_life.elf Program: 12.8 KiB (0.6% used) (.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.extern + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%) (.bss + .data + .fastdata + .stack) Heap: 16.4 MiB (.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern) scons program \u00b6 Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. (* only AVR and STM32 targets ) Example for a STM32 target: $ scons program .----OpenOCD--- build/release/game_of_life.elf '-------------> stm32f469nih Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.259396 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes Info : Dual Bank 2048 kiB STM32F42x/43x/469/479 found ... wrote 16384 bytes from file build/release/game_of_life.elf in 0.589736s (27.131 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.296308s (43.056 KiB/s) ** Verified OK ** shutdown command invoked scons run \u00b6 Executes your project on your computer. (* only Hosted targets ) scons gdb \u00b6 Launches OpenOCD in the background, then launches GDB in foreground with the correct executable. When GDB exits, it stops the OpenOCD process. (* only STM32 targets ) This is just a convenience wrapper for the debug functionality defined in the modm:build module. Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the some or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to scons gdb profile=release , and if that doesn't help, compile and scons program profile=debug and try scons gdb profile=debug again. scons symbols \u00b6 Dumps the symbol table for your executable. $ scons symbols Show symbols for 'build/release/game_of_life.elf': 536871656 00000001 b (anonymous namespace)::nextOperation 536871657 00000001 b (anonymous namespace)::checkNextOperation 536871658 00000001 b (anonymous namespace)::error 536871444 00000001 b read_touch()::initialized ... 134228236 00000668 T I2C1_EV_IRQHandler 134224924 00001136 T otm8009a_init(unsigned char) 134221192 00001378 t _GLOBAL__sub_I_p 536871782 00002054 b (anonymous namespace)::txBuffer scons listing \u00b6 Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions: $ scons listing Ext. Listing\u00b7\u00b7\u00b7 build/release/game_of_life.lss $ less build/release/game_of_life.lss ... Disassembly of section .text: ... 08000d74 <main>: main(): ./main.cpp:315 int main() { 8000d74: b508 push {r3, lr} Board::initialize(); 8000d76: f7ff fcc9 bl 800070c <_ZN5Board10initializeEv> Board::initializeDisplay(); 8000d7a: f000 fd91 bl 80018a0 <_ZN5Board17initializeDisplayEv> Board::initializeTouchscreen(); 8000d7e: f7ff fc55 bl 800062c <_ZN5Board21initializeTouchscreenEv> game_of_life(); 8000d82: f7ff feff bl 8000b84 <_Z12game_of_lifev> ... scons bin \u00b6 Creates a binary file of your executable. $ scons bin Binary File\u00b7\u00b7\u00b7\u00b7 build/release/game_of_life.bin scons -c \u00b6 Cleans the build artifacts. $ scons -c Removed build/release/main.o Removed build/release/modm/ext/tlsf/tlsf.o Removed build/release/modm/src/modm/ui/display/virtual_graphic_display.o Removed build/release/modm/src/modm/utils/dummy.o Removed build/release/modm/libmodm.a Removed build/release/game_of_life.elf Removed build/release/game_of_life.lss scons cmakewrapper \u00b6 Generates a CMakeLists.txt file that wraps the scons commands so that the project can be imported into IDE with CMake support, like CLion. Consider this an unstable feature scons qtcreator \u00b6 Generates several files so that the project can be imported into Qt Creator via the .creator file importer. Note, that no compiliation or debugging features are supported, this is only meant for using the IDE as an editor. Consider this an unstable feature XPCC Generator Tool \u00b6 The modm:communication:xpcc:generator module contains the Python tools to translate the XPCC XML declarations into various language implementations. This module contains a SCons wrapper tool, that understands the XML dependencies and automatically updates the generated files when it becomes necessary. The wrapper tool is automatically used when the generator module is detected, and its options are evaluated for the wrapper as follows: env . XpccCommunication ( xmlfile = options [ \"::xpcc:generator:source\" ], container = options [ \"::xpcc:generator:container\" ], path = options [ \"::xpcc:generator:path\" ], namespace = options [ \"::xpcc:generator:namespace\" ] ) The generated files are available as a top-level #include <identifiers.hpp> . Information Tool \u00b6 Our info SCons tool generates a set of header files containing preprocessor defines with the repository state. A call to env.InfoGit(with_status={True, False}) will generate a <info_git.h> header file and add these two defines to the command line CPP options: MODM_GIT_INFO MODM_GIT_STATUS : defined only if called with with_state=True . You can enable this by setting the modm:build:scons:info.git option. A call to env.InfoBuild() will generate a <info_build.h> header file and add this define to the command line CPP options: MODM_BUILD_INFO You can enable this by setting the modm:build:scons:info.build option. Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need! Git Information \u00b6 These are the values defined as const char * strings in <info_git.h> : MODM_GIT_SHA : commit hash: %H . MODM_GIT_SHA_ABBR : short commit hash: %h . MODM_GIT_SUBJECT : commit subject as text: %s . MODM_GIT_AUTHOR : author name: %an . MODM_GIT_AUTHOR_EMAIL : author email: %ae . MODM_GIT_AUTHOR_DATE : authoring date: %ad . MODM_GIT_AUTHOR_DATE_TIMESTAMP : authoring date as Unix timestamp: %at . MODM_GIT_COMMITTER : committer name: %cn . MODM_GIT_COMMITTER_EMAIL : committer email: %ce . MODM_GIT_COMMITTER_DATE : committer date: %cd . MODM_GIT_COMMITTER_DATE_TIMESTAMP : committer das as Unix timestamp: %ct . MODM_GIT_CONFIG_USER_NAME : local user name: user.name . MODM_GIT_CONFIG_USER_EMAIL : local user email: user.email . If called with_status=True , this information is added as well: MODM_GIT_MODIFIED : number of modified files: M . MODM_GIT_ADDED : number of added files: A . MODM_GIT_DELETED : number of deleted files: D . MODM_GIT_RENAMED : number of renamed files: R . MODM_GIT_COPIED : number of copied files: C . MODM_GIT_UPDATED_NOT_MERGED : number of updated, but not merged files: U . MODM_GIT_UNTRACKED : number of untracked files: ? . This is the output of the example/linux/git project showing an unclean repository state with uncommitted changes. This can give you a few hints as to where a firmware came from and help you pinpoint the source of a bug or feature. Info: Local Git User: Info: Name: Name Surname Info: Email: name.surname@provider.com Info: Last Commit: Info: SHA: 1b5a9a642857182161a615039c92907e59881614 Info: Abbreviated SHA: 1b5a9a642 Info: Subject: wip Info: Info: Author: Info: Name: Name Surname Info: Email: name.surname@provider.com Info: Date: Tue Jul 17 22:23:20 2018 +0200 Info: Timestamp: 1531859000 Info: Info: Committer: Info: Name: Name Surname Info: Email: name.surname@provider.com Info: Date: Tue Jul 17 22:23:20 2018 +0200 Info: Timestamp: 1531859000 Info: Info: File Status: Info: Modified: 10 Info: Added: 0 Info: Deleted: 0 Info: Renamed: 0 Info: Copied: 0 Info: Untracked: 6 Build Information \u00b6 These are the values defined as const char * strings in <info_build.h> : MODM_BUILD_PROJECT_NAME : as defined in the modm:build:project.name option. MODM_BUILD_MACHINE : machine information. MODM_BUILD_USER : user information. MODM_BUILD_OS : OS version string (best effort, may not be useful!). MODM_BUILD_COMPILER : compiler information. The output of the examples/linux/build_info running on macOS: Info: Project: build_info Info: Machine: name.local Info: User: user Info: Os: Mac 10.12.6 (x86_64) Info: Compiler: g++-8 (Homebrew GCC 8.1.0) 8.1.0 Bitmap Tool \u00b6 If the modm:build:scons:image.source is defined as a path, it'll be searched for .pbm files to convert into C++ data files using the bitmap tool: source , header = env . Bitmap ( bpm_file ) See the GraphicsDisplay::drawImage() method in the modm:ui:display module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as #include <image.hpp> . Options \u00b6 include_sconstruct \u00b6 Generate a SConstruct file: True \u2208 { True, False } This overwrites any top-level SConstruct file! cache_dir \u00b6 Path to SConstruct CacheDir: { Path } If value is /cache , the cache is placed into the top-level build/ folder. You can disable CacheDir by setting an empty string. image.source \u00b6 Path to directory containing .pbm files: { Path } info.git \u00b6 Generate git repository state information: Disabled \u2208 { Disabled, Info, Info+Status } Info : generates information about the last commit. Info+Status : like Info plus git file status. info.build \u00b6 Generate build state information: False \u2208 { True, False } Collectors \u00b6 flag_format \u00b6 Formatting compile flags for SCons \u2208 Callable path.tools \u00b6 SCons tool paths to be added to the Environment \u2208 Path tools \u00b6 SCons tools to be added to the Environment \u2208 String Dependencies \u00b6 modm:build:scons modm_build_scons modm: build: scons modm_build modm: build modm_build_scons->modm_build","title":"modm:build:scons"},{"location":"reference/module/modm-build-scons/#modmbuildscons-scons-build-script-generator","text":"SCons is a software construction build system written in Python. For a better embedded experience, we've extended it with a custom build tools by the DLR as well as our own modm-specific build tools. This module generates two files: a modm/SConscript file: configures all required SCons tools with the right settings (also using information from the modm:build module) to compile the modm library. a top-level SConstruct file: configures additional, optional tools and sets up all the relevant SCons functions for your target. The SConscript file is self contained and does not depend on anything outside of the modm/ directory. This allows it to be combined with SConscript of other projects without clashing. In fact, if you look at your generated SConstruct file, you'll notice that it doesn't contain a lot of logic or specific data, it is only meant for calling the right SCons tool with the right arguments. We do not intend to serve every possible use-case with this module. If you need something special, write your own SConstruct file, maybe starting by modifying ours. Remember to set modm:build:scons:include_sconstruct to False , so that your custom SConstruct does not get overwritten. See the instructions inside our generated default SConstruct .","title":"modm:build:scons: SCons Build Script Generator"},{"location":"reference/module/modm-build-scons/#scons-methods","text":"This module generates these SCons methods depending on the target.","title":"SCons Methods"},{"location":"reference/module/modm-build-scons/#scons","text":"Defaults to scons build . You can add these arguments to any of the scons commands: verbose=1 : gives a more verbose output, so you can, for example, check what options the compiler is called with. profile=release : Compile project with the release profile options (default). profile=debug : Compile project with the debug profile options. For a description of the release and debug profiles, see the modm:build module documentation. Debug Profile When working with the debug profile, make sure to add profile=debug to all commands, especially scons program profile=debug and scons gdb profile=debug !","title":"scons"},{"location":"reference/module/modm-build-scons/#scons-build","text":"Compiles your application into an executable. Example for a STM32 target: $ scons build Compiling C++\u00b7\u00b7 build/release/main.o Compiling C\u00b7\u00b7\u00b7\u00b7 build/release/modm/ext/tlsf/tlsf.o ... Compiling C++\u00b7\u00b7 build/release/modm/src/modm/ui/display/virtual_graphic_display.o Compiling C++\u00b7\u00b7 build/release/modm/src/modm/utils/dummy.o Create Library\u00b7 build/release/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/release/modm/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/release/game_of_life.elf","title":"scons build"},{"location":"reference/module/modm-build-scons/#scons-size","text":"Displays the static Flash and RAM consumption of your target. (* only STM32 targets ) Example for a STM32 target with 16MB external heap: $ scons size Memory usage:.. build/release/game_of_life.elf Program: 12.8 KiB (0.6% used) (.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.extern + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%) (.bss + .data + .fastdata + .stack) Heap: 16.4 MiB (.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern)","title":"scons size"},{"location":"reference/module/modm-build-scons/#scons-program","text":"Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. (* only AVR and STM32 targets ) Example for a STM32 target: $ scons program .----OpenOCD--- build/release/game_of_life.elf '-------------> stm32f469nih Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.259396 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes Info : Dual Bank 2048 kiB STM32F42x/43x/469/479 found ... wrote 16384 bytes from file build/release/game_of_life.elf in 0.589736s (27.131 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.296308s (43.056 KiB/s) ** Verified OK ** shutdown command invoked","title":"scons program"},{"location":"reference/module/modm-build-scons/#scons-run","text":"Executes your project on your computer. (* only Hosted targets )","title":"scons run"},{"location":"reference/module/modm-build-scons/#scons-gdb","text":"Launches OpenOCD in the background, then launches GDB in foreground with the correct executable. When GDB exits, it stops the OpenOCD process. (* only STM32 targets ) This is just a convenience wrapper for the debug functionality defined in the modm:build module. Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the some or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to scons gdb profile=release , and if that doesn't help, compile and scons program profile=debug and try scons gdb profile=debug again.","title":"scons gdb"},{"location":"reference/module/modm-build-scons/#scons-symbols","text":"Dumps the symbol table for your executable. $ scons symbols Show symbols for 'build/release/game_of_life.elf': 536871656 00000001 b (anonymous namespace)::nextOperation 536871657 00000001 b (anonymous namespace)::checkNextOperation 536871658 00000001 b (anonymous namespace)::error 536871444 00000001 b read_touch()::initialized ... 134228236 00000668 T I2C1_EV_IRQHandler 134224924 00001136 T otm8009a_init(unsigned char) 134221192 00001378 t _GLOBAL__sub_I_p 536871782 00002054 b (anonymous namespace)::txBuffer","title":"scons symbols"},{"location":"reference/module/modm-build-scons/#scons-listing","text":"Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions: $ scons listing Ext. Listing\u00b7\u00b7\u00b7 build/release/game_of_life.lss $ less build/release/game_of_life.lss ... Disassembly of section .text: ... 08000d74 <main>: main(): ./main.cpp:315 int main() { 8000d74: b508 push {r3, lr} Board::initialize(); 8000d76: f7ff fcc9 bl 800070c <_ZN5Board10initializeEv> Board::initializeDisplay(); 8000d7a: f000 fd91 bl 80018a0 <_ZN5Board17initializeDisplayEv> Board::initializeTouchscreen(); 8000d7e: f7ff fc55 bl 800062c <_ZN5Board21initializeTouchscreenEv> game_of_life(); 8000d82: f7ff feff bl 8000b84 <_Z12game_of_lifev> ...","title":"scons listing"},{"location":"reference/module/modm-build-scons/#scons-bin","text":"Creates a binary file of your executable. $ scons bin Binary File\u00b7\u00b7\u00b7\u00b7 build/release/game_of_life.bin","title":"scons bin"},{"location":"reference/module/modm-build-scons/#scons-c","text":"Cleans the build artifacts. $ scons -c Removed build/release/main.o Removed build/release/modm/ext/tlsf/tlsf.o Removed build/release/modm/src/modm/ui/display/virtual_graphic_display.o Removed build/release/modm/src/modm/utils/dummy.o Removed build/release/modm/libmodm.a Removed build/release/game_of_life.elf Removed build/release/game_of_life.lss","title":"scons -c"},{"location":"reference/module/modm-build-scons/#scons-cmakewrapper","text":"Generates a CMakeLists.txt file that wraps the scons commands so that the project can be imported into IDE with CMake support, like CLion. Consider this an unstable feature","title":"scons cmakewrapper"},{"location":"reference/module/modm-build-scons/#scons-qtcreator","text":"Generates several files so that the project can be imported into Qt Creator via the .creator file importer. Note, that no compiliation or debugging features are supported, this is only meant for using the IDE as an editor. Consider this an unstable feature","title":"scons qtcreator"},{"location":"reference/module/modm-build-scons/#xpcc-generator-tool","text":"The modm:communication:xpcc:generator module contains the Python tools to translate the XPCC XML declarations into various language implementations. This module contains a SCons wrapper tool, that understands the XML dependencies and automatically updates the generated files when it becomes necessary. The wrapper tool is automatically used when the generator module is detected, and its options are evaluated for the wrapper as follows: env . XpccCommunication ( xmlfile = options [ \"::xpcc:generator:source\" ], container = options [ \"::xpcc:generator:container\" ], path = options [ \"::xpcc:generator:path\" ], namespace = options [ \"::xpcc:generator:namespace\" ] ) The generated files are available as a top-level #include <identifiers.hpp> .","title":"XPCC Generator Tool"},{"location":"reference/module/modm-build-scons/#information-tool","text":"Our info SCons tool generates a set of header files containing preprocessor defines with the repository state. A call to env.InfoGit(with_status={True, False}) will generate a <info_git.h> header file and add these two defines to the command line CPP options: MODM_GIT_INFO MODM_GIT_STATUS : defined only if called with with_state=True . You can enable this by setting the modm:build:scons:info.git option. A call to env.InfoBuild() will generate a <info_build.h> header file and add this define to the command line CPP options: MODM_BUILD_INFO You can enable this by setting the modm:build:scons:info.build option. Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need!","title":"Information Tool"},{"location":"reference/module/modm-build-scons/#git-information","text":"These are the values defined as const char * strings in <info_git.h> : MODM_GIT_SHA : commit hash: %H . MODM_GIT_SHA_ABBR : short commit hash: %h . MODM_GIT_SUBJECT : commit subject as text: %s . MODM_GIT_AUTHOR : author name: %an . MODM_GIT_AUTHOR_EMAIL : author email: %ae . MODM_GIT_AUTHOR_DATE : authoring date: %ad . MODM_GIT_AUTHOR_DATE_TIMESTAMP : authoring date as Unix timestamp: %at . MODM_GIT_COMMITTER : committer name: %cn . MODM_GIT_COMMITTER_EMAIL : committer email: %ce . MODM_GIT_COMMITTER_DATE : committer date: %cd . MODM_GIT_COMMITTER_DATE_TIMESTAMP : committer das as Unix timestamp: %ct . MODM_GIT_CONFIG_USER_NAME : local user name: user.name . MODM_GIT_CONFIG_USER_EMAIL : local user email: user.email . If called with_status=True , this information is added as well: MODM_GIT_MODIFIED : number of modified files: M . MODM_GIT_ADDED : number of added files: A . MODM_GIT_DELETED : number of deleted files: D . MODM_GIT_RENAMED : number of renamed files: R . MODM_GIT_COPIED : number of copied files: C . MODM_GIT_UPDATED_NOT_MERGED : number of updated, but not merged files: U . MODM_GIT_UNTRACKED : number of untracked files: ? . This is the output of the example/linux/git project showing an unclean repository state with uncommitted changes. This can give you a few hints as to where a firmware came from and help you pinpoint the source of a bug or feature. Info: Local Git User: Info: Name: Name Surname Info: Email: name.surname@provider.com Info: Last Commit: Info: SHA: 1b5a9a642857182161a615039c92907e59881614 Info: Abbreviated SHA: 1b5a9a642 Info: Subject: wip Info: Info: Author: Info: Name: Name Surname Info: Email: name.surname@provider.com Info: Date: Tue Jul 17 22:23:20 2018 +0200 Info: Timestamp: 1531859000 Info: Info: Committer: Info: Name: Name Surname Info: Email: name.surname@provider.com Info: Date: Tue Jul 17 22:23:20 2018 +0200 Info: Timestamp: 1531859000 Info: Info: File Status: Info: Modified: 10 Info: Added: 0 Info: Deleted: 0 Info: Renamed: 0 Info: Copied: 0 Info: Untracked: 6","title":"Git Information"},{"location":"reference/module/modm-build-scons/#build-information","text":"These are the values defined as const char * strings in <info_build.h> : MODM_BUILD_PROJECT_NAME : as defined in the modm:build:project.name option. MODM_BUILD_MACHINE : machine information. MODM_BUILD_USER : user information. MODM_BUILD_OS : OS version string (best effort, may not be useful!). MODM_BUILD_COMPILER : compiler information. The output of the examples/linux/build_info running on macOS: Info: Project: build_info Info: Machine: name.local Info: User: user Info: Os: Mac 10.12.6 (x86_64) Info: Compiler: g++-8 (Homebrew GCC 8.1.0) 8.1.0","title":"Build Information"},{"location":"reference/module/modm-build-scons/#bitmap-tool","text":"If the modm:build:scons:image.source is defined as a path, it'll be searched for .pbm files to convert into C++ data files using the bitmap tool: source , header = env . Bitmap ( bpm_file ) See the GraphicsDisplay::drawImage() method in the modm:ui:display module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as #include <image.hpp> .","title":"Bitmap Tool"},{"location":"reference/module/modm-build-scons/#options","text":"","title":"Options"},{"location":"reference/module/modm-build-scons/#include_sconstruct","text":"Generate a SConstruct file: True \u2208 { True, False } This overwrites any top-level SConstruct file!","title":"include_sconstruct"},{"location":"reference/module/modm-build-scons/#cache_dir","text":"Path to SConstruct CacheDir: { Path } If value is /cache , the cache is placed into the top-level build/ folder. You can disable CacheDir by setting an empty string.","title":"cache_dir"},{"location":"reference/module/modm-build-scons/#imagesource","text":"Path to directory containing .pbm files: { Path }","title":"image.source"},{"location":"reference/module/modm-build-scons/#infogit","text":"Generate git repository state information: Disabled \u2208 { Disabled, Info, Info+Status } Info : generates information about the last commit. Info+Status : like Info plus git file status.","title":"info.git"},{"location":"reference/module/modm-build-scons/#infobuild","text":"Generate build state information: False \u2208 { True, False }","title":"info.build"},{"location":"reference/module/modm-build-scons/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-build-scons/#flag_format","text":"Formatting compile flags for SCons \u2208 Callable","title":"flag_format"},{"location":"reference/module/modm-build-scons/#pathtools","text":"SCons tool paths to be added to the Environment \u2208 Path","title":"path.tools"},{"location":"reference/module/modm-build-scons/#tools","text":"SCons tools to be added to the Environment \u2208 String","title":"tools"},{"location":"reference/module/modm-build-scons/#dependencies","text":"modm:build:scons modm_build_scons modm: build: scons modm_build modm: build modm_build_scons->modm_build","title":"Dependencies"},{"location":"reference/module/modm-build/","text":"These module docs are in beta and may be incomplete. modm:build: Build System Generators \u00b6 This parent module defines a common set of functionality that is independent of the specific build system generator implementation. This includes straight-forward options like project name and build path but also more complicated configuration for programming your target via AvrDude/OpenOCD/Black Magic Probe and debugging via GDB. Note that this module does not compile your project, you will need to choose the modm:build:scons or modm:build:cmake submodule for that, or provide your own build system. Using OpenOCD \u00b6 For accessing your ARM Cortex-M based device, we use OpenOCD by default and generate a modm/openocd.cfg file with the target specific configuration: Search directories passed via the openocd.search metadata key. User configuration files passed via the openocd.configfile metadata key. Your custom modm:build:openocd.cfg is added here too. Two programming commands: program_release for uploading the release profile. program_debug for uploading your debug profile. You can now upload your program in a one-line command: openocd -f modm/openocd.cfg -c \"program_release\" openocd -f modm/openocd.cfg -c \"program_debug\" Open On-Chip Debugger 0.10.0 adapter speed: 2000 kHz adapter_nsrst_delay: 100 none separate srst_only separate srst_nogate srst_open_drain connect_deassert_srst program_debug Info : clock speed 1800 kHz Info : STLINK v2 JTAG v28 API v2 SWIM v18 VID 0x0483 PID 0x374B Info : using stlink api v2 Info : Target voltage: 3.260972 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints adapter speed: 1800 kHz ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes wrote 16384 bytes from file path/to/project.elf in 0.589551s (27.139 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.328969s (38.781 KiB/s) ** Verified OK ** adapter speed: 1800 kHz target halted due to debug-request, current mode: Thread xPSR: 0x01000000 pc: 0x0800263c msp: 0x10000be0 shutdown command invoked Using GDB \u00b6 For debugging your program on ARM Cortex-M device, we provide the modm/gdbinit file for the arm-none-eabi-gdb debugger connected to your target via OpenOCD. Four commands are provided for convenience: file_debug loads the debug profile ELF file. file_release loads the release profile ELF file. restart resets the device and halts. rerun resets the device and continues execution. GDB is configured in TUI mode and continues running the target after attaching, but does not load an ELF file! Please call file_{debug, release} first or pass the ELF file as a command line argument. You can start your debug session by launching OpenOCD and then GDB: # Run OpenOCD without any commands in the background openocd -f modm/openocd.cfg # Open another terminal arm-none-eabi-gdb -x modm/gdbinit # OR optionally with your custom ELF file arm-none-eabi-gdb -x modm/gdbinit path/to/project.elf \u250c\u2014\u2014main.cpp\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2510 >\u2502194 DRAW(x+1, y+3); \u2502 \u2502195 DRAW(x+2, y+3); \u2502 \u2502196 #else \u2502 \u2502197 DRAW(x , y ); \u2502 \u2502198 #endif \u2502 \u2502199 #undef DRAW \u2502 \u2502200 } \u2502 \u2502201 \u2502 \u2502202 static inline void drawScreen(framebuffer_t before, frame\u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 >\u25020x80017a0 <game_of_life()+1692> strh.w r3, [r4, r12, lsl #1] \u2502 \u25020x80017a4 <game_of_life()+1696> add r0, lr \u2502 \u25020x80017a6 <game_of_life()+1698> ldr r2, [r2, #0] \u2502 \u25020x80017a8 <game_of_life()+1700> strh.w r3, [r2, r0, lsl #1] \u2502 \u25020x80017ac <game_of_life()+1704> ldr r3, [sp, #12] \u2502 \u25020x80017ae <game_of_life()+1706> ldr r2, [sp, #0] \u2502 \u25020x80017b0 <game_of_life()+1708> add r2, r3 \u2502 \u25020x80017b2 <game_of_life()+1710> ldrb r3, [r7, r1] \u2502 \u25020x80017b4 <game_of_life()+1712> strb r3, [r2, r1] \u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 extended-r Remote target In: game_of_life L194 PC: 0x80017a0 Program received signal SIGINT, Interrupt. 0x080017a0 in drawPixel (color=<optimized out>, y=42, x=578) at main.c (gdb) Be careful attaching to a running target Due to the OpenOCD implementation, the target is halted for a very short period of time, while the device's debug peripheral is initialized. This time is dependent on the debug adapter and may range from just a few milliseconds to hundreds. Make sure your hardware can handle that! Using Black Magic Probe \u00b6 Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. Currently, only uploading code to the target is supported with this modm module. Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes. $ ls -l /dev/tty.usb* crw-rw-rw- 1 root wheel 21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF crw-rw-rw- 1 root wheel 21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1 You can upload your code using a Black Magic Probe with specifying the GDB interface as port parameter. $ scons bmp port=/dev/cu.usbmodemDEADBEEF verbose=1 scons: Reading SConscript files ... bmp port iss = /dev/cu.usbmodemDEADBEEF scons: done reading SConscript files. scons: Building targets ... arm-none-eabi-gdb -ex \"target extended-remote /dev/cu.usbmodemDEADBEEF\" -ex \"monitor swdp_scan\" -ex \"attach 1\" -ex \"load path/to/project.elf\" -ex \"detach\" -ex \"quit\" [...] Remote debugging using /dev/cu.usbmodemDEADBEEF Target voltage: unknown Available Targets: No. Att Driver 1 STM32F1 medium density Attaching to Remote target warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0800038e in ?? () Loading section .vector_rom, size 0xec lma 0x8000000 [...] Loading section .table.section_heap, size 0xc lma 0x80013f8 Start address 0x8000e6c, load size 5120 Transfer rate: 10 KB/sec, 365 bytes/write. Detaching from program: , Remote target [Inferior 1 (Remote target) detached] scons: done building targets. Using AvrDude \u00b6 Unfortunately AvrDude does not support a user configuration file like OpenOCD does, so there is no convenient one-line command to issue. You have to use the support of the specific build system. Compiler Options \u00b6 We maintain a common set of compiler options for all build system generator, so that they all have feature parity. We currently only support compiling modm with GCC for AVR, ARM Cortex-M and x86/posix with the options mentioned in the offical GCC options documentation . You can find all compiler options inside the generated build script for your project, the options presented here are only the most important ones. Shared for C and C++ \u00b6 -W{all, extra} : a basic set of warnings. -Werror={format, maybe-uninitialized, overflow, sign-compare} : these warnings are treated as errors. -f{data, function}-sections : puts data and functions into their own linker section. -funsigned-{char, bitfields} : modm tries to use stdint.h types everywhere, but just in case. For release builds : -Os : optimize for smaller size. For debug builds : -Og : optimize for debugging experience. Only C \u00b6 -std=gnu11 : use C11 with GNU extensions (for asm volatile ). -Wnested-externs : shouldn't use extern inside a function body. Only C++ \u00b6 -std=c++17 : use C++17 -fno-exceptions : no exceptions. -fno-rtti : no run-time type information. Linker \u00b6 --gc-section : garbage collecting sections throws out a lot of unused data/code. -L{linkdir} -Tlinkerscript.ld : modm uses a custom linkerscript. Only AVR \u00b6 -mmcu={target} : the target to compile for. Only ARM Cortex-M \u00b6 -mcpu=cortex-m{type} : the target to compile for. -mthumb : only Thumb2 instruction set is supported. -mfloat-abi=hard : if FPU available use the fastest ABI available. -mfpu=fpv{4, 5}-{sp}-d16 : single or double precision FPU. -fsingle-precision-constant : if SP-FPU, treat all FP constants as SP. -Wdouble-promotion : if SP-FPU, warn if FPs are promoted to doubles. In addition, these linker options are added: -nostartfiles : modm implements its own startup script. --specs=nano.specs : use Newlib Nano. --specs=nosys.specs : modm does not use C stdlib features. -wrap,_{calloc, malloc, realloc, free}_r : reimplemented Newlib with our own allocator. Options \u00b6 project.name \u00b6 Project Name: blink \u2208 { String } The project name defaults to the folder name you're calling lbuild from. It's used by your build system to name the executable and it may also be passed to your application via a string constant or CPP define. build.path \u00b6 Build Path: build/blink \u2208 { Path: build/blink } The build path is defaulted to build/{modm:build:project.name} . If you have a lot of embedded projects, you may want to change the build path to a common directory so that you don't have build/ folders everywhere. Remember to add your build path to your .gitignore . You should use a relative path instead of an absolute one, so that this option still works for other developers. openocd.cfg \u00b6 Path to a custom OpenOCD configuration file: { Path } If you have a custom configuration file for your target, it will get included by the generated modm/openocd.cfg . This is useful for not having to duplicate your config if you have several projects using the same target (like small bring-up and test projects). Do not execute commands by default When providing your own config file, wrap your specific commands into functions and do not execute them by default. A stray init or similar in your script will mess with modm's ability to program and debug a device correctly. Collectors \u00b6 archflags \u00b6 \u2208 String archflags.debug \u00b6 \u2208 String archflags.release \u00b6 \u2208 String asflags \u00b6 \u2208 String asflags.debug \u00b6 \u2208 String asflags.release \u00b6 \u2208 String ccflags \u00b6 \u2208 String ccflags.debug \u00b6 \u2208 String ccflags.release \u00b6 \u2208 String cflags \u00b6 \u2208 String cflags.debug \u00b6 \u2208 String cflags.release \u00b6 \u2208 String cppdefines \u00b6 \u2208 String cppdefines.debug \u00b6 \u2208 String cppdefines.release \u00b6 \u2208 String cxxflags \u00b6 \u2208 String cxxflags.debug \u00b6 \u2208 String cxxflags.release \u00b6 \u2208 String elf.debug \u00b6 Path to the compiled .elf file for the debug profile \u2208 Path elf.release \u00b6 Path to the compiled .elf file for the release profile \u2208 Path gitignore \u00b6 Generated files that need to be ignored by Git \u2208 Path library \u00b6 Libraries to link against \u2208 String linkflags \u00b6 \u2208 String linkflags.debug \u00b6 \u2208 String linkflags.release \u00b6 \u2208 String openocd.source \u00b6 Additional OpenOCD source files. \u2208 Path path.include \u00b6 Search path for header files \u2208 Path path.library \u00b6 Search path for static libraries \u2208 Path path.openocd \u00b6 Search path for OpenOCD configuration files \u2208 Path pkg-config \u00b6 Packages to configure against \u2208 String Queries \u00b6 collect_flags \u00b6 Scans the collections for module compile flags. Converts them into SCons-compatible names and places them into a dictionary of the form: flags[filename][name][profile] = list(values). :param env: the post_build step env :param scope_filter: the collection scope filter :returns: compile flags dictionary device \u00b6 Extracts common properties from a modm:target device: - platform - family - partname - core - mcu (AVR only) :returns: a dictionary of common properties. memories \u00b6 Extracts the memory map of the device. A memory region is a dictionary containing: - name of region - start address of region - size of region - access of region :returns: a list of memory regions. source_files \u00b6 Builds a list of files that need to be compiled per repository. :param buildlog: the buildlog object available in the post_build step :returns: a dictionary of sorted lists of filenames, keyed by repository. Dependencies \u00b6 modm:build modm_build modm: build modm_build_cmake modm: build: cmake modm_build_cmake->modm_build modm_build_scons modm: build: scons modm_build_scons->modm_build","title":"modm:build"},{"location":"reference/module/modm-build/#modmbuild-build-system-generators","text":"This parent module defines a common set of functionality that is independent of the specific build system generator implementation. This includes straight-forward options like project name and build path but also more complicated configuration for programming your target via AvrDude/OpenOCD/Black Magic Probe and debugging via GDB. Note that this module does not compile your project, you will need to choose the modm:build:scons or modm:build:cmake submodule for that, or provide your own build system.","title":"modm:build: Build System Generators"},{"location":"reference/module/modm-build/#using-openocd","text":"For accessing your ARM Cortex-M based device, we use OpenOCD by default and generate a modm/openocd.cfg file with the target specific configuration: Search directories passed via the openocd.search metadata key. User configuration files passed via the openocd.configfile metadata key. Your custom modm:build:openocd.cfg is added here too. Two programming commands: program_release for uploading the release profile. program_debug for uploading your debug profile. You can now upload your program in a one-line command: openocd -f modm/openocd.cfg -c \"program_release\" openocd -f modm/openocd.cfg -c \"program_debug\" Open On-Chip Debugger 0.10.0 adapter speed: 2000 kHz adapter_nsrst_delay: 100 none separate srst_only separate srst_nogate srst_open_drain connect_deassert_srst program_debug Info : clock speed 1800 kHz Info : STLINK v2 JTAG v28 API v2 SWIM v18 VID 0x0483 PID 0x374B Info : using stlink api v2 Info : Target voltage: 3.260972 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints adapter speed: 1800 kHz ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes wrote 16384 bytes from file path/to/project.elf in 0.589551s (27.139 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.328969s (38.781 KiB/s) ** Verified OK ** adapter speed: 1800 kHz target halted due to debug-request, current mode: Thread xPSR: 0x01000000 pc: 0x0800263c msp: 0x10000be0 shutdown command invoked","title":"Using OpenOCD"},{"location":"reference/module/modm-build/#using-gdb","text":"For debugging your program on ARM Cortex-M device, we provide the modm/gdbinit file for the arm-none-eabi-gdb debugger connected to your target via OpenOCD. Four commands are provided for convenience: file_debug loads the debug profile ELF file. file_release loads the release profile ELF file. restart resets the device and halts. rerun resets the device and continues execution. GDB is configured in TUI mode and continues running the target after attaching, but does not load an ELF file! Please call file_{debug, release} first or pass the ELF file as a command line argument. You can start your debug session by launching OpenOCD and then GDB: # Run OpenOCD without any commands in the background openocd -f modm/openocd.cfg # Open another terminal arm-none-eabi-gdb -x modm/gdbinit # OR optionally with your custom ELF file arm-none-eabi-gdb -x modm/gdbinit path/to/project.elf \u250c\u2014\u2014main.cpp\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2510 >\u2502194 DRAW(x+1, y+3); \u2502 \u2502195 DRAW(x+2, y+3); \u2502 \u2502196 #else \u2502 \u2502197 DRAW(x , y ); \u2502 \u2502198 #endif \u2502 \u2502199 #undef DRAW \u2502 \u2502200 } \u2502 \u2502201 \u2502 \u2502202 static inline void drawScreen(framebuffer_t before, frame\u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 >\u25020x80017a0 <game_of_life()+1692> strh.w r3, [r4, r12, lsl #1] \u2502 \u25020x80017a4 <game_of_life()+1696> add r0, lr \u2502 \u25020x80017a6 <game_of_life()+1698> ldr r2, [r2, #0] \u2502 \u25020x80017a8 <game_of_life()+1700> strh.w r3, [r2, r0, lsl #1] \u2502 \u25020x80017ac <game_of_life()+1704> ldr r3, [sp, #12] \u2502 \u25020x80017ae <game_of_life()+1706> ldr r2, [sp, #0] \u2502 \u25020x80017b0 <game_of_life()+1708> add r2, r3 \u2502 \u25020x80017b2 <game_of_life()+1710> ldrb r3, [r7, r1] \u2502 \u25020x80017b4 <game_of_life()+1712> strb r3, [r2, r1] \u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 extended-r Remote target In: game_of_life L194 PC: 0x80017a0 Program received signal SIGINT, Interrupt. 0x080017a0 in drawPixel (color=<optimized out>, y=42, x=578) at main.c (gdb) Be careful attaching to a running target Due to the OpenOCD implementation, the target is halted for a very short period of time, while the device's debug peripheral is initialized. This time is dependent on the debug adapter and may range from just a few milliseconds to hundreds. Make sure your hardware can handle that!","title":"Using GDB"},{"location":"reference/module/modm-build/#using-black-magic-probe","text":"Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. Currently, only uploading code to the target is supported with this modm module. Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes. $ ls -l /dev/tty.usb* crw-rw-rw- 1 root wheel 21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF crw-rw-rw- 1 root wheel 21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1 You can upload your code using a Black Magic Probe with specifying the GDB interface as port parameter. $ scons bmp port=/dev/cu.usbmodemDEADBEEF verbose=1 scons: Reading SConscript files ... bmp port iss = /dev/cu.usbmodemDEADBEEF scons: done reading SConscript files. scons: Building targets ... arm-none-eabi-gdb -ex \"target extended-remote /dev/cu.usbmodemDEADBEEF\" -ex \"monitor swdp_scan\" -ex \"attach 1\" -ex \"load path/to/project.elf\" -ex \"detach\" -ex \"quit\" [...] Remote debugging using /dev/cu.usbmodemDEADBEEF Target voltage: unknown Available Targets: No. Att Driver 1 STM32F1 medium density Attaching to Remote target warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0800038e in ?? () Loading section .vector_rom, size 0xec lma 0x8000000 [...] Loading section .table.section_heap, size 0xc lma 0x80013f8 Start address 0x8000e6c, load size 5120 Transfer rate: 10 KB/sec, 365 bytes/write. Detaching from program: , Remote target [Inferior 1 (Remote target) detached] scons: done building targets.","title":"Using Black Magic Probe"},{"location":"reference/module/modm-build/#using-avrdude","text":"Unfortunately AvrDude does not support a user configuration file like OpenOCD does, so there is no convenient one-line command to issue. You have to use the support of the specific build system.","title":"Using AvrDude"},{"location":"reference/module/modm-build/#compiler-options","text":"We maintain a common set of compiler options for all build system generator, so that they all have feature parity. We currently only support compiling modm with GCC for AVR, ARM Cortex-M and x86/posix with the options mentioned in the offical GCC options documentation . You can find all compiler options inside the generated build script for your project, the options presented here are only the most important ones.","title":"Compiler Options"},{"location":"reference/module/modm-build/#shared-for-c-and-c","text":"-W{all, extra} : a basic set of warnings. -Werror={format, maybe-uninitialized, overflow, sign-compare} : these warnings are treated as errors. -f{data, function}-sections : puts data and functions into their own linker section. -funsigned-{char, bitfields} : modm tries to use stdint.h types everywhere, but just in case. For release builds : -Os : optimize for smaller size. For debug builds : -Og : optimize for debugging experience.","title":"Shared for C and C++"},{"location":"reference/module/modm-build/#only-c","text":"-std=gnu11 : use C11 with GNU extensions (for asm volatile ). -Wnested-externs : shouldn't use extern inside a function body.","title":"Only C"},{"location":"reference/module/modm-build/#only-c_1","text":"-std=c++17 : use C++17 -fno-exceptions : no exceptions. -fno-rtti : no run-time type information.","title":"Only C++"},{"location":"reference/module/modm-build/#linker","text":"--gc-section : garbage collecting sections throws out a lot of unused data/code. -L{linkdir} -Tlinkerscript.ld : modm uses a custom linkerscript.","title":"Linker"},{"location":"reference/module/modm-build/#only-avr","text":"-mmcu={target} : the target to compile for.","title":"Only AVR"},{"location":"reference/module/modm-build/#only-arm-cortex-m","text":"-mcpu=cortex-m{type} : the target to compile for. -mthumb : only Thumb2 instruction set is supported. -mfloat-abi=hard : if FPU available use the fastest ABI available. -mfpu=fpv{4, 5}-{sp}-d16 : single or double precision FPU. -fsingle-precision-constant : if SP-FPU, treat all FP constants as SP. -Wdouble-promotion : if SP-FPU, warn if FPs are promoted to doubles. In addition, these linker options are added: -nostartfiles : modm implements its own startup script. --specs=nano.specs : use Newlib Nano. --specs=nosys.specs : modm does not use C stdlib features. -wrap,_{calloc, malloc, realloc, free}_r : reimplemented Newlib with our own allocator.","title":"Only ARM Cortex-M"},{"location":"reference/module/modm-build/#options","text":"","title":"Options"},{"location":"reference/module/modm-build/#projectname","text":"Project Name: blink \u2208 { String } The project name defaults to the folder name you're calling lbuild from. It's used by your build system to name the executable and it may also be passed to your application via a string constant or CPP define.","title":"project.name"},{"location":"reference/module/modm-build/#buildpath","text":"Build Path: build/blink \u2208 { Path: build/blink } The build path is defaulted to build/{modm:build:project.name} . If you have a lot of embedded projects, you may want to change the build path to a common directory so that you don't have build/ folders everywhere. Remember to add your build path to your .gitignore . You should use a relative path instead of an absolute one, so that this option still works for other developers.","title":"build.path"},{"location":"reference/module/modm-build/#openocdcfg","text":"Path to a custom OpenOCD configuration file: { Path } If you have a custom configuration file for your target, it will get included by the generated modm/openocd.cfg . This is useful for not having to duplicate your config if you have several projects using the same target (like small bring-up and test projects). Do not execute commands by default When providing your own config file, wrap your specific commands into functions and do not execute them by default. A stray init or similar in your script will mess with modm's ability to program and debug a device correctly.","title":"openocd.cfg"},{"location":"reference/module/modm-build/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-build/#archflags","text":"\u2208 String","title":"archflags"},{"location":"reference/module/modm-build/#archflagsdebug","text":"\u2208 String","title":"archflags.debug"},{"location":"reference/module/modm-build/#archflagsrelease","text":"\u2208 String","title":"archflags.release"},{"location":"reference/module/modm-build/#asflags","text":"\u2208 String","title":"asflags"},{"location":"reference/module/modm-build/#asflagsdebug","text":"\u2208 String","title":"asflags.debug"},{"location":"reference/module/modm-build/#asflagsrelease","text":"\u2208 String","title":"asflags.release"},{"location":"reference/module/modm-build/#ccflags","text":"\u2208 String","title":"ccflags"},{"location":"reference/module/modm-build/#ccflagsdebug","text":"\u2208 String","title":"ccflags.debug"},{"location":"reference/module/modm-build/#ccflagsrelease","text":"\u2208 String","title":"ccflags.release"},{"location":"reference/module/modm-build/#cflags","text":"\u2208 String","title":"cflags"},{"location":"reference/module/modm-build/#cflagsdebug","text":"\u2208 String","title":"cflags.debug"},{"location":"reference/module/modm-build/#cflagsrelease","text":"\u2208 String","title":"cflags.release"},{"location":"reference/module/modm-build/#cppdefines","text":"\u2208 String","title":"cppdefines"},{"location":"reference/module/modm-build/#cppdefinesdebug","text":"\u2208 String","title":"cppdefines.debug"},{"location":"reference/module/modm-build/#cppdefinesrelease","text":"\u2208 String","title":"cppdefines.release"},{"location":"reference/module/modm-build/#cxxflags","text":"\u2208 String","title":"cxxflags"},{"location":"reference/module/modm-build/#cxxflagsdebug","text":"\u2208 String","title":"cxxflags.debug"},{"location":"reference/module/modm-build/#cxxflagsrelease","text":"\u2208 String","title":"cxxflags.release"},{"location":"reference/module/modm-build/#elfdebug","text":"Path to the compiled .elf file for the debug profile \u2208 Path","title":"elf.debug"},{"location":"reference/module/modm-build/#elfrelease","text":"Path to the compiled .elf file for the release profile \u2208 Path","title":"elf.release"},{"location":"reference/module/modm-build/#gitignore","text":"Generated files that need to be ignored by Git \u2208 Path","title":"gitignore"},{"location":"reference/module/modm-build/#library","text":"Libraries to link against \u2208 String","title":"library"},{"location":"reference/module/modm-build/#linkflags","text":"\u2208 String","title":"linkflags"},{"location":"reference/module/modm-build/#linkflagsdebug","text":"\u2208 String","title":"linkflags.debug"},{"location":"reference/module/modm-build/#linkflagsrelease","text":"\u2208 String","title":"linkflags.release"},{"location":"reference/module/modm-build/#openocdsource","text":"Additional OpenOCD source files. \u2208 Path","title":"openocd.source"},{"location":"reference/module/modm-build/#pathinclude","text":"Search path for header files \u2208 Path","title":"path.include"},{"location":"reference/module/modm-build/#pathlibrary","text":"Search path for static libraries \u2208 Path","title":"path.library"},{"location":"reference/module/modm-build/#pathopenocd","text":"Search path for OpenOCD configuration files \u2208 Path","title":"path.openocd"},{"location":"reference/module/modm-build/#pkg-config","text":"Packages to configure against \u2208 String","title":"pkg-config"},{"location":"reference/module/modm-build/#queries","text":"","title":"Queries"},{"location":"reference/module/modm-build/#collect_flags","text":"Scans the collections for module compile flags. Converts them into SCons-compatible names and places them into a dictionary of the form: flags[filename][name][profile] = list(values). :param env: the post_build step env :param scope_filter: the collection scope filter :returns: compile flags dictionary","title":"collect_flags"},{"location":"reference/module/modm-build/#device","text":"Extracts common properties from a modm:target device: - platform - family - partname - core - mcu (AVR only) :returns: a dictionary of common properties.","title":"device"},{"location":"reference/module/modm-build/#memories","text":"Extracts the memory map of the device. A memory region is a dictionary containing: - name of region - start address of region - size of region - access of region :returns: a list of memory regions.","title":"memories"},{"location":"reference/module/modm-build/#source_files","text":"Builds a list of files that need to be compiled per repository. :param buildlog: the buildlog object available in the post_build step :returns: a dictionary of sorted lists of filenames, keyed by repository.","title":"source_files"},{"location":"reference/module/modm-build/#dependencies","text":"modm:build modm_build modm: build modm_build_cmake modm: build: cmake modm_build_cmake->modm_build modm_build_scons modm: build: scons modm_build_scons->modm_build","title":"Dependencies"},{"location":"reference/module/modm-cmsis-core/","text":"These module docs are in beta and may be incomplete. modm:cmsis:core: ARM CMSIS-CORE \u00b6 This module provides these files for accessing the ARM Cortex-M CPU and peripherals: cmsis_gcc.h : Contains the GCC-specific API. core_cm{core}.h : Contains the core-specific API. Please see the API documentation for their content and how to use them. Dependencies \u00b6 modm:cmsis:core modm_cmsis_core modm: cmsis: core modm_cmsis modm: cmsis modm_cmsis_core->modm_cmsis modm_cmsis_device modm: cmsis: device modm_cmsis_device->modm_cmsis_core","title":"modm:cmsis:core"},{"location":"reference/module/modm-cmsis-core/#modmcmsiscore-arm-cmsis-core","text":"This module provides these files for accessing the ARM Cortex-M CPU and peripherals: cmsis_gcc.h : Contains the GCC-specific API. core_cm{core}.h : Contains the core-specific API. Please see the API documentation for their content and how to use them.","title":"modm:cmsis:core: ARM CMSIS-CORE"},{"location":"reference/module/modm-cmsis-core/#dependencies","text":"modm:cmsis:core modm_cmsis_core modm: cmsis: core modm_cmsis modm: cmsis modm_cmsis_core->modm_cmsis modm_cmsis_device modm: cmsis: device modm_cmsis_device->modm_cmsis_core","title":"Dependencies"},{"location":"reference/module/modm-cmsis-device/","text":"These module docs are in beta and may be incomplete. modm:cmsis:device: STM32 CMSIS Headers \u00b6 This module wraps the CMSIS headers for STM32 devices and provides the header file and CPP definitions for accessing the modm:target peripherals. Specifically, it copies the target header file which provides the CMSIS implementation of the target's language interface for its memory-mapped peripherals. Discrepancies between documentation and headers These CMSIS headers should reflect what's written in the documentation, however, in our experience there may be small differences in naming, behavior and availability between it and this implementation. Since ST is not interested in addressing these issues, please contribute to our patch list . The generated header file modm/platform/device.hpp contains the necessary target define STM32{FAMILY}{NAME}xx or similar and includes the modm:target -specific header. Include only modm/platform/device.hpp ! This file is only included by interface implementations inside the modm/platform folder! If you need to implement your own drivers, include only this file. CMSIS Compliance \u00b6 modm implements the target specific CMSIS functionality itself, without using the CMSIS interface. This is necessary to provide similar functionality on non-Cortex-M based targets. Specifically, these functions are not implemented: uint32_t SystemCoreClock and void SystemCoreClockUpdate() : please use modm::clock::f_cpu as defined in the modm:architecture:clock module. void SystemInit() : modm defines its own startup architecture, see the modm:platform:core module for details. Debugging Peripherals \u00b6 When debugging with GDB, it can sometimes be difficult to access peripherals, due to the CMSIS implementation with CPP defines and GCC optimization flags. Depending on these circumstances, GDB may only \"see\" a peripheral in a certain context, which can make the debugging experience quite frustrating. To aid this, we generate a linkerscript fragment and source file, which place the peripherals memory as real objects in the peripheral memory space. You can then access these peripherals inside GDB at any time, regardless of context and build profile setting: (gdb) p/x *GPIOB $1 = { MODER = 0xaa0280, OTYPER = 0x300, OSPEEDR = 0x2a00c0, PUPDR = 0x400100, IDR = 0xfd0, ODR = 0x100, BSRR = 0x0, LCKR = 0x0, AFR = {0x0, 0x7744} } This does not have any effect on your firmware! It is purely a debug helper feature and none of these definitions make it into the executable. Beware read/write side-effects When debugging be aware of the side-effects that your read or write to a peripheral memory location can have. It's fairly obvious that a write may have consequences, but also reads can modify peripheral state, for example, a hardware FIFO buffer may pop the queue if your read the top of it. Content \u00b6 // Variable ADC_Common_TypeDef ___ADC123_COMMON ; ADC_TypeDef ___ADC1 ; ADC_TypeDef ___ADC2 ; ADC_TypeDef ___ADC3 ; CAN_TypeDef ___CAN1 ; CAN_TypeDef ___CAN2 ; CRC_TypeDef ___CRC ; CoreDebug_Type ___CoreDebug ; DAC_TypeDef ___DAC ; DAC_TypeDef ___DAC1 ; DBGMCU_TypeDef ___DBGMCU ; DCMI_TypeDef ___DCMI ; DMA2D_TypeDef ___DMA2D ; DMA_Stream_TypeDef ___DMA1_Stream0 ; DMA_Stream_TypeDef ___DMA1_Stream1 ; DMA_Stream_TypeDef ___DMA1_Stream2 ; DMA_Stream_TypeDef ___DMA1_Stream3 ; DMA_Stream_TypeDef ___DMA1_Stream4 ; DMA_Stream_TypeDef ___DMA1_Stream5 ; DMA_Stream_TypeDef ___DMA1_Stream6 ; DMA_Stream_TypeDef ___DMA1_Stream7 ; DMA_Stream_TypeDef ___DMA2_Stream0 ; DMA_Stream_TypeDef ___DMA2_Stream1 ; DMA_Stream_TypeDef ___DMA2_Stream2 ; DMA_Stream_TypeDef ___DMA2_Stream3 ; DMA_Stream_TypeDef ___DMA2_Stream4 ; DMA_Stream_TypeDef ___DMA2_Stream5 ; DMA_Stream_TypeDef ___DMA2_Stream6 ; DMA_Stream_TypeDef ___DMA2_Stream7 ; DMA_TypeDef ___DMA1 ; DMA_TypeDef ___DMA2 ; DSI_TypeDef ___DSI ; DWT_Type ___DWT ; ETH_TypeDef ___ETH ; EXTI_TypeDef ___EXTI ; FLASH_TypeDef ___FLASH ; FMC_Bank1E_TypeDef ___FMC_Bank1E ; FMC_Bank1_TypeDef ___FMC_Bank1 ; FMC_Bank3_TypeDef ___FMC_Bank3 ; FMC_Bank5_6_TypeDef ___FMC_Bank5_6 ; FPU_Type ___FPU ; GPIO_TypeDef ___GPIOA ; GPIO_TypeDef ___GPIOB ; GPIO_TypeDef ___GPIOC ; GPIO_TypeDef ___GPIOD ; GPIO_TypeDef ___GPIOE ; GPIO_TypeDef ___GPIOF ; GPIO_TypeDef ___GPIOG ; GPIO_TypeDef ___GPIOH ; GPIO_TypeDef ___GPIOI ; GPIO_TypeDef ___GPIOJ ; GPIO_TypeDef ___GPIOK ; I2C_TypeDef ___I2C1 ; I2C_TypeDef ___I2C2 ; I2C_TypeDef ___I2C3 ; ITM_Type ___ITM ; IWDG_TypeDef ___IWDG ; LTDC_Layer_TypeDef ___LTDC_Layer1 ; LTDC_Layer_TypeDef ___LTDC_Layer2 ; LTDC_TypeDef ___LTDC ; MPU_Type ___MPU ; NVIC_Type ___NVIC ; PWR_TypeDef ___PWR ; QUADSPI_TypeDef ___QUADSPI ; RCC_TypeDef ___RCC ; RNG_TypeDef ___RNG ; RTC_TypeDef ___RTC ; SAI_Block_TypeDef ___SAI1_Block_A ; SAI_Block_TypeDef ___SAI1_Block_B ; SAI_TypeDef ___SAI1 ; SCB_Type ___SCB ; SCnSCB_Type ___SCnSCB ; SDIO_TypeDef ___SDIO ; SPI_TypeDef ___I2S2ext ; SPI_TypeDef ___I2S3ext ; SPI_TypeDef ___SPI1 ; SPI_TypeDef ___SPI2 ; SPI_TypeDef ___SPI3 ; SPI_TypeDef ___SPI4 ; SPI_TypeDef ___SPI5 ; SPI_TypeDef ___SPI6 ; SYSCFG_TypeDef ___SYSCFG ; SysTick_Type ___SysTick ; TIM_TypeDef ___TIM1 ; TIM_TypeDef ___TIM10 ; TIM_TypeDef ___TIM11 ; TIM_TypeDef ___TIM12 ; TIM_TypeDef ___TIM13 ; TIM_TypeDef ___TIM14 ; TIM_TypeDef ___TIM2 ; TIM_TypeDef ___TIM3 ; TIM_TypeDef ___TIM4 ; TIM_TypeDef ___TIM5 ; TIM_TypeDef ___TIM6 ; TIM_TypeDef ___TIM7 ; TIM_TypeDef ___TIM8 ; TIM_TypeDef ___TIM9 ; TPI_Type ___TPI ; USART_TypeDef ___UART4 ; USART_TypeDef ___UART5 ; USART_TypeDef ___UART7 ; USART_TypeDef ___UART8 ; USART_TypeDef ___USART1 ; USART_TypeDef ___USART2 ; USART_TypeDef ___USART3 ; USART_TypeDef ___USART6 ; WWDG_TypeDef ___WWDG ; // Define #define STM32F469xx Queries \u00b6 rcc-map \u00b6 None Dependencies \u00b6 modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis modm: cmsis modm_cmsis_device->modm_cmsis modm_cmsis_core modm: cmsis: core modm_cmsis_device->modm_cmsis_core modm_freertos modm: freertos modm_freertos->modm_cmsis_device modm_platform_adc modm: platform: adc modm_platform_adc->modm_cmsis_device modm_platform_can modm: platform: can modm_platform_can->modm_cmsis_device modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_cmsis_device modm_platform_dma modm: platform: dma modm_platform_dma->modm_cmsis_device modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_cmsis_device modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_cmsis_device modm_platform_random modm: platform: random modm_platform_random->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_cmsis_device modm_platform_spi modm: platform: spi modm_platform_spi->modm_cmsis_device modm_platform_systick modm: platform: systick modm_platform_systick->modm_cmsis_device modm_platform_timer modm: platform: timer modm_platform_timer->modm_cmsis_device modm_platform_uart modm: platform: uart modm_platform_uart->modm_cmsis_device modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_cmsis_device","title":"modm:cmsis:device"},{"location":"reference/module/modm-cmsis-device/#modmcmsisdevice-stm32-cmsis-headers","text":"This module wraps the CMSIS headers for STM32 devices and provides the header file and CPP definitions for accessing the modm:target peripherals. Specifically, it copies the target header file which provides the CMSIS implementation of the target's language interface for its memory-mapped peripherals. Discrepancies between documentation and headers These CMSIS headers should reflect what's written in the documentation, however, in our experience there may be small differences in naming, behavior and availability between it and this implementation. Since ST is not interested in addressing these issues, please contribute to our patch list . The generated header file modm/platform/device.hpp contains the necessary target define STM32{FAMILY}{NAME}xx or similar and includes the modm:target -specific header. Include only modm/platform/device.hpp ! This file is only included by interface implementations inside the modm/platform folder! If you need to implement your own drivers, include only this file.","title":"modm:cmsis:device: STM32 CMSIS Headers"},{"location":"reference/module/modm-cmsis-device/#cmsis-compliance","text":"modm implements the target specific CMSIS functionality itself, without using the CMSIS interface. This is necessary to provide similar functionality on non-Cortex-M based targets. Specifically, these functions are not implemented: uint32_t SystemCoreClock and void SystemCoreClockUpdate() : please use modm::clock::f_cpu as defined in the modm:architecture:clock module. void SystemInit() : modm defines its own startup architecture, see the modm:platform:core module for details.","title":"CMSIS Compliance"},{"location":"reference/module/modm-cmsis-device/#debugging-peripherals","text":"When debugging with GDB, it can sometimes be difficult to access peripherals, due to the CMSIS implementation with CPP defines and GCC optimization flags. Depending on these circumstances, GDB may only \"see\" a peripheral in a certain context, which can make the debugging experience quite frustrating. To aid this, we generate a linkerscript fragment and source file, which place the peripherals memory as real objects in the peripheral memory space. You can then access these peripherals inside GDB at any time, regardless of context and build profile setting: (gdb) p/x *GPIOB $1 = { MODER = 0xaa0280, OTYPER = 0x300, OSPEEDR = 0x2a00c0, PUPDR = 0x400100, IDR = 0xfd0, ODR = 0x100, BSRR = 0x0, LCKR = 0x0, AFR = {0x0, 0x7744} } This does not have any effect on your firmware! It is purely a debug helper feature and none of these definitions make it into the executable. Beware read/write side-effects When debugging be aware of the side-effects that your read or write to a peripheral memory location can have. It's fairly obvious that a write may have consequences, but also reads can modify peripheral state, for example, a hardware FIFO buffer may pop the queue if your read the top of it.","title":"Debugging Peripherals"},{"location":"reference/module/modm-cmsis-device/#content","text":"// Variable ADC_Common_TypeDef ___ADC123_COMMON ; ADC_TypeDef ___ADC1 ; ADC_TypeDef ___ADC2 ; ADC_TypeDef ___ADC3 ; CAN_TypeDef ___CAN1 ; CAN_TypeDef ___CAN2 ; CRC_TypeDef ___CRC ; CoreDebug_Type ___CoreDebug ; DAC_TypeDef ___DAC ; DAC_TypeDef ___DAC1 ; DBGMCU_TypeDef ___DBGMCU ; DCMI_TypeDef ___DCMI ; DMA2D_TypeDef ___DMA2D ; DMA_Stream_TypeDef ___DMA1_Stream0 ; DMA_Stream_TypeDef ___DMA1_Stream1 ; DMA_Stream_TypeDef ___DMA1_Stream2 ; DMA_Stream_TypeDef ___DMA1_Stream3 ; DMA_Stream_TypeDef ___DMA1_Stream4 ; DMA_Stream_TypeDef ___DMA1_Stream5 ; DMA_Stream_TypeDef ___DMA1_Stream6 ; DMA_Stream_TypeDef ___DMA1_Stream7 ; DMA_Stream_TypeDef ___DMA2_Stream0 ; DMA_Stream_TypeDef ___DMA2_Stream1 ; DMA_Stream_TypeDef ___DMA2_Stream2 ; DMA_Stream_TypeDef ___DMA2_Stream3 ; DMA_Stream_TypeDef ___DMA2_Stream4 ; DMA_Stream_TypeDef ___DMA2_Stream5 ; DMA_Stream_TypeDef ___DMA2_Stream6 ; DMA_Stream_TypeDef ___DMA2_Stream7 ; DMA_TypeDef ___DMA1 ; DMA_TypeDef ___DMA2 ; DSI_TypeDef ___DSI ; DWT_Type ___DWT ; ETH_TypeDef ___ETH ; EXTI_TypeDef ___EXTI ; FLASH_TypeDef ___FLASH ; FMC_Bank1E_TypeDef ___FMC_Bank1E ; FMC_Bank1_TypeDef ___FMC_Bank1 ; FMC_Bank3_TypeDef ___FMC_Bank3 ; FMC_Bank5_6_TypeDef ___FMC_Bank5_6 ; FPU_Type ___FPU ; GPIO_TypeDef ___GPIOA ; GPIO_TypeDef ___GPIOB ; GPIO_TypeDef ___GPIOC ; GPIO_TypeDef ___GPIOD ; GPIO_TypeDef ___GPIOE ; GPIO_TypeDef ___GPIOF ; GPIO_TypeDef ___GPIOG ; GPIO_TypeDef ___GPIOH ; GPIO_TypeDef ___GPIOI ; GPIO_TypeDef ___GPIOJ ; GPIO_TypeDef ___GPIOK ; I2C_TypeDef ___I2C1 ; I2C_TypeDef ___I2C2 ; I2C_TypeDef ___I2C3 ; ITM_Type ___ITM ; IWDG_TypeDef ___IWDG ; LTDC_Layer_TypeDef ___LTDC_Layer1 ; LTDC_Layer_TypeDef ___LTDC_Layer2 ; LTDC_TypeDef ___LTDC ; MPU_Type ___MPU ; NVIC_Type ___NVIC ; PWR_TypeDef ___PWR ; QUADSPI_TypeDef ___QUADSPI ; RCC_TypeDef ___RCC ; RNG_TypeDef ___RNG ; RTC_TypeDef ___RTC ; SAI_Block_TypeDef ___SAI1_Block_A ; SAI_Block_TypeDef ___SAI1_Block_B ; SAI_TypeDef ___SAI1 ; SCB_Type ___SCB ; SCnSCB_Type ___SCnSCB ; SDIO_TypeDef ___SDIO ; SPI_TypeDef ___I2S2ext ; SPI_TypeDef ___I2S3ext ; SPI_TypeDef ___SPI1 ; SPI_TypeDef ___SPI2 ; SPI_TypeDef ___SPI3 ; SPI_TypeDef ___SPI4 ; SPI_TypeDef ___SPI5 ; SPI_TypeDef ___SPI6 ; SYSCFG_TypeDef ___SYSCFG ; SysTick_Type ___SysTick ; TIM_TypeDef ___TIM1 ; TIM_TypeDef ___TIM10 ; TIM_TypeDef ___TIM11 ; TIM_TypeDef ___TIM12 ; TIM_TypeDef ___TIM13 ; TIM_TypeDef ___TIM14 ; TIM_TypeDef ___TIM2 ; TIM_TypeDef ___TIM3 ; TIM_TypeDef ___TIM4 ; TIM_TypeDef ___TIM5 ; TIM_TypeDef ___TIM6 ; TIM_TypeDef ___TIM7 ; TIM_TypeDef ___TIM8 ; TIM_TypeDef ___TIM9 ; TPI_Type ___TPI ; USART_TypeDef ___UART4 ; USART_TypeDef ___UART5 ; USART_TypeDef ___UART7 ; USART_TypeDef ___UART8 ; USART_TypeDef ___USART1 ; USART_TypeDef ___USART2 ; USART_TypeDef ___USART3 ; USART_TypeDef ___USART6 ; WWDG_TypeDef ___WWDG ; // Define #define STM32F469xx","title":"Content"},{"location":"reference/module/modm-cmsis-device/#queries","text":"","title":"Queries"},{"location":"reference/module/modm-cmsis-device/#rcc-map","text":"None","title":"rcc-map"},{"location":"reference/module/modm-cmsis-device/#dependencies","text":"modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis modm: cmsis modm_cmsis_device->modm_cmsis modm_cmsis_core modm: cmsis: core modm_cmsis_device->modm_cmsis_core modm_freertos modm: freertos modm_freertos->modm_cmsis_device modm_platform_adc modm: platform: adc modm_platform_adc->modm_cmsis_device modm_platform_can modm: platform: can modm_platform_can->modm_cmsis_device modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_cmsis_device modm_platform_dma modm: platform: dma modm_platform_dma->modm_cmsis_device modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_cmsis_device modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_cmsis_device modm_platform_random modm: platform: random modm_platform_random->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_cmsis_device modm_platform_spi modm: platform: spi modm_platform_spi->modm_cmsis_device modm_platform_systick modm: platform: systick modm_platform_systick->modm_cmsis_device modm_platform_timer modm: platform: timer modm_platform_timer->modm_cmsis_device modm_platform_uart modm: platform: uart modm_platform_uart->modm_cmsis_device modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_cmsis_device","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp/","text":"These module docs are in beta and may be incomplete. modm:cmsis:dsp: ARM CMSIS-DSP \u00b6 This module provides the CMSIS-DSP library. Please see the API documentation for details. Options \u00b6 unaligned_data \u00b6 Allow unaligned data storage: False \u2208 { True, False } If the core supports it, this options enables storing data in unaligned memory. This may reduce data size, but cost some speed. check_matrix_sizes \u00b6 Check input/output matrix size: False \u2208 { True, False } Check the input and output sizes of matrices and return ARM_MATH_SIZE_MISMATCH on failure. round_float_inputs \u00b6 Round float inputs: True \u2208 { True, False } Rounds float inputs properly during all conversions. Dependencies \u00b6 modm:cmsis:dsp modm_cmsis_dsp modm: cmsis: dsp modm_cmsis modm: cmsis modm_cmsis_dsp->modm_cmsis","title":"modm:cmsis:dsp"},{"location":"reference/module/modm-cmsis-dsp/#modmcmsisdsp-arm-cmsis-dsp","text":"This module provides the CMSIS-DSP library. Please see the API documentation for details.","title":"modm:cmsis:dsp: ARM CMSIS-DSP"},{"location":"reference/module/modm-cmsis-dsp/#options","text":"","title":"Options"},{"location":"reference/module/modm-cmsis-dsp/#unaligned_data","text":"Allow unaligned data storage: False \u2208 { True, False } If the core supports it, this options enables storing data in unaligned memory. This may reduce data size, but cost some speed.","title":"unaligned_data"},{"location":"reference/module/modm-cmsis-dsp/#check_matrix_sizes","text":"Check input/output matrix size: False \u2208 { True, False } Check the input and output sizes of matrices and return ARM_MATH_SIZE_MISMATCH on failure.","title":"check_matrix_sizes"},{"location":"reference/module/modm-cmsis-dsp/#round_float_inputs","text":"Round float inputs: True \u2208 { True, False } Rounds float inputs properly during all conversions.","title":"round_float_inputs"},{"location":"reference/module/modm-cmsis-dsp/#dependencies","text":"modm:cmsis:dsp modm_cmsis_dsp modm: cmsis: dsp modm_cmsis modm: cmsis modm_cmsis_dsp->modm_cmsis","title":"Dependencies"},{"location":"reference/module/modm-cmsis/","text":"These module docs are in beta and may be incomplete. modm:cmsis: ARM CMSIS Support \u00b6 The Cortex Microcontroller Software Interface Standard is a software standard by ARM that defines a number of foundational interfaces for Cortex-M microcontrollers. We use only use these parts of CMSIS: The modm:cmsis:core module provides access to the ARM Cortex-M peripherals via CMSIS-CORE. The modm:cmsis:device module provides access to the peripherals of the modm:target devices via the vendor's CMSIS implementation. The modm:cmsis:dsp module provides a basic digital signal processing library via CMSIS-DSP. Content \u00b6 // Variable ADC_Common_TypeDef ___ADC123_COMMON ; ADC_TypeDef ___ADC1 ; ADC_TypeDef ___ADC2 ; ADC_TypeDef ___ADC3 ; CAN_TypeDef ___CAN1 ; CAN_TypeDef ___CAN2 ; CRC_TypeDef ___CRC ; CoreDebug_Type ___CoreDebug ; DAC_TypeDef ___DAC ; DAC_TypeDef ___DAC1 ; DBGMCU_TypeDef ___DBGMCU ; DCMI_TypeDef ___DCMI ; DMA2D_TypeDef ___DMA2D ; DMA_Stream_TypeDef ___DMA1_Stream0 ; DMA_Stream_TypeDef ___DMA1_Stream1 ; DMA_Stream_TypeDef ___DMA1_Stream2 ; DMA_Stream_TypeDef ___DMA1_Stream3 ; DMA_Stream_TypeDef ___DMA1_Stream4 ; DMA_Stream_TypeDef ___DMA1_Stream5 ; DMA_Stream_TypeDef ___DMA1_Stream6 ; DMA_Stream_TypeDef ___DMA1_Stream7 ; DMA_Stream_TypeDef ___DMA2_Stream0 ; DMA_Stream_TypeDef ___DMA2_Stream1 ; DMA_Stream_TypeDef ___DMA2_Stream2 ; DMA_Stream_TypeDef ___DMA2_Stream3 ; DMA_Stream_TypeDef ___DMA2_Stream4 ; DMA_Stream_TypeDef ___DMA2_Stream5 ; DMA_Stream_TypeDef ___DMA2_Stream6 ; DMA_Stream_TypeDef ___DMA2_Stream7 ; DMA_TypeDef ___DMA1 ; DMA_TypeDef ___DMA2 ; DSI_TypeDef ___DSI ; DWT_Type ___DWT ; ETH_TypeDef ___ETH ; EXTI_TypeDef ___EXTI ; FLASH_TypeDef ___FLASH ; FMC_Bank1E_TypeDef ___FMC_Bank1E ; FMC_Bank1_TypeDef ___FMC_Bank1 ; FMC_Bank3_TypeDef ___FMC_Bank3 ; FMC_Bank5_6_TypeDef ___FMC_Bank5_6 ; FPU_Type ___FPU ; GPIO_TypeDef ___GPIOA ; GPIO_TypeDef ___GPIOB ; GPIO_TypeDef ___GPIOC ; GPIO_TypeDef ___GPIOD ; GPIO_TypeDef ___GPIOE ; GPIO_TypeDef ___GPIOF ; GPIO_TypeDef ___GPIOG ; GPIO_TypeDef ___GPIOH ; GPIO_TypeDef ___GPIOI ; GPIO_TypeDef ___GPIOJ ; GPIO_TypeDef ___GPIOK ; I2C_TypeDef ___I2C1 ; I2C_TypeDef ___I2C2 ; I2C_TypeDef ___I2C3 ; ITM_Type ___ITM ; IWDG_TypeDef ___IWDG ; LTDC_Layer_TypeDef ___LTDC_Layer1 ; LTDC_Layer_TypeDef ___LTDC_Layer2 ; LTDC_TypeDef ___LTDC ; MPU_Type ___MPU ; NVIC_Type ___NVIC ; PWR_TypeDef ___PWR ; QUADSPI_TypeDef ___QUADSPI ; RCC_TypeDef ___RCC ; RNG_TypeDef ___RNG ; RTC_TypeDef ___RTC ; SAI_Block_TypeDef ___SAI1_Block_A ; SAI_Block_TypeDef ___SAI1_Block_B ; SAI_TypeDef ___SAI1 ; SCB_Type ___SCB ; SCnSCB_Type ___SCnSCB ; SDIO_TypeDef ___SDIO ; SPI_TypeDef ___I2S2ext ; SPI_TypeDef ___I2S3ext ; SPI_TypeDef ___SPI1 ; SPI_TypeDef ___SPI2 ; SPI_TypeDef ___SPI3 ; SPI_TypeDef ___SPI4 ; SPI_TypeDef ___SPI5 ; SPI_TypeDef ___SPI6 ; SYSCFG_TypeDef ___SYSCFG ; SysTick_Type ___SysTick ; TIM_TypeDef ___TIM1 ; TIM_TypeDef ___TIM10 ; TIM_TypeDef ___TIM11 ; TIM_TypeDef ___TIM12 ; TIM_TypeDef ___TIM13 ; TIM_TypeDef ___TIM14 ; TIM_TypeDef ___TIM2 ; TIM_TypeDef ___TIM3 ; TIM_TypeDef ___TIM4 ; TIM_TypeDef ___TIM5 ; TIM_TypeDef ___TIM6 ; TIM_TypeDef ___TIM7 ; TIM_TypeDef ___TIM8 ; TIM_TypeDef ___TIM9 ; TPI_Type ___TPI ; USART_TypeDef ___UART4 ; USART_TypeDef ___UART5 ; USART_TypeDef ___UART7 ; USART_TypeDef ___UART8 ; USART_TypeDef ___USART1 ; USART_TypeDef ___USART2 ; USART_TypeDef ___USART3 ; USART_TypeDef ___USART6 ; WWDG_TypeDef ___WWDG ; // Define #define STM32F469xx Dependencies \u00b6 modm:cmsis modm_cmsis modm: cmsis modm_cmsis_core modm: cmsis: core modm_cmsis_core->modm_cmsis modm_cmsis_device modm: cmsis: device modm_cmsis_device->modm_cmsis modm_cmsis_dsp modm: cmsis: dsp modm_cmsis_dsp->modm_cmsis","title":"modm:cmsis"},{"location":"reference/module/modm-cmsis/#modmcmsis-arm-cmsis-support","text":"The Cortex Microcontroller Software Interface Standard is a software standard by ARM that defines a number of foundational interfaces for Cortex-M microcontrollers. We use only use these parts of CMSIS: The modm:cmsis:core module provides access to the ARM Cortex-M peripherals via CMSIS-CORE. The modm:cmsis:device module provides access to the peripherals of the modm:target devices via the vendor's CMSIS implementation. The modm:cmsis:dsp module provides a basic digital signal processing library via CMSIS-DSP.","title":"modm:cmsis: ARM CMSIS Support"},{"location":"reference/module/modm-cmsis/#content","text":"// Variable ADC_Common_TypeDef ___ADC123_COMMON ; ADC_TypeDef ___ADC1 ; ADC_TypeDef ___ADC2 ; ADC_TypeDef ___ADC3 ; CAN_TypeDef ___CAN1 ; CAN_TypeDef ___CAN2 ; CRC_TypeDef ___CRC ; CoreDebug_Type ___CoreDebug ; DAC_TypeDef ___DAC ; DAC_TypeDef ___DAC1 ; DBGMCU_TypeDef ___DBGMCU ; DCMI_TypeDef ___DCMI ; DMA2D_TypeDef ___DMA2D ; DMA_Stream_TypeDef ___DMA1_Stream0 ; DMA_Stream_TypeDef ___DMA1_Stream1 ; DMA_Stream_TypeDef ___DMA1_Stream2 ; DMA_Stream_TypeDef ___DMA1_Stream3 ; DMA_Stream_TypeDef ___DMA1_Stream4 ; DMA_Stream_TypeDef ___DMA1_Stream5 ; DMA_Stream_TypeDef ___DMA1_Stream6 ; DMA_Stream_TypeDef ___DMA1_Stream7 ; DMA_Stream_TypeDef ___DMA2_Stream0 ; DMA_Stream_TypeDef ___DMA2_Stream1 ; DMA_Stream_TypeDef ___DMA2_Stream2 ; DMA_Stream_TypeDef ___DMA2_Stream3 ; DMA_Stream_TypeDef ___DMA2_Stream4 ; DMA_Stream_TypeDef ___DMA2_Stream5 ; DMA_Stream_TypeDef ___DMA2_Stream6 ; DMA_Stream_TypeDef ___DMA2_Stream7 ; DMA_TypeDef ___DMA1 ; DMA_TypeDef ___DMA2 ; DSI_TypeDef ___DSI ; DWT_Type ___DWT ; ETH_TypeDef ___ETH ; EXTI_TypeDef ___EXTI ; FLASH_TypeDef ___FLASH ; FMC_Bank1E_TypeDef ___FMC_Bank1E ; FMC_Bank1_TypeDef ___FMC_Bank1 ; FMC_Bank3_TypeDef ___FMC_Bank3 ; FMC_Bank5_6_TypeDef ___FMC_Bank5_6 ; FPU_Type ___FPU ; GPIO_TypeDef ___GPIOA ; GPIO_TypeDef ___GPIOB ; GPIO_TypeDef ___GPIOC ; GPIO_TypeDef ___GPIOD ; GPIO_TypeDef ___GPIOE ; GPIO_TypeDef ___GPIOF ; GPIO_TypeDef ___GPIOG ; GPIO_TypeDef ___GPIOH ; GPIO_TypeDef ___GPIOI ; GPIO_TypeDef ___GPIOJ ; GPIO_TypeDef ___GPIOK ; I2C_TypeDef ___I2C1 ; I2C_TypeDef ___I2C2 ; I2C_TypeDef ___I2C3 ; ITM_Type ___ITM ; IWDG_TypeDef ___IWDG ; LTDC_Layer_TypeDef ___LTDC_Layer1 ; LTDC_Layer_TypeDef ___LTDC_Layer2 ; LTDC_TypeDef ___LTDC ; MPU_Type ___MPU ; NVIC_Type ___NVIC ; PWR_TypeDef ___PWR ; QUADSPI_TypeDef ___QUADSPI ; RCC_TypeDef ___RCC ; RNG_TypeDef ___RNG ; RTC_TypeDef ___RTC ; SAI_Block_TypeDef ___SAI1_Block_A ; SAI_Block_TypeDef ___SAI1_Block_B ; SAI_TypeDef ___SAI1 ; SCB_Type ___SCB ; SCnSCB_Type ___SCnSCB ; SDIO_TypeDef ___SDIO ; SPI_TypeDef ___I2S2ext ; SPI_TypeDef ___I2S3ext ; SPI_TypeDef ___SPI1 ; SPI_TypeDef ___SPI2 ; SPI_TypeDef ___SPI3 ; SPI_TypeDef ___SPI4 ; SPI_TypeDef ___SPI5 ; SPI_TypeDef ___SPI6 ; SYSCFG_TypeDef ___SYSCFG ; SysTick_Type ___SysTick ; TIM_TypeDef ___TIM1 ; TIM_TypeDef ___TIM10 ; TIM_TypeDef ___TIM11 ; TIM_TypeDef ___TIM12 ; TIM_TypeDef ___TIM13 ; TIM_TypeDef ___TIM14 ; TIM_TypeDef ___TIM2 ; TIM_TypeDef ___TIM3 ; TIM_TypeDef ___TIM4 ; TIM_TypeDef ___TIM5 ; TIM_TypeDef ___TIM6 ; TIM_TypeDef ___TIM7 ; TIM_TypeDef ___TIM8 ; TIM_TypeDef ___TIM9 ; TPI_Type ___TPI ; USART_TypeDef ___UART4 ; USART_TypeDef ___UART5 ; USART_TypeDef ___UART7 ; USART_TypeDef ___UART8 ; USART_TypeDef ___USART1 ; USART_TypeDef ___USART2 ; USART_TypeDef ___USART3 ; USART_TypeDef ___USART6 ; WWDG_TypeDef ___WWDG ; // Define #define STM32F469xx","title":"Content"},{"location":"reference/module/modm-cmsis/#dependencies","text":"modm:cmsis modm_cmsis modm: cmsis modm_cmsis_core modm: cmsis: core modm_cmsis_core->modm_cmsis modm_cmsis_device modm: cmsis: device modm_cmsis_device->modm_cmsis modm_cmsis_dsp modm: cmsis: dsp modm_cmsis_dsp->modm_cmsis","title":"Dependencies"},{"location":"reference/module/modm-communication-ros/","text":"These module docs are in beta and may be incomplete. modm:communication:ros: Drivers for rosserial \u00b6 Content \u00b6 // Class class ModmHardware < class Uart > ; Dependencies \u00b6 modm:communication:ros modm_communication_ros modm: communication: ros modm_architecture_clock modm: architecture: clock modm_communication_ros->modm_architecture_clock modm_architecture_uart modm: architecture: uart modm_communication_ros->modm_architecture_uart modm_communication modm: communication modm_communication_ros->modm_communication modm_processing_timer modm: processing: timer modm_communication_ros->modm_processing_timer","title":"modm:communication:ros"},{"location":"reference/module/modm-communication-ros/#modmcommunicationros-drivers-for-rosserial","text":"","title":"modm:communication:ros: Drivers for rosserial"},{"location":"reference/module/modm-communication-ros/#content","text":"// Class class ModmHardware < class Uart > ;","title":"Content"},{"location":"reference/module/modm-communication-ros/#dependencies","text":"modm:communication:ros modm_communication_ros modm: communication: ros modm_architecture_clock modm: architecture: clock modm_communication_ros->modm_architecture_clock modm_architecture_uart modm: architecture: uart modm_communication_ros->modm_architecture_uart modm_communication modm: communication modm_communication_ros->modm_communication modm_processing_timer modm: processing: timer modm_communication_ros->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-communication-sab/","text":"These module docs are in beta and may be incomplete. modm:communication:sab: Sensor Actuator Bus (SAB) \u00b6 The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave. Protocol \u00b6 Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire) Structure \u00b6 +------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton) Header \u00b6 7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code. Electrical characteristics \u00b6 Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them). Content \u00b6 // Class class modm :: sab2 :: Interface < typename Device , std :: size_t N = maxPayloadLength > ; class modm :: sab :: Interface < typename Device > ; class modm :: sab :: Master < typename Interface > ; class modm :: sab :: Response ; class modm :: sab :: Slave < typename Interface > ; class modm :: sab :: Transmitter ; // Struct struct modm :: sab :: Action ; struct modm :: sab :: Callable ; // Function uint16_t modm :: sab2 :: crcUpdate ( uint16_t crc , uint8_t data ); uint8_t modm :: sab :: crcUpdate ( uint8_t crc , uint8_t data ); // Enum enum Error ; enum Error ; enum Flags ; // Variable const uint16_t modm :: sab2 :: crcInitialValue = 0xffff ; const uint8_t modm :: sab2 :: controlEscapeByte = 0x7d ; const uint8_t modm :: sab2 :: frameBounderyByte = 0x7e ; const uint8_t modm :: sab2 :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: crcInitialValue = 0x00 ; const uint8_t modm :: sab :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: syncByte = 0x54 ; // Define #define SAB_ACTION(command, object, function, length) Dependencies \u00b6 modm:communication:sab modm_communication_sab modm: communication: sab modm_architecture_accessor modm: architecture: accessor modm_communication_sab->modm_architecture_accessor modm_communication modm: communication modm_communication_sab->modm_communication modm_debug modm: debug modm_communication_sab->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab->modm_processing_timer modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_communication_sab","title":"modm:communication:sab"},{"location":"reference/module/modm-communication-sab/#modmcommunicationsab-sensor-actuator-bus-sab","text":"The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave.","title":"modm:communication:sab: Sensor Actuator Bus (SAB)"},{"location":"reference/module/modm-communication-sab/#protocol","text":"Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire)","title":"Protocol"},{"location":"reference/module/modm-communication-sab/#structure","text":"+------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton)","title":"Structure"},{"location":"reference/module/modm-communication-sab/#header","text":"7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code.","title":"Header"},{"location":"reference/module/modm-communication-sab/#electrical-characteristics","text":"Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them).","title":"Electrical characteristics"},{"location":"reference/module/modm-communication-sab/#content","text":"// Class class modm :: sab2 :: Interface < typename Device , std :: size_t N = maxPayloadLength > ; class modm :: sab :: Interface < typename Device > ; class modm :: sab :: Master < typename Interface > ; class modm :: sab :: Response ; class modm :: sab :: Slave < typename Interface > ; class modm :: sab :: Transmitter ; // Struct struct modm :: sab :: Action ; struct modm :: sab :: Callable ; // Function uint16_t modm :: sab2 :: crcUpdate ( uint16_t crc , uint8_t data ); uint8_t modm :: sab :: crcUpdate ( uint8_t crc , uint8_t data ); // Enum enum Error ; enum Error ; enum Flags ; // Variable const uint16_t modm :: sab2 :: crcInitialValue = 0xffff ; const uint8_t modm :: sab2 :: controlEscapeByte = 0x7d ; const uint8_t modm :: sab2 :: frameBounderyByte = 0x7e ; const uint8_t modm :: sab2 :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: crcInitialValue = 0x00 ; const uint8_t modm :: sab :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: syncByte = 0x54 ; // Define #define SAB_ACTION(command, object, function, length)","title":"Content"},{"location":"reference/module/modm-communication-sab/#dependencies","text":"modm:communication:sab modm_communication_sab modm: communication: sab modm_architecture_accessor modm: architecture: accessor modm_communication_sab->modm_architecture_accessor modm_communication modm: communication modm_communication_sab->modm_communication modm_debug modm: debug modm_communication_sab->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab->modm_processing_timer modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_communication_sab","title":"Dependencies"},{"location":"reference/module/modm-communication-sab2/","text":"These module docs are in beta and may be incomplete. modm:communication:sab2: Sensor Actuator Bus Version 2 (SAB2) \u00b6 The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave. Protocol \u00b6 Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire) Structure \u00b6 +------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton) Header \u00b6 7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code. Electrical characteristics \u00b6 Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them). Content \u00b6 // Class class modm :: sab2 :: Interface < typename Device , std :: size_t N = maxPayloadLength > ; // Function uint16_t modm :: sab2 :: crcUpdate ( uint16_t crc , uint8_t data ); // Enum enum Error ; // Variable const uint16_t modm :: sab2 :: crcInitialValue = 0xffff ; const uint8_t modm :: sab2 :: controlEscapeByte = 0x7d ; const uint8_t modm :: sab2 :: frameBounderyByte = 0x7e ; const uint8_t modm :: sab2 :: maxPayloadLength = 32 ; Dependencies \u00b6 modm:communication:sab2 modm_communication_sab2 modm: communication: sab2 modm_architecture_accessor modm: architecture: accessor modm_communication_sab2->modm_architecture_accessor modm_communication modm: communication modm_communication_sab2->modm_communication modm_communication_sab modm: communication: sab modm_communication_sab2->modm_communication_sab modm_debug modm: debug modm_communication_sab2->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab2->modm_processing_timer","title":"modm:communication:sab2"},{"location":"reference/module/modm-communication-sab2/#modmcommunicationsab2-sensor-actuator-bus-version-2-sab2","text":"The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave.","title":"modm:communication:sab2: Sensor Actuator Bus Version 2 (SAB2)"},{"location":"reference/module/modm-communication-sab2/#protocol","text":"Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire)","title":"Protocol"},{"location":"reference/module/modm-communication-sab2/#structure","text":"+------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton)","title":"Structure"},{"location":"reference/module/modm-communication-sab2/#header","text":"7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code.","title":"Header"},{"location":"reference/module/modm-communication-sab2/#electrical-characteristics","text":"Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them).","title":"Electrical characteristics"},{"location":"reference/module/modm-communication-sab2/#content","text":"// Class class modm :: sab2 :: Interface < typename Device , std :: size_t N = maxPayloadLength > ; // Function uint16_t modm :: sab2 :: crcUpdate ( uint16_t crc , uint8_t data ); // Enum enum Error ; // Variable const uint16_t modm :: sab2 :: crcInitialValue = 0xffff ; const uint8_t modm :: sab2 :: controlEscapeByte = 0x7d ; const uint8_t modm :: sab2 :: frameBounderyByte = 0x7e ; const uint8_t modm :: sab2 :: maxPayloadLength = 32 ;","title":"Content"},{"location":"reference/module/modm-communication-sab2/#dependencies","text":"modm:communication:sab2 modm_communication_sab2 modm: communication: sab2 modm_architecture_accessor modm: architecture: accessor modm_communication_sab2->modm_architecture_accessor modm_communication modm: communication modm_communication_sab2->modm_communication modm_communication_sab modm: communication: sab modm_communication_sab2->modm_communication_sab modm_debug modm: debug modm_communication_sab2->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab2->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-communication-xpcc-generator/","text":"These module docs are in beta and may be incomplete. modm:communication:xpcc:generator: XPCC Generator \u00b6 Options \u00b6 source \u00b6 Path to the XPCC source file: { Path } container \u00b6 Name of the XPCC container to generate for: { String } path \u00b6 Path to the XPCC generated folder: generated/xpcc \u2208 { Path } namespace \u00b6 Namespace of the generated XPCC communications: robot \u2208 { String } Dependencies \u00b6 modm:communication:xpcc:generator modm_communication_xpcc_generator modm: communication: xpcc: generator modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc_generator->modm_communication_xpcc","title":"modm:communication:xpcc:generator"},{"location":"reference/module/modm-communication-xpcc-generator/#modmcommunicationxpccgenerator-xpcc-generator","text":"","title":"modm:communication:xpcc:generator: XPCC Generator"},{"location":"reference/module/modm-communication-xpcc-generator/#options","text":"","title":"Options"},{"location":"reference/module/modm-communication-xpcc-generator/#source","text":"Path to the XPCC source file: { Path }","title":"source"},{"location":"reference/module/modm-communication-xpcc-generator/#container","text":"Name of the XPCC container to generate for: { String }","title":"container"},{"location":"reference/module/modm-communication-xpcc-generator/#path","text":"Path to the XPCC generated folder: generated/xpcc \u2208 { Path }","title":"path"},{"location":"reference/module/modm-communication-xpcc-generator/#namespace","text":"Namespace of the generated XPCC communications: robot \u2208 { String }","title":"namespace"},{"location":"reference/module/modm-communication-xpcc-generator/#dependencies","text":"modm:communication:xpcc:generator modm_communication_xpcc_generator modm: communication: xpcc: generator modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc_generator->modm_communication_xpcc","title":"Dependencies"},{"location":"reference/module/modm-communication-xpcc/","text":"These module docs are in beta and may be incomplete. modm:communication:xpcc: Cross Platform Component Communication (XPCC) \u00b6 Options \u00b6 timeout.acknowledge \u00b6 Timeout in ms of an reception acknowledgement: 100 \u2208 { 10 .. 100 .. 10000 } timeout.response \u00b6 Timeout in ms of an request response: 200 \u2208 { 10 .. 200 .. 10000 } Content \u00b6 // Class class xpcc :: AbstractComponent ; class xpcc :: ActionResult < typename T = void > ; class xpcc :: ActionResult < void > ; class xpcc :: BackendInterface ; class xpcc :: CanConnector :: ReceiveListItem ; class xpcc :: CanConnector :: SendListItem ; class xpcc :: CanConnector < typename Driver > ; class xpcc :: CanConnectorBase ; class xpcc :: Communicatable ; class xpcc :: CommunicatableTask ; class xpcc :: Communicator ; class xpcc :: Dispatcher :: Entry ; class xpcc :: Dispatcher ; class xpcc :: DynamicPostman :: ActionHandler ; class xpcc :: DynamicPostman :: EventListener ; class xpcc :: DynamicPostman ; class xpcc :: Postman ; class xpcc :: ResponseCallback ; class xpcc :: ResponseHandle ; // Struct struct xpcc :: Header ; // Function modm :: IOStream & xpcc :: operator << ( modm :: IOStream & s , const Header & header ); // Enum enum Response ; // Typedef using xpcc :: ActionResponse = typedef modm :: ResumableResult < xpcc :: ActionResult < T > > ; // Define #define XPCC_CAN_PACKET_ACKNOWLEDGE #define XPCC_CAN_PACKET_ACKNOWLEDGE_MASK #define XPCC_CAN_PACKET_DESTINATION(x) #define XPCC_CAN_PACKET_DESTINATION_MASK #define XPCC_CAN_PACKET_EVENT #define XPCC_CAN_PACKET_EVENT_MASK #define XPCC_CAN_PACKET_ID(x) #define XPCC_CAN_PACKET_ID_MASK #define XPCC_CAN_PACKET_SOURCE(x) #define XPCC_CAN_PACKET_SOURCE_MASK #define XPCC_CAN_PACKET_TYPE_MASK #define XPCC_CAN_PACKET_TYPE_REQUEST Dependencies \u00b6 modm:communication:xpcc modm_communication_xpcc modm: communication: xpcc modm_architecture_can modm: architecture: can modm_communication_xpcc->modm_architecture_can modm_communication modm: communication modm_communication_xpcc->modm_communication modm_container modm: container modm_communication_xpcc->modm_container modm_debug modm: debug modm_communication_xpcc->modm_debug modm_io modm: io modm_communication_xpcc->modm_io modm_math_utils modm: math: utils modm_communication_xpcc->modm_math_utils modm_processing_resumable modm: processing: resumable modm_communication_xpcc->modm_processing_resumable modm_processing_timer modm: processing: timer modm_communication_xpcc->modm_processing_timer modm_communication_xpcc_generator modm: communication: xpcc: generator modm_communication_xpcc_generator->modm_communication_xpcc modm_ui_menu modm: ui: menu modm_ui_menu->modm_communication_xpcc","title":"modm:communication:xpcc"},{"location":"reference/module/modm-communication-xpcc/#modmcommunicationxpcc-cross-platform-component-communication-xpcc","text":"","title":"modm:communication:xpcc: Cross Platform Component Communication (XPCC)"},{"location":"reference/module/modm-communication-xpcc/#options","text":"","title":"Options"},{"location":"reference/module/modm-communication-xpcc/#timeoutacknowledge","text":"Timeout in ms of an reception acknowledgement: 100 \u2208 { 10 .. 100 .. 10000 }","title":"timeout.acknowledge"},{"location":"reference/module/modm-communication-xpcc/#timeoutresponse","text":"Timeout in ms of an request response: 200 \u2208 { 10 .. 200 .. 10000 }","title":"timeout.response"},{"location":"reference/module/modm-communication-xpcc/#content","text":"// Class class xpcc :: AbstractComponent ; class xpcc :: ActionResult < typename T = void > ; class xpcc :: ActionResult < void > ; class xpcc :: BackendInterface ; class xpcc :: CanConnector :: ReceiveListItem ; class xpcc :: CanConnector :: SendListItem ; class xpcc :: CanConnector < typename Driver > ; class xpcc :: CanConnectorBase ; class xpcc :: Communicatable ; class xpcc :: CommunicatableTask ; class xpcc :: Communicator ; class xpcc :: Dispatcher :: Entry ; class xpcc :: Dispatcher ; class xpcc :: DynamicPostman :: ActionHandler ; class xpcc :: DynamicPostman :: EventListener ; class xpcc :: DynamicPostman ; class xpcc :: Postman ; class xpcc :: ResponseCallback ; class xpcc :: ResponseHandle ; // Struct struct xpcc :: Header ; // Function modm :: IOStream & xpcc :: operator << ( modm :: IOStream & s , const Header & header ); // Enum enum Response ; // Typedef using xpcc :: ActionResponse = typedef modm :: ResumableResult < xpcc :: ActionResult < T > > ; // Define #define XPCC_CAN_PACKET_ACKNOWLEDGE #define XPCC_CAN_PACKET_ACKNOWLEDGE_MASK #define XPCC_CAN_PACKET_DESTINATION(x) #define XPCC_CAN_PACKET_DESTINATION_MASK #define XPCC_CAN_PACKET_EVENT #define XPCC_CAN_PACKET_EVENT_MASK #define XPCC_CAN_PACKET_ID(x) #define XPCC_CAN_PACKET_ID_MASK #define XPCC_CAN_PACKET_SOURCE(x) #define XPCC_CAN_PACKET_SOURCE_MASK #define XPCC_CAN_PACKET_TYPE_MASK #define XPCC_CAN_PACKET_TYPE_REQUEST","title":"Content"},{"location":"reference/module/modm-communication-xpcc/#dependencies","text":"modm:communication:xpcc modm_communication_xpcc modm: communication: xpcc modm_architecture_can modm: architecture: can modm_communication_xpcc->modm_architecture_can modm_communication modm: communication modm_communication_xpcc->modm_communication modm_container modm: container modm_communication_xpcc->modm_container modm_debug modm: debug modm_communication_xpcc->modm_debug modm_io modm: io modm_communication_xpcc->modm_io modm_math_utils modm: math: utils modm_communication_xpcc->modm_math_utils modm_processing_resumable modm: processing: resumable modm_communication_xpcc->modm_processing_resumable modm_processing_timer modm: processing: timer modm_communication_xpcc->modm_processing_timer modm_communication_xpcc_generator modm: communication: xpcc: generator modm_communication_xpcc_generator->modm_communication_xpcc modm_ui_menu modm: ui: menu modm_ui_menu->modm_communication_xpcc","title":"Dependencies"},{"location":"reference/module/modm-communication/","text":"These module docs are in beta and may be incomplete. modm:communication: Communication Protocols \u00b6 Content \u00b6 // Class class ModmHardware < class Uart > ; class modm :: sab2 :: Interface < typename Device , std :: size_t N = maxPayloadLength > ; class modm :: sab :: Interface < typename Device > ; class modm :: sab :: Master < typename Interface > ; class modm :: sab :: Response ; class modm :: sab :: Slave < typename Interface > ; class modm :: sab :: Transmitter ; class xpcc :: AbstractComponent ; class xpcc :: ActionResult < typename T = void > ; class xpcc :: ActionResult < void > ; class xpcc :: BackendInterface ; class xpcc :: CanConnector :: ReceiveListItem ; class xpcc :: CanConnector :: SendListItem ; class xpcc :: CanConnector < typename Driver > ; class xpcc :: CanConnectorBase ; class xpcc :: Communicatable ; class xpcc :: CommunicatableTask ; class xpcc :: Communicator ; class xpcc :: Dispatcher :: Entry ; class xpcc :: Dispatcher ; class xpcc :: DynamicPostman :: ActionHandler ; class xpcc :: DynamicPostman :: EventListener ; class xpcc :: DynamicPostman ; class xpcc :: Postman ; class xpcc :: ResponseCallback ; class xpcc :: ResponseHandle ; // Struct struct modm :: sab :: Action ; struct modm :: sab :: Callable ; struct xpcc :: Header ; // Function modm :: IOStream & xpcc :: operator << ( modm :: IOStream & s , const Header & header ); uint16_t modm :: sab2 :: crcUpdate ( uint16_t crc , uint8_t data ); uint8_t modm :: sab :: crcUpdate ( uint8_t crc , uint8_t data ); // Enum enum Error ; enum Error ; enum Flags ; enum Response ; // Variable const uint16_t modm :: sab2 :: crcInitialValue = 0xffff ; const uint8_t modm :: sab2 :: controlEscapeByte = 0x7d ; const uint8_t modm :: sab2 :: frameBounderyByte = 0x7e ; const uint8_t modm :: sab2 :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: crcInitialValue = 0x00 ; const uint8_t modm :: sab :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: syncByte = 0x54 ; // Typedef using xpcc :: ActionResponse = typedef modm :: ResumableResult < xpcc :: ActionResult < T > > ; // Define #define SAB_ACTION(command, object, function, length) #define XPCC_CAN_PACKET_ACKNOWLEDGE #define XPCC_CAN_PACKET_ACKNOWLEDGE_MASK #define XPCC_CAN_PACKET_DESTINATION(x) #define XPCC_CAN_PACKET_DESTINATION_MASK #define XPCC_CAN_PACKET_EVENT #define XPCC_CAN_PACKET_EVENT_MASK #define XPCC_CAN_PACKET_ID(x) #define XPCC_CAN_PACKET_ID_MASK #define XPCC_CAN_PACKET_SOURCE(x) #define XPCC_CAN_PACKET_SOURCE_MASK #define XPCC_CAN_PACKET_TYPE_MASK #define XPCC_CAN_PACKET_TYPE_REQUEST Dependencies \u00b6 modm:communication modm_communication modm: communication modm_communication_ros modm: communication: ros modm_communication_ros->modm_communication modm_communication_sab modm: communication: sab modm_communication_sab->modm_communication modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_communication modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_communication","title":"modm:communication"},{"location":"reference/module/modm-communication/#modmcommunication-communication-protocols","text":"","title":"modm:communication: Communication Protocols"},{"location":"reference/module/modm-communication/#content","text":"// Class class ModmHardware < class Uart > ; class modm :: sab2 :: Interface < typename Device , std :: size_t N = maxPayloadLength > ; class modm :: sab :: Interface < typename Device > ; class modm :: sab :: Master < typename Interface > ; class modm :: sab :: Response ; class modm :: sab :: Slave < typename Interface > ; class modm :: sab :: Transmitter ; class xpcc :: AbstractComponent ; class xpcc :: ActionResult < typename T = void > ; class xpcc :: ActionResult < void > ; class xpcc :: BackendInterface ; class xpcc :: CanConnector :: ReceiveListItem ; class xpcc :: CanConnector :: SendListItem ; class xpcc :: CanConnector < typename Driver > ; class xpcc :: CanConnectorBase ; class xpcc :: Communicatable ; class xpcc :: CommunicatableTask ; class xpcc :: Communicator ; class xpcc :: Dispatcher :: Entry ; class xpcc :: Dispatcher ; class xpcc :: DynamicPostman :: ActionHandler ; class xpcc :: DynamicPostman :: EventListener ; class xpcc :: DynamicPostman ; class xpcc :: Postman ; class xpcc :: ResponseCallback ; class xpcc :: ResponseHandle ; // Struct struct modm :: sab :: Action ; struct modm :: sab :: Callable ; struct xpcc :: Header ; // Function modm :: IOStream & xpcc :: operator << ( modm :: IOStream & s , const Header & header ); uint16_t modm :: sab2 :: crcUpdate ( uint16_t crc , uint8_t data ); uint8_t modm :: sab :: crcUpdate ( uint8_t crc , uint8_t data ); // Enum enum Error ; enum Error ; enum Flags ; enum Response ; // Variable const uint16_t modm :: sab2 :: crcInitialValue = 0xffff ; const uint8_t modm :: sab2 :: controlEscapeByte = 0x7d ; const uint8_t modm :: sab2 :: frameBounderyByte = 0x7e ; const uint8_t modm :: sab2 :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: crcInitialValue = 0x00 ; const uint8_t modm :: sab :: maxPayloadLength = 32 ; const uint8_t modm :: sab :: syncByte = 0x54 ; // Typedef using xpcc :: ActionResponse = typedef modm :: ResumableResult < xpcc :: ActionResult < T > > ; // Define #define SAB_ACTION(command, object, function, length) #define XPCC_CAN_PACKET_ACKNOWLEDGE #define XPCC_CAN_PACKET_ACKNOWLEDGE_MASK #define XPCC_CAN_PACKET_DESTINATION(x) #define XPCC_CAN_PACKET_DESTINATION_MASK #define XPCC_CAN_PACKET_EVENT #define XPCC_CAN_PACKET_EVENT_MASK #define XPCC_CAN_PACKET_ID(x) #define XPCC_CAN_PACKET_ID_MASK #define XPCC_CAN_PACKET_SOURCE(x) #define XPCC_CAN_PACKET_SOURCE_MASK #define XPCC_CAN_PACKET_TYPE_MASK #define XPCC_CAN_PACKET_TYPE_REQUEST","title":"Content"},{"location":"reference/module/modm-communication/#dependencies","text":"modm:communication modm_communication modm: communication modm_communication_ros modm: communication: ros modm_communication_ros->modm_communication modm_communication_sab modm: communication: sab modm_communication_sab->modm_communication modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_communication modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_communication","title":"Dependencies"},{"location":"reference/module/modm-container/","text":"These module docs are in beta and may be incomplete. modm:container: Containers \u00b6 A container is a holder object that stores a collection other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements. Many containers have several member functions in common, and share functionalities. The decision of which type of container to use for a specific need does not generally depend only on the functionality offered by the container, but also on the efficiency of some of its members (complexity). This is especially true for sequence containers, which offer different trade-offs in complexity between inserting/removing elements and accessing them. modm::Stack and modm::Queue are implemented as container adapters. Container adapters are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as modm::BoundedDeque or modm::LinkedList ) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container class independently of the underlying container class used. Sequence containers: modm::DynamicArray modm::LinkedList modm::DoublyLinkedList modm::BoundedDeque Container adapters: modm::Queue modm::Stack modm::BoundedStack modm::BoundedQueue Other: modm::SmartPointer modm::Pair Two special containers hiding in the modm:architecture:atomic module: modm::atomic::Queue modm::atomic::Container The first is a simple, interrupt-safe queue (but only for the AVRs). Whenever you need to exchange data between a interrupt routine and the normal program consider using this queue. The atomic container wraps objects and provides atomic access to them. This comes in handy when simple objects are accessed by an interrupt and the main program. The container provides secure access without much work in this case. Generic Interface \u00b6 All implementation share a common set of function. Not every container implement every one of it, only a subset which is sufficient for the container. append prepend (insert) removeFront removeBack (remove) getFront getBack push (only Stack and Queue) pop (only Stack and Queue) get (only Stack and Queue) at operator[] clear isEmpty isFull getSize getMaxSize getCapacity Content \u00b6 // Class class modm :: BoundedDeque :: const_iterator ; class modm :: BoundedDeque < typename T , std :: size_t N > ; class modm :: BoundedQueue < typename T , std :: size_t N , typename Container = BoundedDeque < T , N > > ; class modm :: BoundedStack < typename T , std :: size_t N , typename Container = BoundedDeque < T , N > > ; class modm :: DoublyLinkedList :: const_iterator ; class modm :: DoublyLinkedList :: iterator ; class modm :: DoublyLinkedList < typename T , typename Allocator = allocator :: Dynamic < T > > ; class modm :: DynamicArray :: const_iterator ; class modm :: DynamicArray :: iterator ; class modm :: DynamicArray < typename T , typename Allocator = allocator :: Dynamic < T > > ; class modm :: LinkedList :: const_iterator ; class modm :: LinkedList :: iterator ; class modm :: LinkedList < typename T , typename Allocator = allocator :: Dynamic < T > > ; class modm :: Pair < typename T1 , typename T2 > ; class modm :: Queue < typename T , typename Container > ; class modm :: SmartPointer ; class modm :: Stack < typename T , typename Container > ; // Struct struct modm :: DoublyLinkedList :: Node ; struct modm :: LinkedList :: Node ; // Function modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: SmartPointer & sPtr ); Dependencies \u00b6 modm:container modm_container modm: container modm_architecture modm: architecture modm_container->modm_architecture modm_io modm: io modm_container->modm_io modm_utils modm: utils modm_container->modm_utils modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_container modm_math_geometry modm: math: geometry modm_math_geometry->modm_container modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_container modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_container modm_ui_gui modm: ui: gui modm_ui_gui->modm_container modm_ui_menu modm: ui: menu modm_ui_menu->modm_container","title":"modm:container"},{"location":"reference/module/modm-container/#modmcontainer-containers","text":"A container is a holder object that stores a collection other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements. Many containers have several member functions in common, and share functionalities. The decision of which type of container to use for a specific need does not generally depend only on the functionality offered by the container, but also on the efficiency of some of its members (complexity). This is especially true for sequence containers, which offer different trade-offs in complexity between inserting/removing elements and accessing them. modm::Stack and modm::Queue are implemented as container adapters. Container adapters are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as modm::BoundedDeque or modm::LinkedList ) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container class independently of the underlying container class used. Sequence containers: modm::DynamicArray modm::LinkedList modm::DoublyLinkedList modm::BoundedDeque Container adapters: modm::Queue modm::Stack modm::BoundedStack modm::BoundedQueue Other: modm::SmartPointer modm::Pair Two special containers hiding in the modm:architecture:atomic module: modm::atomic::Queue modm::atomic::Container The first is a simple, interrupt-safe queue (but only for the AVRs). Whenever you need to exchange data between a interrupt routine and the normal program consider using this queue. The atomic container wraps objects and provides atomic access to them. This comes in handy when simple objects are accessed by an interrupt and the main program. The container provides secure access without much work in this case.","title":"modm:container: Containers"},{"location":"reference/module/modm-container/#generic-interface","text":"All implementation share a common set of function. Not every container implement every one of it, only a subset which is sufficient for the container. append prepend (insert) removeFront removeBack (remove) getFront getBack push (only Stack and Queue) pop (only Stack and Queue) get (only Stack and Queue) at operator[] clear isEmpty isFull getSize getMaxSize getCapacity","title":"Generic Interface"},{"location":"reference/module/modm-container/#content","text":"// Class class modm :: BoundedDeque :: const_iterator ; class modm :: BoundedDeque < typename T , std :: size_t N > ; class modm :: BoundedQueue < typename T , std :: size_t N , typename Container = BoundedDeque < T , N > > ; class modm :: BoundedStack < typename T , std :: size_t N , typename Container = BoundedDeque < T , N > > ; class modm :: DoublyLinkedList :: const_iterator ; class modm :: DoublyLinkedList :: iterator ; class modm :: DoublyLinkedList < typename T , typename Allocator = allocator :: Dynamic < T > > ; class modm :: DynamicArray :: const_iterator ; class modm :: DynamicArray :: iterator ; class modm :: DynamicArray < typename T , typename Allocator = allocator :: Dynamic < T > > ; class modm :: LinkedList :: const_iterator ; class modm :: LinkedList :: iterator ; class modm :: LinkedList < typename T , typename Allocator = allocator :: Dynamic < T > > ; class modm :: Pair < typename T1 , typename T2 > ; class modm :: Queue < typename T , typename Container > ; class modm :: SmartPointer ; class modm :: Stack < typename T , typename Container > ; // Struct struct modm :: DoublyLinkedList :: Node ; struct modm :: LinkedList :: Node ; // Function modm :: IOStream & modm :: operator << ( modm :: IOStream & s , const modm :: SmartPointer & sPtr );","title":"Content"},{"location":"reference/module/modm-container/#dependencies","text":"modm:container modm_container modm: container modm_architecture modm: architecture modm_container->modm_architecture modm_io modm: io modm_container->modm_io modm_utils modm: utils modm_container->modm_utils modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_container modm_math_geometry modm: math: geometry modm_math_geometry->modm_container modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_container modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_container modm_ui_gui modm: ui: gui modm_ui_gui->modm_container modm_ui_menu modm: ui: menu modm_ui_menu->modm_container","title":"Dependencies"},{"location":"reference/module/modm-debug/","text":"These module docs are in beta and may be incomplete. modm:debug: Logging \u00b6 The modm::log::Logger uses a modm::IOStream to read messages and write them to a given output device. Write a log message with streams: MODM_LOG_DEBUG << \"i=\" << i << \", y=\" << y << modm :: flush ; The name of the stream represents the log level of the message. Available are: MODM_LOG_DEBUG MODM_LOG_INFO MODM_LOG_WARNING MODM_LOG_ERROR A log message can also be generated separately: int a [ 3 ] = { 1 , 2 , 3 }; MODM_LOG_DEBUG << \"a = \" ; for ( int i = 0 ; i < sizeof ( a ); ++ i ) { MODM_LOG_DEBUG << a [ i ] << \", \" ; } MODM_LOG_DEBUG << modm :: flush ; Flow of a call \u00b6 This is to give an estimation how many resources a call of the logger use. All considerations are for a PC program. The given call is: MODM_LOG_DEBUG << 123456 ; The macro resolves to: if ( MODM_LOG_LEVEL <= modm :: log :: DEBUG ) modm :: log :: debug modm::log::debug is an instance of modm::Logger : Call of modm::Logger::operator << (T) (with T = int32_t ) which is inline IOStream::operator << (T) (with T = int32_t ) is inline IOStream::writeInteger(int32_t) IOStream::writeInteger(int32_t) will create the formatted string virtual call of IODevice::write(const char*) redirect to std::cout In sum there are two nested method calls with one of them being virtual. Content \u00b6 // Class class modm :: ErrorReport ; class modm :: log :: DefaultStyle ; class modm :: log :: Logger ; class modm :: log :: Prefix < typename T , typename STYLE = DefaultStyle > ; class modm :: log :: StdColour < Colour TEXT , Colour BACKGROUND , typename STYLE = DefaultStyle > ; class modm :: log :: Style < typename STYLE = DefaultStyle > ; class modm :: log :: StyleWrapper < typename STYLE > ; // Enum enum Colour ; enum Level ; // Variable Logger modm :: log :: debug ; Logger modm :: log :: error ; Logger modm :: log :: info ; Logger modm :: log :: warning ; // Define #define FILENAME #define MODM_FILE_INFO #define MODM_LOG_DEBUG #define MODM_LOG_ERROR #define MODM_LOG_INFO #define MODM_LOG_LEVEL #define MODM_LOG_OFF #define MODM_LOG_WARNING Dependencies \u00b6 modm:debug modm_debug modm: debug modm_architecture modm: architecture modm_debug->modm_architecture modm_io modm: io modm_debug->modm_io modm_utils modm: utils modm_debug->modm_utils modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_debug modm_communication_sab modm: communication: sab modm_communication_sab->modm_debug modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_debug modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_debug modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_debug modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_debug modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_debug modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_debug modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_debug modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_debug modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_debug modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_debug modm_platform_can modm: platform: can modm_platform_can->modm_debug modm_ui_gui modm: ui: gui modm_ui_gui->modm_debug","title":"modm:debug"},{"location":"reference/module/modm-debug/#modmdebug-logging","text":"The modm::log::Logger uses a modm::IOStream to read messages and write them to a given output device. Write a log message with streams: MODM_LOG_DEBUG << \"i=\" << i << \", y=\" << y << modm :: flush ; The name of the stream represents the log level of the message. Available are: MODM_LOG_DEBUG MODM_LOG_INFO MODM_LOG_WARNING MODM_LOG_ERROR A log message can also be generated separately: int a [ 3 ] = { 1 , 2 , 3 }; MODM_LOG_DEBUG << \"a = \" ; for ( int i = 0 ; i < sizeof ( a ); ++ i ) { MODM_LOG_DEBUG << a [ i ] << \", \" ; } MODM_LOG_DEBUG << modm :: flush ;","title":"modm:debug: Logging"},{"location":"reference/module/modm-debug/#flow-of-a-call","text":"This is to give an estimation how many resources a call of the logger use. All considerations are for a PC program. The given call is: MODM_LOG_DEBUG << 123456 ; The macro resolves to: if ( MODM_LOG_LEVEL <= modm :: log :: DEBUG ) modm :: log :: debug modm::log::debug is an instance of modm::Logger : Call of modm::Logger::operator << (T) (with T = int32_t ) which is inline IOStream::operator << (T) (with T = int32_t ) is inline IOStream::writeInteger(int32_t) IOStream::writeInteger(int32_t) will create the formatted string virtual call of IODevice::write(const char*) redirect to std::cout In sum there are two nested method calls with one of them being virtual.","title":"Flow of a call"},{"location":"reference/module/modm-debug/#content","text":"// Class class modm :: ErrorReport ; class modm :: log :: DefaultStyle ; class modm :: log :: Logger ; class modm :: log :: Prefix < typename T , typename STYLE = DefaultStyle > ; class modm :: log :: StdColour < Colour TEXT , Colour BACKGROUND , typename STYLE = DefaultStyle > ; class modm :: log :: Style < typename STYLE = DefaultStyle > ; class modm :: log :: StyleWrapper < typename STYLE > ; // Enum enum Colour ; enum Level ; // Variable Logger modm :: log :: debug ; Logger modm :: log :: error ; Logger modm :: log :: info ; Logger modm :: log :: warning ; // Define #define FILENAME #define MODM_FILE_INFO #define MODM_LOG_DEBUG #define MODM_LOG_ERROR #define MODM_LOG_INFO #define MODM_LOG_LEVEL #define MODM_LOG_OFF #define MODM_LOG_WARNING","title":"Content"},{"location":"reference/module/modm-debug/#dependencies","text":"modm:debug modm_debug modm: debug modm_architecture modm: architecture modm_debug->modm_architecture modm_io modm: io modm_debug->modm_io modm_utils modm: utils modm_debug->modm_utils modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_debug modm_communication_sab modm: communication: sab modm_communication_sab->modm_debug modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_debug modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_debug modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_debug modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_debug modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_debug modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_debug modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_debug modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_debug modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_debug modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_debug modm_platform_can modm: platform: can modm_platform_can->modm_debug modm_ui_gui modm: ui: gui modm_ui_gui->modm_debug","title":"Dependencies"},{"location":"reference/module/modm-docs/","text":"These module docs are in beta and may be incomplete. modm:docs: Documentation Generator \u00b6 Options \u00b6 generate_module_docs \u00b6 Generate the module docs (alpha): False \u2208 { True, False } generate_module_docs_as_qch \u00b6 Generate the module docs as qch (Qt Help format) (alpha): False \u2208 { True, False }","title":"modm:docs"},{"location":"reference/module/modm-docs/#modmdocs-documentation-generator","text":"","title":"modm:docs: Documentation Generator"},{"location":"reference/module/modm-docs/#options","text":"","title":"Options"},{"location":"reference/module/modm-docs/#generate_module_docs","text":"Generate the module docs (alpha): False \u2208 { True, False }","title":"generate_module_docs"},{"location":"reference/module/modm-docs/#generate_module_docs_as_qch","text":"Generate the module docs as qch (Qt Help format) (alpha): False \u2208 { True, False }","title":"generate_module_docs_as_qch"},{"location":"reference/module/modm-driver-ad7280a/","text":"These module docs are in beta and may be incomplete. modm:driver:ad7280a: AD7280A Lithium Ion Battery Monitoring System \u00b6 The AD7280A is monitor for lithium ion battery packs with up to six cells. It contains six 12-ADCs with 1\u00b5s conversion per channel and a cell balancing interface. Up to 7 devices can be added through a Daisy-Chain interface (chain of 8 devices). cell voltage accuracy of \u00b11.6 mV. Supply voltage 8-30V six auxiliary ADC input channels Recommended SPI Clk frequency is 1 MHz. With a 1 MHz Clk, it takes approximately 1.54 ms to read back the voltage conversions on 48 channels. When addressing devices in the chain directly the frequency needs to be lower than 1 MHz because delays introduced in each stage of the chain. Content \u00b6 // Class class modm :: Ad7280a < typename Spi , typename Cs , typename Cnvst , int N > ; // Struct struct modm :: ad7280a :: ConversionValue ; struct modm :: ad7280a :: RegisterValue ; // Function IOStream & modm :: operator << ( IOStream & os , const ad7280a :: ConversionValue & c ); IOStream & modm :: operator << ( IOStream & os , const ad7280a :: RegisterValue & c ); // Enum enum Average ; enum Cell ; enum Channel ; enum Device ; enum Register ; Dependencies \u00b6 modm:driver:ad7280a modm_driver_ad7280a modm: driver: ad7280a modm_architecture_delay modm: architecture: delay modm_driver_ad7280a->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7280a->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_ad7280a->modm_architecture_spi modm_driver modm: driver modm_driver_ad7280a->modm_driver modm_io modm: io modm_driver_ad7280a->modm_io modm_math_utils modm: math: utils modm_driver_ad7280a->modm_math_utils modm_utils modm: utils modm_driver_ad7280a->modm_utils","title":"modm:driver:ad7280a"},{"location":"reference/module/modm-driver-ad7280a/#modmdriverad7280a-ad7280a-lithium-ion-battery-monitoring-system","text":"The AD7280A is monitor for lithium ion battery packs with up to six cells. It contains six 12-ADCs with 1\u00b5s conversion per channel and a cell balancing interface. Up to 7 devices can be added through a Daisy-Chain interface (chain of 8 devices). cell voltage accuracy of \u00b11.6 mV. Supply voltage 8-30V six auxiliary ADC input channels Recommended SPI Clk frequency is 1 MHz. With a 1 MHz Clk, it takes approximately 1.54 ms to read back the voltage conversions on 48 channels. When addressing devices in the chain directly the frequency needs to be lower than 1 MHz because delays introduced in each stage of the chain.","title":"modm:driver:ad7280a: AD7280A Lithium Ion Battery Monitoring System"},{"location":"reference/module/modm-driver-ad7280a/#content","text":"// Class class modm :: Ad7280a < typename Spi , typename Cs , typename Cnvst , int N > ; // Struct struct modm :: ad7280a :: ConversionValue ; struct modm :: ad7280a :: RegisterValue ; // Function IOStream & modm :: operator << ( IOStream & os , const ad7280a :: ConversionValue & c ); IOStream & modm :: operator << ( IOStream & os , const ad7280a :: RegisterValue & c ); // Enum enum Average ; enum Cell ; enum Channel ; enum Device ; enum Register ;","title":"Content"},{"location":"reference/module/modm-driver-ad7280a/#dependencies","text":"modm:driver:ad7280a modm_driver_ad7280a modm: driver: ad7280a modm_architecture_delay modm: architecture: delay modm_driver_ad7280a->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7280a->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_ad7280a->modm_architecture_spi modm_driver modm: driver modm_driver_ad7280a->modm_driver modm_io modm: io modm_driver_ad7280a->modm_io modm_math_utils modm: math: utils modm_driver_ad7280a->modm_math_utils modm_utils modm: utils modm_driver_ad7280a->modm_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-ad7928/","text":"These module docs are in beta and may be incomplete. modm:driver:ad7928: AD79x8 ADC \u00b6 The AD7928/AD7918/AD7908 are, respectively, 12/10/8 bit analog-digital converters. The conversion time is determined by the Spi clock frequency. A maximum Spi clock of 20 Mhz is supported. Content \u00b6 // Class class modm :: Ad7928 < typename SpiMaster , typename Cs > ; // Struct struct modm :: ad7928 :: Data ; struct modm :: ad7928 ; // Function IOStream & modm :: operator << ( IOStream & out , const ad7928 :: Data & data ); Dependencies \u00b6 modm:driver:ad7928 modm_driver_ad7928 modm: driver: ad7928 modm_architecture_accessor modm: architecture: accessor modm_driver_ad7928->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ad7928->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7928->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ad7928->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ad7928->modm_architecture_spi_device modm_driver modm: driver modm_driver_ad7928->modm_driver modm_io modm: io modm_driver_ad7928->modm_io modm_processing_resumable modm: processing: resumable modm_driver_ad7928->modm_processing_resumable","title":"modm:driver:ad7928"},{"location":"reference/module/modm-driver-ad7928/#modmdriverad7928-ad79x8-adc","text":"The AD7928/AD7918/AD7908 are, respectively, 12/10/8 bit analog-digital converters. The conversion time is determined by the Spi clock frequency. A maximum Spi clock of 20 Mhz is supported.","title":"modm:driver:ad7928: AD79x8 ADC"},{"location":"reference/module/modm-driver-ad7928/#content","text":"// Class class modm :: Ad7928 < typename SpiMaster , typename Cs > ; // Struct struct modm :: ad7928 :: Data ; struct modm :: ad7928 ; // Function IOStream & modm :: operator << ( IOStream & out , const ad7928 :: Data & data );","title":"Content"},{"location":"reference/module/modm-driver-ad7928/#dependencies","text":"modm:driver:ad7928 modm_driver_ad7928 modm: driver: ad7928 modm_architecture_accessor modm: architecture: accessor modm_driver_ad7928->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ad7928->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7928->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ad7928->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ad7928->modm_architecture_spi_device modm_driver modm: driver modm_driver_ad7928->modm_driver modm_io modm: io modm_driver_ad7928->modm_io modm_processing_resumable modm: processing: resumable modm_driver_ad7928->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-adc-sampler/","text":"These module docs are in beta and may be incomplete. modm:driver:adc_sampler: Oversampling of ADC inputs \u00b6 This template class stores 8, 16 or 32bit ADC values in a buffer and provides an easy interface for managing that data. The code will read the ADC channels you specify in an array. This means you can remap the ADC channels in the order that they should appear in the buffer. The array must obviously have as many elements as channels! For example, if channels 0,2,7 are connected, but the sensors are in the wrong order, just remap them with the array {7,0,2}. To make use of oversampling and averaging, set Oversamples > 0 . This will loop Oversamples times through the ADC channels, adding the average of each result to the buffer. This class will choose the smallest data width for you. It decides this by adding the ADC resolution and the oversample size and choosing the next smallest size (not larger than 32bit though!). Warning The averaging algorithm only works for unsigned ADC data! Content \u00b6 // Class class modm :: AdcSampler < class AdcInterrupt , uint8_t Channels , uint32_t Oversamples = 1 > ; Dependencies \u00b6 modm:driver:adc_sampler modm_driver_adc_sampler modm: driver: adc_sampler modm_architecture_adc modm: architecture: adc modm_driver_adc_sampler->modm_architecture_adc modm_driver modm: driver modm_driver_adc_sampler->modm_driver modm_math_utils modm: math: utils modm_driver_adc_sampler->modm_math_utils modm_utils modm: utils modm_driver_adc_sampler->modm_utils","title":"modm:driver:adc_sampler"},{"location":"reference/module/modm-driver-adc-sampler/#modmdriveradc_sampler-oversampling-of-adc-inputs","text":"This template class stores 8, 16 or 32bit ADC values in a buffer and provides an easy interface for managing that data. The code will read the ADC channels you specify in an array. This means you can remap the ADC channels in the order that they should appear in the buffer. The array must obviously have as many elements as channels! For example, if channels 0,2,7 are connected, but the sensors are in the wrong order, just remap them with the array {7,0,2}. To make use of oversampling and averaging, set Oversamples > 0 . This will loop Oversamples times through the ADC channels, adding the average of each result to the buffer. This class will choose the smallest data width for you. It decides this by adding the ADC resolution and the oversample size and choosing the next smallest size (not larger than 32bit though!). Warning The averaging algorithm only works for unsigned ADC data!","title":"modm:driver:adc_sampler: Oversampling of ADC inputs"},{"location":"reference/module/modm-driver-adc-sampler/#content","text":"// Class class modm :: AdcSampler < class AdcInterrupt , uint8_t Channels , uint32_t Oversamples = 1 > ;","title":"Content"},{"location":"reference/module/modm-driver-adc-sampler/#dependencies","text":"modm:driver:adc_sampler modm_driver_adc_sampler modm: driver: adc_sampler modm_architecture_adc modm: architecture: adc modm_driver_adc_sampler->modm_architecture_adc modm_driver modm: driver modm_driver_adc_sampler->modm_driver modm_math_utils modm: math: utils modm_driver_adc_sampler->modm_math_utils modm_utils modm: utils modm_driver_adc_sampler->modm_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-adns9800/","text":"These module docs are in beta and may be incomplete. modm:driver:adns9800: ADNS-9800 Laser Motion Sensor \u00b6 Based on work of Alexander Entinger, MSc / LXRobotics Based on https://github.com/mrjohnk/ADNS-9800 Options \u00b6 firmware \u00b6 Select the firmware version to initialize the device with.: a6 \u2208 { a4, a4b, a5, a6 } Content \u00b6 // Class class modm :: Adns9800 < typename Spi , typename Cs > ; // Struct struct modm :: adns9800 ; // Variable constexpr uint16_t firmware_length = 3070 ; constexpr uint8_t firmware_data [ firmware_length ] ; Dependencies \u00b6 modm:driver:adns9800 modm_driver_adns9800 modm: driver: adns9800 modm_architecture_delay modm: architecture: delay modm_driver_adns9800->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_adns9800->modm_architecture_spi modm_debug modm: debug modm_driver_adns9800->modm_debug modm_driver modm: driver modm_driver_adns9800->modm_driver","title":"modm:driver:adns9800"},{"location":"reference/module/modm-driver-adns9800/#modmdriveradns9800-adns-9800-laser-motion-sensor","text":"Based on work of Alexander Entinger, MSc / LXRobotics Based on https://github.com/mrjohnk/ADNS-9800","title":"modm:driver:adns9800: ADNS-9800 Laser Motion Sensor"},{"location":"reference/module/modm-driver-adns9800/#options","text":"","title":"Options"},{"location":"reference/module/modm-driver-adns9800/#firmware","text":"Select the firmware version to initialize the device with.: a6 \u2208 { a4, a4b, a5, a6 }","title":"firmware"},{"location":"reference/module/modm-driver-adns9800/#content","text":"// Class class modm :: Adns9800 < typename Spi , typename Cs > ; // Struct struct modm :: adns9800 ; // Variable constexpr uint16_t firmware_length = 3070 ; constexpr uint8_t firmware_data [ firmware_length ] ;","title":"Content"},{"location":"reference/module/modm-driver-adns9800/#dependencies","text":"modm:driver:adns9800 modm_driver_adns9800 modm: driver: adns9800 modm_architecture_delay modm: architecture: delay modm_driver_adns9800->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_adns9800->modm_architecture_spi modm_debug modm: debug modm_driver_adns9800->modm_debug modm_driver modm: driver modm_driver_adns9800->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-ads7843/","text":"These module docs are in beta and may be incomplete. modm:driver:ads7843: ADS7843 Resistive Touch Controller \u00b6 The ADS7843 by Texas Instruments is the de-facto standard for cheap resistive touch screens. There are many compatible devices from other manufacturers available, such as the UH7843 by Zilltek, the TSC2046 and the XPT2046 by XPTEK. All of these are 100%% compatible with the ADS7843. Content \u00b6 // Class class modm :: Ads7843 < typename Spi , typename Cs , typename Int > ; Dependencies \u00b6 modm:driver:ads7843 modm_driver_ads7843 modm: driver: ads7843 modm_architecture_delay modm: architecture: delay modm_driver_ads7843->modm_architecture_delay modm_driver modm: driver modm_driver_ads7843->modm_driver modm_ui_display modm: ui: display modm_driver_ads7843->modm_ui_display","title":"modm:driver:ads7843"},{"location":"reference/module/modm-driver-ads7843/#modmdriverads7843-ads7843-resistive-touch-controller","text":"The ADS7843 by Texas Instruments is the de-facto standard for cheap resistive touch screens. There are many compatible devices from other manufacturers available, such as the UH7843 by Zilltek, the TSC2046 and the XPT2046 by XPTEK. All of these are 100%% compatible with the ADS7843.","title":"modm:driver:ads7843: ADS7843 Resistive Touch Controller"},{"location":"reference/module/modm-driver-ads7843/#content","text":"// Class class modm :: Ads7843 < typename Spi , typename Cs , typename Int > ;","title":"Content"},{"location":"reference/module/modm-driver-ads7843/#dependencies","text":"modm:driver:ads7843 modm_driver_ads7843 modm: driver: ads7843 modm_architecture_delay modm: architecture: delay modm_driver_ads7843->modm_architecture_delay modm_driver modm: driver modm_driver_ads7843->modm_driver modm_ui_display modm: ui: display modm_driver_ads7843->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-ams5915/","text":"These module docs are in beta and may be incomplete. modm:driver:ams5915: AMS 5915 Pressure Sensor \u00b6 Driver for the AMS 5915 differential and absolute pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 500 \u03bcs within the output registers of the internal ASIC. Datasheet Content \u00b6 // Class class modm :: Ams5915 < typename I2cMaster > ; // Struct struct modm :: ams5915 :: Data ; struct modm :: ams5915 ; Dependencies \u00b6 modm:driver:ams5915 modm_driver_ams5915 modm: driver: ams5915 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ams5915->modm_architecture_i2c_device modm_driver modm: driver modm_driver_ams5915->modm_driver modm_math_utils modm: math: utils modm_driver_ams5915->modm_math_utils","title":"modm:driver:ams5915"},{"location":"reference/module/modm-driver-ams5915/#modmdriverams5915-ams-5915-pressure-sensor","text":"Driver for the AMS 5915 differential and absolute pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 500 \u03bcs within the output registers of the internal ASIC. Datasheet","title":"modm:driver:ams5915: AMS 5915 Pressure Sensor"},{"location":"reference/module/modm-driver-ams5915/#content","text":"// Class class modm :: Ams5915 < typename I2cMaster > ; // Struct struct modm :: ams5915 :: Data ; struct modm :: ams5915 ;","title":"Content"},{"location":"reference/module/modm-driver-ams5915/#dependencies","text":"modm:driver:ams5915 modm_driver_ams5915 modm: driver: ams5915 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ams5915->modm_architecture_i2c_device modm_driver modm: driver modm_driver_ams5915->modm_driver modm_math_utils modm: math: utils modm_driver_ams5915->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device-heap/","text":"These module docs are in beta and may be incomplete. modm:driver:block.device:heap: Heap Block Device \u00b6 Content \u00b6 // Class class modm :: BdHeap < size_t DeviceSize_ , bool externalMemory = false > ; Dependencies \u00b6 modm:driver:block.device:heap modm_driver_block_device_heap modm: driver: block.device: heap modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_heap->modm_architecture_block_device modm_driver_block_device modm: driver: block.device modm_driver_block_device_heap->modm_driver_block_device modm_utils modm: utils modm_driver_block_device_heap->modm_utils","title":"modm:driver:block.device:heap"},{"location":"reference/module/modm-driver-block-device-heap/#modmdriverblockdeviceheap-heap-block-device","text":"","title":"modm:driver:block.device:heap: Heap Block Device"},{"location":"reference/module/modm-driver-block-device-heap/#content","text":"// Class class modm :: BdHeap < size_t DeviceSize_ , bool externalMemory = false > ;","title":"Content"},{"location":"reference/module/modm-driver-block-device-heap/#dependencies","text":"modm:driver:block.device:heap modm_driver_block_device_heap modm: driver: block.device: heap modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_heap->modm_architecture_block_device modm_driver_block_device modm: driver: block.device modm_driver_block_device_heap->modm_driver_block_device modm_utils modm: utils modm_driver_block_device_heap->modm_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device-mirror/","text":"These module docs are in beta and may be incomplete. modm:driver:block.device:mirror: Mirroring Block Device \u00b6 Content \u00b6 // Class class modm :: BdMirror < typename BlockDeviceA , typename BlockDeviceB > ; Dependencies \u00b6 modm:driver:block.device:mirror modm_driver_block_device_mirror modm: driver: block.device: mirror modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_mirror->modm_architecture_block_device modm_driver_block_device modm: driver: block.device modm_driver_block_device_mirror->modm_driver_block_device","title":"modm:driver:block.device:mirror"},{"location":"reference/module/modm-driver-block-device-mirror/#modmdriverblockdevicemirror-mirroring-block-device","text":"","title":"modm:driver:block.device:mirror: Mirroring Block Device"},{"location":"reference/module/modm-driver-block-device-mirror/#content","text":"// Class class modm :: BdMirror < typename BlockDeviceA , typename BlockDeviceB > ;","title":"Content"},{"location":"reference/module/modm-driver-block-device-mirror/#dependencies","text":"modm:driver:block.device:mirror modm_driver_block_device_mirror modm: driver: block.device: mirror modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_mirror->modm_architecture_block_device modm_driver_block_device modm: driver: block.device modm_driver_block_device_mirror->modm_driver_block_device","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device-spi-flash/","text":"These module docs are in beta and may be incomplete. modm:driver:block.device:spi.flash: SPI Flash Block Device \u00b6 Microchip SST26VF064B 64MBit flash chip in SOIJ-8, WDFN-8 or SOIC-16. Content \u00b6 // Class class modm :: BdSpiFlash < typename Spi , typename Cs , uint32_t flashSize > ; // Struct struct modm :: BdSpiFlash :: JedecId ; Dependencies \u00b6 modm:driver:block.device:spi.flash modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_spi_flash->modm_architecture_block_device modm_architecture_register modm: architecture: register modm_driver_block_device_spi_flash->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_block_device_spi_flash->modm_architecture_spi_device modm_driver_block_device modm: driver: block.device modm_driver_block_device_spi_flash->modm_driver_block_device","title":"modm:driver:block.device:spi.flash"},{"location":"reference/module/modm-driver-block-device-spi-flash/#modmdriverblockdevicespiflash-spi-flash-block-device","text":"Microchip SST26VF064B 64MBit flash chip in SOIJ-8, WDFN-8 or SOIC-16.","title":"modm:driver:block.device:spi.flash: SPI Flash Block Device"},{"location":"reference/module/modm-driver-block-device-spi-flash/#content","text":"// Class class modm :: BdSpiFlash < typename Spi , typename Cs , uint32_t flashSize > ; // Struct struct modm :: BdSpiFlash :: JedecId ;","title":"Content"},{"location":"reference/module/modm-driver-block-device-spi-flash/#dependencies","text":"modm:driver:block.device:spi.flash modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_spi_flash->modm_architecture_block_device modm_architecture_register modm: architecture: register modm_driver_block_device_spi_flash->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_block_device_spi_flash->modm_architecture_spi_device modm_driver_block_device modm: driver: block.device modm_driver_block_device_spi_flash->modm_driver_block_device","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device/","text":"These module docs are in beta and may be incomplete. modm:driver:block.device: Block Devices \u00b6 Content \u00b6 // Class class modm :: BdHeap < size_t DeviceSize_ , bool externalMemory = false > ; class modm :: BdMirror < typename BlockDeviceA , typename BlockDeviceB > ; class modm :: BdSpiFlash < typename Spi , typename Cs , uint32_t flashSize > ; // Struct struct modm :: BdSpiFlash :: JedecId ; Dependencies \u00b6 modm:driver:block.device modm_driver_block_device modm: driver: block.device modm_driver modm: driver modm_driver_block_device->modm_driver modm_driver_block_device_heap modm: driver: block.device: heap modm_driver_block_device_heap->modm_driver_block_device modm_driver_block_device_mirror modm: driver: block.device: mirror modm_driver_block_device_mirror->modm_driver_block_device modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_driver_block_device","title":"modm:driver:block.device"},{"location":"reference/module/modm-driver-block-device/#modmdriverblockdevice-block-devices","text":"","title":"modm:driver:block.device: Block Devices"},{"location":"reference/module/modm-driver-block-device/#content","text":"// Class class modm :: BdHeap < size_t DeviceSize_ , bool externalMemory = false > ; class modm :: BdMirror < typename BlockDeviceA , typename BlockDeviceB > ; class modm :: BdSpiFlash < typename Spi , typename Cs , uint32_t flashSize > ; // Struct struct modm :: BdSpiFlash :: JedecId ;","title":"Content"},{"location":"reference/module/modm-driver-block-device/#dependencies","text":"modm:driver:block.device modm_driver_block_device modm: driver: block.device modm_driver modm: driver modm_driver_block_device->modm_driver modm_driver_block_device_heap modm: driver: block.device: heap modm_driver_block_device_heap->modm_driver_block_device modm_driver_block_device_mirror modm: driver: block.device: mirror modm_driver_block_device_mirror->modm_driver_block_device modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_driver_block_device_spi_flash->modm_driver_block_device","title":"Dependencies"},{"location":"reference/module/modm-driver-bme280/","text":"These module docs are in beta and may be incomplete. modm:driver:bme280: BME280 Pressure Sensor \u00b6 The BME280 is a high precision digital temperature, pressure and humidity sensor with I2C interface. It is known that many BME280-modules suffer from self-heating (I2C pull-ups?). So the reported temperature is about 1 to 3 degree higher than with other sensors. Forced ventilation can drop the temperature by 2 to 3 degrees. Content \u00b6 // Class class modm :: Bme280 < typename I2cMaster > ; class modm :: bme280data :: Data ; class modm :: bme280data :: DataDouble ; // Struct struct modm :: bme280 ; struct modm :: bme280data :: Calibration ; struct modm :: bme280data :: DataBase ; // Define #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL Dependencies \u00b6 modm:driver:bme280 modm_driver_bme280 modm: driver: bme280 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bme280->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bme280->modm_architecture_register modm_debug modm: debug modm_driver_bme280->modm_debug modm_driver modm: driver modm_driver_bme280->modm_driver modm_math_utils modm: math: utils modm_driver_bme280->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bme280->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bme280->modm_processing_timer","title":"modm:driver:bme280"},{"location":"reference/module/modm-driver-bme280/#modmdriverbme280-bme280-pressure-sensor","text":"The BME280 is a high precision digital temperature, pressure and humidity sensor with I2C interface. It is known that many BME280-modules suffer from self-heating (I2C pull-ups?). So the reported temperature is about 1 to 3 degree higher than with other sensors. Forced ventilation can drop the temperature by 2 to 3 degrees.","title":"modm:driver:bme280: BME280 Pressure Sensor"},{"location":"reference/module/modm-driver-bme280/#content","text":"// Class class modm :: Bme280 < typename I2cMaster > ; class modm :: bme280data :: Data ; class modm :: bme280data :: DataDouble ; // Struct struct modm :: bme280 ; struct modm :: bme280data :: Calibration ; struct modm :: bme280data :: DataBase ; // Define #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL","title":"Content"},{"location":"reference/module/modm-driver-bme280/#dependencies","text":"modm:driver:bme280 modm_driver_bme280 modm: driver: bme280 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bme280->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bme280->modm_architecture_register modm_debug modm: debug modm_driver_bme280->modm_debug modm_driver modm: driver modm_driver_bme280->modm_driver modm_math_utils modm: math: utils modm_driver_bme280->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bme280->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bme280->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-driver-bmp085/","text":"These module docs are in beta and may be incomplete. modm:driver:bmp085: BMP085 Pressure Sensor \u00b6 The BMP085 is a high precision digital pressure sensor with I2C interface. Unfortunately this sensor is so sensitive, it will give you wrong results when there is traffic on the I2C during either temperature or pressure conversion. So during that time make sure no other sensors on the bus are read out. For further information, consult the datasheet . Also compatible to and tested with BMP180. Content \u00b6 // Class class modm :: Bmp085 < typename I2cMaster > ; class modm :: bmp085data :: Data ; class modm :: bmp085data :: DataBase ; class modm :: bmp085data :: DataDouble ; // Struct struct modm :: bmp085 ; struct modm :: bmp085data :: Calibration ; // Define #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL Dependencies \u00b6 modm:driver:bmp085 modm_driver_bmp085 modm: driver: bmp085 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bmp085->modm_architecture_i2c_device modm_debug modm: debug modm_driver_bmp085->modm_debug modm_driver modm: driver modm_driver_bmp085->modm_driver modm_math_utils modm: math: utils modm_driver_bmp085->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bmp085->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bmp085->modm_processing_timer","title":"modm:driver:bmp085"},{"location":"reference/module/modm-driver-bmp085/#modmdriverbmp085-bmp085-pressure-sensor","text":"The BMP085 is a high precision digital pressure sensor with I2C interface. Unfortunately this sensor is so sensitive, it will give you wrong results when there is traffic on the I2C during either temperature or pressure conversion. So during that time make sure no other sensors on the bus are read out. For further information, consult the datasheet . Also compatible to and tested with BMP180.","title":"modm:driver:bmp085: BMP085 Pressure Sensor"},{"location":"reference/module/modm-driver-bmp085/#content","text":"// Class class modm :: Bmp085 < typename I2cMaster > ; class modm :: bmp085data :: Data ; class modm :: bmp085data :: DataBase ; class modm :: bmp085data :: DataDouble ; // Struct struct modm :: bmp085 ; struct modm :: bmp085data :: Calibration ; // Define #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL","title":"Content"},{"location":"reference/module/modm-driver-bmp085/#dependencies","text":"modm:driver:bmp085 modm_driver_bmp085 modm: driver: bmp085 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bmp085->modm_architecture_i2c_device modm_debug modm: debug modm_driver_bmp085->modm_debug modm_driver modm: driver modm_driver_bmp085->modm_driver modm_math_utils modm: math: utils modm_driver_bmp085->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bmp085->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bmp085->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-driver-drv832x-spi/","text":"These module docs are in beta and may be incomplete. modm:driver:drv832x_spi: DRV832xS: Three-Phase Smart Gate Driver \u00b6 This driver only covers the gate driver configuration accessible via SPI interface. DRV832x Datasheet . Content \u00b6 // Class class modm :: Drv832xSpi < class SpiMaster , class Cs > ; // Struct struct modm :: drv832xSpi ; // Function IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: CsaControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: DriverControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: FaultStatus1_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveHS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveLS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: OcpControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: VgsStatus2_t & c ); Dependencies \u00b6 modm:driver:drv832x_spi modm_driver_drv832x_spi modm: driver: drv832x_spi modm_architecture_gpio modm: architecture: gpio modm_driver_drv832x_spi->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_drv832x_spi->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_drv832x_spi->modm_architecture_spi_device modm_driver modm: driver modm_driver_drv832x_spi->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_drv832x_spi->modm_processing_resumable","title":"modm:driver:drv832x_spi"},{"location":"reference/module/modm-driver-drv832x-spi/#modmdriverdrv832x_spi-drv832xs-three-phase-smart-gate-driver","text":"This driver only covers the gate driver configuration accessible via SPI interface. DRV832x Datasheet .","title":"modm:driver:drv832x_spi: DRV832xS: Three-Phase Smart Gate Driver"},{"location":"reference/module/modm-driver-drv832x-spi/#content","text":"// Class class modm :: Drv832xSpi < class SpiMaster , class Cs > ; // Struct struct modm :: drv832xSpi ; // Function IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: CsaControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: DriverControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: FaultStatus1_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveHS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveLS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: OcpControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: VgsStatus2_t & c );","title":"Content"},{"location":"reference/module/modm-driver-drv832x-spi/#dependencies","text":"modm:driver:drv832x_spi modm_driver_drv832x_spi modm: driver: drv832x_spi modm_architecture_gpio modm: architecture: gpio modm_driver_drv832x_spi->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_drv832x_spi->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_drv832x_spi->modm_architecture_spi_device modm_driver modm: driver modm_driver_drv832x_spi->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_drv832x_spi->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-ds1302/","text":"These module docs are in beta and may be incomplete. modm:driver:ds1302: DS1302 Real-Time Clock \u00b6 Content \u00b6 // Class class modm :: Ds1302 < class PinSet > ; // Struct struct modm :: ds1302 :: Config ; struct modm :: ds1302 :: Data ; struct modm :: ds1302 ; Dependencies \u00b6 modm:driver:ds1302 modm_driver_ds1302 modm: driver: ds1302 modm_architecture_delay modm: architecture: delay modm_driver_ds1302->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ds1302->modm_architecture_gpio modm_driver modm: driver modm_driver_ds1302->modm_driver","title":"modm:driver:ds1302"},{"location":"reference/module/modm-driver-ds1302/#modmdriverds1302-ds1302-real-time-clock","text":"","title":"modm:driver:ds1302: DS1302 Real-Time Clock"},{"location":"reference/module/modm-driver-ds1302/#content","text":"// Class class modm :: Ds1302 < class PinSet > ; // Struct struct modm :: ds1302 :: Config ; struct modm :: ds1302 :: Data ; struct modm :: ds1302 ;","title":"Content"},{"location":"reference/module/modm-driver-ds1302/#dependencies","text":"modm:driver:ds1302 modm_driver_ds1302 modm: driver: ds1302 modm_architecture_delay modm: architecture: delay modm_driver_ds1302->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ds1302->modm_architecture_gpio modm_driver modm: driver modm_driver_ds1302->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-ds1631/","text":"These module docs are in beta and may be incomplete. modm:driver:ds1631: DS1x31 Temperature Sensor \u00b6 Content \u00b6 // Class class modm :: Ds1631 < typename I2cMaster > ; // Struct struct modm :: ds1631 ; Dependencies \u00b6 modm:driver:ds1631 modm_driver_ds1631 modm: driver: ds1631 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ds1631->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ds1631->modm_architecture_register modm_driver modm: driver modm_driver_ds1631->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_ds1631->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_ds1631->modm_processing_protothread","title":"modm:driver:ds1631"},{"location":"reference/module/modm-driver-ds1631/#modmdriverds1631-ds1x31-temperature-sensor","text":"","title":"modm:driver:ds1631: DS1x31 Temperature Sensor"},{"location":"reference/module/modm-driver-ds1631/#content","text":"// Class class modm :: Ds1631 < typename I2cMaster > ; // Struct struct modm :: ds1631 ;","title":"Content"},{"location":"reference/module/modm-driver-ds1631/#dependencies","text":"modm:driver:ds1631 modm_driver_ds1631 modm: driver: ds1631 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ds1631->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ds1631->modm_architecture_register modm_driver modm: driver modm_driver_ds1631->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_ds1631->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_ds1631->modm_processing_protothread","title":"Dependencies"},{"location":"reference/module/modm-driver-ds18b20/","text":"These module docs are in beta and may be incomplete. modm:driver:ds18b20: 1-Wire Thermometer \u00b6 Programmable resolution 1-wire digital thermometer. The DS18B20 digital thermometer provides 9-bit to 12-bit Celsius temperature measurements and has an alarm function with non-volatile user-programmable upper and lower trigger points. The DS18B20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor. It has an operating temperature range of -55\u00b0C to +125\u00b0C and is accurate to \u00b10.5\u00b0C over the range of -10\u00b0C to +85\u00b0C. In addition, the DS18B20 can derive power directly from the data line (\"parasite power\"), eliminating the need for an external power supply. Features: - Power Supply Range is 3.0V to 5.5V - Each device has a unique 64-Bit Serial Code Stored in an On-Board ROM - Thermometer Resolution is User Selectable from 9 to 12 Bits - Converts Temperature to 12-Bit Digital Word in 750ms (Max) Content \u00b6 // Class class modm :: Ds18b20 < typename OneWire > ; Dependencies \u00b6 modm:driver:ds18b20 modm_driver_ds18b20 modm: driver: ds18b20 modm_architecture_1_wire modm: architecture: 1-wire modm_driver_ds18b20->modm_architecture_1_wire modm_driver modm: driver modm_driver_ds18b20->modm_driver","title":"modm:driver:ds18b20"},{"location":"reference/module/modm-driver-ds18b20/#modmdriverds18b20-1-wire-thermometer","text":"Programmable resolution 1-wire digital thermometer. The DS18B20 digital thermometer provides 9-bit to 12-bit Celsius temperature measurements and has an alarm function with non-volatile user-programmable upper and lower trigger points. The DS18B20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor. It has an operating temperature range of -55\u00b0C to +125\u00b0C and is accurate to \u00b10.5\u00b0C over the range of -10\u00b0C to +85\u00b0C. In addition, the DS18B20 can derive power directly from the data line (\"parasite power\"), eliminating the need for an external power supply. Features: - Power Supply Range is 3.0V to 5.5V - Each device has a unique 64-Bit Serial Code Stored in an On-Board ROM - Thermometer Resolution is User Selectable from 9 to 12 Bits - Converts Temperature to 12-Bit Digital Word in 750ms (Max)","title":"modm:driver:ds18b20: 1-Wire Thermometer"},{"location":"reference/module/modm-driver-ds18b20/#content","text":"// Class class modm :: Ds18b20 < typename OneWire > ;","title":"Content"},{"location":"reference/module/modm-driver-ds18b20/#dependencies","text":"modm:driver:ds18b20 modm_driver_ds18b20 modm: driver: ds18b20 modm_architecture_1_wire modm: architecture: 1-wire modm_driver_ds18b20->modm_architecture_1_wire modm_driver modm: driver modm_driver_ds18b20->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-ea-dog/","text":"These module docs are in beta and may be incomplete. modm:driver:ea_dog: EA-DOG Displays \u00b6 Options \u00b6 ST7036_voltage \u00b6 Select the supply voltage of the ST7036.: 3.3V \u2208 { 3.3V, 5V } Content \u00b6 // Class class modm :: DogL128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM081 < typename SPI , typename CS , typename RS > ; class modm :: DogM128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM132 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM162 < typename SPI , typename CS , typename RS > ; class modm :: DogM163 < typename SPI , typename CS , typename RS > ; class modm :: DogS102 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: St7036 < typename SPI , typename CS , typename RS , unsigned int Width , unsigned int Heigth > ; class modm :: St7565 < typename SPI , typename CS , typename A0 , typename Reset , unsigned int Width , unsigned int Height , bool TopView > ; // Variable const uint8_t modm :: st7565 :: configuration_dogm132 [ 12 ] ; const uint8_t modm :: st7565 :: configuration_dogs102 [ 11 ] ; const uint8_t modm :: st7565 :: configuration_dogx128 [ 12 ] ; // Define #define ST7565_ADC_NORMAL #define ST7565_ADC_REVERSE #define ST7565_BIAS_1_7 #define ST7565_BIAS_1_9 #define ST7565_BOOSTER_234 #define ST7565_BOOSTER_5 #define ST7565_BOOSTER_6 #define ST7565_BOOSTER_SET #define ST7565_COL_ADDRESS_LSB #define ST7565_COL_ADDRESS_MSB #define ST7565_INDICATOR_MODE_1HZ #define ST7565_INDICATOR_MODE_2HZ #define ST7565_INDICATOR_MODE_OFF #define ST7565_INDICATOR_MODE_ON #define ST7565_INDICATOR_OFF #define ST7565_INDICATOR_ON #define ST7565_NOP #define ST7565_NORMAL #define ST7565_OFF #define ST7565_ON #define ST7565_PAGE_ADDRESS #define ST7565_POWER_CONTROL #define ST7565_POWER_LOW_POWER #define ST7565_POWER_LOW_VOLTAGE #define ST7565_POWER_WIDE_RANGE #define ST7565_RESET_CMD #define ST7565_REVERSE #define ST7565_SCAN_DIR_NORMAL #define ST7565_SCAN_DIR_REVERSE #define ST7565_SHOW_ALL_POINTS #define ST7565_SHOW_NORMAL #define ST7565_VOLTAGE #define ST7565_VOLUME_MODE_1 #define ST7565_VOLUME_MODE_2 Dependencies \u00b6 modm:driver:ea_dog modm_driver_ea_dog modm: driver: ea_dog modm_architecture_accessor modm: architecture: accessor modm_driver_ea_dog->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ea_dog->modm_architecture_delay modm_driver modm: driver modm_driver_ea_dog->modm_driver modm_ui_display modm: ui: display modm_driver_ea_dog->modm_ui_display","title":"modm:driver:ea_dog"},{"location":"reference/module/modm-driver-ea-dog/#modmdriverea_dog-ea-dog-displays","text":"","title":"modm:driver:ea_dog: EA-DOG Displays"},{"location":"reference/module/modm-driver-ea-dog/#options","text":"","title":"Options"},{"location":"reference/module/modm-driver-ea-dog/#st7036_voltage","text":"Select the supply voltage of the ST7036.: 3.3V \u2208 { 3.3V, 5V }","title":"ST7036_voltage"},{"location":"reference/module/modm-driver-ea-dog/#content","text":"// Class class modm :: DogL128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM081 < typename SPI , typename CS , typename RS > ; class modm :: DogM128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM132 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM162 < typename SPI , typename CS , typename RS > ; class modm :: DogM163 < typename SPI , typename CS , typename RS > ; class modm :: DogS102 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: St7036 < typename SPI , typename CS , typename RS , unsigned int Width , unsigned int Heigth > ; class modm :: St7565 < typename SPI , typename CS , typename A0 , typename Reset , unsigned int Width , unsigned int Height , bool TopView > ; // Variable const uint8_t modm :: st7565 :: configuration_dogm132 [ 12 ] ; const uint8_t modm :: st7565 :: configuration_dogs102 [ 11 ] ; const uint8_t modm :: st7565 :: configuration_dogx128 [ 12 ] ; // Define #define ST7565_ADC_NORMAL #define ST7565_ADC_REVERSE #define ST7565_BIAS_1_7 #define ST7565_BIAS_1_9 #define ST7565_BOOSTER_234 #define ST7565_BOOSTER_5 #define ST7565_BOOSTER_6 #define ST7565_BOOSTER_SET #define ST7565_COL_ADDRESS_LSB #define ST7565_COL_ADDRESS_MSB #define ST7565_INDICATOR_MODE_1HZ #define ST7565_INDICATOR_MODE_2HZ #define ST7565_INDICATOR_MODE_OFF #define ST7565_INDICATOR_MODE_ON #define ST7565_INDICATOR_OFF #define ST7565_INDICATOR_ON #define ST7565_NOP #define ST7565_NORMAL #define ST7565_OFF #define ST7565_ON #define ST7565_PAGE_ADDRESS #define ST7565_POWER_CONTROL #define ST7565_POWER_LOW_POWER #define ST7565_POWER_LOW_VOLTAGE #define ST7565_POWER_WIDE_RANGE #define ST7565_RESET_CMD #define ST7565_REVERSE #define ST7565_SCAN_DIR_NORMAL #define ST7565_SCAN_DIR_REVERSE #define ST7565_SHOW_ALL_POINTS #define ST7565_SHOW_NORMAL #define ST7565_VOLTAGE #define ST7565_VOLUME_MODE_1 #define ST7565_VOLUME_MODE_2","title":"Content"},{"location":"reference/module/modm-driver-ea-dog/#dependencies","text":"modm:driver:ea_dog modm_driver_ea_dog modm: driver: ea_dog modm_architecture_accessor modm: architecture: accessor modm_driver_ea_dog->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ea_dog->modm_architecture_delay modm_driver modm: driver modm_driver_ea_dog->modm_driver modm_ui_display modm: ui: display modm_driver_ea_dog->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-fat/","text":"These module docs are in beta and may be incomplete. modm:driver:fat: FAT File System \u00b6 Content \u00b6 // Class class modm :: fat :: Directory ; class modm :: fat :: File ; class modm :: fat :: FileInfo ; class modm :: fat :: FileSystem ; class modm :: fat :: PhysicalVolume ; // Typedef typedef DRESULT modm :: fat :: Result ; typedef DSTATUS modm :: fat :: Status ; Dependencies \u00b6 modm:driver:fat modm_driver_fat modm: driver: fat modm_driver modm: driver modm_driver_fat->modm_driver modm_fatfs modm: fatfs modm_driver_fat->modm_fatfs","title":"modm:driver:fat"},{"location":"reference/module/modm-driver-fat/#modmdriverfat-fat-file-system","text":"","title":"modm:driver:fat: FAT File System"},{"location":"reference/module/modm-driver-fat/#content","text":"// Class class modm :: fat :: Directory ; class modm :: fat :: File ; class modm :: fat :: FileInfo ; class modm :: fat :: FileSystem ; class modm :: fat :: PhysicalVolume ; // Typedef typedef DRESULT modm :: fat :: Result ; typedef DSTATUS modm :: fat :: Status ;","title":"Content"},{"location":"reference/module/modm-driver-fat/#dependencies","text":"modm:driver:fat modm_driver_fat modm: driver: fat modm_driver modm: driver modm_driver_fat->modm_driver modm_fatfs modm: fatfs modm_driver_fat->modm_fatfs","title":"Dependencies"},{"location":"reference/module/modm-driver-ft245/","text":"These module docs are in beta and may be incomplete. modm:driver:ft245: FT245 USB FIFO \u00b6 The FT245R USB FIFO from Future Technology Devices International is a single chip USB to parallel FIFO bidirectional data transfer interface. Wr and Rd must be GpioOutputs and set to output mode before. Rxf and Txe must be GpioInputs. Port is switched between input and output mode. Example \u00b6 #include <modm/architecture.hpp> #include <modm/driver/usb/ft245.hpp> using namespace modm :: platform ; using myPort = GpioPort < GpioD0 , 8 > ; using Rxf = GpioInputC11 ; using Txe = GpioInputC10 ; using Rd = GpioOutputA15 ; using Wr = GpioOutputA9 ; using myFt = modm :: Ft245 < myPort , Rd , Wr , Rxf , Txe > ; int main () { Rd :: setOutput ( modm :: Gpio :: High ); Wr :: setOutput ( modm :: Gpio :: Low ); while ( 1 ) { uint8_t c ; if ( myFt :: read ( c )) { myFt :: write ( c + 1 ); } } } Content \u00b6 // Class class modm :: Ft245 < typename PORT , typename RD , typename WR , typename RXF , typename TXE > ; Dependencies \u00b6 modm:driver:ft245 modm_driver_ft245 modm: driver: ft245 modm_architecture_gpio modm: architecture: gpio modm_driver_ft245->modm_architecture_gpio modm_driver modm: driver modm_driver_ft245->modm_driver","title":"modm:driver:ft245"},{"location":"reference/module/modm-driver-ft245/#modmdriverft245-ft245-usb-fifo","text":"The FT245R USB FIFO from Future Technology Devices International is a single chip USB to parallel FIFO bidirectional data transfer interface. Wr and Rd must be GpioOutputs and set to output mode before. Rxf and Txe must be GpioInputs. Port is switched between input and output mode.","title":"modm:driver:ft245: FT245 USB FIFO"},{"location":"reference/module/modm-driver-ft245/#example","text":"#include <modm/architecture.hpp> #include <modm/driver/usb/ft245.hpp> using namespace modm :: platform ; using myPort = GpioPort < GpioD0 , 8 > ; using Rxf = GpioInputC11 ; using Txe = GpioInputC10 ; using Rd = GpioOutputA15 ; using Wr = GpioOutputA9 ; using myFt = modm :: Ft245 < myPort , Rd , Wr , Rxf , Txe > ; int main () { Rd :: setOutput ( modm :: Gpio :: High ); Wr :: setOutput ( modm :: Gpio :: Low ); while ( 1 ) { uint8_t c ; if ( myFt :: read ( c )) { myFt :: write ( c + 1 ); } } }","title":"Example"},{"location":"reference/module/modm-driver-ft245/#content","text":"// Class class modm :: Ft245 < typename PORT , typename RD , typename WR , typename RXF , typename TXE > ;","title":"Content"},{"location":"reference/module/modm-driver-ft245/#dependencies","text":"modm:driver:ft245 modm_driver_ft245 modm: driver: ft245 modm_architecture_gpio modm: architecture: gpio modm_driver_ft245->modm_architecture_gpio modm_driver modm: driver modm_driver_ft245->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-ft6x06/","text":"These module docs are in beta and may be incomplete. modm:driver:ft6x06: FT6x06 Capacitive Touch Controller \u00b6 Content \u00b6 // Class class modm :: Ft6x06 < typename I2cMaster > ; // Struct struct modm :: ft6x06 :: Data ; struct modm :: ft6x06 :: touch_t ; struct modm :: ft6x06 ; Dependencies \u00b6 modm:driver:ft6x06 modm_driver_ft6x06 modm: driver: ft6x06 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ft6x06->modm_architecture_i2c_device modm_driver modm: driver modm_driver_ft6x06->modm_driver modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_driver_ft6x06","title":"modm:driver:ft6x06"},{"location":"reference/module/modm-driver-ft6x06/#modmdriverft6x06-ft6x06-capacitive-touch-controller","text":"","title":"modm:driver:ft6x06: FT6x06 Capacitive Touch Controller"},{"location":"reference/module/modm-driver-ft6x06/#content","text":"// Class class modm :: Ft6x06 < typename I2cMaster > ; // Struct struct modm :: ft6x06 :: Data ; struct modm :: ft6x06 :: touch_t ; struct modm :: ft6x06 ;","title":"Content"},{"location":"reference/module/modm-driver-ft6x06/#dependencies","text":"modm:driver:ft6x06 modm_driver_ft6x06 modm: driver: ft6x06 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ft6x06->modm_architecture_i2c_device modm_driver modm: driver modm_driver_ft6x06->modm_driver modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_driver_ft6x06","title":"Dependencies"},{"location":"reference/module/modm-driver-hclax/","text":"These module docs are in beta and may be incomplete. modm:driver:hclax: HCLA Pressure Sensor \u00b6 Driver for the HCLA differential pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 250 \u03bcs within the output registers of the internal ASIC. Content \u00b6 // Class class modm :: HclaX < typename I2cMaster > ; // Struct struct modm :: hclax :: Data ; struct modm :: hclax ; Dependencies \u00b6 modm:driver:hclax modm_driver_hclax modm: driver: hclax modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hclax->modm_architecture_i2c_device modm_driver modm: driver modm_driver_hclax->modm_driver modm_math_utils modm: math: utils modm_driver_hclax->modm_math_utils","title":"modm:driver:hclax"},{"location":"reference/module/modm-driver-hclax/#modmdriverhclax-hcla-pressure-sensor","text":"Driver for the HCLA differential pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 250 \u03bcs within the output registers of the internal ASIC.","title":"modm:driver:hclax: HCLA Pressure Sensor"},{"location":"reference/module/modm-driver-hclax/#content","text":"// Class class modm :: HclaX < typename I2cMaster > ; // Struct struct modm :: hclax :: Data ; struct modm :: hclax ;","title":"Content"},{"location":"reference/module/modm-driver-hclax/#dependencies","text":"modm:driver:hclax modm_driver_hclax modm: driver: hclax modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hclax->modm_architecture_i2c_device modm_driver modm: driver modm_driver_hclax->modm_driver modm_math_utils modm: math: utils modm_driver_hclax->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-hd44780/","text":"These module docs are in beta and may be incomplete. modm:driver:hd44780: HD44780 Displays \u00b6 Content \u00b6 // Class class modm :: Hd44780 < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Base < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Dual < typename DATA , typename RW , typename RS , typename E1 , typename E2 > ; // Struct struct modm :: Hd44780Base :: Bus < Data , Enable , 4 > ; struct modm :: Hd44780Base :: Bus < Data , Enable , 8 > ; struct modm :: Hd44780Base :: Bus < typename Data , typename Enable , uint8_t Width > ; Dependencies \u00b6 modm:driver:hd44780 modm_driver_hd44780 modm: driver: hd44780 modm_architecture_delay modm: architecture: delay modm_driver_hd44780->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_hd44780->modm_architecture_gpio modm_driver modm: driver modm_driver_hd44780->modm_driver modm_ui_display modm: ui: display modm_driver_hd44780->modm_ui_display","title":"modm:driver:hd44780"},{"location":"reference/module/modm-driver-hd44780/#modmdriverhd44780-hd44780-displays","text":"","title":"modm:driver:hd44780: HD44780 Displays"},{"location":"reference/module/modm-driver-hd44780/#content","text":"// Class class modm :: Hd44780 < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Base < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Dual < typename DATA , typename RW , typename RS , typename E1 , typename E2 > ; // Struct struct modm :: Hd44780Base :: Bus < Data , Enable , 4 > ; struct modm :: Hd44780Base :: Bus < Data , Enable , 8 > ; struct modm :: Hd44780Base :: Bus < typename Data , typename Enable , uint8_t Width > ;","title":"Content"},{"location":"reference/module/modm-driver-hd44780/#dependencies","text":"modm:driver:hd44780 modm_driver_hd44780 modm: driver: hd44780 modm_architecture_delay modm: architecture: delay modm_driver_hd44780->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_hd44780->modm_architecture_gpio modm_driver modm: driver modm_driver_hd44780->modm_driver modm_ui_display modm: ui: display modm_driver_hd44780->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-hmc58x/","text":"These module docs are in beta and may be incomplete. modm:driver:hmc58x: HMC58x3 3-Axis Digital Magnetometer \u00b6 The HMC58x3 is a surface-mount, multi-chip module designed for low-field magnetic sensing with a digital interface for applications such as low-cost compassing and magnetometry. The HMC58x3 includes high-resolution magneto-resistive sensors plus an ASIC containing amplification, automatic degaussing strap drivers, offset cancellation, and a 12-bit ADC that enables 1-2 degrees compass heading accuracy. Content \u00b6 // Class class modm :: Hmc5843 < typename I2cMaster > ; class modm :: Hmc5883 < typename I2cMaster > ; class modm :: Hmc58x3 < typename I2cMaster > ; // Struct struct modm :: hmc5843 ; struct modm :: hmc5883 ; struct modm :: hmc58x3 :: Data ; struct modm :: hmc58x3 ; Dependencies \u00b6 modm:driver:hmc58x modm_driver_hmc58x modm: driver: hmc58x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc58x->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc58x->modm_architecture_register modm_driver modm: driver modm_driver_hmc58x->modm_driver modm_math_utils modm: math: utils modm_driver_hmc58x->modm_math_utils","title":"modm:driver:hmc58x"},{"location":"reference/module/modm-driver-hmc58x/#modmdriverhmc58x-hmc58x3-3-axis-digital-magnetometer","text":"The HMC58x3 is a surface-mount, multi-chip module designed for low-field magnetic sensing with a digital interface for applications such as low-cost compassing and magnetometry. The HMC58x3 includes high-resolution magneto-resistive sensors plus an ASIC containing amplification, automatic degaussing strap drivers, offset cancellation, and a 12-bit ADC that enables 1-2 degrees compass heading accuracy.","title":"modm:driver:hmc58x: HMC58x3 3-Axis Digital Magnetometer"},{"location":"reference/module/modm-driver-hmc58x/#content","text":"// Class class modm :: Hmc5843 < typename I2cMaster > ; class modm :: Hmc5883 < typename I2cMaster > ; class modm :: Hmc58x3 < typename I2cMaster > ; // Struct struct modm :: hmc5843 ; struct modm :: hmc5883 ; struct modm :: hmc58x3 :: Data ; struct modm :: hmc58x3 ;","title":"Content"},{"location":"reference/module/modm-driver-hmc58x/#dependencies","text":"modm:driver:hmc58x modm_driver_hmc58x modm: driver: hmc58x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc58x->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc58x->modm_architecture_register modm_driver modm: driver modm_driver_hmc58x->modm_driver modm_math_utils modm: math: utils modm_driver_hmc58x->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-hmc6343/","text":"These module docs are in beta and may be incomplete. modm:driver:hmc6343: HMC6343 3-Axis Compass \u00b6 The Honeywell HMC6343 is a fully integrated compass module that includes firmware for heading computation and calibration for magnetic distortions. The module combines 3-axis magneto-resistive sensors and 3-axis MEMS accelerometers, analog and digital support circuits, microprocessor and algorithms required for heading computation. Content \u00b6 // Class class modm :: Hmc6343 < class I2cMaster > ; // Struct struct modm :: hmc6343 :: Data ; struct modm :: hmc6343 ; Dependencies \u00b6 modm:driver:hmc6343 modm_driver_hmc6343 modm: driver: hmc6343 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc6343->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc6343->modm_architecture_register modm_driver modm: driver modm_driver_hmc6343->modm_driver modm_math_utils modm: math: utils modm_driver_hmc6343->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_hmc6343->modm_processing_protothread","title":"modm:driver:hmc6343"},{"location":"reference/module/modm-driver-hmc6343/#modmdriverhmc6343-hmc6343-3-axis-compass","text":"The Honeywell HMC6343 is a fully integrated compass module that includes firmware for heading computation and calibration for magnetic distortions. The module combines 3-axis magneto-resistive sensors and 3-axis MEMS accelerometers, analog and digital support circuits, microprocessor and algorithms required for heading computation.","title":"modm:driver:hmc6343: HMC6343 3-Axis Compass"},{"location":"reference/module/modm-driver-hmc6343/#content","text":"// Class class modm :: Hmc6343 < class I2cMaster > ; // Struct struct modm :: hmc6343 :: Data ; struct modm :: hmc6343 ;","title":"Content"},{"location":"reference/module/modm-driver-hmc6343/#dependencies","text":"modm:driver:hmc6343 modm_driver_hmc6343 modm: driver: hmc6343 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc6343->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc6343->modm_architecture_register modm_driver modm: driver modm_driver_hmc6343->modm_driver modm_math_utils modm: math: utils modm_driver_hmc6343->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_hmc6343->modm_processing_protothread","title":"Dependencies"},{"location":"reference/module/modm-driver-i2c-eeprom/","text":"These module docs are in beta and may be incomplete. modm:driver:i2c.eeprom: I2C Eeprom \u00b6 Compatible with the 24C256 (ST) and 24FC1025 (Microchip) family and other I2C eeprom with an 16-bit address pointer. Base address for most 24xxyyyy eeproms is 0x50. Content \u00b6 // Class class modm :: I2cEeprom < typename I2cMaster > ; Dependencies \u00b6 modm:driver:i2c.eeprom modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_i2c_eeprom->modm_architecture_i2c_device modm_driver modm: driver modm_driver_i2c_eeprom->modm_driver","title":"modm:driver:i2c.eeprom"},{"location":"reference/module/modm-driver-i2c-eeprom/#modmdriveri2ceeprom-i2c-eeprom","text":"Compatible with the 24C256 (ST) and 24FC1025 (Microchip) family and other I2C eeprom with an 16-bit address pointer. Base address for most 24xxyyyy eeproms is 0x50.","title":"modm:driver:i2c.eeprom: I2C Eeprom"},{"location":"reference/module/modm-driver-i2c-eeprom/#content","text":"// Class class modm :: I2cEeprom < typename I2cMaster > ;","title":"Content"},{"location":"reference/module/modm-driver-i2c-eeprom/#dependencies","text":"modm:driver:i2c.eeprom modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_i2c_eeprom->modm_architecture_i2c_device modm_driver modm: driver modm_driver_i2c_eeprom->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-itg3200/","text":"These module docs are in beta and may be incomplete. modm:driver:itg3200: ITG3200 Digital Gyroscope \u00b6 For further information on the special sensing functions, consult the datasheet . Content \u00b6 // Class class modm :: Itg3200 < typename I2cMaster > ; // Struct struct modm :: itg3200 :: Data ; struct modm :: itg3200 ; Dependencies \u00b6 modm:driver:itg3200 modm_driver_itg3200 modm: driver: itg3200 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_itg3200->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_itg3200->modm_architecture_register modm_driver modm: driver modm_driver_itg3200->modm_driver modm_math_utils modm: math: utils modm_driver_itg3200->modm_math_utils","title":"modm:driver:itg3200"},{"location":"reference/module/modm-driver-itg3200/#modmdriveritg3200-itg3200-digital-gyroscope","text":"For further information on the special sensing functions, consult the datasheet .","title":"modm:driver:itg3200: ITG3200 Digital Gyroscope"},{"location":"reference/module/modm-driver-itg3200/#content","text":"// Class class modm :: Itg3200 < typename I2cMaster > ; // Struct struct modm :: itg3200 :: Data ; struct modm :: itg3200 ;","title":"Content"},{"location":"reference/module/modm-driver-itg3200/#dependencies","text":"modm:driver:itg3200 modm_driver_itg3200 modm: driver: itg3200 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_itg3200->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_itg3200->modm_architecture_register modm_driver modm: driver modm_driver_itg3200->modm_driver modm_math_utils modm: math: utils modm_driver_itg3200->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-l3gd20/","text":"These module docs are in beta and may be incomplete. modm:driver:l3gd20: L3GD20 3-Axis Gyroscope \u00b6 The L3GD20 is a low-power three-axis angular rate sensor. The L3GD20 has a full scale of \u00b1250/\u00b1500/\u00b12000 dps and is capable of measuring rates with a user-selectable bandwidth. Content \u00b6 // Class class modm :: L3gd20 < class Transport > ; // Struct struct modm :: l3gd20 :: Data ; struct modm :: l3gd20 ; Dependencies \u00b6 modm:driver:l3gd20 modm_driver_l3gd20 modm: driver: l3gd20 modm_architecture_register modm: architecture: register modm_driver_l3gd20->modm_architecture_register modm_driver modm: driver modm_driver_l3gd20->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_l3gd20->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_l3gd20->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_l3gd20->modm_processing_resumable","title":"modm:driver:l3gd20"},{"location":"reference/module/modm-driver-l3gd20/#modmdriverl3gd20-l3gd20-3-axis-gyroscope","text":"The L3GD20 is a low-power three-axis angular rate sensor. The L3GD20 has a full scale of \u00b1250/\u00b1500/\u00b12000 dps and is capable of measuring rates with a user-selectable bandwidth.","title":"modm:driver:l3gd20: L3GD20 3-Axis Gyroscope"},{"location":"reference/module/modm-driver-l3gd20/#content","text":"// Class class modm :: L3gd20 < class Transport > ; // Struct struct modm :: l3gd20 :: Data ; struct modm :: l3gd20 ;","title":"Content"},{"location":"reference/module/modm-driver-l3gd20/#dependencies","text":"modm:driver:l3gd20 modm_driver_l3gd20 modm: driver: l3gd20 modm_architecture_register modm: architecture: register modm_driver_l3gd20->modm_architecture_register modm_driver modm: driver modm_driver_l3gd20->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_l3gd20->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_l3gd20->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_l3gd20->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-lawicel/","text":"These module docs are in beta and may be incomplete. modm:driver:lawicel: Lawicel Format Converter \u00b6 Converts modm::can::Message to and from the Lawicel string format ( char * ). Lawicel AB ( http://www.lawicel.com ) offers medium sized CAN to USB and CAN to RS232 converters. Their data format is widely used. This converter only understands messages of type 'r', 't', 'R' and 'T' which transmits CAN frames. It does not understand commands to change the baud rate. Content \u00b6 // Class class modm :: CanLawicelFormatter ; Dependencies \u00b6 modm:driver:lawicel modm_driver_lawicel modm: driver: lawicel modm_architecture_can modm: architecture: can modm_driver_lawicel->modm_architecture_can modm_driver modm: driver modm_driver_lawicel->modm_driver","title":"modm:driver:lawicel"},{"location":"reference/module/modm-driver-lawicel/#modmdriverlawicel-lawicel-format-converter","text":"Converts modm::can::Message to and from the Lawicel string format ( char * ). Lawicel AB ( http://www.lawicel.com ) offers medium sized CAN to USB and CAN to RS232 converters. Their data format is widely used. This converter only understands messages of type 'r', 't', 'R' and 'T' which transmits CAN frames. It does not understand commands to change the baud rate.","title":"modm:driver:lawicel: Lawicel Format Converter"},{"location":"reference/module/modm-driver-lawicel/#content","text":"// Class class modm :: CanLawicelFormatter ;","title":"Content"},{"location":"reference/module/modm-driver-lawicel/#dependencies","text":"modm:driver:lawicel modm_driver_lawicel modm: driver: lawicel modm_architecture_can modm: architecture: can modm_driver_lawicel->modm_architecture_can modm_driver modm: driver modm_driver_lawicel->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-lis3-transport/","text":"These module docs are in beta and may be incomplete. modm:driver:lis3.transport: LIS3xx Transport Layer \u00b6 Content \u00b6 // Class class modm :: Lis3TransportI2c < class I2cMaster > ; class modm :: Lis3TransportSpi < class SpiMaster , class Cs > ; Dependencies \u00b6 modm:driver:lis3.transport modm_driver_lis3_transport modm: driver: lis3.transport modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lis3_transport->modm_architecture_i2c_device modm_architecture_spi_device modm: architecture: spi.device modm_driver_lis3_transport->modm_architecture_spi_device modm_driver modm: driver modm_driver_lis3_transport->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_lis3_transport->modm_processing_resumable modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_driver_lis3_transport modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_driver_lis3_transport modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_driver_lis3_transport modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_driver_lis3_transport","title":"modm:driver:lis3.transport"},{"location":"reference/module/modm-driver-lis3-transport/#modmdriverlis3transport-lis3xx-transport-layer","text":"","title":"modm:driver:lis3.transport: LIS3xx Transport Layer"},{"location":"reference/module/modm-driver-lis3-transport/#content","text":"// Class class modm :: Lis3TransportI2c < class I2cMaster > ; class modm :: Lis3TransportSpi < class SpiMaster , class Cs > ;","title":"Content"},{"location":"reference/module/modm-driver-lis3-transport/#dependencies","text":"modm:driver:lis3.transport modm_driver_lis3_transport modm: driver: lis3.transport modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lis3_transport->modm_architecture_i2c_device modm_architecture_spi_device modm: architecture: spi.device modm_driver_lis3_transport->modm_architecture_spi_device modm_driver modm: driver modm_driver_lis3_transport->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_lis3_transport->modm_processing_resumable modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_driver_lis3_transport modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_driver_lis3_transport modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_driver_lis3_transport modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_driver_lis3_transport","title":"Dependencies"},{"location":"reference/module/modm-driver-lis302dl/","text":"These module docs are in beta and may be incomplete. modm:driver:lis302dl: LIS302DL 3-Axis Accelerometer \u00b6 The LIS302DL is an ultra compact low-power three axes linear accelerometer. It includes a sensing element and an IC interface able to provide the measured acceleration to the external world through an I2C/SPI serial interface. Content \u00b6 // Class class modm :: Lis302dl < class Transport > ; // Struct struct modm :: lis302dl :: Data ; struct modm :: lis302dl ; Dependencies \u00b6 modm:driver:lis302dl modm_driver_lis302dl modm: driver: lis302dl modm_architecture_register modm: architecture: register modm_driver_lis302dl->modm_architecture_register modm_driver modm: driver modm_driver_lis302dl->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis302dl->modm_driver_lis3_transport modm_processing_resumable modm: processing: resumable modm_driver_lis302dl->modm_processing_resumable","title":"modm:driver:lis302dl"},{"location":"reference/module/modm-driver-lis302dl/#modmdriverlis302dl-lis302dl-3-axis-accelerometer","text":"The LIS302DL is an ultra compact low-power three axes linear accelerometer. It includes a sensing element and an IC interface able to provide the measured acceleration to the external world through an I2C/SPI serial interface.","title":"modm:driver:lis302dl: LIS302DL 3-Axis Accelerometer"},{"location":"reference/module/modm-driver-lis302dl/#content","text":"// Class class modm :: Lis302dl < class Transport > ; // Struct struct modm :: lis302dl :: Data ; struct modm :: lis302dl ;","title":"Content"},{"location":"reference/module/modm-driver-lis302dl/#dependencies","text":"modm:driver:lis302dl modm_driver_lis302dl modm: driver: lis302dl modm_architecture_register modm: architecture: register modm_driver_lis302dl->modm_architecture_register modm_driver modm: driver modm_driver_lis302dl->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis302dl->modm_driver_lis3_transport modm_processing_resumable modm: processing: resumable modm_driver_lis302dl->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-lis3dsh/","text":"These module docs are in beta and may be incomplete. modm:driver:lis3dsh: LIS3DSH 3-Axis Accelerometer \u00b6 The LIS3DSH is an ultra low-power high performance three-axis linear accelerometer belonging to the \"nano\" family with embedded state machine that can be programmed to implement autonomous applications. The LIS3DSH has dynamically selectable full scales of \u00b12g/\u00b14g/\u00b16g/\u00b18g/\u00b116g and it is capable of measuring accelerations with output data rates from 3.125 Hz to 1.6 kHz. Content \u00b6 // Class class modm :: Lis3dsh < class Transport > ; // Struct struct modm :: lis3dsh :: Data ; struct modm :: lis3dsh ; Dependencies \u00b6 modm:driver:lis3dsh modm_driver_lis3dsh modm: driver: lis3dsh modm_architecture_register modm: architecture: register modm_driver_lis3dsh->modm_architecture_register modm_driver modm: driver modm_driver_lis3dsh->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3dsh->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lis3dsh->modm_math_utils","title":"modm:driver:lis3dsh"},{"location":"reference/module/modm-driver-lis3dsh/#modmdriverlis3dsh-lis3dsh-3-axis-accelerometer","text":"The LIS3DSH is an ultra low-power high performance three-axis linear accelerometer belonging to the \"nano\" family with embedded state machine that can be programmed to implement autonomous applications. The LIS3DSH has dynamically selectable full scales of \u00b12g/\u00b14g/\u00b16g/\u00b18g/\u00b116g and it is capable of measuring accelerations with output data rates from 3.125 Hz to 1.6 kHz.","title":"modm:driver:lis3dsh: LIS3DSH 3-Axis Accelerometer"},{"location":"reference/module/modm-driver-lis3dsh/#content","text":"// Class class modm :: Lis3dsh < class Transport > ; // Struct struct modm :: lis3dsh :: Data ; struct modm :: lis3dsh ;","title":"Content"},{"location":"reference/module/modm-driver-lis3dsh/#dependencies","text":"modm:driver:lis3dsh modm_driver_lis3dsh modm: driver: lis3dsh modm_architecture_register modm: architecture: register modm_driver_lis3dsh->modm_architecture_register modm_driver modm: driver modm_driver_lis3dsh->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3dsh->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lis3dsh->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-lm75/","text":"These module docs are in beta and may be incomplete. modm:driver:lm75: LM75 Thermometer \u00b6 LM75 digital temperature sensor driver. The LM75 is a digital temperature sensor with an I2C interface and measures temperature over a range of -55 to +125 deg Celsius with a resolution of 0.5 deg C and an accuracy of up to 2 deg C. The sensor has a default refresh rate between 3Hz and 10Hz which is hardcoded into the sensor and cannot be changed. Content \u00b6 // Class class modm :: Lm75 < class I2cMaster > ; class modm :: Tmp102 < class I2cMaster > ; class modm :: Tmp175 < typename I2cMaster > ; // Struct struct modm :: lm75 :: Data ; struct modm :: lm75 ; Dependencies \u00b6 modm:driver:lm75 modm_driver_lm75 modm: driver: lm75 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lm75->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_lm75->modm_architecture_register modm_driver modm: driver modm_driver_lm75->modm_driver modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_driver_lm75 modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_driver_lm75 modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_driver_lm75","title":"modm:driver:lm75"},{"location":"reference/module/modm-driver-lm75/#modmdriverlm75-lm75-thermometer","text":"LM75 digital temperature sensor driver. The LM75 is a digital temperature sensor with an I2C interface and measures temperature over a range of -55 to +125 deg Celsius with a resolution of 0.5 deg C and an accuracy of up to 2 deg C. The sensor has a default refresh rate between 3Hz and 10Hz which is hardcoded into the sensor and cannot be changed.","title":"modm:driver:lm75: LM75 Thermometer"},{"location":"reference/module/modm-driver-lm75/#content","text":"// Class class modm :: Lm75 < class I2cMaster > ; class modm :: Tmp102 < class I2cMaster > ; class modm :: Tmp175 < typename I2cMaster > ; // Struct struct modm :: lm75 :: Data ; struct modm :: lm75 ;","title":"Content"},{"location":"reference/module/modm-driver-lm75/#dependencies","text":"modm:driver:lm75 modm_driver_lm75 modm: driver: lm75 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lm75->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_lm75->modm_architecture_register modm_driver modm: driver modm_driver_lm75->modm_driver modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_driver_lm75 modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_driver_lm75 modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_driver_lm75","title":"Dependencies"},{"location":"reference/module/modm-driver-lsm303a/","text":"These module docs are in beta and may be incomplete. modm:driver:lsm303a: LSM303DLHC 3-Axis Accelerometer \u00b6 The LSM303DLHC is a system-in-package featuring a 3D digital linear acceleration sensor and a 3D digital magnetic sensor. The sensor has linear acceleration full scales of \u00b12g/\u00b14g/\u00b18g/\u00b116g and a magnetic field full scale of \u00b11.3/\u00b11.9/\u00b12.5/\u00b14.0/\u00b14.7/\u00b15.6/\u00b18.1 gauss. The LSM303DLHC includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz. Since the device actually features two I2C devices which are just placed in the same package, this class only implements the acceleration sensor. Content \u00b6 // Class class modm :: Lsm303a < class I2cMaster > ; // Struct struct modm :: lsm303a :: Data ; struct modm :: lsm303a ; Dependencies \u00b6 modm:driver:lsm303a modm_driver_lsm303a modm: driver: lsm303a modm_architecture_register modm: architecture: register modm_driver_lsm303a->modm_architecture_register modm_driver modm: driver modm_driver_lsm303a->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm303a->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lsm303a->modm_math_utils","title":"modm:driver:lsm303a"},{"location":"reference/module/modm-driver-lsm303a/#modmdriverlsm303a-lsm303dlhc-3-axis-accelerometer","text":"The LSM303DLHC is a system-in-package featuring a 3D digital linear acceleration sensor and a 3D digital magnetic sensor. The sensor has linear acceleration full scales of \u00b12g/\u00b14g/\u00b18g/\u00b116g and a magnetic field full scale of \u00b11.3/\u00b11.9/\u00b12.5/\u00b14.0/\u00b14.7/\u00b15.6/\u00b18.1 gauss. The LSM303DLHC includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz. Since the device actually features two I2C devices which are just placed in the same package, this class only implements the acceleration sensor.","title":"modm:driver:lsm303a: LSM303DLHC 3-Axis Accelerometer"},{"location":"reference/module/modm-driver-lsm303a/#content","text":"// Class class modm :: Lsm303a < class I2cMaster > ; // Struct struct modm :: lsm303a :: Data ; struct modm :: lsm303a ;","title":"Content"},{"location":"reference/module/modm-driver-lsm303a/#dependencies","text":"modm:driver:lsm303a modm_driver_lsm303a modm: driver: lsm303a modm_architecture_register modm: architecture: register modm_driver_lsm303a->modm_architecture_register modm_driver modm: driver modm_driver_lsm303a->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm303a->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lsm303a->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-driver-ltc2984/","text":"These module docs are in beta and may be incomplete. modm:driver:ltc2984: LTC298x Thermometer \u00b6 LTC2983/LTC2984: Integrated temperature measurement system (20 channel) The integrated EEPROM of the LTC2984 is not supported by now. LTC2984 and LTC2983 are 100%% compatible except the LTC2983 has no integrated EEPROM. Datasheet Content \u00b6 // Class class modm :: Ltc2984 < class SpiMaster , class Cs > ; // Struct struct modm :: ltc2984 :: Configuration :: Rsense ; struct modm :: ltc2984 :: Configuration :: Rtd ; struct modm :: ltc2984 :: Configuration ; struct modm :: ltc2984 :: Data ; struct modm :: ltc2984 ; // Function IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data & c ); IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data :: Status & c ); ltc2984 :: CommandStatus modm :: operator | ( ltc2984 :: CommandStatus r , ltc2984 :: Channel c ); ltc2984 :: Register modm :: operator + ( ltc2984 :: Register r , ltc2984 :: Channel c ); Dependencies \u00b6 modm:driver:ltc2984 modm_driver_ltc2984 modm: driver: ltc2984 modm_architecture_gpio modm: architecture: gpio modm_driver_ltc2984->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ltc2984->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ltc2984->modm_architecture_spi_device modm_driver modm: driver modm_driver_ltc2984->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_ltc2984->modm_processing_resumable","title":"modm:driver:ltc2984"},{"location":"reference/module/modm-driver-ltc2984/#modmdriverltc2984-ltc298x-thermometer","text":"LTC2983/LTC2984: Integrated temperature measurement system (20 channel) The integrated EEPROM of the LTC2984 is not supported by now. LTC2984 and LTC2983 are 100%% compatible except the LTC2983 has no integrated EEPROM. Datasheet","title":"modm:driver:ltc2984: LTC298x Thermometer"},{"location":"reference/module/modm-driver-ltc2984/#content","text":"// Class class modm :: Ltc2984 < class SpiMaster , class Cs > ; // Struct struct modm :: ltc2984 :: Configuration :: Rsense ; struct modm :: ltc2984 :: Configuration :: Rtd ; struct modm :: ltc2984 :: Configuration ; struct modm :: ltc2984 :: Data ; struct modm :: ltc2984 ; // Function IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data & c ); IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data :: Status & c ); ltc2984 :: CommandStatus modm :: operator | ( ltc2984 :: CommandStatus r , ltc2984 :: Channel c ); ltc2984 :: Register modm :: operator + ( ltc2984 :: Register r , ltc2984 :: Channel c );","title":"Content"},{"location":"reference/module/modm-driver-ltc2984/#dependencies","text":"modm:driver:ltc2984 modm_driver_ltc2984 modm: driver: ltc2984 modm_architecture_gpio modm: architecture: gpio modm_driver_ltc2984->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ltc2984->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ltc2984->modm_architecture_spi_device modm_driver modm: driver modm_driver_ltc2984->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_ltc2984->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-max6966/","text":"These module docs are in beta and may be incomplete. modm:driver:max6966: MAX6966 8-bit PWM Driver \u00b6 10-channel, daisy-chainable, constant-current sink, 8bit PWM LED driver. Content \u00b6 // Class class modm :: MAX6966 < typename Spi , typename Cs , uint8_t DRIVERS = 1 > ; // Enum enum Brightness ; enum Config ; enum Current ; enum Register ; enum Time ; // Variable const uint8_t modm :: max6966 :: READ = 0x80 ; const uint8_t modm :: max6966 :: WRITE = 0x00 ; Dependencies \u00b6 modm:driver:max6966 modm_driver_max6966 modm: driver: max6966 modm_architecture_delay modm: architecture: delay modm_driver_max6966->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_max6966->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_max6966->modm_architecture_spi modm_driver modm: driver modm_driver_max6966->modm_driver","title":"modm:driver:max6966"},{"location":"reference/module/modm-driver-max6966/#modmdrivermax6966-max6966-8-bit-pwm-driver","text":"10-channel, daisy-chainable, constant-current sink, 8bit PWM LED driver.","title":"modm:driver:max6966: MAX6966 8-bit PWM Driver"},{"location":"reference/module/modm-driver-max6966/#content","text":"// Class class modm :: MAX6966 < typename Spi , typename Cs , uint8_t DRIVERS = 1 > ; // Enum enum Brightness ; enum Config ; enum Current ; enum Register ; enum Time ; // Variable const uint8_t modm :: max6966 :: READ = 0x80 ; const uint8_t modm :: max6966 :: WRITE = 0x00 ;","title":"Content"},{"location":"reference/module/modm-driver-max6966/#dependencies","text":"modm:driver:max6966 modm_driver_max6966 modm: driver: max6966 modm_architecture_delay modm: architecture: delay modm_driver_max6966->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_max6966->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_max6966->modm_architecture_spi modm_driver modm: driver modm_driver_max6966->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-max7219/","text":"These module docs are in beta and may be incomplete. modm:driver:max7219: MAX7219 Display \u00b6 Content \u00b6 // Class class modm :: Max7219 < typename SPI , typename CS , uint8_t MODULES = 1 > ; class modm :: Max7219Matrix < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ; class modm :: Max7219MatrixHorizontal < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ; Dependencies \u00b6 modm:driver:max7219 modm_driver_max7219 modm: driver: max7219 modm_architecture_spi modm: architecture: spi modm_driver_max7219->modm_architecture_spi modm_driver modm: driver modm_driver_max7219->modm_driver modm_ui_display modm: ui: display modm_driver_max7219->modm_ui_display","title":"modm:driver:max7219"},{"location":"reference/module/modm-driver-max7219/#modmdrivermax7219-max7219-display","text":"","title":"modm:driver:max7219: MAX7219 Display"},{"location":"reference/module/modm-driver-max7219/#content","text":"// Class class modm :: Max7219 < typename SPI , typename CS , uint8_t MODULES = 1 > ; class modm :: Max7219Matrix < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ; class modm :: Max7219MatrixHorizontal < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ;","title":"Content"},{"location":"reference/module/modm-driver-max7219/#dependencies","text":"modm:driver:max7219 modm_driver_max7219 modm: driver: max7219 modm_architecture_spi modm: architecture: spi modm_driver_max7219->modm_architecture_spi modm_driver modm: driver modm_driver_max7219->modm_driver modm_ui_display modm: ui: display modm_driver_max7219->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-mcp23x17/","text":"These module docs are in beta and may be incomplete. modm:driver:mcp23x17: MCP23x17 16-Bit I/O Expander \u00b6 Port GPB is the high byte, GPA the low byte. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16bit, use the get(Inputs|Outputs|Directions|Polarities)() getters. Content \u00b6 // Class class modm :: Mcp23TransportI2c < class I2cMaster > ; class modm :: Mcp23TransportSpi < class SpiMaster , class Cs > ; class modm :: Mcp23x17 < class Transport > ; // Struct struct modm :: Mcp23x17 :: Memory ; struct modm :: mcp23x17 ; Dependencies \u00b6 modm:driver:mcp23x17 modm_driver_mcp23x17 modm: driver: mcp23x17 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_mcp23x17->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mcp23x17->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mcp23x17->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_mcp23x17->modm_architecture_spi_device modm_driver modm: driver modm_driver_mcp23x17->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_mcp23x17->modm_processing_resumable","title":"modm:driver:mcp23x17"},{"location":"reference/module/modm-driver-mcp23x17/#modmdrivermcp23x17-mcp23x17-16-bit-io-expander","text":"Port GPB is the high byte, GPA the low byte. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16bit, use the get(Inputs|Outputs|Directions|Polarities)() getters.","title":"modm:driver:mcp23x17: MCP23x17 16-Bit I/O Expander"},{"location":"reference/module/modm-driver-mcp23x17/#content","text":"// Class class modm :: Mcp23TransportI2c < class I2cMaster > ; class modm :: Mcp23TransportSpi < class SpiMaster , class Cs > ; class modm :: Mcp23x17 < class Transport > ; // Struct struct modm :: Mcp23x17 :: Memory ; struct modm :: mcp23x17 ;","title":"Content"},{"location":"reference/module/modm-driver-mcp23x17/#dependencies","text":"modm:driver:mcp23x17 modm_driver_mcp23x17 modm: driver: mcp23x17 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_mcp23x17->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mcp23x17->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mcp23x17->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_mcp23x17->modm_architecture_spi_device modm_driver modm: driver modm_driver_mcp23x17->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_mcp23x17->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-mcp2515/","text":"These module docs are in beta and may be incomplete. modm:driver:mcp2515: MPC2515 External CAN Controller \u00b6 Options \u00b6 clock \u00b6 Used clock for the MCP2515. The device configuration is selected according to the clock speed.: 16MHz \u2208 { 16MHz, 20MHz } Content \u00b6 // Class class modm :: CanBitTimingMcp2515 < int32_t Clk , int32_t Bitrate > ; class modm :: Mcp2515 < typename SPI , typename CS , typename INT > ; // Struct struct modm :: CanBitTimingMcp2515 :: CanBitTimingConfiguration ; // Enum enum BFPCTRL ; enum CANCTRL ; enum CANINTE ; enum CANINTF ; enum CANSTAT ; enum CNF1 ; enum CNF2 ; enum CNF3 ; enum EFLG ; enum RXB0CTRL ; enum RXB1CTRL ; enum RXBnDLC ; enum RXBnSIDL ; enum Register ; enum RxStatus ; enum Status ; enum TXBnCTRL ; enum TXBnSIDL ; enum TXRTSCTRL ; // Define #define MCP2515_FILTER(id) #define MCP2515_FILTER_EXTENDED(id) #define MCP2515_MASK(id) #define MCP2515_MASK_EXTENDED(id) Dependencies \u00b6 modm:driver:mcp2515 modm_driver_mcp2515 modm: driver: mcp2515 modm_architecture_accessor modm: architecture: accessor modm_driver_mcp2515->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_driver_mcp2515->modm_architecture_assert modm_architecture_can modm: architecture: can modm_driver_mcp2515->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_driver_mcp2515->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_mcp2515->modm_architecture_delay modm_debug modm: debug modm_driver_mcp2515->modm_debug modm_driver modm: driver modm_driver_mcp2515->modm_driver","title":"modm:driver:mcp2515"},{"location":"reference/module/modm-driver-mcp2515/#modmdrivermcp2515-mpc2515-external-can-controller","text":"","title":"modm:driver:mcp2515: MPC2515 External CAN Controller"},{"location":"reference/module/modm-driver-mcp2515/#options","text":"","title":"Options"},{"location":"reference/module/modm-driver-mcp2515/#clock","text":"Used clock for the MCP2515. The device configuration is selected according to the clock speed.: 16MHz \u2208 { 16MHz, 20MHz }","title":"clock"},{"location":"reference/module/modm-driver-mcp2515/#content","text":"// Class class modm :: CanBitTimingMcp2515 < int32_t Clk , int32_t Bitrate > ; class modm :: Mcp2515 < typename SPI , typename CS , typename INT > ; // Struct struct modm :: CanBitTimingMcp2515 :: CanBitTimingConfiguration ; // Enum enum BFPCTRL ; enum CANCTRL ; enum CANINTE ; enum CANINTF ; enum CANSTAT ; enum CNF1 ; enum CNF2 ; enum CNF3 ; enum EFLG ; enum RXB0CTRL ; enum RXB1CTRL ; enum RXBnDLC ; enum RXBnSIDL ; enum Register ; enum RxStatus ; enum Status ; enum TXBnCTRL ; enum TXBnSIDL ; enum TXRTSCTRL ; // Define #define MCP2515_FILTER(id) #define MCP2515_FILTER_EXTENDED(id) #define MCP2515_MASK(id) #define MCP2515_MASK_EXTENDED(id)","title":"Content"},{"location":"reference/module/modm-driver-mcp2515/#dependencies","text":"modm:driver:mcp2515 modm_driver_mcp2515 modm: driver: mcp2515 modm_architecture_accessor modm: architecture: accessor modm_driver_mcp2515->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_driver_mcp2515->modm_architecture_assert modm_architecture_can modm: architecture: can modm_driver_mcp2515->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_driver_mcp2515->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_mcp2515->modm_architecture_delay modm_debug modm: debug modm_driver_mcp2515->modm_debug modm_driver modm: driver modm_driver_mcp2515->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-memory-bus/","text":"These module docs are in beta and may be incomplete. modm:driver:memory_bus: Parallel Busses \u00b6 Content \u00b6 // Class class modm :: BitbangMemoryInterface < typename PORT , typename CS , typename CD , typename WR > ; class modm :: MemoryBus < typename PORT , typename CS , typename RD , typename WR > ; class modm :: TftMemoryBus16Bit ; class modm :: TftMemoryBus8Bit ; class modm :: TftMemoryBus8BitGpio < typename PORT , typename CS , typename RD , typename WR , typename CD > ; Dependencies \u00b6 modm:driver:memory_bus modm_driver_memory_bus modm: driver: memory_bus modm_architecture_delay modm: architecture: delay modm_driver_memory_bus->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_memory_bus->modm_architecture_gpio modm_driver modm: driver modm_driver_memory_bus->modm_driver modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_driver_memory_bus","title":"modm:driver:memory_bus"},{"location":"reference/module/modm-driver-memory-bus/#modmdrivermemory_bus-parallel-busses","text":"","title":"modm:driver:memory_bus: Parallel Busses"},{"location":"reference/module/modm-driver-memory-bus/#content","text":"// Class class modm :: BitbangMemoryInterface < typename PORT , typename CS , typename CD , typename WR > ; class modm :: MemoryBus < typename PORT , typename CS , typename RD , typename WR > ; class modm :: TftMemoryBus16Bit ; class modm :: TftMemoryBus8Bit ; class modm :: TftMemoryBus8BitGpio < typename PORT , typename CS , typename RD , typename WR , typename CD > ;","title":"Content"},{"location":"reference/module/modm-driver-memory-bus/#dependencies","text":"modm:driver:memory_bus modm_driver_memory_bus modm: driver: memory_bus modm_architecture_delay modm: architecture: delay modm_driver_memory_bus->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_memory_bus->modm_architecture_gpio modm_driver modm: driver modm_driver_memory_bus->modm_driver modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_driver_memory_bus","title":"Dependencies"},{"location":"reference/module/modm-driver-nokia5110/","text":"These module docs are in beta and may be incomplete. modm:driver:nokia5110: Nokia 5110 Displays \u00b6 Content \u00b6 // Class class modm :: Nokia5110 < typename Spi , typename Ce , typename Dc , typename Reset > ; Dependencies \u00b6 modm:driver:nokia5110 modm_driver_nokia5110 modm: driver: nokia5110 modm_architecture_spi modm: architecture: spi modm_driver_nokia5110->modm_architecture_spi modm_driver modm: driver modm_driver_nokia5110->modm_driver modm_ui_display modm: ui: display modm_driver_nokia5110->modm_ui_display","title":"modm:driver:nokia5110"},{"location":"reference/module/modm-driver-nokia5110/#modmdrivernokia5110-nokia-5110-displays","text":"","title":"modm:driver:nokia5110: Nokia 5110 Displays"},{"location":"reference/module/modm-driver-nokia5110/#content","text":"// Class class modm :: Nokia5110 < typename Spi , typename Ce , typename Dc , typename Reset > ;","title":"Content"},{"location":"reference/module/modm-driver-nokia5110/#dependencies","text":"modm:driver:nokia5110 modm_driver_nokia5110 modm: driver: nokia5110 modm_architecture_spi modm: architecture: spi modm_driver_nokia5110->modm_architecture_spi modm_driver modm: driver modm_driver_nokia5110->modm_driver modm_ui_display modm: ui: display modm_driver_nokia5110->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-nrf24/","text":"These module docs are in beta and may be incomplete. modm:driver:nrf24: NRF24 Drivers \u00b6 Content \u00b6 // Class class modm :: Nrf24Config < typename Nrf24Phy > ; class modm :: Nrf24Data < typename Nrf24Phy > ; class modm :: Nrf24Phy < typename Spi , typename Csn , typename Ce > ; // Struct struct modm :: Nrf24Data :: Frame ; struct modm :: Nrf24Data :: Header ; struct modm :: Nrf24Data :: Packet :: Payload ; struct modm :: Nrf24Data :: Packet ; struct modm :: Nrf24Register ; // Define #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL Dependencies \u00b6 modm:driver:nrf24 modm_driver_nrf24 modm: driver: nrf24 modm_architecture_delay modm: architecture: delay modm_driver_nrf24->modm_architecture_delay modm_architecture_register modm: architecture: register modm_driver_nrf24->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_driver_nrf24->modm_architecture_spi modm_debug modm: debug modm_driver_nrf24->modm_debug modm_driver modm: driver modm_driver_nrf24->modm_driver modm_math_utils modm: math: utils modm_driver_nrf24->modm_math_utils modm_processing_timer modm: processing: timer modm_driver_nrf24->modm_processing_timer","title":"modm:driver:nrf24"},{"location":"reference/module/modm-driver-nrf24/#modmdrivernrf24-nrf24-drivers","text":"","title":"modm:driver:nrf24: NRF24 Drivers"},{"location":"reference/module/modm-driver-nrf24/#content","text":"// Class class modm :: Nrf24Config < typename Nrf24Phy > ; class modm :: Nrf24Data < typename Nrf24Phy > ; class modm :: Nrf24Phy < typename Spi , typename Csn , typename Ce > ; // Struct struct modm :: Nrf24Data :: Frame ; struct modm :: Nrf24Data :: Header ; struct modm :: Nrf24Data :: Packet :: Payload ; struct modm :: Nrf24Data :: Packet ; struct modm :: Nrf24Register ; // Define #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL","title":"Content"},{"location":"reference/module/modm-driver-nrf24/#dependencies","text":"modm:driver:nrf24 modm_driver_nrf24 modm: driver: nrf24 modm_architecture_delay modm: architecture: delay modm_driver_nrf24->modm_architecture_delay modm_architecture_register modm: architecture: register modm_driver_nrf24->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_driver_nrf24->modm_architecture_spi modm_debug modm: debug modm_driver_nrf24->modm_debug modm_driver modm: driver modm_driver_nrf24->modm_driver modm_math_utils modm: math: utils modm_driver_nrf24->modm_math_utils modm_processing_timer modm: processing: timer modm_driver_nrf24->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-driver-parallel-tft-display/","text":"These module docs are in beta and may be incomplete. modm:driver:parallel_tft_display: Parallel Bus TFT Display \u00b6 Content \u00b6 // Class class modm :: ParallelTft < typename INTERFACE > ; Dependencies \u00b6 modm:driver:parallel_tft_display modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_architecture_delay modm: architecture: delay modm_driver_parallel_tft_display->modm_architecture_delay modm_driver modm: driver modm_driver_parallel_tft_display->modm_driver modm_ui_display modm: ui: display modm_driver_parallel_tft_display->modm_ui_display","title":"modm:driver:parallel_tft_display"},{"location":"reference/module/modm-driver-parallel-tft-display/#modmdriverparallel_tft_display-parallel-bus-tft-display","text":"","title":"modm:driver:parallel_tft_display: Parallel Bus TFT Display"},{"location":"reference/module/modm-driver-parallel-tft-display/#content","text":"// Class class modm :: ParallelTft < typename INTERFACE > ;","title":"Content"},{"location":"reference/module/modm-driver-parallel-tft-display/#dependencies","text":"modm:driver:parallel_tft_display modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_architecture_delay modm: architecture: delay modm_driver_parallel_tft_display->modm_architecture_delay modm_driver modm: driver modm_driver_parallel_tft_display->modm_driver modm_ui_display modm: ui: display modm_driver_parallel_tft_display->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-pat9125el/","text":"These module docs are in beta and may be incomplete. modm:driver:pat9125el: Driver for PAT9125EL motion sensor \u00b6 Content \u00b6 // Class class modm :: Pat9125el < typename Transport , typename IntPin = void > ; class modm :: Pat9125elI2cTransport < class I2cMaster > ; // Struct struct modm :: pat9125el ; Dependencies \u00b6 modm:driver:pat9125el modm_driver_pat9125el modm: driver: pat9125el modm_architecture_delay modm: architecture: delay modm_driver_pat9125el->modm_architecture_delay modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pat9125el->modm_architecture_i2c_device modm_architecture_spi modm: architecture: spi modm_driver_pat9125el->modm_architecture_spi modm_debug modm: debug modm_driver_pat9125el->modm_debug modm_driver modm: driver modm_driver_pat9125el->modm_driver modm_math_geometry modm: math: geometry modm_driver_pat9125el->modm_math_geometry","title":"modm:driver:pat9125el"},{"location":"reference/module/modm-driver-pat9125el/#modmdriverpat9125el-driver-for-pat9125el-motion-sensor","text":"","title":"modm:driver:pat9125el: Driver for PAT9125EL motion sensor"},{"location":"reference/module/modm-driver-pat9125el/#content","text":"// Class class modm :: Pat9125el < typename Transport , typename IntPin = void > ; class modm :: Pat9125elI2cTransport < class I2cMaster > ; // Struct struct modm :: pat9125el ;","title":"Content"},{"location":"reference/module/modm-driver-pat9125el/#dependencies","text":"modm:driver:pat9125el modm_driver_pat9125el modm: driver: pat9125el modm_architecture_delay modm: architecture: delay modm_driver_pat9125el->modm_architecture_delay modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pat9125el->modm_architecture_i2c_device modm_architecture_spi modm: architecture: spi modm_driver_pat9125el->modm_architecture_spi modm_debug modm: debug modm_driver_pat9125el->modm_debug modm_driver modm: driver modm_driver_pat9125el->modm_driver modm_math_geometry modm: math: geometry modm_driver_pat9125el->modm_math_geometry","title":"Dependencies"},{"location":"reference/module/modm-driver-pca8574/","text":"These module docs are in beta and may be incomplete. modm:driver:pca8574: PCA8574 8-Bit I/O Expander \u00b6 Content \u00b6 // Class class modm :: Pca8574 < class I2cMaster > ; // Struct struct modm :: pca8574 ; Dependencies \u00b6 modm:driver:pca8574 modm_driver_pca8574 modm: driver: pca8574 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca8574->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca8574->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca8574->modm_architecture_register modm_driver modm: driver modm_driver_pca8574->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_pca8574->modm_processing_resumable","title":"modm:driver:pca8574"},{"location":"reference/module/modm-driver-pca8574/#modmdriverpca8574-pca8574-8-bit-io-expander","text":"","title":"modm:driver:pca8574: PCA8574 8-Bit I/O Expander"},{"location":"reference/module/modm-driver-pca8574/#content","text":"// Class class modm :: Pca8574 < class I2cMaster > ; // Struct struct modm :: pca8574 ;","title":"Content"},{"location":"reference/module/modm-driver-pca8574/#dependencies","text":"modm:driver:pca8574 modm_driver_pca8574 modm: driver: pca8574 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca8574->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca8574->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca8574->modm_architecture_register modm_driver modm: driver modm_driver_pca8574->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_pca8574->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-pca9535/","text":"These module docs are in beta and may be incomplete. modm:driver:pca9535: PCA9535 16-Bit I/O Expander \u00b6 Also software-compatible with PCA9555. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16-bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16-bit, use the get(Inputs|Outputs|Directions|Polarities)() getters. using Pin = expander . Pin ; using Pins = expander . Pins ; RF_CALL_BLOCKING ( expander . setOutput ( Pins ( 0xff )); // set all lower 8 pins to output RF_CALL_BLOCKING ( expander . set ( Pin :: P0_0 )); // set only pin 00 high RF_CALL_BLOCKING ( expander . reset ( Pin :: P0_1 | Pin :: P0_2 )); // reset 2 pins RF_CALL_BLOCKING ( expander . toggle ( Pin :: P0_3 | Pin :: P0_4 | Pin :: P0_5 )); // toggle 3 pins RF_CALL_BLOCKING ( expander . readInput ()); // transfer input states from the external chip bool high = expander . read ( Pin :: P1_0 ); // check a single pin Pins input = expander . getInputs (); // get all 16 input states bool isAnyPinHigh = input . any ( Pin :: P1_1 | Pin :: P1_2 | Pin :: P1_3 ); // check if any of 3 pins is high Content \u00b6 // Class class modm :: Pca9535 < typename I2cMaster > ; // Struct struct modm :: pca9535 ; Dependencies \u00b6 modm:driver:pca9535 modm_driver_pca9535 modm: driver: pca9535 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca9535->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9535->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca9535->modm_architecture_register modm_driver modm: driver modm_driver_pca9535->modm_driver modm_math_utils modm: math: utils modm_driver_pca9535->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_pca9535->modm_processing_resumable","title":"modm:driver:pca9535"},{"location":"reference/module/modm-driver-pca9535/#modmdriverpca9535-pca9535-16-bit-io-expander","text":"Also software-compatible with PCA9555. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16-bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16-bit, use the get(Inputs|Outputs|Directions|Polarities)() getters. using Pin = expander . Pin ; using Pins = expander . Pins ; RF_CALL_BLOCKING ( expander . setOutput ( Pins ( 0xff )); // set all lower 8 pins to output RF_CALL_BLOCKING ( expander . set ( Pin :: P0_0 )); // set only pin 00 high RF_CALL_BLOCKING ( expander . reset ( Pin :: P0_1 | Pin :: P0_2 )); // reset 2 pins RF_CALL_BLOCKING ( expander . toggle ( Pin :: P0_3 | Pin :: P0_4 | Pin :: P0_5 )); // toggle 3 pins RF_CALL_BLOCKING ( expander . readInput ()); // transfer input states from the external chip bool high = expander . read ( Pin :: P1_0 ); // check a single pin Pins input = expander . getInputs (); // get all 16 input states bool isAnyPinHigh = input . any ( Pin :: P1_1 | Pin :: P1_2 | Pin :: P1_3 ); // check if any of 3 pins is high","title":"modm:driver:pca9535: PCA9535 16-Bit I/O Expander"},{"location":"reference/module/modm-driver-pca9535/#content","text":"// Class class modm :: Pca9535 < typename I2cMaster > ; // Struct struct modm :: pca9535 ;","title":"Content"},{"location":"reference/module/modm-driver-pca9535/#dependencies","text":"modm:driver:pca9535 modm_driver_pca9535 modm: driver: pca9535 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca9535->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9535->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca9535->modm_architecture_register modm_driver modm: driver modm_driver_pca9535->modm_driver modm_math_utils modm: math: utils modm_driver_pca9535->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_pca9535->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-pca9548a/","text":"These module docs are in beta and may be incomplete. modm:driver:pca9548a: PCA9548A/TCA9548A I2C Switch \u00b6 This bidirectional 8-channel switch with reset can be used to multiplex I2C busses. Content \u00b6 // Class class modm :: Pca9548a < typename I2cMaster > ; Dependencies \u00b6 modm:driver:pca9548a modm_driver_pca9548a modm: driver: pca9548a modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9548a->modm_architecture_i2c_device modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_driver_pca9548a->modm_architecture_i2c_multiplexer modm_driver modm: driver modm_driver_pca9548a->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_pca9548a->modm_processing_resumable","title":"modm:driver:pca9548a"},{"location":"reference/module/modm-driver-pca9548a/#modmdriverpca9548a-pca9548atca9548a-i2c-switch","text":"This bidirectional 8-channel switch with reset can be used to multiplex I2C busses.","title":"modm:driver:pca9548a: PCA9548A/TCA9548A I2C Switch"},{"location":"reference/module/modm-driver-pca9548a/#content","text":"// Class class modm :: Pca9548a < typename I2cMaster > ;","title":"Content"},{"location":"reference/module/modm-driver-pca9548a/#dependencies","text":"modm:driver:pca9548a modm_driver_pca9548a modm: driver: pca9548a modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9548a->modm_architecture_i2c_device modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_driver_pca9548a->modm_architecture_i2c_multiplexer modm_driver modm: driver modm_driver_pca9548a->modm_driver modm_processing_resumable modm: processing: resumable modm_driver_pca9548a->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-driver-pca9685/","text":"These module docs are in beta and may be incomplete. modm:driver:pca9685: PCA9685 12-bit PWM Driver \u00b6 PCA9685 16-channel, 12-bit PWM LED controller via I2C-Bus. Content \u00b6 // Class class modm :: Pca9685 < typename I2cMaster > ; // Struct struct modm :: pca9685 ; Dependencies \u00b6 modm:driver:pca9685 modm_driver_pca9685 modm: driver: pca9685 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9685->modm_architecture_i2c_device modm_driver modm: driver modm_driver_pca9685->modm_driver","title":"modm:driver:pca9685"},{"location":"reference/module/modm-driver-pca9685/#modmdriverpca9685-pca9685-12-bit-pwm-driver","text":"PCA9685 16-channel, 12-bit PWM LED controller via I2C-Bus.","title":"modm:driver:pca9685: PCA9685 12-bit PWM Driver"},{"location":"reference/module/modm-driver-pca9685/#content","text":"// Class class modm :: Pca9685 < typename I2cMaster > ; // Struct struct modm :: pca9685 ;","title":"Content"},{"location":"reference/module/modm-driver-pca9685/#dependencies","text":"modm:driver:pca9685 modm_driver_pca9685 modm: driver: pca9685 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9685->modm_architecture_i2c_device modm_driver modm: driver modm_driver_pca9685->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-driver-siemens-s65/","text":"These module docs are in beta and may be incomplete. modm:driver:siemens_s65: Siemens S65 Display \u00b6 Content \u00b6 // Class class modm :: SiemensS65Common < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Landscape < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Portrait < typename SPI , typename CS , typename RS , typename Reset > ; // Define #define S65_LPC_ACCELERATED Dependencies \u00b6 modm:driver:siemens_s65 modm_driver_siemens_s65 modm: driver: siemens_s65 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s65->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_siemens_s65->modm_architecture_spi modm_driver modm: driver modm_driver_siemens_s65->modm_driver modm_ui_display modm: ui: display modm_driver_siemens_s65->modm_ui_display","title":"modm:driver:siemens_s65"},{"location":"reference/module/modm-driver-siemens-s65/#modmdriversiemens_s65-siemens-s65-display","text":"","title":"modm:driver:siemens_s65: Siemens S65 Display"},{"location":"reference/module/modm-driver-siemens-s65/#content","text":"// Class class modm :: SiemensS65Common < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Landscape < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Portrait < typename SPI , typename CS , typename RS , typename Reset > ; // Define #define S65_LPC_ACCELERATED","title":"Content"},{"location":"reference/module/modm-driver-siemens-s65/#dependencies","text":"modm:driver:siemens_s65 modm_driver_siemens_s65 modm: driver: siemens_s65 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s65->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_siemens_s65->modm_architecture_spi modm_driver modm: driver modm_driver_siemens_s65->modm_driver modm_ui_display modm: ui: display modm_driver_siemens_s65->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-siemens-s75/","text":"These module docs are in beta and may be incomplete. modm:driver:siemens_s75: Siemens S75/CX75/C81/M75 Display \u00b6 The controller in displays manufactured by Alps is a SOLOMON SYSTECH SSD1286 which can drive color displays of up to 132 x 176 pixels in 18 bit color. The portrait mode is a bit more 'native' for this display because modm::BufferedGraphicDisplay requests that the vertical resolution is divisible by 8. In portrait mode the connector is at the top. In landscapeLeft mode the connector is at the left border. In landscapeRight mode the connector is at the right border. Pinout at LCD: 1 IN CD Command / Data Low = Command (Register) High = Data. 2 IN RESET Resets the display. Active low. Low = Reset, High = No reset. 3 IN CS Chip select. Active low. Low = Chip is selected, High = Chip is not selected. 4 OUT VD Sync Output. Unused. 5 GND Supply 6 IN D0 Bit 0 of parallel data 7 3V3 (2V9) Supply 8 GND Supply 9 VLED + Supply Backlight 10 VLED - Supply Backlight 11 GND Supply 12 IN RD Read Strobe. Must be tied high. 13 IN WR Write Strobe. High-to-Low strobe write data to display memory. 14 IN D1 Bit 1 of parallel data. 15 IN D2 Bit 2 of parallel data. 16 IN D3 Bit 3 of parallel data. 17 IN D4 Bit 4 of parallel data. 18 IN D5 Bit 5 of parallel data. 19 IN D6 Bit 6 of parallel data. 20 IN D7 Bit 7 of parallel data. Pin 1 is unmarked. Pin 5 can be recognized by a thicker trace which is GND. The backlight (VLED +, VLED -) consists of four white LEDs in series. The forward voltage is about 12 volts. Content \u00b6 // Class class modm :: SiemensS75Common < typename MEMORY , typename RESET , uint16_t WIDTH , uint16_t HEIGHT , modm :: Orientation ORIENTATION > ; class modm :: SiemensS75LandscapeLeft < typename MEMORY , typename RESET > ; class modm :: SiemensS75LandscapeRight < typename MEMORY , typename RESET > ; class modm :: SiemensS75Portrait < typename MEMORY , typename RESET > ; class modm :: SiemensS75PortraitUpsideDown < typename MEMORY , typename RESET > ; // Enum enum Orientation ; Dependencies \u00b6 modm:driver:siemens_s75 modm_driver_siemens_s75 modm: driver: siemens_s75 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s75->modm_architecture_delay modm_driver modm: driver modm_driver_siemens_s75->modm_driver modm_driver_memory_bus modm: driver: memory_bus modm_driver_siemens_s75->modm_driver_memory_bus modm_ui_display modm: ui: display modm_driver_siemens_s75->modm_ui_display","title":"modm:driver:siemens_s75"},{"location":"reference/module/modm-driver-siemens-s75/#modmdriversiemens_s75-siemens-s75cx75c81m75-display","text":"The controller in displays manufactured by Alps is a SOLOMON SYSTECH SSD1286 which can drive color displays of up to 132 x 176 pixels in 18 bit color. The portrait mode is a bit more 'native' for this display because modm::BufferedGraphicDisplay requests that the vertical resolution is divisible by 8. In portrait mode the connector is at the top. In landscapeLeft mode the connector is at the left border. In landscapeRight mode the connector is at the right border. Pinout at LCD: 1 IN CD Command / Data Low = Command (Register) High = Data. 2 IN RESET Resets the display. Active low. Low = Reset, High = No reset. 3 IN CS Chip select. Active low. Low = Chip is selected, High = Chip is not selected. 4 OUT VD Sync Output. Unused. 5 GND Supply 6 IN D0 Bit 0 of parallel data 7 3V3 (2V9) Supply 8 GND Supply 9 VLED + Supply Backlight 10 VLED - Supply Backlight 11 GND Supply 12 IN RD Read Strobe. Must be tied high. 13 IN WR Write Strobe. High-to-Low strobe write data to display memory. 14 IN D1 Bit 1 of parallel data. 15 IN D2 Bit 2 of parallel data. 16 IN D3 Bit 3 of parallel data. 17 IN D4 Bit 4 of parallel data. 18 IN D5 Bit 5 of parallel data. 19 IN D6 Bit 6 of parallel data. 20 IN D7 Bit 7 of parallel data. Pin 1 is unmarked. Pin 5 can be recognized by a thicker trace which is GND. The backlight (VLED +, VLED -) consists of four white LEDs in series. The forward voltage is about 12 volts.","title":"modm:driver:siemens_s75: Siemens S75/CX75/C81/M75 Display"},{"location":"reference/module/modm-driver-siemens-s75/#content","text":"// Class class modm :: SiemensS75Common < typename MEMORY , typename RESET , uint16_t WIDTH , uint16_t HEIGHT , modm :: Orientation ORIENTATION > ; class modm :: SiemensS75LandscapeLeft < typename MEMORY , typename RESET > ; class modm :: SiemensS75LandscapeRight < typename MEMORY , typename RESET > ; class modm :: SiemensS75Portrait < typename MEMORY , typename RESET > ; class modm :: SiemensS75PortraitUpsideDown < typename MEMORY , typename RESET > ; // Enum enum Orientation ;","title":"Content"},{"location":"reference/module/modm-driver-siemens-s75/#dependencies","text":"modm:driver:siemens_s75 modm_driver_siemens_s75 modm: driver: siemens_s75 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s75->modm_architecture_delay modm_driver modm: driver modm_driver_siemens_s75->modm_driver modm_driver_memory_bus modm: driver: memory_bus modm_driver_siemens_s75->modm_driver_memory_bus modm_ui_display modm: ui: display modm_driver_siemens_s75->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-ssd1306/","text":"These module docs are in beta and may be incomplete. modm:driver:ssd1306: SSD1306 Display \u00b6 Content \u00b6 // Class class modm :: Ssd1306 < class I2cMaster , uint8_t Height = 64 > ; // Struct struct modm :: ssd1306 ; Dependencies \u00b6 modm:driver:ssd1306 modm_driver_ssd1306 modm: driver: ssd1306 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ssd1306->modm_architecture_i2c_device modm_driver modm: driver modm_driver_ssd1306->modm_driver modm_processing_timer modm: processing: timer modm_driver_ssd1306->modm_processing_timer modm_ui_display modm: ui: display modm_driver_ssd1306->modm_ui_display","title":"modm:driver:ssd1306"},{"location":"reference/module/modm-driver-ssd1306/#modmdriverssd1306-ssd1306-display","text":"","title":"modm:driver:ssd1306: SSD1306 Display"},{"location":"reference/module/modm-driver-ssd1306/#content","text":"// Class class modm :: Ssd1306 < class I2cMaster , uint8_t Height = 64 > ; // Struct struct modm :: ssd1306 ;","title":"Content"},{"location":"reference/module/modm-driver-ssd1306/#dependencies","text":"modm:driver:ssd1306 modm_driver_ssd1306 modm: driver: ssd1306 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ssd1306->modm_architecture_i2c_device modm_driver modm: driver modm_driver_ssd1306->modm_driver modm_processing_timer modm: processing: timer modm_driver_ssd1306->modm_processing_timer modm_ui_display modm: ui: display modm_driver_ssd1306->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-driver-tcs3414/","text":"These module docs are in beta and may be incomplete. modm:driver:tcs3414: TCS3414 Digital Color Sensor \u00b6 Content \u00b6 // Class class modm :: Tcs3414 :: uint16_t_LOW_HIGH ; class modm :: Tcs3414 < typename I2cMaster > ; // Struct struct modm :: Tcs3414 :: Data . __unnamed__ ; struct modm :: tcs3414 ; // Variable struct modm :: Tcs3414 :: Data :: @ 0 modm :: Tcs3414 < I2cMaster >:: Data :: @ 1 ; uint8_t modm :: Tcs3414 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ; Dependencies \u00b6 modm:driver:tcs3414 modm_driver_tcs3414 modm: driver: tcs3414 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3414->modm_architecture_i2c_device modm_driver modm: driver modm_driver_tcs3414->modm_driver modm_ui_color modm: ui: color modm_driver_tcs3414->modm_ui_color","title":"modm:driver:tcs3414"},{"location":"reference/module/modm-driver-tcs3414/#modmdrivertcs3414-tcs3414-digital-color-sensor","text":"","title":"modm:driver:tcs3414: TCS3414 Digital Color Sensor"},{"location":"reference/module/modm-driver-tcs3414/#content","text":"// Class class modm :: Tcs3414 :: uint16_t_LOW_HIGH ; class modm :: Tcs3414 < typename I2cMaster > ; // Struct struct modm :: Tcs3414 :: Data . __unnamed__ ; struct modm :: tcs3414 ; // Variable struct modm :: Tcs3414 :: Data :: @ 0 modm :: Tcs3414 < I2cMaster >:: Data :: @ 1 ; uint8_t modm :: Tcs3414 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ;","title":"Content"},{"location":"reference/module/modm-driver-tcs3414/#dependencies","text":"modm:driver:tcs3414 modm_driver_tcs3414 modm: driver: tcs3414 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3414->modm_architecture_i2c_device modm_driver modm: driver modm_driver_tcs3414->modm_driver modm_ui_color modm: ui: color modm_driver_tcs3414->modm_ui_color","title":"Dependencies"},{"location":"reference/module/modm-driver-tcs3472/","text":"These module docs are in beta and may be incomplete. modm:driver:tcs3472: TCS3472X Digital Color Sensor \u00b6 Content \u00b6 // Class class modm :: Tcs3472 :: uint16_t_LOW_HIGH ; class modm :: Tcs3472 < typename I2cMaster > ; // Struct struct modm :: Tcs3472 :: Data . __unnamed__ ; struct modm :: tcs3472 ; // Variable struct modm :: Tcs3472 :: Data :: @ 2 modm :: Tcs3472 < I2cMaster >:: Data :: @ 3 ; uint8_t modm :: Tcs3472 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ; Dependencies \u00b6 modm:driver:tcs3472 modm_driver_tcs3472 modm: driver: tcs3472 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3472->modm_architecture_i2c_device modm_driver modm: driver modm_driver_tcs3472->modm_driver modm_ui_color modm: ui: color modm_driver_tcs3472->modm_ui_color","title":"modm:driver:tcs3472"},{"location":"reference/module/modm-driver-tcs3472/#modmdrivertcs3472-tcs3472x-digital-color-sensor","text":"","title":"modm:driver:tcs3472: TCS3472X Digital Color Sensor"},{"location":"reference/module/modm-driver-tcs3472/#content","text":"// Class class modm :: Tcs3472 :: uint16_t_LOW_HIGH ; class modm :: Tcs3472 < typename I2cMaster > ; // Struct struct modm :: Tcs3472 :: Data . __unnamed__ ; struct modm :: tcs3472 ; // Variable struct modm :: Tcs3472 :: Data :: @ 2 modm :: Tcs3472 < I2cMaster >:: Data :: @ 3 ; uint8_t modm :: Tcs3472 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ;","title":"Content"},{"location":"reference/module/modm-driver-tcs3472/#dependencies","text":"modm:driver:tcs3472 modm_driver_tcs3472 modm: driver: tcs3472 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3472->modm_architecture_i2c_device modm_driver modm: driver modm_driver_tcs3472->modm_driver modm_ui_color modm: ui: color modm_driver_tcs3472->modm_ui_color","title":"Dependencies"},{"location":"reference/module/modm-driver-tmp102/","text":"These module docs are in beta and may be incomplete. modm:driver:tmp102: TMP102 Thermometer \u00b6 The TMP102 is a digital temperature sensor with an I2C interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 0.5 deg C. The sensor has a default refresh rate of 4Hz but can be set from 0.25Hz up to 33Hz using setUpdateRate(rate) . The sensor will then read itself when calling the update() method frequently. However, you may manually start a conversion with startConversion() , wait for 30ms and then readTemperature() to achieve other (less frequent) update rates. Content \u00b6 // Struct struct modm :: tmp102 :: Data ; struct modm :: tmp102 ; Dependencies \u00b6 modm:driver:tmp102 modm_driver_tmp102 modm: driver: tmp102 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp102->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp102->modm_architecture_register modm_driver modm: driver modm_driver_tmp102->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_tmp102->modm_driver_lm75 modm_math_utils modm: math: utils modm_driver_tmp102->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_tmp102->modm_processing_protothread","title":"modm:driver:tmp102"},{"location":"reference/module/modm-driver-tmp102/#modmdrivertmp102-tmp102-thermometer","text":"The TMP102 is a digital temperature sensor with an I2C interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 0.5 deg C. The sensor has a default refresh rate of 4Hz but can be set from 0.25Hz up to 33Hz using setUpdateRate(rate) . The sensor will then read itself when calling the update() method frequently. However, you may manually start a conversion with startConversion() , wait for 30ms and then readTemperature() to achieve other (less frequent) update rates.","title":"modm:driver:tmp102: TMP102 Thermometer"},{"location":"reference/module/modm-driver-tmp102/#content","text":"// Struct struct modm :: tmp102 :: Data ; struct modm :: tmp102 ;","title":"Content"},{"location":"reference/module/modm-driver-tmp102/#dependencies","text":"modm:driver:tmp102 modm_driver_tmp102 modm: driver: tmp102 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp102->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp102->modm_architecture_register modm_driver modm: driver modm_driver_tmp102->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_tmp102->modm_driver_lm75 modm_math_utils modm: math: utils modm_driver_tmp102->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_tmp102->modm_processing_protothread","title":"Dependencies"},{"location":"reference/module/modm-driver-tmp175/","text":"These module docs are in beta and may be incomplete. modm:driver:tmp175: TMP175 Thermometer \u00b6 TMP175 digital temperature sensor driver. The TMP175 is a digital temperature sensor with a two-wire interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 1.5 deg C. The sensor has a default refresh rate of 4Hz but can be raised up to 30Hz by repeatedly manually starting a conversion (with startConversion()), which lasts between 30ms and 240ms depending on resolution. Content \u00b6 // Struct struct modm :: tmp175 ; Dependencies \u00b6 modm:driver:tmp175 modm_driver_tmp175 modm: driver: tmp175 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp175->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp175->modm_architecture_register modm_driver modm: driver modm_driver_tmp175->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_tmp175->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_tmp175->modm_processing_protothread","title":"modm:driver:tmp175"},{"location":"reference/module/modm-driver-tmp175/#modmdrivertmp175-tmp175-thermometer","text":"TMP175 digital temperature sensor driver. The TMP175 is a digital temperature sensor with a two-wire interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 1.5 deg C. The sensor has a default refresh rate of 4Hz but can be raised up to 30Hz by repeatedly manually starting a conversion (with startConversion()), which lasts between 30ms and 240ms depending on resolution.","title":"modm:driver:tmp175: TMP175 Thermometer"},{"location":"reference/module/modm-driver-tmp175/#content","text":"// Struct struct modm :: tmp175 ;","title":"Content"},{"location":"reference/module/modm-driver-tmp175/#dependencies","text":"modm:driver:tmp175 modm_driver_tmp175 modm: driver: tmp175 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp175->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp175->modm_architecture_register modm_driver modm: driver modm_driver_tmp175->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_tmp175->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_tmp175->modm_processing_protothread","title":"Dependencies"},{"location":"reference/module/modm-driver-vl53l0/","text":"These module docs are in beta and may be incomplete. modm:driver:vl53l0: VL53L0X Proximity Sensor \u00b6 Content \u00b6 // Class class modm :: Vl53l0 < typename I2cMaster > ; // Struct struct modm :: vl53l0 :: Data ; struct modm :: vl53l0 :: TimeOverhead ; struct modm :: vl53l0 ; // Function IOStream & modm :: operator << ( IOStream & os , const vl53l0 :: RangeErrorCode & c ); Dependencies \u00b6 modm:driver:vl53l0 modm_driver_vl53l0 modm: driver: vl53l0 modm_architecture_accessor modm: architecture: accessor modm_driver_vl53l0->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl53l0->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl53l0->modm_architecture_register modm_debug modm: debug modm_driver_vl53l0->modm_debug modm_driver modm: driver modm_driver_vl53l0->modm_driver modm_processing_timer modm: processing: timer modm_driver_vl53l0->modm_processing_timer","title":"modm:driver:vl53l0"},{"location":"reference/module/modm-driver-vl53l0/#modmdrivervl53l0-vl53l0x-proximity-sensor","text":"","title":"modm:driver:vl53l0: VL53L0X Proximity Sensor"},{"location":"reference/module/modm-driver-vl53l0/#content","text":"// Class class modm :: Vl53l0 < typename I2cMaster > ; // Struct struct modm :: vl53l0 :: Data ; struct modm :: vl53l0 :: TimeOverhead ; struct modm :: vl53l0 ; // Function IOStream & modm :: operator << ( IOStream & os , const vl53l0 :: RangeErrorCode & c );","title":"Content"},{"location":"reference/module/modm-driver-vl53l0/#dependencies","text":"modm:driver:vl53l0 modm_driver_vl53l0 modm: driver: vl53l0 modm_architecture_accessor modm: architecture: accessor modm_driver_vl53l0->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl53l0->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl53l0->modm_architecture_register modm_debug modm: debug modm_driver_vl53l0->modm_debug modm_driver modm: driver modm_driver_vl53l0->modm_driver modm_processing_timer modm: processing: timer modm_driver_vl53l0->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-driver-vl6180/","text":"These module docs are in beta and may be incomplete. modm:driver:vl6180: VL6180X Proximity Sensor \u00b6 Content \u00b6 // Class class modm :: Vl6180 < typename I2cMaster > ; // Struct struct modm :: vl6180 :: Data ; struct modm :: vl6180 ; Dependencies \u00b6 modm:driver:vl6180 modm_driver_vl6180 modm: driver: vl6180 modm_architecture_accessor modm: architecture: accessor modm_driver_vl6180->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl6180->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl6180->modm_architecture_register modm_architecture_unaligned modm: architecture: unaligned modm_driver_vl6180->modm_architecture_unaligned modm_debug modm: debug modm_driver_vl6180->modm_debug modm_driver modm: driver modm_driver_vl6180->modm_driver modm_math_utils modm: math: utils modm_driver_vl6180->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_vl6180->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_vl6180->modm_processing_timer","title":"modm:driver:vl6180"},{"location":"reference/module/modm-driver-vl6180/#modmdrivervl6180-vl6180x-proximity-sensor","text":"","title":"modm:driver:vl6180: VL6180X Proximity Sensor"},{"location":"reference/module/modm-driver-vl6180/#content","text":"// Class class modm :: Vl6180 < typename I2cMaster > ; // Struct struct modm :: vl6180 :: Data ; struct modm :: vl6180 ;","title":"Content"},{"location":"reference/module/modm-driver-vl6180/#dependencies","text":"modm:driver:vl6180 modm_driver_vl6180 modm: driver: vl6180 modm_architecture_accessor modm: architecture: accessor modm_driver_vl6180->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl6180->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl6180->modm_architecture_register modm_architecture_unaligned modm: architecture: unaligned modm_driver_vl6180->modm_architecture_unaligned modm_debug modm: debug modm_driver_vl6180->modm_debug modm_driver modm: driver modm_driver_vl6180->modm_driver modm_math_utils modm: math: utils modm_driver_vl6180->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_vl6180->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_vl6180->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-driver-ws2812/","text":"These module docs are in beta and may be incomplete. modm:driver:ws2812: WS2812 Driver \u00b6 Drives any number of chained WS2812 LEDs using a 3-bit SPI encoding (0 -> 100, 1 -> 110) running at 3 MHz. Thus, writing one LED takes 24\u00b5s and 9 bytes of memory. There are several caveats: This only provides a blocking write API, due to technical limitations. Atomicity is not enforced, this should be done externally if required. The memory footprint is 3x as large, due to the bit stuffing for SPI. There is no enforced reset period of at least 50\u00b5s after the write is finished, it is up to the user to not trigger another write too early. This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now. Content \u00b6 // Class class modm :: Ws2812b < class SpiMaster , class Output , size_t LEDs > ; Dependencies \u00b6 modm:driver:ws2812 modm_driver_ws2812 modm: driver: ws2812 modm_architecture_spi modm: architecture: spi modm_driver_ws2812->modm_architecture_spi modm_driver modm: driver modm_driver_ws2812->modm_driver modm_math_units modm: math: units modm_driver_ws2812->modm_math_units modm_ui_color modm: ui: color modm_driver_ws2812->modm_ui_color","title":"modm:driver:ws2812"},{"location":"reference/module/modm-driver-ws2812/#modmdriverws2812-ws2812-driver","text":"Drives any number of chained WS2812 LEDs using a 3-bit SPI encoding (0 -> 100, 1 -> 110) running at 3 MHz. Thus, writing one LED takes 24\u00b5s and 9 bytes of memory. There are several caveats: This only provides a blocking write API, due to technical limitations. Atomicity is not enforced, this should be done externally if required. The memory footprint is 3x as large, due to the bit stuffing for SPI. There is no enforced reset period of at least 50\u00b5s after the write is finished, it is up to the user to not trigger another write too early. This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now.","title":"modm:driver:ws2812: WS2812 Driver"},{"location":"reference/module/modm-driver-ws2812/#content","text":"// Class class modm :: Ws2812b < class SpiMaster , class Output , size_t LEDs > ;","title":"Content"},{"location":"reference/module/modm-driver-ws2812/#dependencies","text":"modm:driver:ws2812 modm_driver_ws2812 modm: driver: ws2812 modm_architecture_spi modm: architecture: spi modm_driver_ws2812->modm_architecture_spi modm_driver modm: driver modm_driver_ws2812->modm_driver modm_math_units modm: math: units modm_driver_ws2812->modm_math_units modm_ui_color modm: ui: color modm_driver_ws2812->modm_ui_color","title":"Dependencies"},{"location":"reference/module/modm-driver/","text":"These module docs are in beta and may be incomplete. modm:driver: External Device Drivers \u00b6 Content \u00b6 // Class class modm :: Ad7280a < typename Spi , typename Cs , typename Cnvst , int N > ; class modm :: Ad7928 < typename SpiMaster , typename Cs > ; class modm :: AdcSampler < class AdcInterrupt , uint8_t Channels , uint32_t Oversamples = 1 > ; class modm :: Adns9800 < typename Spi , typename Cs > ; class modm :: Ads7843 < typename Spi , typename Cs , typename Int > ; class modm :: Ams5915 < typename I2cMaster > ; class modm :: BdHeap < size_t DeviceSize_ , bool externalMemory = false > ; class modm :: BdMirror < typename BlockDeviceA , typename BlockDeviceB > ; class modm :: BdSpiFlash < typename Spi , typename Cs , uint32_t flashSize > ; class modm :: BitbangMemoryInterface < typename PORT , typename CS , typename CD , typename WR > ; class modm :: Bme280 < typename I2cMaster > ; class modm :: Bmp085 < typename I2cMaster > ; class modm :: CanBitTimingMcp2515 < int32_t Clk , int32_t Bitrate > ; class modm :: CanLawicelFormatter ; class modm :: DogL128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM081 < typename SPI , typename CS , typename RS > ; class modm :: DogM128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM132 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM162 < typename SPI , typename CS , typename RS > ; class modm :: DogM163 < typename SPI , typename CS , typename RS > ; class modm :: DogS102 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: Drv832xSpi < class SpiMaster , class Cs > ; class modm :: Ds1302 < class PinSet > ; class modm :: Ds1631 < typename I2cMaster > ; class modm :: Ds18b20 < typename OneWire > ; class modm :: Ft245 < typename PORT , typename RD , typename WR , typename RXF , typename TXE > ; class modm :: Ft6x06 < typename I2cMaster > ; class modm :: HclaX < typename I2cMaster > ; class modm :: Hd44780 < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Base < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Dual < typename DATA , typename RW , typename RS , typename E1 , typename E2 > ; class modm :: Hmc5843 < typename I2cMaster > ; class modm :: Hmc5883 < typename I2cMaster > ; class modm :: Hmc58x3 < typename I2cMaster > ; class modm :: Hmc6343 < class I2cMaster > ; class modm :: I2cEeprom < typename I2cMaster > ; class modm :: Itg3200 < typename I2cMaster > ; class modm :: L3gd20 < class Transport > ; class modm :: Lis302dl < class Transport > ; class modm :: Lis3TransportI2c < class I2cMaster > ; class modm :: Lis3TransportSpi < class SpiMaster , class Cs > ; class modm :: Lis3dsh < class Transport > ; class modm :: Lm75 < class I2cMaster > ; class modm :: Lsm303a < class I2cMaster > ; class modm :: Ltc2984 < class SpiMaster , class Cs > ; class modm :: MAX6966 < typename Spi , typename Cs , uint8_t DRIVERS = 1 > ; class modm :: Max7219 < typename SPI , typename CS , uint8_t MODULES = 1 > ; class modm :: Max7219Matrix < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ; class modm :: Max7219MatrixHorizontal < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ; class modm :: Mcp23TransportI2c < class I2cMaster > ; class modm :: Mcp23TransportSpi < class SpiMaster , class Cs > ; class modm :: Mcp23x17 < class Transport > ; class modm :: Mcp2515 < typename SPI , typename CS , typename INT > ; class modm :: MemoryBus < typename PORT , typename CS , typename RD , typename WR > ; class modm :: Nokia5110 < typename Spi , typename Ce , typename Dc , typename Reset > ; class modm :: Nrf24Config < typename Nrf24Phy > ; class modm :: Nrf24Data < typename Nrf24Phy > ; class modm :: Nrf24Phy < typename Spi , typename Csn , typename Ce > ; class modm :: ParallelTft < typename INTERFACE > ; class modm :: Pat9125el < typename Transport , typename IntPin = void > ; class modm :: Pat9125elI2cTransport < class I2cMaster > ; class modm :: Pca8574 < class I2cMaster > ; class modm :: Pca9535 < typename I2cMaster > ; class modm :: Pca9548a < typename I2cMaster > ; class modm :: Pca9685 < typename I2cMaster > ; class modm :: SiemensS65Common < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Landscape < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Portrait < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS75Common < typename MEMORY , typename RESET , uint16_t WIDTH , uint16_t HEIGHT , modm :: Orientation ORIENTATION > ; class modm :: SiemensS75LandscapeLeft < typename MEMORY , typename RESET > ; class modm :: SiemensS75LandscapeRight < typename MEMORY , typename RESET > ; class modm :: SiemensS75Portrait < typename MEMORY , typename RESET > ; class modm :: SiemensS75PortraitUpsideDown < typename MEMORY , typename RESET > ; class modm :: Ssd1306 < class I2cMaster , uint8_t Height = 64 > ; class modm :: St7036 < typename SPI , typename CS , typename RS , unsigned int Width , unsigned int Heigth > ; class modm :: St7565 < typename SPI , typename CS , typename A0 , typename Reset , unsigned int Width , unsigned int Height , bool TopView > ; class modm :: Tcs3414 :: uint16_t_LOW_HIGH ; class modm :: Tcs3414 < typename I2cMaster > ; class modm :: Tcs3472 :: uint16_t_LOW_HIGH ; class modm :: Tcs3472 < typename I2cMaster > ; class modm :: TftMemoryBus16Bit ; class modm :: TftMemoryBus8Bit ; class modm :: TftMemoryBus8BitGpio < typename PORT , typename CS , typename RD , typename WR , typename CD > ; class modm :: Tmp102 < class I2cMaster > ; class modm :: Tmp175 < typename I2cMaster > ; class modm :: Vl53l0 < typename I2cMaster > ; class modm :: Vl6180 < typename I2cMaster > ; class modm :: Ws2812b < class SpiMaster , class Output , size_t LEDs > ; class modm :: bme280data :: Data ; class modm :: bme280data :: DataDouble ; class modm :: bmp085data :: Data ; class modm :: bmp085data :: DataBase ; class modm :: bmp085data :: DataDouble ; class modm :: fat :: Directory ; class modm :: fat :: File ; class modm :: fat :: FileInfo ; class modm :: fat :: FileSystem ; class modm :: fat :: PhysicalVolume ; // Struct struct modm :: BdSpiFlash :: JedecId ; struct modm :: CanBitTimingMcp2515 :: CanBitTimingConfiguration ; struct modm :: Hd44780Base :: Bus < Data , Enable , 4 > ; struct modm :: Hd44780Base :: Bus < Data , Enable , 8 > ; struct modm :: Hd44780Base :: Bus < typename Data , typename Enable , uint8_t Width > ; struct modm :: Mcp23x17 :: Memory ; struct modm :: Nrf24Data :: Frame ; struct modm :: Nrf24Data :: Header ; struct modm :: Nrf24Data :: Packet :: Payload ; struct modm :: Nrf24Data :: Packet ; struct modm :: Nrf24Register ; struct modm :: Tcs3414 :: Data . __unnamed__ ; struct modm :: Tcs3472 :: Data . __unnamed__ ; struct modm :: ad7280a :: ConversionValue ; struct modm :: ad7280a :: RegisterValue ; struct modm :: ad7928 :: Data ; struct modm :: ad7928 ; struct modm :: adns9800 ; struct modm :: ams5915 :: Data ; struct modm :: ams5915 ; struct modm :: bme280 ; struct modm :: bme280data :: Calibration ; struct modm :: bme280data :: DataBase ; struct modm :: bmp085 ; struct modm :: bmp085data :: Calibration ; struct modm :: drv832xSpi ; struct modm :: ds1302 :: Config ; struct modm :: ds1302 :: Data ; struct modm :: ds1302 ; struct modm :: ds1631 ; struct modm :: ft6x06 :: Data ; struct modm :: ft6x06 :: touch_t ; struct modm :: ft6x06 ; struct modm :: hclax :: Data ; struct modm :: hclax ; struct modm :: hmc5843 ; struct modm :: hmc5883 ; struct modm :: hmc58x3 :: Data ; struct modm :: hmc58x3 ; struct modm :: hmc6343 :: Data ; struct modm :: hmc6343 ; struct modm :: itg3200 :: Data ; struct modm :: itg3200 ; struct modm :: l3gd20 :: Data ; struct modm :: l3gd20 ; struct modm :: lis302dl :: Data ; struct modm :: lis302dl ; struct modm :: lis3dsh :: Data ; struct modm :: lis3dsh ; struct modm :: lm75 :: Data ; struct modm :: lm75 ; struct modm :: lsm303a :: Data ; struct modm :: lsm303a ; struct modm :: ltc2984 :: Configuration :: Rsense ; struct modm :: ltc2984 :: Configuration :: Rtd ; struct modm :: ltc2984 :: Configuration ; struct modm :: ltc2984 :: Data ; struct modm :: ltc2984 ; struct modm :: mcp23x17 ; struct modm :: pat9125el ; struct modm :: pca8574 ; struct modm :: pca9535 ; struct modm :: pca9685 ; struct modm :: ssd1306 ; struct modm :: tcs3414 ; struct modm :: tcs3472 ; struct modm :: tmp102 :: Data ; struct modm :: tmp102 ; struct modm :: tmp175 ; struct modm :: vl53l0 :: Data ; struct modm :: vl53l0 :: TimeOverhead ; struct modm :: vl53l0 ; struct modm :: vl6180 :: Data ; struct modm :: vl6180 ; // Function IOStream & modm :: operator << ( IOStream & os , const ad7280a :: ConversionValue & c ); IOStream & modm :: operator << ( IOStream & os , const ad7280a :: RegisterValue & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: CsaControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: DriverControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: FaultStatus1_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveHS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveLS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: OcpControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: VgsStatus2_t & c ); IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data & c ); IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data :: Status & c ); IOStream & modm :: operator << ( IOStream & os , const vl53l0 :: RangeErrorCode & c ); IOStream & modm :: operator << ( IOStream & out , const ad7928 :: Data & data ); ltc2984 :: CommandStatus modm :: operator | ( ltc2984 :: CommandStatus r , ltc2984 :: Channel c ); ltc2984 :: Register modm :: operator + ( ltc2984 :: Register r , ltc2984 :: Channel c ); // Enum enum Average ; enum BFPCTRL ; enum Brightness ; enum CANCTRL ; enum CANINTE ; enum CANINTF ; enum CANSTAT ; enum CNF1 ; enum CNF2 ; enum CNF3 ; enum Cell ; enum Channel ; enum Config ; enum Current ; enum Device ; enum EFLG ; enum Orientation ; enum RXB0CTRL ; enum RXB1CTRL ; enum RXBnDLC ; enum RXBnSIDL ; enum Register ; enum Register ; enum Register ; enum RxStatus ; enum Status ; enum TXBnCTRL ; enum TXBnSIDL ; enum TXRTSCTRL ; enum Time ; // Variable const uint8_t modm :: max6966 :: READ = 0x80 ; const uint8_t modm :: max6966 :: WRITE = 0x00 ; const uint8_t modm :: st7565 :: configuration_dogm132 [ 12 ] ; const uint8_t modm :: st7565 :: configuration_dogs102 [ 11 ] ; const uint8_t modm :: st7565 :: configuration_dogx128 [ 12 ] ; constexpr uint16_t firmware_length = 3070 ; constexpr uint8_t firmware_data [ firmware_length ] ; struct modm :: Tcs3414 :: Data :: @ 0 modm :: Tcs3414 < I2cMaster >:: Data :: @ 1 ; struct modm :: Tcs3472 :: Data :: @ 2 modm :: Tcs3472 < I2cMaster >:: Data :: @ 3 ; uint8_t modm :: Tcs3414 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ; uint8_t modm :: Tcs3472 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ; // Typedef typedef DRESULT modm :: fat :: Result ; typedef DSTATUS modm :: fat :: Status ; // Define #define MCP2515_FILTER(id) #define MCP2515_FILTER_EXTENDED(id) #define MCP2515_MASK(id) #define MCP2515_MASK_EXTENDED(id) #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define S65_LPC_ACCELERATED #define ST7565_ADC_NORMAL #define ST7565_ADC_REVERSE #define ST7565_BIAS_1_7 #define ST7565_BIAS_1_9 #define ST7565_BOOSTER_234 #define ST7565_BOOSTER_5 #define ST7565_BOOSTER_6 #define ST7565_BOOSTER_SET #define ST7565_COL_ADDRESS_LSB #define ST7565_COL_ADDRESS_MSB #define ST7565_INDICATOR_MODE_1HZ #define ST7565_INDICATOR_MODE_2HZ #define ST7565_INDICATOR_MODE_OFF #define ST7565_INDICATOR_MODE_ON #define ST7565_INDICATOR_OFF #define ST7565_INDICATOR_ON #define ST7565_NOP #define ST7565_NORMAL #define ST7565_OFF #define ST7565_ON #define ST7565_PAGE_ADDRESS #define ST7565_POWER_CONTROL #define ST7565_POWER_LOW_POWER #define ST7565_POWER_LOW_VOLTAGE #define ST7565_POWER_WIDE_RANGE #define ST7565_RESET_CMD #define ST7565_REVERSE #define ST7565_SCAN_DIR_NORMAL #define ST7565_SCAN_DIR_REVERSE #define ST7565_SHOW_ALL_POINTS #define ST7565_SHOW_NORMAL #define ST7565_VOLTAGE #define ST7565_VOLUME_MODE_1 #define ST7565_VOLUME_MODE_2 Dependencies \u00b6 modm:driver modm_driver modm: driver modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_driver modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_driver modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_driver modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_driver modm_driver_ads7843 modm: driver: ads7843 modm_driver_ads7843->modm_driver modm_driver_ams5915 modm: driver: ams5915 modm_driver_ams5915->modm_driver modm_driver_block_device modm: driver: block.device modm_driver_block_device->modm_driver modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_driver modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_driver modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_driver modm_driver_ds1302 modm: driver: ds1302 modm_driver_ds1302->modm_driver modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_driver modm_driver_ds18b20 modm: driver: ds18b20 modm_driver_ds18b20->modm_driver modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_driver modm_driver_fat modm: driver: fat modm_driver_fat->modm_driver modm_driver_ft245 modm: driver: ft245 modm_driver_ft245->modm_driver modm_driver_ft6x06 modm: driver: ft6x06 modm_driver_ft6x06->modm_driver modm_driver_hclax modm: driver: hclax modm_driver_hclax->modm_driver modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_driver modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_driver modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_driver modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_driver_i2c_eeprom->modm_driver modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_driver modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_driver modm_driver_lawicel modm: driver: lawicel modm_driver_lawicel->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_driver modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_driver modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_lm75->modm_driver modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_driver modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_driver modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_driver modm_driver_max7219 modm: driver: max7219 modm_driver_max7219->modm_driver modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_driver modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_driver modm_driver_memory_bus modm: driver: memory_bus modm_driver_memory_bus->modm_driver modm_driver_nokia5110 modm: driver: nokia5110 modm_driver_nokia5110->modm_driver modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_driver modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_driver_parallel_tft_display->modm_driver modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_driver modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_driver modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_driver modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_driver modm_driver_pca9685 modm: driver: pca9685 modm_driver_pca9685->modm_driver modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_driver modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_driver modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_driver modm_driver_tcs3414 modm: driver: tcs3414 modm_driver_tcs3414->modm_driver modm_driver_tcs3472 modm: driver: tcs3472 modm_driver_tcs3472->modm_driver modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_driver modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_driver modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_driver modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_driver modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_driver","title":"modm:driver"},{"location":"reference/module/modm-driver/#modmdriver-external-device-drivers","text":"","title":"modm:driver: External Device Drivers"},{"location":"reference/module/modm-driver/#content","text":"// Class class modm :: Ad7280a < typename Spi , typename Cs , typename Cnvst , int N > ; class modm :: Ad7928 < typename SpiMaster , typename Cs > ; class modm :: AdcSampler < class AdcInterrupt , uint8_t Channels , uint32_t Oversamples = 1 > ; class modm :: Adns9800 < typename Spi , typename Cs > ; class modm :: Ads7843 < typename Spi , typename Cs , typename Int > ; class modm :: Ams5915 < typename I2cMaster > ; class modm :: BdHeap < size_t DeviceSize_ , bool externalMemory = false > ; class modm :: BdMirror < typename BlockDeviceA , typename BlockDeviceB > ; class modm :: BdSpiFlash < typename Spi , typename Cs , uint32_t flashSize > ; class modm :: BitbangMemoryInterface < typename PORT , typename CS , typename CD , typename WR > ; class modm :: Bme280 < typename I2cMaster > ; class modm :: Bmp085 < typename I2cMaster > ; class modm :: CanBitTimingMcp2515 < int32_t Clk , int32_t Bitrate > ; class modm :: CanLawicelFormatter ; class modm :: DogL128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM081 < typename SPI , typename CS , typename RS > ; class modm :: DogM128 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM132 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: DogM162 < typename SPI , typename CS , typename RS > ; class modm :: DogM163 < typename SPI , typename CS , typename RS > ; class modm :: DogS102 < typename SPI , typename CS , typename A0 , typename Reset , bool TopView = false > ; class modm :: Drv832xSpi < class SpiMaster , class Cs > ; class modm :: Ds1302 < class PinSet > ; class modm :: Ds1631 < typename I2cMaster > ; class modm :: Ds18b20 < typename OneWire > ; class modm :: Ft245 < typename PORT , typename RD , typename WR , typename RXF , typename TXE > ; class modm :: Ft6x06 < typename I2cMaster > ; class modm :: HclaX < typename I2cMaster > ; class modm :: Hd44780 < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Base < typename DATA , typename RW , typename RS , typename E > ; class modm :: Hd44780Dual < typename DATA , typename RW , typename RS , typename E1 , typename E2 > ; class modm :: Hmc5843 < typename I2cMaster > ; class modm :: Hmc5883 < typename I2cMaster > ; class modm :: Hmc58x3 < typename I2cMaster > ; class modm :: Hmc6343 < class I2cMaster > ; class modm :: I2cEeprom < typename I2cMaster > ; class modm :: Itg3200 < typename I2cMaster > ; class modm :: L3gd20 < class Transport > ; class modm :: Lis302dl < class Transport > ; class modm :: Lis3TransportI2c < class I2cMaster > ; class modm :: Lis3TransportSpi < class SpiMaster , class Cs > ; class modm :: Lis3dsh < class Transport > ; class modm :: Lm75 < class I2cMaster > ; class modm :: Lsm303a < class I2cMaster > ; class modm :: Ltc2984 < class SpiMaster , class Cs > ; class modm :: MAX6966 < typename Spi , typename Cs , uint8_t DRIVERS = 1 > ; class modm :: Max7219 < typename SPI , typename CS , uint8_t MODULES = 1 > ; class modm :: Max7219Matrix < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ; class modm :: Max7219MatrixHorizontal < typename SPI , typename CS , uint8_t COLUMNS = 1 , uint8_t ROWS = 1 > ; class modm :: Mcp23TransportI2c < class I2cMaster > ; class modm :: Mcp23TransportSpi < class SpiMaster , class Cs > ; class modm :: Mcp23x17 < class Transport > ; class modm :: Mcp2515 < typename SPI , typename CS , typename INT > ; class modm :: MemoryBus < typename PORT , typename CS , typename RD , typename WR > ; class modm :: Nokia5110 < typename Spi , typename Ce , typename Dc , typename Reset > ; class modm :: Nrf24Config < typename Nrf24Phy > ; class modm :: Nrf24Data < typename Nrf24Phy > ; class modm :: Nrf24Phy < typename Spi , typename Csn , typename Ce > ; class modm :: ParallelTft < typename INTERFACE > ; class modm :: Pat9125el < typename Transport , typename IntPin = void > ; class modm :: Pat9125elI2cTransport < class I2cMaster > ; class modm :: Pca8574 < class I2cMaster > ; class modm :: Pca9535 < typename I2cMaster > ; class modm :: Pca9548a < typename I2cMaster > ; class modm :: Pca9685 < typename I2cMaster > ; class modm :: SiemensS65Common < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Landscape < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS65Portrait < typename SPI , typename CS , typename RS , typename Reset > ; class modm :: SiemensS75Common < typename MEMORY , typename RESET , uint16_t WIDTH , uint16_t HEIGHT , modm :: Orientation ORIENTATION > ; class modm :: SiemensS75LandscapeLeft < typename MEMORY , typename RESET > ; class modm :: SiemensS75LandscapeRight < typename MEMORY , typename RESET > ; class modm :: SiemensS75Portrait < typename MEMORY , typename RESET > ; class modm :: SiemensS75PortraitUpsideDown < typename MEMORY , typename RESET > ; class modm :: Ssd1306 < class I2cMaster , uint8_t Height = 64 > ; class modm :: St7036 < typename SPI , typename CS , typename RS , unsigned int Width , unsigned int Heigth > ; class modm :: St7565 < typename SPI , typename CS , typename A0 , typename Reset , unsigned int Width , unsigned int Height , bool TopView > ; class modm :: Tcs3414 :: uint16_t_LOW_HIGH ; class modm :: Tcs3414 < typename I2cMaster > ; class modm :: Tcs3472 :: uint16_t_LOW_HIGH ; class modm :: Tcs3472 < typename I2cMaster > ; class modm :: TftMemoryBus16Bit ; class modm :: TftMemoryBus8Bit ; class modm :: TftMemoryBus8BitGpio < typename PORT , typename CS , typename RD , typename WR , typename CD > ; class modm :: Tmp102 < class I2cMaster > ; class modm :: Tmp175 < typename I2cMaster > ; class modm :: Vl53l0 < typename I2cMaster > ; class modm :: Vl6180 < typename I2cMaster > ; class modm :: Ws2812b < class SpiMaster , class Output , size_t LEDs > ; class modm :: bme280data :: Data ; class modm :: bme280data :: DataDouble ; class modm :: bmp085data :: Data ; class modm :: bmp085data :: DataBase ; class modm :: bmp085data :: DataDouble ; class modm :: fat :: Directory ; class modm :: fat :: File ; class modm :: fat :: FileInfo ; class modm :: fat :: FileSystem ; class modm :: fat :: PhysicalVolume ; // Struct struct modm :: BdSpiFlash :: JedecId ; struct modm :: CanBitTimingMcp2515 :: CanBitTimingConfiguration ; struct modm :: Hd44780Base :: Bus < Data , Enable , 4 > ; struct modm :: Hd44780Base :: Bus < Data , Enable , 8 > ; struct modm :: Hd44780Base :: Bus < typename Data , typename Enable , uint8_t Width > ; struct modm :: Mcp23x17 :: Memory ; struct modm :: Nrf24Data :: Frame ; struct modm :: Nrf24Data :: Header ; struct modm :: Nrf24Data :: Packet :: Payload ; struct modm :: Nrf24Data :: Packet ; struct modm :: Nrf24Register ; struct modm :: Tcs3414 :: Data . __unnamed__ ; struct modm :: Tcs3472 :: Data . __unnamed__ ; struct modm :: ad7280a :: ConversionValue ; struct modm :: ad7280a :: RegisterValue ; struct modm :: ad7928 :: Data ; struct modm :: ad7928 ; struct modm :: adns9800 ; struct modm :: ams5915 :: Data ; struct modm :: ams5915 ; struct modm :: bme280 ; struct modm :: bme280data :: Calibration ; struct modm :: bme280data :: DataBase ; struct modm :: bmp085 ; struct modm :: bmp085data :: Calibration ; struct modm :: drv832xSpi ; struct modm :: ds1302 :: Config ; struct modm :: ds1302 :: Data ; struct modm :: ds1302 ; struct modm :: ds1631 ; struct modm :: ft6x06 :: Data ; struct modm :: ft6x06 :: touch_t ; struct modm :: ft6x06 ; struct modm :: hclax :: Data ; struct modm :: hclax ; struct modm :: hmc5843 ; struct modm :: hmc5883 ; struct modm :: hmc58x3 :: Data ; struct modm :: hmc58x3 ; struct modm :: hmc6343 :: Data ; struct modm :: hmc6343 ; struct modm :: itg3200 :: Data ; struct modm :: itg3200 ; struct modm :: l3gd20 :: Data ; struct modm :: l3gd20 ; struct modm :: lis302dl :: Data ; struct modm :: lis302dl ; struct modm :: lis3dsh :: Data ; struct modm :: lis3dsh ; struct modm :: lm75 :: Data ; struct modm :: lm75 ; struct modm :: lsm303a :: Data ; struct modm :: lsm303a ; struct modm :: ltc2984 :: Configuration :: Rsense ; struct modm :: ltc2984 :: Configuration :: Rtd ; struct modm :: ltc2984 :: Configuration ; struct modm :: ltc2984 :: Data ; struct modm :: ltc2984 ; struct modm :: mcp23x17 ; struct modm :: pat9125el ; struct modm :: pca8574 ; struct modm :: pca9535 ; struct modm :: pca9685 ; struct modm :: ssd1306 ; struct modm :: tcs3414 ; struct modm :: tcs3472 ; struct modm :: tmp102 :: Data ; struct modm :: tmp102 ; struct modm :: tmp175 ; struct modm :: vl53l0 :: Data ; struct modm :: vl53l0 :: TimeOverhead ; struct modm :: vl53l0 ; struct modm :: vl6180 :: Data ; struct modm :: vl6180 ; // Function IOStream & modm :: operator << ( IOStream & os , const ad7280a :: ConversionValue & c ); IOStream & modm :: operator << ( IOStream & os , const ad7280a :: RegisterValue & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: CsaControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: DriverControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: FaultStatus1_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveHS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: GateDriveLS_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: OcpControl_t & c ); IOStream & modm :: operator << ( IOStream & os , const drv832xSpi :: VgsStatus2_t & c ); IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data & c ); IOStream & modm :: operator << ( IOStream & os , const ltc2984 :: Data :: Status & c ); IOStream & modm :: operator << ( IOStream & os , const vl53l0 :: RangeErrorCode & c ); IOStream & modm :: operator << ( IOStream & out , const ad7928 :: Data & data ); ltc2984 :: CommandStatus modm :: operator | ( ltc2984 :: CommandStatus r , ltc2984 :: Channel c ); ltc2984 :: Register modm :: operator + ( ltc2984 :: Register r , ltc2984 :: Channel c ); // Enum enum Average ; enum BFPCTRL ; enum Brightness ; enum CANCTRL ; enum CANINTE ; enum CANINTF ; enum CANSTAT ; enum CNF1 ; enum CNF2 ; enum CNF3 ; enum Cell ; enum Channel ; enum Config ; enum Current ; enum Device ; enum EFLG ; enum Orientation ; enum RXB0CTRL ; enum RXB1CTRL ; enum RXBnDLC ; enum RXBnSIDL ; enum Register ; enum Register ; enum Register ; enum RxStatus ; enum Status ; enum TXBnCTRL ; enum TXBnSIDL ; enum TXRTSCTRL ; enum Time ; // Variable const uint8_t modm :: max6966 :: READ = 0x80 ; const uint8_t modm :: max6966 :: WRITE = 0x00 ; const uint8_t modm :: st7565 :: configuration_dogm132 [ 12 ] ; const uint8_t modm :: st7565 :: configuration_dogs102 [ 11 ] ; const uint8_t modm :: st7565 :: configuration_dogx128 [ 12 ] ; constexpr uint16_t firmware_length = 3070 ; constexpr uint8_t firmware_data [ firmware_length ] ; struct modm :: Tcs3414 :: Data :: @ 0 modm :: Tcs3414 < I2cMaster >:: Data :: @ 1 ; struct modm :: Tcs3472 :: Data :: @ 2 modm :: Tcs3472 < I2cMaster >:: Data :: @ 3 ; uint8_t modm :: Tcs3414 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ; uint8_t modm :: Tcs3472 < I2cMaster >:: Data :: dataBytes [ 2 * 4 ] ; // Typedef typedef DRESULT modm :: fat :: Result ; typedef DSTATUS modm :: fat :: Status ; // Define #define MCP2515_FILTER(id) #define MCP2515_FILTER_EXTENDED(id) #define MCP2515_MASK(id) #define MCP2515_MASK_EXTENDED(id) #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define MODM_LOG_LEVEL #define S65_LPC_ACCELERATED #define ST7565_ADC_NORMAL #define ST7565_ADC_REVERSE #define ST7565_BIAS_1_7 #define ST7565_BIAS_1_9 #define ST7565_BOOSTER_234 #define ST7565_BOOSTER_5 #define ST7565_BOOSTER_6 #define ST7565_BOOSTER_SET #define ST7565_COL_ADDRESS_LSB #define ST7565_COL_ADDRESS_MSB #define ST7565_INDICATOR_MODE_1HZ #define ST7565_INDICATOR_MODE_2HZ #define ST7565_INDICATOR_MODE_OFF #define ST7565_INDICATOR_MODE_ON #define ST7565_INDICATOR_OFF #define ST7565_INDICATOR_ON #define ST7565_NOP #define ST7565_NORMAL #define ST7565_OFF #define ST7565_ON #define ST7565_PAGE_ADDRESS #define ST7565_POWER_CONTROL #define ST7565_POWER_LOW_POWER #define ST7565_POWER_LOW_VOLTAGE #define ST7565_POWER_WIDE_RANGE #define ST7565_RESET_CMD #define ST7565_REVERSE #define ST7565_SCAN_DIR_NORMAL #define ST7565_SCAN_DIR_REVERSE #define ST7565_SHOW_ALL_POINTS #define ST7565_SHOW_NORMAL #define ST7565_VOLTAGE #define ST7565_VOLUME_MODE_1 #define ST7565_VOLUME_MODE_2","title":"Content"},{"location":"reference/module/modm-driver/#dependencies","text":"modm:driver modm_driver modm: driver modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_driver modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_driver modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_driver modm_driver_adns9800 modm: driver: adns9800 modm_driver_adns9800->modm_driver modm_driver_ads7843 modm: driver: ads7843 modm_driver_ads7843->modm_driver modm_driver_ams5915 modm: driver: ams5915 modm_driver_ams5915->modm_driver modm_driver_block_device modm: driver: block.device modm_driver_block_device->modm_driver modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_driver modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_driver modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_driver modm_driver_ds1302 modm: driver: ds1302 modm_driver_ds1302->modm_driver modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_driver modm_driver_ds18b20 modm: driver: ds18b20 modm_driver_ds18b20->modm_driver modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_driver modm_driver_fat modm: driver: fat modm_driver_fat->modm_driver modm_driver_ft245 modm: driver: ft245 modm_driver_ft245->modm_driver modm_driver_ft6x06 modm: driver: ft6x06 modm_driver_ft6x06->modm_driver modm_driver_hclax modm: driver: hclax modm_driver_hclax->modm_driver modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_driver modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_driver modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_driver modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_driver_i2c_eeprom->modm_driver modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_driver modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_driver modm_driver_lawicel modm: driver: lawicel modm_driver_lawicel->modm_driver modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_driver modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_driver modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_driver modm_driver_lm75 modm: driver: lm75 modm_driver_lm75->modm_driver modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_driver modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_driver modm_driver_max6966 modm: driver: max6966 modm_driver_max6966->modm_driver modm_driver_max7219 modm: driver: max7219 modm_driver_max7219->modm_driver modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_driver modm_driver_mcp2515 modm: driver: mcp2515 modm_driver_mcp2515->modm_driver modm_driver_memory_bus modm: driver: memory_bus modm_driver_memory_bus->modm_driver modm_driver_nokia5110 modm: driver: nokia5110 modm_driver_nokia5110->modm_driver modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_driver modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_driver_parallel_tft_display->modm_driver modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_driver modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_driver modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_driver modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_driver modm_driver_pca9685 modm: driver: pca9685 modm_driver_pca9685->modm_driver modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_driver modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_driver modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_driver modm_driver_tcs3414 modm: driver: tcs3414 modm_driver_tcs3414->modm_driver modm_driver_tcs3472 modm: driver: tcs3472 modm_driver_tcs3472->modm_driver modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_driver modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_driver modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_driver modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_driver modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_driver","title":"Dependencies"},{"location":"reference/module/modm-fatfs/","text":"These module docs are in beta and may be incomplete. modm:fatfs: FatFS \u00b6 Generic FAT Filesystem Module. See http://elm-chan.org/fsw/ff/00index_e.html . Warning This version of FatFS is outdated and rarely used in modm. Dependencies \u00b6 modm:fatfs modm_fatfs modm: fatfs modm_driver_fat modm: driver: fat modm_driver_fat->modm_fatfs","title":"modm:fatfs"},{"location":"reference/module/modm-fatfs/#modmfatfs-fatfs","text":"Generic FAT Filesystem Module. See http://elm-chan.org/fsw/ff/00index_e.html . Warning This version of FatFS is outdated and rarely used in modm.","title":"modm:fatfs: FatFS"},{"location":"reference/module/modm-fatfs/#dependencies","text":"modm:fatfs modm_fatfs modm: fatfs modm_driver_fat modm: driver: fat modm_driver_fat->modm_fatfs","title":"Dependencies"},{"location":"reference/module/modm-freertos/","text":"These module docs are in beta and may be incomplete. modm:freertos: a:FreeRTOS \u00b6 Amazon FreeRTOS port for modm to be used with via the modm:processing:rtos module. Options \u00b6 frequency \u00b6 Context switch frequency in Hz: 1000 \u2208 { 1 ... 1000 } Dependencies \u00b6 modm:freertos modm_freertos modm: freertos modm_architecture_assert modm: architecture: assert modm_freertos->modm_architecture_assert modm_cmsis_device modm: cmsis: device modm_freertos->modm_cmsis_device modm_platform_clock modm: platform: clock modm_freertos->modm_platform_clock modm_processing_rtos modm: processing: rtos modm_processing_rtos->modm_freertos","title":"modm:freertos"},{"location":"reference/module/modm-freertos/#modmfreertos-afreertos","text":"Amazon FreeRTOS port for modm to be used with via the modm:processing:rtos module.","title":"modm:freertos: a:FreeRTOS"},{"location":"reference/module/modm-freertos/#options","text":"","title":"Options"},{"location":"reference/module/modm-freertos/#frequency","text":"Context switch frequency in Hz: 1000 \u2208 { 1 ... 1000 }","title":"frequency"},{"location":"reference/module/modm-freertos/#dependencies","text":"modm:freertos modm_freertos modm: freertos modm_architecture_assert modm: architecture: assert modm_freertos->modm_architecture_assert modm_cmsis_device modm: cmsis: device modm_freertos->modm_cmsis_device modm_platform_clock modm: platform: clock modm_freertos->modm_platform_clock modm_processing_rtos modm: processing: rtos modm_processing_rtos->modm_freertos","title":"Dependencies"},{"location":"reference/module/modm-io/","text":"These module docs are in beta and may be incomplete. modm:io: Input/Output Streams \u00b6 The modm::IOStream class contains efficient formatting that supports both C++ std::basic_ostream -like formatting via operator << as well as implementing a reasonably large subset of printf . modm :: IOStream stream ( device ); stream << \"format number 8: \" << uint8_t ( 8 ) << \" or as signed -100: \" << int8_t ( - 100 ); stream << modm :: endl ; stream . printf ( \"format number 8: %u or as signed -100: %d\" , 8 , - 100 ); AVR supported features All expensive features incl. printf are disabled by default! Check the options. Using printf \u00b6 This module uses the printf implementation from mpaland/printf . Format Specifiers \u00b6 A format specifier follows this prototype: %[flags][width][.precision][length]type The following format specifiers are supported: Supported Types \u00b6 Type Output d or i Signed decimal integer u Unsigned decimal integer b Unsigned binary o Unsigned octal x Unsigned hexadecimal integer (lowercase) X Unsigned hexadecimal integer (uppercase) f or F Decimal floating point ( with_float option) e or E Scientific-notation (exponential) floating point ( with_float option) g or G Scientific or decimal floating point ( with_float option) c Single character s String of characters p Pointer address % A % followed by another % character will write a single % Supported Flags \u00b6 Flags Description - Left-justify within the given field width; Right justification is the default. + Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign. (space) If no sign is going to be written, a blank space is inserted before the value. # Used with o, b, x or X specifiers the value is preceded with 0, 0b, 0x or 0X respectively for values different than zero. Used with f, F it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written. 0 Left-pads the number with zeros (0) instead of spaces when padding is specified (see width sub-specifier). Supported Width \u00b6 Width Description (number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger. * The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. Supported Precision \u00b6 Precision Description .number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0. For f and F specifiers: this is the number of digits to be printed after the decimal point. By default, this is 6, maximum is 9 . For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. If the period is specified without an explicit value for precision, 0 is assumed. .* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. Supported Length \u00b6 The length sub-specifier modifies the length of the data type. Length d i u o x X (none) int unsigned int hh char unsigned char h short int unsigned short int l long int unsigned long int ll long long int unsigned long long int ( with_long_long option) j intmax_t uintmax_t z size_t size_t t ptrdiff_t ptrdiff_t ( with_ptrdiff option) Redirecting IOStreams \u00b6 The modm::IODeviceWrapper transforms any peripheral device that provides static write() and read() functions into an IODevice . You have to decide what happens when the device buffer is full and you cannot write to it at the moment. There are two options: busy wait until the buffer is free, or discard the bytes that cannot be written. Option 1 has the advantage, that none of your data will be lost, however, busy-waiting can take a long time and can mess up your program timings. There is also a high risk of deadlock , when writing to a IODevice inside of an interrupt and then busy-waiting forever because the IODevice requires interrupts itself to send out the data. It is therefore highly recommended to use option 2, where surplus data will be discarded. You should increase the IODevice buffer size, if you experience missing data from your connection. This behavior is also deadlock safe when called from inside another interrupt, and your program timing is minimally affected (essentially only coping data into the buffer). There is no default template argument, so that you hopefully make a conscious decision and be aware of this behavior. Example: // configure a UART using Uart = Uart0 ; // wrap it into an IODevice modm :: IODeviceWrapper < Uart , modm :: IOBuffer :: DiscardIfFull > device ; // use this device to print a message device . write ( \"Hello\" ); // or create a IOStream and use the stream to print something modm :: IOStream stream ( device ); stream << \" World!\" ; Options \u00b6 with_long_long \u00b6 Support for 64-bit integer formatting: True \u2208 { True, False } with_float \u00b6 Support for floating point formatting: True \u2208 { True, False } On AVRs floating point values can be printed, however, the formatting cannot be specified and all values are printed as scientific-notation exponential floating point with_ptrdiff \u00b6 Support for pointer difference formatting: True \u2208 { True, False } with_printf \u00b6 Support for printf-style formatting: True \u2208 { True, False } Content \u00b6 // Class class modm :: IODevice ; class modm :: IODeviceWrapper < class Device , IOBuffer behavior > ; class modm :: IOStream ; // Function IOStream & modm :: ascii ( IOStream & ios ); IOStream & modm :: bin ( IOStream & ios ); IOStream & modm :: black ( IOStream & ios ); IOStream & modm :: blue ( IOStream & ios ); IOStream & modm :: cyan ( IOStream & ios ); IOStream & modm :: endl ( IOStream & ios ); IOStream & modm :: flush ( IOStream & ios ); IOStream & modm :: green ( IOStream & ios ); IOStream & modm :: hex ( IOStream & ios ); IOStream & modm :: magenta ( IOStream & ios ); IOStream & modm :: red ( IOStream & ios ); IOStream & modm :: white ( IOStream & ios ); IOStream & modm :: yellow ( IOStream & ios ); // Enum enum IOBuffer ; Dependencies \u00b6 modm:io modm_io modm: io modm_architecture_accessor modm: architecture: accessor modm_io->modm_architecture_accessor modm_math_utils modm: math: utils modm_io->modm_math_utils modm_architecture_accessor->modm_io modm_architecture_can modm: architecture: can modm_architecture_can->modm_io modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_io modm_architecture_register modm: architecture: register modm_architecture_register->modm_io modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_io modm_container modm: container modm_container->modm_io modm_debug modm: debug modm_debug->modm_io modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_io modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_io modm_math_geometry modm: math: geometry modm_math_geometry->modm_io modm_math_matrix modm: math: matrix modm_math_matrix->modm_io modm_processing_timer modm: processing: timer modm_processing_timer->modm_io modm_ui_color modm: ui: color modm_ui_color->modm_io modm_ui_display modm: ui: display modm_ui_display->modm_io modm_unittest modm: unittest modm_unittest->modm_io","title":"modm:io"},{"location":"reference/module/modm-io/#modmio-inputoutput-streams","text":"The modm::IOStream class contains efficient formatting that supports both C++ std::basic_ostream -like formatting via operator << as well as implementing a reasonably large subset of printf . modm :: IOStream stream ( device ); stream << \"format number 8: \" << uint8_t ( 8 ) << \" or as signed -100: \" << int8_t ( - 100 ); stream << modm :: endl ; stream . printf ( \"format number 8: %u or as signed -100: %d\" , 8 , - 100 ); AVR supported features All expensive features incl. printf are disabled by default! Check the options.","title":"modm:io: Input/Output Streams"},{"location":"reference/module/modm-io/#using-printf","text":"This module uses the printf implementation from mpaland/printf .","title":"Using printf"},{"location":"reference/module/modm-io/#format-specifiers","text":"A format specifier follows this prototype: %[flags][width][.precision][length]type The following format specifiers are supported:","title":"Format Specifiers"},{"location":"reference/module/modm-io/#supported-types","text":"Type Output d or i Signed decimal integer u Unsigned decimal integer b Unsigned binary o Unsigned octal x Unsigned hexadecimal integer (lowercase) X Unsigned hexadecimal integer (uppercase) f or F Decimal floating point ( with_float option) e or E Scientific-notation (exponential) floating point ( with_float option) g or G Scientific or decimal floating point ( with_float option) c Single character s String of characters p Pointer address % A % followed by another % character will write a single %","title":"Supported Types"},{"location":"reference/module/modm-io/#supported-flags","text":"Flags Description - Left-justify within the given field width; Right justification is the default. + Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign. (space) If no sign is going to be written, a blank space is inserted before the value. # Used with o, b, x or X specifiers the value is preceded with 0, 0b, 0x or 0X respectively for values different than zero. Used with f, F it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written. 0 Left-pads the number with zeros (0) instead of spaces when padding is specified (see width sub-specifier).","title":"Supported Flags"},{"location":"reference/module/modm-io/#supported-width","text":"Width Description (number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger. * The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.","title":"Supported Width"},{"location":"reference/module/modm-io/#supported-precision","text":"Precision Description .number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0. For f and F specifiers: this is the number of digits to be printed after the decimal point. By default, this is 6, maximum is 9 . For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. If the period is specified without an explicit value for precision, 0 is assumed. .* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.","title":"Supported Precision"},{"location":"reference/module/modm-io/#supported-length","text":"The length sub-specifier modifies the length of the data type. Length d i u o x X (none) int unsigned int hh char unsigned char h short int unsigned short int l long int unsigned long int ll long long int unsigned long long int ( with_long_long option) j intmax_t uintmax_t z size_t size_t t ptrdiff_t ptrdiff_t ( with_ptrdiff option)","title":"Supported Length"},{"location":"reference/module/modm-io/#redirecting-iostreams","text":"The modm::IODeviceWrapper transforms any peripheral device that provides static write() and read() functions into an IODevice . You have to decide what happens when the device buffer is full and you cannot write to it at the moment. There are two options: busy wait until the buffer is free, or discard the bytes that cannot be written. Option 1 has the advantage, that none of your data will be lost, however, busy-waiting can take a long time and can mess up your program timings. There is also a high risk of deadlock , when writing to a IODevice inside of an interrupt and then busy-waiting forever because the IODevice requires interrupts itself to send out the data. It is therefore highly recommended to use option 2, where surplus data will be discarded. You should increase the IODevice buffer size, if you experience missing data from your connection. This behavior is also deadlock safe when called from inside another interrupt, and your program timing is minimally affected (essentially only coping data into the buffer). There is no default template argument, so that you hopefully make a conscious decision and be aware of this behavior. Example: // configure a UART using Uart = Uart0 ; // wrap it into an IODevice modm :: IODeviceWrapper < Uart , modm :: IOBuffer :: DiscardIfFull > device ; // use this device to print a message device . write ( \"Hello\" ); // or create a IOStream and use the stream to print something modm :: IOStream stream ( device ); stream << \" World!\" ;","title":"Redirecting IOStreams"},{"location":"reference/module/modm-io/#options","text":"","title":"Options"},{"location":"reference/module/modm-io/#with_long_long","text":"Support for 64-bit integer formatting: True \u2208 { True, False }","title":"with_long_long"},{"location":"reference/module/modm-io/#with_float","text":"Support for floating point formatting: True \u2208 { True, False } On AVRs floating point values can be printed, however, the formatting cannot be specified and all values are printed as scientific-notation exponential floating point","title":"with_float"},{"location":"reference/module/modm-io/#with_ptrdiff","text":"Support for pointer difference formatting: True \u2208 { True, False }","title":"with_ptrdiff"},{"location":"reference/module/modm-io/#with_printf","text":"Support for printf-style formatting: True \u2208 { True, False }","title":"with_printf"},{"location":"reference/module/modm-io/#content","text":"// Class class modm :: IODevice ; class modm :: IODeviceWrapper < class Device , IOBuffer behavior > ; class modm :: IOStream ; // Function IOStream & modm :: ascii ( IOStream & ios ); IOStream & modm :: bin ( IOStream & ios ); IOStream & modm :: black ( IOStream & ios ); IOStream & modm :: blue ( IOStream & ios ); IOStream & modm :: cyan ( IOStream & ios ); IOStream & modm :: endl ( IOStream & ios ); IOStream & modm :: flush ( IOStream & ios ); IOStream & modm :: green ( IOStream & ios ); IOStream & modm :: hex ( IOStream & ios ); IOStream & modm :: magenta ( IOStream & ios ); IOStream & modm :: red ( IOStream & ios ); IOStream & modm :: white ( IOStream & ios ); IOStream & modm :: yellow ( IOStream & ios ); // Enum enum IOBuffer ;","title":"Content"},{"location":"reference/module/modm-io/#dependencies","text":"modm:io modm_io modm: io modm_architecture_accessor modm: architecture: accessor modm_io->modm_architecture_accessor modm_math_utils modm: math: utils modm_io->modm_math_utils modm_architecture_accessor->modm_io modm_architecture_can modm: architecture: can modm_architecture_can->modm_io modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c->modm_io modm_architecture_register modm: architecture: register modm_architecture_register->modm_io modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_io modm_container modm: container modm_container->modm_io modm_debug modm: debug modm_debug->modm_io modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_io modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_io modm_math_geometry modm: math: geometry modm_math_geometry->modm_io modm_math_matrix modm: math: matrix modm_math_matrix->modm_io modm_processing_timer modm: processing: timer modm_processing_timer->modm_io modm_ui_color modm: ui: color modm_ui_color->modm_io modm_ui_display modm: ui: display modm_ui_display->modm_io modm_unittest modm: unittest modm_unittest->modm_io","title":"Dependencies"},{"location":"reference/module/modm-math-filter/","text":"These module docs are in beta and may be incomplete. modm:math:filter: Filters \u00b6 Content \u00b6 // Class class modm :: Pid < typename T , unsigned int ScaleFactor = 1 > ; class modm :: SCurveController < typename T > ; class modm :: SCurveGenerator < typename T > ; class modm :: filter :: Debounce < typename T = uint8_t > ; class modm :: filter :: Fir < typename T , int N , int BLOCK_SIZE , signed int ScaleFactor = 1 > ; class modm :: filter :: Median < typename T , int N > ; class modm :: filter :: MovingAverage < typename T , std :: size_t N > ; class modm :: filter :: Ramp < typename T > ; // Struct struct modm :: Pid :: Parameter ; struct modm :: SCurveController :: Parameter ; Dependencies \u00b6 modm:math:filter modm_math_filter modm: math: filter modm_architecture modm: architecture modm_math_filter->modm_architecture modm_math modm: math modm_math_filter->modm_math modm_math_utils modm: math: utils modm_math_filter->modm_math_utils","title":"modm:math:filter"},{"location":"reference/module/modm-math-filter/#modmmathfilter-filters","text":"","title":"modm:math:filter: Filters"},{"location":"reference/module/modm-math-filter/#content","text":"// Class class modm :: Pid < typename T , unsigned int ScaleFactor = 1 > ; class modm :: SCurveController < typename T > ; class modm :: SCurveGenerator < typename T > ; class modm :: filter :: Debounce < typename T = uint8_t > ; class modm :: filter :: Fir < typename T , int N , int BLOCK_SIZE , signed int ScaleFactor = 1 > ; class modm :: filter :: Median < typename T , int N > ; class modm :: filter :: MovingAverage < typename T , std :: size_t N > ; class modm :: filter :: Ramp < typename T > ; // Struct struct modm :: Pid :: Parameter ; struct modm :: SCurveController :: Parameter ;","title":"Content"},{"location":"reference/module/modm-math-filter/#dependencies","text":"modm:math:filter modm_math_filter modm: math: filter modm_architecture modm: architecture modm_math_filter->modm_architecture modm_math modm: math modm_math_filter->modm_math modm_math_utils modm: math: utils modm_math_filter->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-math-geometry/","text":"These module docs are in beta and may be incomplete. modm:math:geometry: Geometric Operations \u00b6 Content \u00b6 // Class class modm :: Angle ; class modm :: Circle2D < typename T > ; class modm :: Line2D < typename T > ; class modm :: LineSegment2D < typename T = int16_t > ; class modm :: Location2D < typename T = int16_t > ; class modm :: Matrix < typename T , uint8_t ROWS , uint8_t COLUMNS > ; class modm :: PointSet2D < typename T > ; class modm :: Polygon2D < typename T > ; class modm :: Quaternion < class T > ; class modm :: Ray2D < typename T = int16_t > ; class modm :: Vector < T , 1 > ; class modm :: Vector < T , 2 > ; class modm :: Vector < T , 3 > ; class modm :: Vector < T , 4 > ; class modm :: Vector < typename T , uint8_t N > ; // Struct struct modm :: GeometricTraits < double > ; struct modm :: GeometricTraits < float > ; struct modm :: GeometricTraits < int16_t > ; struct modm :: GeometricTraits < int32_t > ; struct modm :: GeometricTraits < int8_t > ; struct modm :: GeometricTraits < typename T > ; struct modm :: GeometricTraits < uint8_t > ; struct modm :: detail :: MakeSigned < Vector < T , N > > ; struct modm :: detail :: MakeUnsigned < Vector < T , N > > ; struct modm :: detail :: WideType < Vector < T , N > > ; // Function IOStream & modm :: operator << ( IOStream & os , const Location2D < T > & l ); IOStream & modm :: operator << ( IOStream & os , const Vector < U , 2 > & c ); Quaternion < T > modm :: operator * ( const T & lhs , const Quaternion < T > & rhs ); Vector < U , 2 > modm :: operator * ( float scale , const Vector < U , 2 > & vector ); Vector < U , 2 > modm :: operator / ( float scale , const Vector < U , 2 > & vector ); static Vector < T , 1 > modm :: operator * ( const U & lhs , const Vector < T , 1 > & rhs ); static Vector < T , 3 > modm :: operator * ( const U & lhs , const Vector < T , 3 > & rhs ); static Vector < T , 4 > modm :: operator * ( const U & lhs , const Vector < T , 4 > & rhs ); static Vector < U , 3 > modm :: operator * ( const Matrix < T , 3 , 3 > & lhs , const Vector < U , 3 > & rhs ); static Vector < U , 4 > modm :: operator * ( const Matrix < T , 4 , 4 > & lhs , const Vector < U , 4 > & rhs ); static constexpr float modm :: toDegree ( float angle ); static constexpr float modm :: toRadian ( float angle ); // Typedef typedef Vector < float , 1 > modm :: Vector1f ; typedef Vector < float , 2 > modm :: Vector2f ; typedef Vector < float , 3 > modm :: Vector3f ; typedef Vector < float , 4 > modm :: Vector4f ; typedef Vector < int16_t , 1 > modm :: Vector1i ; typedef Vector < int16_t , 2 > modm :: Vector2i ; typedef Vector < int16_t , 3 > modm :: Vector3i ; typedef Vector < int16_t , 4 > modm :: Vector4i ; typedef Vector < uint16_t , 2 > modm :: Vector2u ; typedef Vector < uint16_t , 3 > modm :: Vector3u ; typedef Vector < uint16_t , 4 > modm :: Vector4u ; // Define #define IMPLEMENT_VECTOR_ACCESSOR2(a, b) #define IMPLEMENT_VECTOR_ACCESSOR3(a, b, c) #define IMPLEMENT_VECTOR_ACCESSOR4(a, b, c, d) #define M_1_PI #define M_2_PI #define M_PI #define M_PI_2 #define M_PI_4 #define M_SQRT2 #define M_TWOPI Dependencies \u00b6 modm:math:geometry modm_math_geometry modm: math: geometry modm_architecture modm: architecture modm_math_geometry->modm_architecture modm_container modm: container modm_math_geometry->modm_container modm_io modm: io modm_math_geometry->modm_io modm_math modm: math modm_math_geometry->modm_math modm_math_matrix modm: math: matrix modm_math_geometry->modm_math_matrix modm_math_utils modm: math: utils modm_math_geometry->modm_math_utils modm_math_matrix->modm_math_geometry modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_math_geometry modm_ui_display modm: ui: display modm_ui_display->modm_math_geometry","title":"modm:math:geometry"},{"location":"reference/module/modm-math-geometry/#modmmathgeometry-geometric-operations","text":"","title":"modm:math:geometry: Geometric Operations"},{"location":"reference/module/modm-math-geometry/#content","text":"// Class class modm :: Angle ; class modm :: Circle2D < typename T > ; class modm :: Line2D < typename T > ; class modm :: LineSegment2D < typename T = int16_t > ; class modm :: Location2D < typename T = int16_t > ; class modm :: Matrix < typename T , uint8_t ROWS , uint8_t COLUMNS > ; class modm :: PointSet2D < typename T > ; class modm :: Polygon2D < typename T > ; class modm :: Quaternion < class T > ; class modm :: Ray2D < typename T = int16_t > ; class modm :: Vector < T , 1 > ; class modm :: Vector < T , 2 > ; class modm :: Vector < T , 3 > ; class modm :: Vector < T , 4 > ; class modm :: Vector < typename T , uint8_t N > ; // Struct struct modm :: GeometricTraits < double > ; struct modm :: GeometricTraits < float > ; struct modm :: GeometricTraits < int16_t > ; struct modm :: GeometricTraits < int32_t > ; struct modm :: GeometricTraits < int8_t > ; struct modm :: GeometricTraits < typename T > ; struct modm :: GeometricTraits < uint8_t > ; struct modm :: detail :: MakeSigned < Vector < T , N > > ; struct modm :: detail :: MakeUnsigned < Vector < T , N > > ; struct modm :: detail :: WideType < Vector < T , N > > ; // Function IOStream & modm :: operator << ( IOStream & os , const Location2D < T > & l ); IOStream & modm :: operator << ( IOStream & os , const Vector < U , 2 > & c ); Quaternion < T > modm :: operator * ( const T & lhs , const Quaternion < T > & rhs ); Vector < U , 2 > modm :: operator * ( float scale , const Vector < U , 2 > & vector ); Vector < U , 2 > modm :: operator / ( float scale , const Vector < U , 2 > & vector ); static Vector < T , 1 > modm :: operator * ( const U & lhs , const Vector < T , 1 > & rhs ); static Vector < T , 3 > modm :: operator * ( const U & lhs , const Vector < T , 3 > & rhs ); static Vector < T , 4 > modm :: operator * ( const U & lhs , const Vector < T , 4 > & rhs ); static Vector < U , 3 > modm :: operator * ( const Matrix < T , 3 , 3 > & lhs , const Vector < U , 3 > & rhs ); static Vector < U , 4 > modm :: operator * ( const Matrix < T , 4 , 4 > & lhs , const Vector < U , 4 > & rhs ); static constexpr float modm :: toDegree ( float angle ); static constexpr float modm :: toRadian ( float angle ); // Typedef typedef Vector < float , 1 > modm :: Vector1f ; typedef Vector < float , 2 > modm :: Vector2f ; typedef Vector < float , 3 > modm :: Vector3f ; typedef Vector < float , 4 > modm :: Vector4f ; typedef Vector < int16_t , 1 > modm :: Vector1i ; typedef Vector < int16_t , 2 > modm :: Vector2i ; typedef Vector < int16_t , 3 > modm :: Vector3i ; typedef Vector < int16_t , 4 > modm :: Vector4i ; typedef Vector < uint16_t , 2 > modm :: Vector2u ; typedef Vector < uint16_t , 3 > modm :: Vector3u ; typedef Vector < uint16_t , 4 > modm :: Vector4u ; // Define #define IMPLEMENT_VECTOR_ACCESSOR2(a, b) #define IMPLEMENT_VECTOR_ACCESSOR3(a, b, c) #define IMPLEMENT_VECTOR_ACCESSOR4(a, b, c, d) #define M_1_PI #define M_2_PI #define M_PI #define M_PI_2 #define M_PI_4 #define M_SQRT2 #define M_TWOPI","title":"Content"},{"location":"reference/module/modm-math-geometry/#dependencies","text":"modm:math:geometry modm_math_geometry modm: math: geometry modm_architecture modm: architecture modm_math_geometry->modm_architecture modm_container modm: container modm_math_geometry->modm_container modm_io modm: io modm_math_geometry->modm_io modm_math modm: math modm_math_geometry->modm_math modm_math_matrix modm: math: matrix modm_math_geometry->modm_math_matrix modm_math_utils modm: math: utils modm_math_geometry->modm_math_utils modm_math_matrix->modm_math_geometry modm_driver_pat9125el modm: driver: pat9125el modm_driver_pat9125el->modm_math_geometry modm_ui_display modm: ui: display modm_ui_display->modm_math_geometry","title":"Dependencies"},{"location":"reference/module/modm-math-interpolation/","text":"These module docs are in beta and may be incomplete. modm:math:interpolation: Interpolation Methods \u00b6 Simple interpolation methods between a list of points. Linear Interpolation \u00b6 Example: // Definition of the supporting points. The first type is the // input type, the second the output type using Point = modm :: Pair < int8_t , int16_t > ; // Create a array of supporting points describing the curve. const Point supportingPoints [ 6 ] = { { 30 , - 200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; modm :: interpolation :: Linear < Point > value ( supportingPoints , 6 ); // ... int8_t a = 40 ; int16_t b = value . interpolate ( a ); Example with supporting points read from flash: // Definition of a supporting point using Point = modm :: Pair < int8_t , int16_t > ; // Array of supporting points in flash FLASH_STORAGE ( Point supportingPoints [ 6 ]) = { { 30 , - 200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; // Create an interpolator object which reads the // supporting points from flash. modm :: interpolation :: Linear < Point , modm :: accessor :: Flash > value ( modm :: accessor :: asFlash ( supportingPoints ), 6 ); // ... int8_t a = 20 ; int16_t b = value . interpolate ( a ); Lagrange Interpolation \u00b6 Example: using Point = modm :: Pair < float , float > ; // interpolate x^2 over the range of 1 <= x <= 3 Point points [ 3 ] = { { 1 , 1 }, { 2 , 4 }, { 3 , 9 } }; modm :: interpolation :: Lagrange < Point > value ( points , 3 ); // ... float output = value . interpolate ( 1.5f ); // output => 2.25; Warning Only floating points types are allowed as second type of modm::Pair , otherwise the calculation will deliver wrong results! See Wikipedia . Content \u00b6 // Class class modm :: interpolation :: Lagrange < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ; class modm :: interpolation :: Linear < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ; Dependencies \u00b6 modm:math:interpolation modm_math_interpolation modm: math: interpolation modm_architecture_accessor modm: architecture: accessor modm_math_interpolation->modm_architecture_accessor modm_container modm: container modm_math_interpolation->modm_container modm_math modm: math modm_math_interpolation->modm_math modm_math_utils modm: math: utils modm_math_interpolation->modm_math_utils","title":"modm:math:interpolation"},{"location":"reference/module/modm-math-interpolation/#modmmathinterpolation-interpolation-methods","text":"Simple interpolation methods between a list of points.","title":"modm:math:interpolation: Interpolation Methods"},{"location":"reference/module/modm-math-interpolation/#linear-interpolation","text":"Example: // Definition of the supporting points. The first type is the // input type, the second the output type using Point = modm :: Pair < int8_t , int16_t > ; // Create a array of supporting points describing the curve. const Point supportingPoints [ 6 ] = { { 30 , - 200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; modm :: interpolation :: Linear < Point > value ( supportingPoints , 6 ); // ... int8_t a = 40 ; int16_t b = value . interpolate ( a ); Example with supporting points read from flash: // Definition of a supporting point using Point = modm :: Pair < int8_t , int16_t > ; // Array of supporting points in flash FLASH_STORAGE ( Point supportingPoints [ 6 ]) = { { 30 , - 200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; // Create an interpolator object which reads the // supporting points from flash. modm :: interpolation :: Linear < Point , modm :: accessor :: Flash > value ( modm :: accessor :: asFlash ( supportingPoints ), 6 ); // ... int8_t a = 20 ; int16_t b = value . interpolate ( a );","title":"Linear Interpolation"},{"location":"reference/module/modm-math-interpolation/#lagrange-interpolation","text":"Example: using Point = modm :: Pair < float , float > ; // interpolate x^2 over the range of 1 <= x <= 3 Point points [ 3 ] = { { 1 , 1 }, { 2 , 4 }, { 3 , 9 } }; modm :: interpolation :: Lagrange < Point > value ( points , 3 ); // ... float output = value . interpolate ( 1.5f ); // output => 2.25; Warning Only floating points types are allowed as second type of modm::Pair , otherwise the calculation will deliver wrong results! See Wikipedia .","title":"Lagrange Interpolation"},{"location":"reference/module/modm-math-interpolation/#content","text":"// Class class modm :: interpolation :: Lagrange < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ; class modm :: interpolation :: Linear < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ;","title":"Content"},{"location":"reference/module/modm-math-interpolation/#dependencies","text":"modm:math:interpolation modm_math_interpolation modm: math: interpolation modm_architecture_accessor modm: architecture: accessor modm_math_interpolation->modm_architecture_accessor modm_container modm: container modm_math_interpolation->modm_container modm_math modm: math modm_math_interpolation->modm_math modm_math_utils modm: math: utils modm_math_interpolation->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-math-matrix/","text":"These module docs are in beta and may be incomplete. modm:math:matrix: Matrix Math \u00b6 Content \u00b6 // Class class modm :: LUDecomposition :: LUSubDecomposition < T , OFFSET , WIDTH , OFFSET > ; class modm :: LUDecomposition :: LUSubDecomposition < typename T , uint8_t OFFSET , uint8_t HEIGHT , uint8_t WIDTH > ; class modm :: LUDecomposition :: RowOperation < T , 0 > ; class modm :: LUDecomposition :: RowOperation < typename T , uint8_t HEIGHT > ; class modm :: LUDecomposition ; // Function IOStream & modm :: operator << ( IOStream & , const Matrix < T , WIDTH , HEIGHT > & ); T modm :: determinant ( const modm :: Matrix < T , 1 , 1 > & m ); T modm :: determinant ( const modm :: Matrix < T , 2 , 2 > & m ); T modm :: determinant ( const modm :: Matrix < T , N , N > & m ); // Typedef typedef Matrix < float , 1 , 1 > modm :: Matrix1f ; typedef Matrix < float , 2 , 2 > modm :: Matrix2f ; typedef Matrix < float , 3 , 3 > modm :: Matrix3f ; typedef Matrix < float , 4 , 4 > modm :: Matrix4f ; Dependencies \u00b6 modm:math:matrix modm_math_matrix modm: math: matrix modm_io modm: io modm_math_matrix->modm_io modm_math modm: math modm_math_matrix->modm_math modm_math_geometry modm: math: geometry modm_math_matrix->modm_math_geometry modm_utils modm: utils modm_math_matrix->modm_utils modm_math_geometry->modm_math_matrix","title":"modm:math:matrix"},{"location":"reference/module/modm-math-matrix/#modmmathmatrix-matrix-math","text":"","title":"modm:math:matrix: Matrix Math"},{"location":"reference/module/modm-math-matrix/#content","text":"// Class class modm :: LUDecomposition :: LUSubDecomposition < T , OFFSET , WIDTH , OFFSET > ; class modm :: LUDecomposition :: LUSubDecomposition < typename T , uint8_t OFFSET , uint8_t HEIGHT , uint8_t WIDTH > ; class modm :: LUDecomposition :: RowOperation < T , 0 > ; class modm :: LUDecomposition :: RowOperation < typename T , uint8_t HEIGHT > ; class modm :: LUDecomposition ; // Function IOStream & modm :: operator << ( IOStream & , const Matrix < T , WIDTH , HEIGHT > & ); T modm :: determinant ( const modm :: Matrix < T , 1 , 1 > & m ); T modm :: determinant ( const modm :: Matrix < T , 2 , 2 > & m ); T modm :: determinant ( const modm :: Matrix < T , N , N > & m ); // Typedef typedef Matrix < float , 1 , 1 > modm :: Matrix1f ; typedef Matrix < float , 2 , 2 > modm :: Matrix2f ; typedef Matrix < float , 3 , 3 > modm :: Matrix3f ; typedef Matrix < float , 4 , 4 > modm :: Matrix4f ;","title":"Content"},{"location":"reference/module/modm-math-matrix/#dependencies","text":"modm:math:matrix modm_math_matrix modm: math: matrix modm_io modm: io modm_math_matrix->modm_io modm_math modm: math modm_math_matrix->modm_math modm_math_geometry modm: math: geometry modm_math_matrix->modm_math_geometry modm_utils modm: utils modm_math_matrix->modm_utils modm_math_geometry->modm_math_matrix","title":"Dependencies"},{"location":"reference/module/modm-math-saturated/","text":"These module docs are in beta and may be incomplete. modm:math:saturated: Saturated Arithmetics \u00b6 Content \u00b6 // Class class modm :: Saturated < typename T > ; // Function Saturated < U > modm :: abs ( const Saturated < U > & x ); Saturated < U > modm :: operator + ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & x ); bool modm :: operator != ( const Saturated < U > & a , const Saturated < U > & b ); bool modm :: operator == ( const Saturated < U > & a , const Saturated < U > & b ); Dependencies \u00b6 modm:math:saturated modm_math_saturated modm: math: saturated modm_math modm: math modm_math_saturated->modm_math modm_math_utils modm: math: utils modm_math_saturated->modm_math_utils","title":"modm:math:saturated"},{"location":"reference/module/modm-math-saturated/#modmmathsaturated-saturated-arithmetics","text":"","title":"modm:math:saturated: Saturated Arithmetics"},{"location":"reference/module/modm-math-saturated/#content","text":"// Class class modm :: Saturated < typename T > ; // Function Saturated < U > modm :: abs ( const Saturated < U > & x ); Saturated < U > modm :: operator + ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & x ); bool modm :: operator != ( const Saturated < U > & a , const Saturated < U > & b ); bool modm :: operator == ( const Saturated < U > & a , const Saturated < U > & b );","title":"Content"},{"location":"reference/module/modm-math-saturated/#dependencies","text":"modm:math:saturated modm_math_saturated modm: math: saturated modm_math modm: math modm_math_saturated->modm_math modm_math_utils modm: math: utils modm_math_saturated->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-math-units/","text":"These module docs are in beta and may be incomplete. modm:math:units: SI Units \u00b6 modm uses a couple of common SI units for configuration of peripherals: frequency_t in Hertz: Hz , kHz and MHz . baudrate_t in Baud: Bd , kBd , MBd . bitrate_t in bit/s, bps . These are integral units, so 1 Hz/Bd/bps cannot be split further, and are cast directly to uint32_t type, so they can be used as a non-type template argument. Conversion can be done via constexpr functions from any numerical type: modm::Hz(T value) , modm::kHz(T value) , modm::MHz(T value) . modm::Bd(T value) , modm::kBd(T value) , modm::MBd(T value) . modm::bps(T value) , modm::kbps(T value) , modm::Mbps(T value) . In addition, user-defined literals are provided in the modm::literals namespace: using namespace modm :: literals ; frequency_t frequency = modm :: Mhz ( 10.5 ); frequency = 10.5 _MHz ; baudrate_t baudrate = 115.2 _kBd ; baudrate = modm :: kBd ( 115.2 ); bitrate_t bitrate = modm :: kbps ( 125 ); bitrate = 125 _kbps ; frequency = 4295 _MHz ; // OVERFLOW at 2^32 units! Integral Percentages \u00b6 Since float cannot be used as a non-type template argument, an integer type for providing tolerances in percent_t is available. Note that percent_t is implemented as an enum class, which prevents implicit conversions, since the base for this is not 1. You must therefore use the modm::pct(T value) or _pct constructors. using namespace modm :: literals ; percent_t tolerance = modm :: pct ( 10 ); tolerance = 10 _pct ; // convert back to float. *internal use only* float percent = modm :: pct2f ( tolerance ); This type is not guaranteed to hold more than 100 percent! Content \u00b6 // Function constexpr baudrate_t modm :: Bd ( T value ); constexpr baudrate_t modm :: MBd ( T value ); constexpr baudrate_t modm :: kBd ( T value ); constexpr bitrate_t modm :: Mbps ( T value ); constexpr bitrate_t modm :: bps ( T value ); constexpr bitrate_t modm :: kbps ( T value ); constexpr frequency_t modm :: Hz ( T value ); constexpr frequency_t modm :: MHz ( T value ); constexpr frequency_t modm :: kHz ( T value ); constexpr modm :: literals :: operator \"\" _Bd ( T value ); constexpr modm :: literals :: operator \"\" _Hz ( T value ); constexpr modm :: literals :: operator \"\" _MBd ( T value ); constexpr modm :: literals :: operator \"\" _MHz ( T value ); constexpr modm :: literals :: operator \"\" _Mbps ( T value ); constexpr modm :: literals :: operator \"\" _bps ( T value ); constexpr modm :: literals :: operator \"\" _kBd ( T value ); constexpr modm :: literals :: operator \"\" _kHz ( T value ); constexpr modm :: literals :: operator \"\" _kbps ( T value ); constexpr modm :: literals :: operator \"\" _pct ( T value ); constexpr percent_t modm :: pct ( T value ); // Typedef using modm :: baudrate_t = typedef uint32_t ; using modm :: bitrate_t = typedef uint32_t ; using modm :: frequency_t = typedef uint32_t ; using modm :: percent_t = typedef uint16_t ; Dependencies \u00b6 modm:math:units modm_math_units modm: math: units modm_architecture modm: architecture modm_math_units->modm_architecture modm_math modm: math modm_math_units->modm_math modm_architecture->modm_math_units modm_math->modm_math_units modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_math_units","title":"modm:math:units"},{"location":"reference/module/modm-math-units/#modmmathunits-si-units","text":"modm uses a couple of common SI units for configuration of peripherals: frequency_t in Hertz: Hz , kHz and MHz . baudrate_t in Baud: Bd , kBd , MBd . bitrate_t in bit/s, bps . These are integral units, so 1 Hz/Bd/bps cannot be split further, and are cast directly to uint32_t type, so they can be used as a non-type template argument. Conversion can be done via constexpr functions from any numerical type: modm::Hz(T value) , modm::kHz(T value) , modm::MHz(T value) . modm::Bd(T value) , modm::kBd(T value) , modm::MBd(T value) . modm::bps(T value) , modm::kbps(T value) , modm::Mbps(T value) . In addition, user-defined literals are provided in the modm::literals namespace: using namespace modm :: literals ; frequency_t frequency = modm :: Mhz ( 10.5 ); frequency = 10.5 _MHz ; baudrate_t baudrate = 115.2 _kBd ; baudrate = modm :: kBd ( 115.2 ); bitrate_t bitrate = modm :: kbps ( 125 ); bitrate = 125 _kbps ; frequency = 4295 _MHz ; // OVERFLOW at 2^32 units!","title":"modm:math:units: SI Units"},{"location":"reference/module/modm-math-units/#integral-percentages","text":"Since float cannot be used as a non-type template argument, an integer type for providing tolerances in percent_t is available. Note that percent_t is implemented as an enum class, which prevents implicit conversions, since the base for this is not 1. You must therefore use the modm::pct(T value) or _pct constructors. using namespace modm :: literals ; percent_t tolerance = modm :: pct ( 10 ); tolerance = 10 _pct ; // convert back to float. *internal use only* float percent = modm :: pct2f ( tolerance ); This type is not guaranteed to hold more than 100 percent!","title":"Integral Percentages"},{"location":"reference/module/modm-math-units/#content","text":"// Function constexpr baudrate_t modm :: Bd ( T value ); constexpr baudrate_t modm :: MBd ( T value ); constexpr baudrate_t modm :: kBd ( T value ); constexpr bitrate_t modm :: Mbps ( T value ); constexpr bitrate_t modm :: bps ( T value ); constexpr bitrate_t modm :: kbps ( T value ); constexpr frequency_t modm :: Hz ( T value ); constexpr frequency_t modm :: MHz ( T value ); constexpr frequency_t modm :: kHz ( T value ); constexpr modm :: literals :: operator \"\" _Bd ( T value ); constexpr modm :: literals :: operator \"\" _Hz ( T value ); constexpr modm :: literals :: operator \"\" _MBd ( T value ); constexpr modm :: literals :: operator \"\" _MHz ( T value ); constexpr modm :: literals :: operator \"\" _Mbps ( T value ); constexpr modm :: literals :: operator \"\" _bps ( T value ); constexpr modm :: literals :: operator \"\" _kBd ( T value ); constexpr modm :: literals :: operator \"\" _kHz ( T value ); constexpr modm :: literals :: operator \"\" _kbps ( T value ); constexpr modm :: literals :: operator \"\" _pct ( T value ); constexpr percent_t modm :: pct ( T value ); // Typedef using modm :: baudrate_t = typedef uint32_t ; using modm :: bitrate_t = typedef uint32_t ; using modm :: frequency_t = typedef uint32_t ; using modm :: percent_t = typedef uint16_t ;","title":"Content"},{"location":"reference/module/modm-math-units/#dependencies","text":"modm:math:units modm_math_units modm: math: units modm_architecture modm: architecture modm_math_units->modm_architecture modm_math modm: math modm_math_units->modm_math modm_architecture->modm_math_units modm_math->modm_math_units modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_math_units","title":"Dependencies"},{"location":"reference/module/modm-math-utils/","text":"These module docs are in beta and may be incomplete. modm:math:utils: Utilities \u00b6 Content \u00b6 // Struct struct modm :: ArithmeticTraits < typename T > ; // Function bool modm :: isPositive ( const float & a ); const T & modm :: max ( const T & a , const T & b ); const T & modm :: max ( const T & a , const T & b , Compare compare ); const T & modm :: min ( const T & a , const T & b ); const T & modm :: min ( const T & a , const T & b , Compare compare ); constexpr T modm :: max ( const T a , const T b , const T c ); constexpr bool modm :: isBigEndian (); constexpr bool modm :: isLittleEndian (); constexpr int8_t modm :: leftmostBit ( uint32_t value ); constexpr uint32_t modm :: pow ( uint32_t base , uint8_t exponent ); int16_t modm :: fromBigEndian ( int16_t value ); int16_t modm :: fromLittleEndian ( int16_t value ); int16_t modm :: toBigEndian ( int16_t value ); int16_t modm :: toLittleEndian ( int16_t value ); int32_t modm :: fromBigEndian ( int32_t value ); int32_t modm :: fromLittleEndian ( int32_t value ); int32_t modm :: math :: mac ( int32_t result , int16_t a , int16_t b ); int32_t modm :: math :: mul ( int16_t a , int16_t b ); int32_t modm :: toBigEndian ( int32_t value ); int32_t modm :: toLittleEndian ( int32_t value ); std :: size_t modm :: bitCount ( uint16_t n ); std :: size_t modm :: bitCount ( uint32_t n ); std :: size_t modm :: bitCount ( uint8_t n ); uint16_t modm :: bitReverse ( uint16_t n ); uint16_t modm :: fromBigEndian ( uint16_t value ); uint16_t modm :: fromLittleEndian ( uint16_t value ); uint16_t modm :: math :: sqrt ( uint32_t a ); uint16_t modm :: swap ( uint16_t n ); uint16_t modm :: toBigEndian ( uint16_t value ); uint16_t modm :: toLittleEndian ( uint16_t value ); uint16_t modm__sqrt32 ( uint32_t a ); uint32_t modm :: bitReverse ( uint32_t n ); uint32_t modm :: fromBigEndian ( uint32_t value ); uint32_t modm :: fromLittleEndian ( uint32_t value ); uint32_t modm :: math :: mul ( uint16_t a , uint16_t b ); uint32_t modm :: swap ( uint32_t n ); uint32_t modm :: toBigEndian ( uint32_t value ); uint32_t modm :: toLittleEndian ( uint32_t value ); uint8_t modm :: bitReverse ( uint8_t n ); uint8_t modm :: swap ( uint8_t n ); void modm :: swap ( int16_t & a , int16_t & b ); void modm :: swap ( uint8_t & a , uint8_t & b ); // Variable constexpr uint16_t modm :: Bit10 = ( 1ul << 10 ); constexpr uint16_t modm :: Bit11 = ( 1ul << 11 ); constexpr uint16_t modm :: Bit12 = ( 1ul << 12 ); constexpr uint16_t modm :: Bit13 = ( 1ul << 13 ); constexpr uint16_t modm :: Bit14 = ( 1ul << 14 ); constexpr uint16_t modm :: Bit15 = ( 1ul << 15 ); constexpr uint16_t modm :: Bit8 = ( 1ul << 8 ); constexpr uint16_t modm :: Bit9 = ( 1ul << 9 ); constexpr uint32_t modm :: Bit16 = ( 1ul << 16 ); constexpr uint32_t modm :: Bit17 = ( 1ul << 17 ); constexpr uint32_t modm :: Bit18 = ( 1ul << 18 ); constexpr uint32_t modm :: Bit19 = ( 1ul << 19 ); constexpr uint32_t modm :: Bit20 = ( 1ul << 20 ); constexpr uint32_t modm :: Bit21 = ( 1ul << 21 ); constexpr uint32_t modm :: Bit22 = ( 1ul << 22 ); constexpr uint32_t modm :: Bit23 = ( 1ul << 23 ); constexpr uint32_t modm :: Bit24 = ( 1ul << 24 ); constexpr uint32_t modm :: Bit25 = ( 1ul << 25 ); constexpr uint32_t modm :: Bit26 = ( 1ul << 26 ); constexpr uint32_t modm :: Bit27 = ( 1ul << 27 ); constexpr uint32_t modm :: Bit28 = ( 1ul << 28 ); constexpr uint32_t modm :: Bit29 = ( 1ul << 29 ); constexpr uint32_t modm :: Bit30 = ( 1ul << 30 ); constexpr uint32_t modm :: Bit31 = ( 1ul << 31 ); constexpr uint8_t modm :: Bit0 = ( 1ul << 0 ); constexpr uint8_t modm :: Bit1 = ( 1ul << 1 ); constexpr uint8_t modm :: Bit2 = ( 1ul << 2 ); constexpr uint8_t modm :: Bit3 = ( 1ul << 3 ); constexpr uint8_t modm :: Bit4 = ( 1ul << 4 ); constexpr uint8_t modm :: Bit5 = ( 1ul << 5 ); constexpr uint8_t modm :: Bit6 = ( 1ul << 6 ); constexpr uint8_t modm :: Bit7 = ( 1ul << 7 ); // Typedef using modm :: SignedType = typedef typename detail :: MakeSigned < T >:: type ; using modm :: UnsignedType = typedef typename detail :: MakeUnsigned < T >:: type ; using modm :: WideType = typedef typename detail :: WideType < T >:: type ; Dependencies \u00b6 modm:math:utils modm_math_utils modm: math: utils modm_architecture modm: architecture modm_math_utils->modm_architecture modm_math modm: math modm_math_utils->modm_math modm_architecture_assert modm: architecture: assert modm_architecture_assert->modm_math_utils modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_math_utils modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_math_utils modm_architecture_register modm: architecture: register modm_architecture_register->modm_math_utils modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_math_utils modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_math_utils modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_math_utils modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_math_utils modm_driver_ams5915 modm: driver: ams5915 modm_driver_ams5915->modm_math_utils modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_math_utils modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_math_utils modm_driver_hclax modm: driver: hclax modm_driver_hclax->modm_math_utils modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_math_utils modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_math_utils modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_math_utils modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_math_utils modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_math_utils modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_math_utils modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_math_utils modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_math_utils modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_math_utils modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_math_utils modm_io modm: io modm_io->modm_math_utils modm_math_filter modm: math: filter modm_math_filter->modm_math_utils modm_math_geometry modm: math: geometry modm_math_geometry->modm_math_utils modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_math_utils modm_math_saturated modm: math: saturated modm_math_saturated->modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_math_utils modm_processing_timer modm: processing: timer modm_processing_timer->modm_math_utils modm_ui_animation modm: ui: animation modm_ui_animation->modm_math_utils modm_ui_color modm: ui: color modm_ui_color->modm_math_utils modm_ui_display modm: ui: display modm_ui_display->modm_math_utils","title":"modm:math:utils"},{"location":"reference/module/modm-math-utils/#modmmathutils-utilities","text":"","title":"modm:math:utils: Utilities"},{"location":"reference/module/modm-math-utils/#content","text":"// Struct struct modm :: ArithmeticTraits < typename T > ; // Function bool modm :: isPositive ( const float & a ); const T & modm :: max ( const T & a , const T & b ); const T & modm :: max ( const T & a , const T & b , Compare compare ); const T & modm :: min ( const T & a , const T & b ); const T & modm :: min ( const T & a , const T & b , Compare compare ); constexpr T modm :: max ( const T a , const T b , const T c ); constexpr bool modm :: isBigEndian (); constexpr bool modm :: isLittleEndian (); constexpr int8_t modm :: leftmostBit ( uint32_t value ); constexpr uint32_t modm :: pow ( uint32_t base , uint8_t exponent ); int16_t modm :: fromBigEndian ( int16_t value ); int16_t modm :: fromLittleEndian ( int16_t value ); int16_t modm :: toBigEndian ( int16_t value ); int16_t modm :: toLittleEndian ( int16_t value ); int32_t modm :: fromBigEndian ( int32_t value ); int32_t modm :: fromLittleEndian ( int32_t value ); int32_t modm :: math :: mac ( int32_t result , int16_t a , int16_t b ); int32_t modm :: math :: mul ( int16_t a , int16_t b ); int32_t modm :: toBigEndian ( int32_t value ); int32_t modm :: toLittleEndian ( int32_t value ); std :: size_t modm :: bitCount ( uint16_t n ); std :: size_t modm :: bitCount ( uint32_t n ); std :: size_t modm :: bitCount ( uint8_t n ); uint16_t modm :: bitReverse ( uint16_t n ); uint16_t modm :: fromBigEndian ( uint16_t value ); uint16_t modm :: fromLittleEndian ( uint16_t value ); uint16_t modm :: math :: sqrt ( uint32_t a ); uint16_t modm :: swap ( uint16_t n ); uint16_t modm :: toBigEndian ( uint16_t value ); uint16_t modm :: toLittleEndian ( uint16_t value ); uint16_t modm__sqrt32 ( uint32_t a ); uint32_t modm :: bitReverse ( uint32_t n ); uint32_t modm :: fromBigEndian ( uint32_t value ); uint32_t modm :: fromLittleEndian ( uint32_t value ); uint32_t modm :: math :: mul ( uint16_t a , uint16_t b ); uint32_t modm :: swap ( uint32_t n ); uint32_t modm :: toBigEndian ( uint32_t value ); uint32_t modm :: toLittleEndian ( uint32_t value ); uint8_t modm :: bitReverse ( uint8_t n ); uint8_t modm :: swap ( uint8_t n ); void modm :: swap ( int16_t & a , int16_t & b ); void modm :: swap ( uint8_t & a , uint8_t & b ); // Variable constexpr uint16_t modm :: Bit10 = ( 1ul << 10 ); constexpr uint16_t modm :: Bit11 = ( 1ul << 11 ); constexpr uint16_t modm :: Bit12 = ( 1ul << 12 ); constexpr uint16_t modm :: Bit13 = ( 1ul << 13 ); constexpr uint16_t modm :: Bit14 = ( 1ul << 14 ); constexpr uint16_t modm :: Bit15 = ( 1ul << 15 ); constexpr uint16_t modm :: Bit8 = ( 1ul << 8 ); constexpr uint16_t modm :: Bit9 = ( 1ul << 9 ); constexpr uint32_t modm :: Bit16 = ( 1ul << 16 ); constexpr uint32_t modm :: Bit17 = ( 1ul << 17 ); constexpr uint32_t modm :: Bit18 = ( 1ul << 18 ); constexpr uint32_t modm :: Bit19 = ( 1ul << 19 ); constexpr uint32_t modm :: Bit20 = ( 1ul << 20 ); constexpr uint32_t modm :: Bit21 = ( 1ul << 21 ); constexpr uint32_t modm :: Bit22 = ( 1ul << 22 ); constexpr uint32_t modm :: Bit23 = ( 1ul << 23 ); constexpr uint32_t modm :: Bit24 = ( 1ul << 24 ); constexpr uint32_t modm :: Bit25 = ( 1ul << 25 ); constexpr uint32_t modm :: Bit26 = ( 1ul << 26 ); constexpr uint32_t modm :: Bit27 = ( 1ul << 27 ); constexpr uint32_t modm :: Bit28 = ( 1ul << 28 ); constexpr uint32_t modm :: Bit29 = ( 1ul << 29 ); constexpr uint32_t modm :: Bit30 = ( 1ul << 30 ); constexpr uint32_t modm :: Bit31 = ( 1ul << 31 ); constexpr uint8_t modm :: Bit0 = ( 1ul << 0 ); constexpr uint8_t modm :: Bit1 = ( 1ul << 1 ); constexpr uint8_t modm :: Bit2 = ( 1ul << 2 ); constexpr uint8_t modm :: Bit3 = ( 1ul << 3 ); constexpr uint8_t modm :: Bit4 = ( 1ul << 4 ); constexpr uint8_t modm :: Bit5 = ( 1ul << 5 ); constexpr uint8_t modm :: Bit6 = ( 1ul << 6 ); constexpr uint8_t modm :: Bit7 = ( 1ul << 7 ); // Typedef using modm :: SignedType = typedef typename detail :: MakeSigned < T >:: type ; using modm :: UnsignedType = typedef typename detail :: MakeUnsigned < T >:: type ; using modm :: WideType = typedef typename detail :: WideType < T >:: type ;","title":"Content"},{"location":"reference/module/modm-math-utils/#dependencies","text":"modm:math:utils modm_math_utils modm: math: utils modm_architecture modm: architecture modm_math_utils->modm_architecture modm_math modm: math modm_math_utils->modm_math modm_architecture_assert modm: architecture: assert modm_architecture_assert->modm_math_utils modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_math_utils modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_math_utils modm_architecture_register modm: architecture: register modm_architecture_register->modm_math_utils modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_math_utils modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_math_utils modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_math_utils modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_math_utils modm_driver_ams5915 modm: driver: ams5915 modm_driver_ams5915->modm_math_utils modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_math_utils modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_math_utils modm_driver_hclax modm: driver: hclax modm_driver_hclax->modm_math_utils modm_driver_hmc58x modm: driver: hmc58x modm_driver_hmc58x->modm_math_utils modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_math_utils modm_driver_itg3200 modm: driver: itg3200 modm_driver_itg3200->modm_math_utils modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_math_utils modm_driver_lis3dsh modm: driver: lis3dsh modm_driver_lis3dsh->modm_math_utils modm_driver_lsm303a modm: driver: lsm303a modm_driver_lsm303a->modm_math_utils modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_math_utils modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_math_utils modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_math_utils modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_math_utils modm_io modm: io modm_io->modm_math_utils modm_math_filter modm: math: filter modm_math_filter->modm_math_utils modm_math_geometry modm: math: geometry modm_math_geometry->modm_math_utils modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_math_utils modm_math_saturated modm: math: saturated modm_math_saturated->modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_math_utils modm_processing_timer modm: processing: timer modm_processing_timer->modm_math_utils modm_ui_animation modm: ui: animation modm_ui_animation->modm_math_utils modm_ui_color modm: ui: color modm_ui_color->modm_math_utils modm_ui_display modm: ui: display modm_ui_display->modm_math_utils","title":"Dependencies"},{"location":"reference/module/modm-math/","text":"These module docs are in beta and may be incomplete. modm:math: Math \u00b6 Content \u00b6 // Class class modm :: Angle ; class modm :: Circle2D < typename T > ; class modm :: LUDecomposition :: LUSubDecomposition < T , OFFSET , WIDTH , OFFSET > ; class modm :: LUDecomposition :: LUSubDecomposition < typename T , uint8_t OFFSET , uint8_t HEIGHT , uint8_t WIDTH > ; class modm :: LUDecomposition :: RowOperation < T , 0 > ; class modm :: LUDecomposition :: RowOperation < typename T , uint8_t HEIGHT > ; class modm :: LUDecomposition ; class modm :: Line2D < typename T > ; class modm :: LineSegment2D < typename T = int16_t > ; class modm :: Location2D < typename T = int16_t > ; class modm :: Matrix < typename T , uint8_t ROWS , uint8_t COLUMNS > ; class modm :: Pid < typename T , unsigned int ScaleFactor = 1 > ; class modm :: PointSet2D < typename T > ; class modm :: Polygon2D < typename T > ; class modm :: Quaternion < class T > ; class modm :: Ray2D < typename T = int16_t > ; class modm :: SCurveController < typename T > ; class modm :: SCurveGenerator < typename T > ; class modm :: Saturated < typename T > ; class modm :: Tolerance ; class modm :: Vector < T , 1 > ; class modm :: Vector < T , 2 > ; class modm :: Vector < T , 3 > ; class modm :: Vector < T , 4 > ; class modm :: Vector < typename T , uint8_t N > ; class modm :: filter :: Debounce < typename T = uint8_t > ; class modm :: filter :: Fir < typename T , int N , int BLOCK_SIZE , signed int ScaleFactor = 1 > ; class modm :: filter :: Median < typename T , int N > ; class modm :: filter :: MovingAverage < typename T , std :: size_t N > ; class modm :: filter :: Ramp < typename T > ; class modm :: interpolation :: Lagrange < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ; class modm :: interpolation :: Linear < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ; // Struct struct modm :: ArithmeticTraits < typename T > ; struct modm :: GeometricTraits < double > ; struct modm :: GeometricTraits < float > ; struct modm :: GeometricTraits < int16_t > ; struct modm :: GeometricTraits < int32_t > ; struct modm :: GeometricTraits < int8_t > ; struct modm :: GeometricTraits < typename T > ; struct modm :: GeometricTraits < uint8_t > ; struct modm :: Pid :: Parameter ; struct modm :: SCurveController :: Parameter ; struct modm :: detail :: MakeSigned < Vector < T , N > > ; struct modm :: detail :: MakeUnsigned < Vector < T , N > > ; struct modm :: detail :: WideType < Vector < T , N > > ; // Function IOStream & modm :: operator << ( IOStream & , const Matrix < T , WIDTH , HEIGHT > & ); IOStream & modm :: operator << ( IOStream & os , const Location2D < T > & l ); IOStream & modm :: operator << ( IOStream & os , const Vector < U , 2 > & c ); Quaternion < T > modm :: operator * ( const T & lhs , const Quaternion < T > & rhs ); Saturated < U > modm :: abs ( const Saturated < U > & x ); Saturated < U > modm :: operator + ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & x ); T modm :: determinant ( const modm :: Matrix < T , 1 , 1 > & m ); T modm :: determinant ( const modm :: Matrix < T , 2 , 2 > & m ); T modm :: determinant ( const modm :: Matrix < T , N , N > & m ); Vector < U , 2 > modm :: operator * ( float scale , const Vector < U , 2 > & vector ); Vector < U , 2 > modm :: operator / ( float scale , const Vector < U , 2 > & vector ); bool modm :: isPositive ( const float & a ); bool modm :: operator != ( const Saturated < U > & a , const Saturated < U > & b ); bool modm :: operator == ( const Saturated < U > & a , const Saturated < U > & b ); const T & modm :: max ( const T & a , const T & b ); const T & modm :: max ( const T & a , const T & b , Compare compare ); const T & modm :: min ( const T & a , const T & b ); const T & modm :: min ( const T & a , const T & b , Compare compare ); constexpr T modm :: max ( const T a , const T b , const T c ); constexpr baudrate_t modm :: Bd ( T value ); constexpr baudrate_t modm :: MBd ( T value ); constexpr baudrate_t modm :: kBd ( T value ); constexpr bitrate_t modm :: Mbps ( T value ); constexpr bitrate_t modm :: bps ( T value ); constexpr bitrate_t modm :: kbps ( T value ); constexpr bool modm :: isBigEndian (); constexpr bool modm :: isLittleEndian (); constexpr frequency_t modm :: Hz ( T value ); constexpr frequency_t modm :: MHz ( T value ); constexpr frequency_t modm :: kHz ( T value ); constexpr int8_t modm :: leftmostBit ( uint32_t value ); constexpr modm :: literals :: operator \"\" _Bd ( T value ); constexpr modm :: literals :: operator \"\" _Hz ( T value ); constexpr modm :: literals :: operator \"\" _MBd ( T value ); constexpr modm :: literals :: operator \"\" _MHz ( T value ); constexpr modm :: literals :: operator \"\" _Mbps ( T value ); constexpr modm :: literals :: operator \"\" _bps ( T value ); constexpr modm :: literals :: operator \"\" _kBd ( T value ); constexpr modm :: literals :: operator \"\" _kHz ( T value ); constexpr modm :: literals :: operator \"\" _kbps ( T value ); constexpr modm :: literals :: operator \"\" _pct ( T value ); constexpr percent_t modm :: pct ( T value ); constexpr uint32_t modm :: pow ( uint32_t base , uint8_t exponent ); int16_t modm :: fromBigEndian ( int16_t value ); int16_t modm :: fromLittleEndian ( int16_t value ); int16_t modm :: toBigEndian ( int16_t value ); int16_t modm :: toLittleEndian ( int16_t value ); int32_t modm :: fromBigEndian ( int32_t value ); int32_t modm :: fromLittleEndian ( int32_t value ); int32_t modm :: math :: mac ( int32_t result , int16_t a , int16_t b ); int32_t modm :: math :: mul ( int16_t a , int16_t b ); int32_t modm :: toBigEndian ( int32_t value ); int32_t modm :: toLittleEndian ( int32_t value ); static Vector < T , 1 > modm :: operator * ( const U & lhs , const Vector < T , 1 > & rhs ); static Vector < T , 3 > modm :: operator * ( const U & lhs , const Vector < T , 3 > & rhs ); static Vector < T , 4 > modm :: operator * ( const U & lhs , const Vector < T , 4 > & rhs ); static Vector < U , 3 > modm :: operator * ( const Matrix < T , 3 , 3 > & lhs , const Vector < U , 3 > & rhs ); static Vector < U , 4 > modm :: operator * ( const Matrix < T , 4 , 4 > & lhs , const Vector < U , 4 > & rhs ); static constexpr float modm :: toDegree ( float angle ); static constexpr float modm :: toRadian ( float angle ); std :: size_t modm :: bitCount ( uint16_t n ); std :: size_t modm :: bitCount ( uint32_t n ); std :: size_t modm :: bitCount ( uint8_t n ); uint16_t modm :: bitReverse ( uint16_t n ); uint16_t modm :: fromBigEndian ( uint16_t value ); uint16_t modm :: fromLittleEndian ( uint16_t value ); uint16_t modm :: math :: sqrt ( uint32_t a ); uint16_t modm :: swap ( uint16_t n ); uint16_t modm :: toBigEndian ( uint16_t value ); uint16_t modm :: toLittleEndian ( uint16_t value ); uint16_t modm__sqrt32 ( uint32_t a ); uint32_t modm :: bitReverse ( uint32_t n ); uint32_t modm :: fromBigEndian ( uint32_t value ); uint32_t modm :: fromLittleEndian ( uint32_t value ); uint32_t modm :: math :: mul ( uint16_t a , uint16_t b ); uint32_t modm :: swap ( uint32_t n ); uint32_t modm :: toBigEndian ( uint32_t value ); uint32_t modm :: toLittleEndian ( uint32_t value ); uint8_t modm :: bitReverse ( uint8_t n ); uint8_t modm :: swap ( uint8_t n ); void modm :: swap ( int16_t & a , int16_t & b ); void modm :: swap ( uint8_t & a , uint8_t & b ); // Variable constexpr uint16_t modm :: Bit10 = ( 1ul << 10 ); constexpr uint16_t modm :: Bit11 = ( 1ul << 11 ); constexpr uint16_t modm :: Bit12 = ( 1ul << 12 ); constexpr uint16_t modm :: Bit13 = ( 1ul << 13 ); constexpr uint16_t modm :: Bit14 = ( 1ul << 14 ); constexpr uint16_t modm :: Bit15 = ( 1ul << 15 ); constexpr uint16_t modm :: Bit8 = ( 1ul << 8 ); constexpr uint16_t modm :: Bit9 = ( 1ul << 9 ); constexpr uint32_t modm :: Bit16 = ( 1ul << 16 ); constexpr uint32_t modm :: Bit17 = ( 1ul << 17 ); constexpr uint32_t modm :: Bit18 = ( 1ul << 18 ); constexpr uint32_t modm :: Bit19 = ( 1ul << 19 ); constexpr uint32_t modm :: Bit20 = ( 1ul << 20 ); constexpr uint32_t modm :: Bit21 = ( 1ul << 21 ); constexpr uint32_t modm :: Bit22 = ( 1ul << 22 ); constexpr uint32_t modm :: Bit23 = ( 1ul << 23 ); constexpr uint32_t modm :: Bit24 = ( 1ul << 24 ); constexpr uint32_t modm :: Bit25 = ( 1ul << 25 ); constexpr uint32_t modm :: Bit26 = ( 1ul << 26 ); constexpr uint32_t modm :: Bit27 = ( 1ul << 27 ); constexpr uint32_t modm :: Bit28 = ( 1ul << 28 ); constexpr uint32_t modm :: Bit29 = ( 1ul << 29 ); constexpr uint32_t modm :: Bit30 = ( 1ul << 30 ); constexpr uint32_t modm :: Bit31 = ( 1ul << 31 ); constexpr uint8_t modm :: Bit0 = ( 1ul << 0 ); constexpr uint8_t modm :: Bit1 = ( 1ul << 1 ); constexpr uint8_t modm :: Bit2 = ( 1ul << 2 ); constexpr uint8_t modm :: Bit3 = ( 1ul << 3 ); constexpr uint8_t modm :: Bit4 = ( 1ul << 4 ); constexpr uint8_t modm :: Bit5 = ( 1ul << 5 ); constexpr uint8_t modm :: Bit6 = ( 1ul << 6 ); constexpr uint8_t modm :: Bit7 = ( 1ul << 7 ); // Typedef typedef Matrix < float , 1 , 1 > modm :: Matrix1f ; typedef Matrix < float , 2 , 2 > modm :: Matrix2f ; typedef Matrix < float , 3 , 3 > modm :: Matrix3f ; typedef Matrix < float , 4 , 4 > modm :: Matrix4f ; typedef Vector < float , 1 > modm :: Vector1f ; typedef Vector < float , 2 > modm :: Vector2f ; typedef Vector < float , 3 > modm :: Vector3f ; typedef Vector < float , 4 > modm :: Vector4f ; typedef Vector < int16_t , 1 > modm :: Vector1i ; typedef Vector < int16_t , 2 > modm :: Vector2i ; typedef Vector < int16_t , 3 > modm :: Vector3i ; typedef Vector < int16_t , 4 > modm :: Vector4i ; typedef Vector < uint16_t , 2 > modm :: Vector2u ; typedef Vector < uint16_t , 3 > modm :: Vector3u ; typedef Vector < uint16_t , 4 > modm :: Vector4u ; using modm :: SignedType = typedef typename detail :: MakeSigned < T >:: type ; using modm :: UnsignedType = typedef typename detail :: MakeUnsigned < T >:: type ; using modm :: WideType = typedef typename detail :: WideType < T >:: type ; using modm :: baudrate_t = typedef uint32_t ; using modm :: bitrate_t = typedef uint32_t ; using modm :: frequency_t = typedef uint32_t ; using modm :: percent_t = typedef uint16_t ; // Define #define IMPLEMENT_VECTOR_ACCESSOR2(a, b) #define IMPLEMENT_VECTOR_ACCESSOR3(a, b, c) #define IMPLEMENT_VECTOR_ACCESSOR4(a, b, c, d) #define M_1_PI #define M_2_PI #define M_PI #define M_PI_2 #define M_PI_4 #define M_SQRT2 #define M_TWOPI Dependencies \u00b6 modm:math modm_math modm: math modm_math_units modm: math: units modm_math->modm_math_units modm_math_units->modm_math modm_math_filter modm: math: filter modm_math_filter->modm_math modm_math_geometry modm: math: geometry modm_math_geometry->modm_math modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_math modm_math_matrix modm: math: matrix modm_math_matrix->modm_math modm_math_saturated modm: math: saturated modm_math_saturated->modm_math modm_math_utils modm: math: utils modm_math_utils->modm_math","title":"modm:math"},{"location":"reference/module/modm-math/#modmmath-math","text":"","title":"modm:math: Math"},{"location":"reference/module/modm-math/#content","text":"// Class class modm :: Angle ; class modm :: Circle2D < typename T > ; class modm :: LUDecomposition :: LUSubDecomposition < T , OFFSET , WIDTH , OFFSET > ; class modm :: LUDecomposition :: LUSubDecomposition < typename T , uint8_t OFFSET , uint8_t HEIGHT , uint8_t WIDTH > ; class modm :: LUDecomposition :: RowOperation < T , 0 > ; class modm :: LUDecomposition :: RowOperation < typename T , uint8_t HEIGHT > ; class modm :: LUDecomposition ; class modm :: Line2D < typename T > ; class modm :: LineSegment2D < typename T = int16_t > ; class modm :: Location2D < typename T = int16_t > ; class modm :: Matrix < typename T , uint8_t ROWS , uint8_t COLUMNS > ; class modm :: Pid < typename T , unsigned int ScaleFactor = 1 > ; class modm :: PointSet2D < typename T > ; class modm :: Polygon2D < typename T > ; class modm :: Quaternion < class T > ; class modm :: Ray2D < typename T = int16_t > ; class modm :: SCurveController < typename T > ; class modm :: SCurveGenerator < typename T > ; class modm :: Saturated < typename T > ; class modm :: Tolerance ; class modm :: Vector < T , 1 > ; class modm :: Vector < T , 2 > ; class modm :: Vector < T , 3 > ; class modm :: Vector < T , 4 > ; class modm :: Vector < typename T , uint8_t N > ; class modm :: filter :: Debounce < typename T = uint8_t > ; class modm :: filter :: Fir < typename T , int N , int BLOCK_SIZE , signed int ScaleFactor = 1 > ; class modm :: filter :: Median < typename T , int N > ; class modm :: filter :: MovingAverage < typename T , std :: size_t N > ; class modm :: filter :: Ramp < typename T > ; class modm :: interpolation :: Lagrange < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ; class modm :: interpolation :: Linear < typename T , template < typename > class Accessor =:: modm :: accessor :: Ram > ; // Struct struct modm :: ArithmeticTraits < typename T > ; struct modm :: GeometricTraits < double > ; struct modm :: GeometricTraits < float > ; struct modm :: GeometricTraits < int16_t > ; struct modm :: GeometricTraits < int32_t > ; struct modm :: GeometricTraits < int8_t > ; struct modm :: GeometricTraits < typename T > ; struct modm :: GeometricTraits < uint8_t > ; struct modm :: Pid :: Parameter ; struct modm :: SCurveController :: Parameter ; struct modm :: detail :: MakeSigned < Vector < T , N > > ; struct modm :: detail :: MakeUnsigned < Vector < T , N > > ; struct modm :: detail :: WideType < Vector < T , N > > ; // Function IOStream & modm :: operator << ( IOStream & , const Matrix < T , WIDTH , HEIGHT > & ); IOStream & modm :: operator << ( IOStream & os , const Location2D < T > & l ); IOStream & modm :: operator << ( IOStream & os , const Vector < U , 2 > & c ); Quaternion < T > modm :: operator * ( const T & lhs , const Quaternion < T > & rhs ); Saturated < U > modm :: abs ( const Saturated < U > & x ); Saturated < U > modm :: operator + ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & a , const Saturated < U > & b ); Saturated < U > modm :: operator - ( const Saturated < U > & x ); T modm :: determinant ( const modm :: Matrix < T , 1 , 1 > & m ); T modm :: determinant ( const modm :: Matrix < T , 2 , 2 > & m ); T modm :: determinant ( const modm :: Matrix < T , N , N > & m ); Vector < U , 2 > modm :: operator * ( float scale , const Vector < U , 2 > & vector ); Vector < U , 2 > modm :: operator / ( float scale , const Vector < U , 2 > & vector ); bool modm :: isPositive ( const float & a ); bool modm :: operator != ( const Saturated < U > & a , const Saturated < U > & b ); bool modm :: operator == ( const Saturated < U > & a , const Saturated < U > & b ); const T & modm :: max ( const T & a , const T & b ); const T & modm :: max ( const T & a , const T & b , Compare compare ); const T & modm :: min ( const T & a , const T & b ); const T & modm :: min ( const T & a , const T & b , Compare compare ); constexpr T modm :: max ( const T a , const T b , const T c ); constexpr baudrate_t modm :: Bd ( T value ); constexpr baudrate_t modm :: MBd ( T value ); constexpr baudrate_t modm :: kBd ( T value ); constexpr bitrate_t modm :: Mbps ( T value ); constexpr bitrate_t modm :: bps ( T value ); constexpr bitrate_t modm :: kbps ( T value ); constexpr bool modm :: isBigEndian (); constexpr bool modm :: isLittleEndian (); constexpr frequency_t modm :: Hz ( T value ); constexpr frequency_t modm :: MHz ( T value ); constexpr frequency_t modm :: kHz ( T value ); constexpr int8_t modm :: leftmostBit ( uint32_t value ); constexpr modm :: literals :: operator \"\" _Bd ( T value ); constexpr modm :: literals :: operator \"\" _Hz ( T value ); constexpr modm :: literals :: operator \"\" _MBd ( T value ); constexpr modm :: literals :: operator \"\" _MHz ( T value ); constexpr modm :: literals :: operator \"\" _Mbps ( T value ); constexpr modm :: literals :: operator \"\" _bps ( T value ); constexpr modm :: literals :: operator \"\" _kBd ( T value ); constexpr modm :: literals :: operator \"\" _kHz ( T value ); constexpr modm :: literals :: operator \"\" _kbps ( T value ); constexpr modm :: literals :: operator \"\" _pct ( T value ); constexpr percent_t modm :: pct ( T value ); constexpr uint32_t modm :: pow ( uint32_t base , uint8_t exponent ); int16_t modm :: fromBigEndian ( int16_t value ); int16_t modm :: fromLittleEndian ( int16_t value ); int16_t modm :: toBigEndian ( int16_t value ); int16_t modm :: toLittleEndian ( int16_t value ); int32_t modm :: fromBigEndian ( int32_t value ); int32_t modm :: fromLittleEndian ( int32_t value ); int32_t modm :: math :: mac ( int32_t result , int16_t a , int16_t b ); int32_t modm :: math :: mul ( int16_t a , int16_t b ); int32_t modm :: toBigEndian ( int32_t value ); int32_t modm :: toLittleEndian ( int32_t value ); static Vector < T , 1 > modm :: operator * ( const U & lhs , const Vector < T , 1 > & rhs ); static Vector < T , 3 > modm :: operator * ( const U & lhs , const Vector < T , 3 > & rhs ); static Vector < T , 4 > modm :: operator * ( const U & lhs , const Vector < T , 4 > & rhs ); static Vector < U , 3 > modm :: operator * ( const Matrix < T , 3 , 3 > & lhs , const Vector < U , 3 > & rhs ); static Vector < U , 4 > modm :: operator * ( const Matrix < T , 4 , 4 > & lhs , const Vector < U , 4 > & rhs ); static constexpr float modm :: toDegree ( float angle ); static constexpr float modm :: toRadian ( float angle ); std :: size_t modm :: bitCount ( uint16_t n ); std :: size_t modm :: bitCount ( uint32_t n ); std :: size_t modm :: bitCount ( uint8_t n ); uint16_t modm :: bitReverse ( uint16_t n ); uint16_t modm :: fromBigEndian ( uint16_t value ); uint16_t modm :: fromLittleEndian ( uint16_t value ); uint16_t modm :: math :: sqrt ( uint32_t a ); uint16_t modm :: swap ( uint16_t n ); uint16_t modm :: toBigEndian ( uint16_t value ); uint16_t modm :: toLittleEndian ( uint16_t value ); uint16_t modm__sqrt32 ( uint32_t a ); uint32_t modm :: bitReverse ( uint32_t n ); uint32_t modm :: fromBigEndian ( uint32_t value ); uint32_t modm :: fromLittleEndian ( uint32_t value ); uint32_t modm :: math :: mul ( uint16_t a , uint16_t b ); uint32_t modm :: swap ( uint32_t n ); uint32_t modm :: toBigEndian ( uint32_t value ); uint32_t modm :: toLittleEndian ( uint32_t value ); uint8_t modm :: bitReverse ( uint8_t n ); uint8_t modm :: swap ( uint8_t n ); void modm :: swap ( int16_t & a , int16_t & b ); void modm :: swap ( uint8_t & a , uint8_t & b ); // Variable constexpr uint16_t modm :: Bit10 = ( 1ul << 10 ); constexpr uint16_t modm :: Bit11 = ( 1ul << 11 ); constexpr uint16_t modm :: Bit12 = ( 1ul << 12 ); constexpr uint16_t modm :: Bit13 = ( 1ul << 13 ); constexpr uint16_t modm :: Bit14 = ( 1ul << 14 ); constexpr uint16_t modm :: Bit15 = ( 1ul << 15 ); constexpr uint16_t modm :: Bit8 = ( 1ul << 8 ); constexpr uint16_t modm :: Bit9 = ( 1ul << 9 ); constexpr uint32_t modm :: Bit16 = ( 1ul << 16 ); constexpr uint32_t modm :: Bit17 = ( 1ul << 17 ); constexpr uint32_t modm :: Bit18 = ( 1ul << 18 ); constexpr uint32_t modm :: Bit19 = ( 1ul << 19 ); constexpr uint32_t modm :: Bit20 = ( 1ul << 20 ); constexpr uint32_t modm :: Bit21 = ( 1ul << 21 ); constexpr uint32_t modm :: Bit22 = ( 1ul << 22 ); constexpr uint32_t modm :: Bit23 = ( 1ul << 23 ); constexpr uint32_t modm :: Bit24 = ( 1ul << 24 ); constexpr uint32_t modm :: Bit25 = ( 1ul << 25 ); constexpr uint32_t modm :: Bit26 = ( 1ul << 26 ); constexpr uint32_t modm :: Bit27 = ( 1ul << 27 ); constexpr uint32_t modm :: Bit28 = ( 1ul << 28 ); constexpr uint32_t modm :: Bit29 = ( 1ul << 29 ); constexpr uint32_t modm :: Bit30 = ( 1ul << 30 ); constexpr uint32_t modm :: Bit31 = ( 1ul << 31 ); constexpr uint8_t modm :: Bit0 = ( 1ul << 0 ); constexpr uint8_t modm :: Bit1 = ( 1ul << 1 ); constexpr uint8_t modm :: Bit2 = ( 1ul << 2 ); constexpr uint8_t modm :: Bit3 = ( 1ul << 3 ); constexpr uint8_t modm :: Bit4 = ( 1ul << 4 ); constexpr uint8_t modm :: Bit5 = ( 1ul << 5 ); constexpr uint8_t modm :: Bit6 = ( 1ul << 6 ); constexpr uint8_t modm :: Bit7 = ( 1ul << 7 ); // Typedef typedef Matrix < float , 1 , 1 > modm :: Matrix1f ; typedef Matrix < float , 2 , 2 > modm :: Matrix2f ; typedef Matrix < float , 3 , 3 > modm :: Matrix3f ; typedef Matrix < float , 4 , 4 > modm :: Matrix4f ; typedef Vector < float , 1 > modm :: Vector1f ; typedef Vector < float , 2 > modm :: Vector2f ; typedef Vector < float , 3 > modm :: Vector3f ; typedef Vector < float , 4 > modm :: Vector4f ; typedef Vector < int16_t , 1 > modm :: Vector1i ; typedef Vector < int16_t , 2 > modm :: Vector2i ; typedef Vector < int16_t , 3 > modm :: Vector3i ; typedef Vector < int16_t , 4 > modm :: Vector4i ; typedef Vector < uint16_t , 2 > modm :: Vector2u ; typedef Vector < uint16_t , 3 > modm :: Vector3u ; typedef Vector < uint16_t , 4 > modm :: Vector4u ; using modm :: SignedType = typedef typename detail :: MakeSigned < T >:: type ; using modm :: UnsignedType = typedef typename detail :: MakeUnsigned < T >:: type ; using modm :: WideType = typedef typename detail :: WideType < T >:: type ; using modm :: baudrate_t = typedef uint32_t ; using modm :: bitrate_t = typedef uint32_t ; using modm :: frequency_t = typedef uint32_t ; using modm :: percent_t = typedef uint16_t ; // Define #define IMPLEMENT_VECTOR_ACCESSOR2(a, b) #define IMPLEMENT_VECTOR_ACCESSOR3(a, b, c) #define IMPLEMENT_VECTOR_ACCESSOR4(a, b, c, d) #define M_1_PI #define M_2_PI #define M_PI #define M_PI_2 #define M_PI_4 #define M_SQRT2 #define M_TWOPI","title":"Content"},{"location":"reference/module/modm-math/#dependencies","text":"modm:math modm_math modm: math modm_math_units modm: math: units modm_math->modm_math_units modm_math_units->modm_math modm_math_filter modm: math: filter modm_math_filter->modm_math modm_math_geometry modm: math: geometry modm_math_geometry->modm_math modm_math_interpolation modm: math: interpolation modm_math_interpolation->modm_math modm_math_matrix modm: math: matrix modm_math_matrix->modm_math modm_math_saturated modm: math: saturated modm_math_saturated->modm_math modm_math_utils modm: math: utils modm_math_utils->modm_math","title":"Dependencies"},{"location":"reference/module/modm-platform-1-wire-bitbang/","text":"These module docs are in beta and may be incomplete. modm:platform:1-wire.bitbang: Software 1-Wire \u00b6 Content \u00b6 // Class class modm :: platform :: BitBangOneWireMaster < typename Pin > ; Dependencies \u00b6 modm:platform:1-wire.bitbang modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_architecture_1_wire modm: architecture: 1-wire modm_platform_1_wire_bitbang->modm_architecture_1_wire modm_architecture_delay modm: architecture: delay modm_platform_1_wire_bitbang->modm_architecture_delay modm_platform modm: platform modm_platform_1_wire_bitbang->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_1_wire_bitbang->modm_platform_gpio","title":"modm:platform:1-wire.bitbang"},{"location":"reference/module/modm-platform-1-wire-bitbang/#modmplatform1-wirebitbang-software-1-wire","text":"","title":"modm:platform:1-wire.bitbang: Software 1-Wire"},{"location":"reference/module/modm-platform-1-wire-bitbang/#content","text":"// Class class modm :: platform :: BitBangOneWireMaster < typename Pin > ;","title":"Content"},{"location":"reference/module/modm-platform-1-wire-bitbang/#dependencies","text":"modm:platform:1-wire.bitbang modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_architecture_1_wire modm: architecture: 1-wire modm_platform_1_wire_bitbang->modm_architecture_1_wire modm_architecture_delay modm: architecture: delay modm_platform_1_wire_bitbang->modm_architecture_delay modm_platform modm: platform modm_platform_1_wire_bitbang->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_1_wire_bitbang->modm_platform_gpio","title":"Dependencies"},{"location":"reference/module/modm-platform-adc-1/","text":"These module docs are in beta and may be incomplete. modm:platform:adc:1: Instance 1 \u00b6 Content \u00b6 // Class class modm :: platform :: Adc1 ; class modm :: platform :: AdcInterrupt1 ; Dependencies \u00b6 modm:platform:adc:1 modm_platform_adc_1 modm: platform: adc: 1 modm_platform_adc modm: platform: adc modm_platform_adc_1->modm_platform_adc","title":"modm:platform:adc:1"},{"location":"reference/module/modm-platform-adc-1/#modmplatformadc1-instance-1","text":"","title":"modm:platform:adc:1: Instance 1"},{"location":"reference/module/modm-platform-adc-1/#content","text":"// Class class modm :: platform :: Adc1 ; class modm :: platform :: AdcInterrupt1 ;","title":"Content"},{"location":"reference/module/modm-platform-adc-1/#dependencies","text":"modm:platform:adc:1 modm_platform_adc_1 modm: platform: adc: 1 modm_platform_adc modm: platform: adc modm_platform_adc_1->modm_platform_adc","title":"Dependencies"},{"location":"reference/module/modm-platform-adc-2/","text":"These module docs are in beta and may be incomplete. modm:platform:adc:2: Instance 2 \u00b6 Content \u00b6 // Class class modm :: platform :: Adc2 ; class modm :: platform :: AdcInterrupt2 ; Dependencies \u00b6 modm:platform:adc:2 modm_platform_adc_2 modm: platform: adc: 2 modm_platform_adc modm: platform: adc modm_platform_adc_2->modm_platform_adc","title":"modm:platform:adc:2"},{"location":"reference/module/modm-platform-adc-2/#modmplatformadc2-instance-2","text":"","title":"modm:platform:adc:2: Instance 2"},{"location":"reference/module/modm-platform-adc-2/#content","text":"// Class class modm :: platform :: Adc2 ; class modm :: platform :: AdcInterrupt2 ;","title":"Content"},{"location":"reference/module/modm-platform-adc-2/#dependencies","text":"modm:platform:adc:2 modm_platform_adc_2 modm: platform: adc: 2 modm_platform_adc modm: platform: adc modm_platform_adc_2->modm_platform_adc","title":"Dependencies"},{"location":"reference/module/modm-platform-adc-3/","text":"These module docs are in beta and may be incomplete. modm:platform:adc:3: Instance 3 \u00b6 Content \u00b6 // Class class modm :: platform :: Adc3 ; class modm :: platform :: AdcInterrupt3 ; Dependencies \u00b6 modm:platform:adc:3 modm_platform_adc_3 modm: platform: adc: 3 modm_platform_adc modm: platform: adc modm_platform_adc_3->modm_platform_adc","title":"modm:platform:adc:3"},{"location":"reference/module/modm-platform-adc-3/#modmplatformadc3-instance-3","text":"","title":"modm:platform:adc:3: Instance 3"},{"location":"reference/module/modm-platform-adc-3/#content","text":"// Class class modm :: platform :: Adc3 ; class modm :: platform :: AdcInterrupt3 ;","title":"Content"},{"location":"reference/module/modm-platform-adc-3/#dependencies","text":"modm:platform:adc:3 modm_platform_adc_3 modm: platform: adc: 3 modm_platform_adc modm: platform: adc modm_platform_adc_3->modm_platform_adc","title":"Dependencies"},{"location":"reference/module/modm-platform-adc/","text":"These module docs are in beta and may be incomplete. modm:platform:adc: Analog-to-Digital Converter (ADC) \u00b6 Content \u00b6 // Class class modm :: platform :: Adc1 ; class modm :: platform :: Adc2 ; class modm :: platform :: Adc3 ; class modm :: platform :: AdcInterrupt1 ; class modm :: platform :: AdcInterrupt2 ; class modm :: platform :: AdcInterrupt3 ; Dependencies \u00b6 modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_platform modm: platform modm_platform_adc->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc modm_utils modm: utils modm_platform_adc->modm_utils modm_platform_adc_1 modm: platform: adc: 1 modm_platform_adc_1->modm_platform_adc modm_platform_adc_2 modm: platform: adc: 2 modm_platform_adc_2->modm_platform_adc modm_platform_adc_3 modm: platform: adc: 3 modm_platform_adc_3->modm_platform_adc","title":"modm:platform:adc"},{"location":"reference/module/modm-platform-adc/#modmplatformadc-analog-to-digital-converter-adc","text":"","title":"modm:platform:adc: Analog-to-Digital Converter (ADC)"},{"location":"reference/module/modm-platform-adc/#content","text":"// Class class modm :: platform :: Adc1 ; class modm :: platform :: Adc2 ; class modm :: platform :: Adc3 ; class modm :: platform :: AdcInterrupt1 ; class modm :: platform :: AdcInterrupt2 ; class modm :: platform :: AdcInterrupt3 ;","title":"Content"},{"location":"reference/module/modm-platform-adc/#dependencies","text":"modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_platform modm: platform modm_platform_adc->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc modm_utils modm: utils modm_platform_adc->modm_utils modm_platform_adc_1 modm: platform: adc: 1 modm_platform_adc_1->modm_platform_adc modm_platform_adc_2 modm: platform: adc: 2 modm_platform_adc_2->modm_platform_adc modm_platform_adc_3 modm: platform: adc: 3 modm_platform_adc_3->modm_platform_adc","title":"Dependencies"},{"location":"reference/module/modm-platform-can-1/","text":"These module docs are in beta and may be incomplete. modm:platform:can:1: Instance 1 \u00b6 Options \u00b6 buffer.tx \u00b6 Default: 32 \u2208 { 1 .. 32 .. 65534 } buffer.rx \u00b6 Default: 32 \u2208 { 1 .. 32 .. 65534 } Content \u00b6 // Class class modm :: platform :: Can1 ; Dependencies \u00b6 modm:platform:can:1 modm_platform_can_1 modm: platform: can: 1 modm_platform_can modm: platform: can modm_platform_can_1->modm_platform_can","title":"modm:platform:can:1"},{"location":"reference/module/modm-platform-can-1/#modmplatformcan1-instance-1","text":"","title":"modm:platform:can:1: Instance 1"},{"location":"reference/module/modm-platform-can-1/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-can-1/#buffertx","text":"Default: 32 \u2208 { 1 .. 32 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-can-1/#bufferrx","text":"Default: 32 \u2208 { 1 .. 32 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-can-1/#content","text":"// Class class modm :: platform :: Can1 ;","title":"Content"},{"location":"reference/module/modm-platform-can-1/#dependencies","text":"modm:platform:can:1 modm_platform_can_1 modm: platform: can: 1 modm_platform_can modm: platform: can modm_platform_can_1->modm_platform_can","title":"Dependencies"},{"location":"reference/module/modm-platform-can-2/","text":"These module docs are in beta and may be incomplete. modm:platform:can:2: Instance 2 \u00b6 Options \u00b6 buffer.tx \u00b6 Default: 32 \u2208 { 1 .. 32 .. 65534 } buffer.rx \u00b6 Default: 32 \u2208 { 1 .. 32 .. 65534 } Content \u00b6 // Class class modm :: platform :: Can2 ; Dependencies \u00b6 modm:platform:can:2 modm_platform_can_2 modm: platform: can: 2 modm_platform_can modm: platform: can modm_platform_can_2->modm_platform_can","title":"modm:platform:can:2"},{"location":"reference/module/modm-platform-can-2/#modmplatformcan2-instance-2","text":"","title":"modm:platform:can:2: Instance 2"},{"location":"reference/module/modm-platform-can-2/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-can-2/#buffertx","text":"Default: 32 \u2208 { 1 .. 32 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-can-2/#bufferrx","text":"Default: 32 \u2208 { 1 .. 32 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-can-2/#content","text":"// Class class modm :: platform :: Can2 ;","title":"Content"},{"location":"reference/module/modm-platform-can-2/#dependencies","text":"modm:platform:can:2 modm_platform_can_2 modm: platform: can: 2 modm_platform_can modm: platform: can modm_platform_can_2->modm_platform_can","title":"Dependencies"},{"location":"reference/module/modm-platform-can-common/","text":"These module docs are in beta and may be incomplete. modm:platform:can.common: CAN Common \u00b6 Content \u00b6 // Class class modm :: CanBitTiming < int32_t Clk , int32_t Bitrate > ; // Struct struct modm :: CanBitTiming :: CanBitTimingConfiguration ; Dependencies \u00b6 modm:platform:can.common modm_platform_can_common modm: platform: can.common modm_architecture_clock modm: architecture: clock modm_platform_can_common->modm_architecture_clock modm_platform modm: platform modm_platform_can_common->modm_platform modm_platform_can modm: platform: can modm_platform_can->modm_platform_can_common","title":"modm:platform:can.common"},{"location":"reference/module/modm-platform-can-common/#modmplatformcancommon-can-common","text":"","title":"modm:platform:can.common: CAN Common"},{"location":"reference/module/modm-platform-can-common/#content","text":"// Class class modm :: CanBitTiming < int32_t Clk , int32_t Bitrate > ; // Struct struct modm :: CanBitTiming :: CanBitTimingConfiguration ;","title":"Content"},{"location":"reference/module/modm-platform-can-common/#dependencies","text":"modm:platform:can.common modm_platform_can_common modm: platform: can.common modm_architecture_clock modm: architecture: clock modm_platform_can_common->modm_architecture_clock modm_platform modm: platform modm_platform_can_common->modm_platform modm_platform_can modm: platform: can modm_platform_can->modm_platform_can_common","title":"Dependencies"},{"location":"reference/module/modm-platform-can/","text":"These module docs are in beta and may be incomplete. modm:platform:can: Controller Area Network (CAN) \u00b6 Content \u00b6 // Class class modm :: CanBitTiming < int32_t Clk , int32_t Bitrate > ; class modm :: platform :: Can1 ; class modm :: platform :: Can2 ; class modm :: platform :: CanFilter ; // Struct struct modm :: CanBitTiming :: CanBitTimingConfiguration ; struct modm :: platform :: CanFilter :: ExtendedFilterMask ; struct modm :: platform :: CanFilter :: ExtendedFilterMaskShort ; struct modm :: platform :: CanFilter :: ExtendedIdentifier ; struct modm :: platform :: CanFilter :: ExtendedIdentifierShort ; struct modm :: platform :: CanFilter :: Identifier ; struct modm :: platform :: CanFilter :: IdentifierShort ; struct modm :: platform :: CanFilter :: StandardFilterMask ; struct modm :: platform :: CanFilter :: StandardFilterMaskShort ; struct modm :: platform :: CanFilter :: StandardIdentifier ; struct modm :: platform :: CanFilter :: StandardIdentifierShort ; // Enum enum ErrorCode ; Dependencies \u00b6 modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can->modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can->modm_cmsis_device modm_debug modm: debug modm_platform_can->modm_debug modm_platform modm: platform modm_platform_can->modm_platform modm_platform_can_common modm: platform: can.common modm_platform_can->modm_platform_can_common modm_platform_gpio modm: platform: gpio modm_platform_can->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can->modm_platform_rcc modm_utils modm: utils modm_platform_can->modm_utils modm_platform_can_1 modm: platform: can: 1 modm_platform_can_1->modm_platform_can modm_platform_can_2 modm: platform: can: 2 modm_platform_can_2->modm_platform_can","title":"modm:platform:can"},{"location":"reference/module/modm-platform-can/#modmplatformcan-controller-area-network-can","text":"","title":"modm:platform:can: Controller Area Network (CAN)"},{"location":"reference/module/modm-platform-can/#content","text":"// Class class modm :: CanBitTiming < int32_t Clk , int32_t Bitrate > ; class modm :: platform :: Can1 ; class modm :: platform :: Can2 ; class modm :: platform :: CanFilter ; // Struct struct modm :: CanBitTiming :: CanBitTimingConfiguration ; struct modm :: platform :: CanFilter :: ExtendedFilterMask ; struct modm :: platform :: CanFilter :: ExtendedFilterMaskShort ; struct modm :: platform :: CanFilter :: ExtendedIdentifier ; struct modm :: platform :: CanFilter :: ExtendedIdentifierShort ; struct modm :: platform :: CanFilter :: Identifier ; struct modm :: platform :: CanFilter :: IdentifierShort ; struct modm :: platform :: CanFilter :: StandardFilterMask ; struct modm :: platform :: CanFilter :: StandardFilterMaskShort ; struct modm :: platform :: CanFilter :: StandardIdentifier ; struct modm :: platform :: CanFilter :: StandardIdentifierShort ; // Enum enum ErrorCode ;","title":"Content"},{"location":"reference/module/modm-platform-can/#dependencies","text":"modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can->modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can->modm_cmsis_device modm_debug modm: debug modm_platform_can->modm_debug modm_platform modm: platform modm_platform_can->modm_platform modm_platform_can_common modm: platform: can.common modm_platform_can->modm_platform_can_common modm_platform_gpio modm: platform: gpio modm_platform_can->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can->modm_platform_rcc modm_utils modm: utils modm_platform_can->modm_utils modm_platform_can_1 modm: platform: can: 1 modm_platform_can_1->modm_platform_can modm_platform_can_2 modm: platform: can: 2 modm_platform_can_2->modm_platform_can","title":"Dependencies"},{"location":"reference/module/modm-platform-clock/","text":"These module docs are in beta and may be incomplete. modm:platform:clock: System Clock \u00b6 Dependencies \u00b6 modm:platform:clock modm_platform_clock modm: platform: clock modm_platform modm: platform modm_platform_clock->modm_platform modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_clock modm_freertos modm: freertos modm_freertos->modm_platform_clock modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_platform_clock modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_platform_clock","title":"modm:platform:clock"},{"location":"reference/module/modm-platform-clock/#modmplatformclock-system-clock","text":"","title":"modm:platform:clock: System Clock"},{"location":"reference/module/modm-platform-clock/#dependencies","text":"modm:platform:clock modm_platform_clock modm: platform: clock modm_platform modm: platform modm_platform_clock->modm_platform modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_clock modm_freertos modm: freertos modm_freertos->modm_platform_clock modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_platform_clock modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_platform_clock","title":"Dependencies"},{"location":"reference/module/modm-platform-core/","text":"These module docs are in beta and may be incomplete. modm:platform:core: STM32 core module \u00b6 Provides STM32 specific linkerscripts and startup code. Dependencies \u00b6 modm:platform:core modm_platform_core modm: platform: core modm_platform modm: platform modm_platform_core->modm_platform modm_platform_cortex_m modm: platform: cortex-m modm_platform_core->modm_platform_cortex_m modm_platform_systick modm: platform: systick modm_platform_core->modm_platform_systick modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_core","title":"modm:platform:core"},{"location":"reference/module/modm-platform-core/#modmplatformcore-stm32-core-module","text":"Provides STM32 specific linkerscripts and startup code.","title":"modm:platform:core: STM32 core module"},{"location":"reference/module/modm-platform-core/#dependencies","text":"modm:platform:core modm_platform_core modm: platform: core modm_platform modm: platform modm_platform_core->modm_platform modm_platform_cortex_m modm: platform: cortex-m modm_platform_core->modm_platform_cortex_m modm_platform_systick modm: platform: systick modm_platform_core->modm_platform_systick modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_core","title":"Dependencies"},{"location":"reference/module/modm-platform-cortex-m/","text":"These module docs are in beta and may be incomplete. modm:platform:cortex-m: ARM Cortex-M Core \u00b6 This module generates the startup code, the vector table, the linkerscript and provides runtime support for dynamic memory allocations on the heap and assertion handling. Linkerscript \u00b6 The linkerscript is generated for the devices memory map. Placement of .fastcode section \u00b6 From the Cortex-M3 Technical Reference Manual: 14.5 System Interface: The system interface is a 32-bit AHB-Lite bus. Instruction and vector fetches, and data and debug accesses to the System memory space, 0x20000000 - 0xDFFFFFFF, 0xE0100000 - 0xFFFFFFFF, are performed over this bus. 14.5.6 Pipelined instruction fetches: To provide a clean timing interface on the System bus, instruction and vector fetch requests to this bus are registered. This results in an additional cycle of latency because instructions fetched from the System bus take two cycles. This also means that back-to-back instruction fetches from the System bus are not possible. Note: Instruction fetch requests to the ICode bus are not registered. Performance critical code must run from the ICode interface. So for STM32s where the CCM is not connected to the I-Bus, we execute .fastcode from Flash. Options \u00b6 stack_execution_guard \u00b6 Fill the stack with relative jumps to fault handler to prevent accidental execution.: False \u2208 { True, False } allocator \u00b6 Dynamic memory allocation strategy: newlib \u2208 { block, newlib, tlsf } By default, the arm-none-eabi toolchain ships with the newlib libc, which uses dlmalloc as the underlying allocator algorithm and only requires the implementation of the void * sbrk(ptrdiff_t size) hook. However, this limits the allocator to use just one memory region, which must then also be of continuous extend, since sbrk can only grow and shrink, but not jump. Therefore, when using the newlib strategy, only the largest memory region is used as heap! Depending on the device memory architecture this can leave large memory regions unused. For devices with very small memories, we recommend using the block allocator strategy, which uses a very light-weight and simple algorithm. This also only operates on one continuous memory region as heap. Note Memories can have different traits, such as DMA-ability or access time. The default memory allocator functions (malloc, new, etc) only return DMA-able memories, ordered by fastest access time. Similarly the search for the largest memory region only considers DMA-able memory. Warning For devices which contain separate memories laid out in a continuous way (often called SRAM1, SRAM2, etc.) the newlib and block strategies choose the largest continuous memory region, even though unaligned accesses across memory regions may not be supported in hardware and lead to a bus fault! Consider using the TLSF implementation, which does not suffer from this issue. To use all non-statically allocated memory for heap, use the TLSF strategy, which natively supports multiple memory regions. Our implementation treats all internal memories as separate regions, so unaligned accesses across memory boundaries are not an issue. To request heap memory of different traits, see modm::MemoryTraits . Note The TLSF implementation has a static overhead of about 1kB per memory trait group, however, these can then contain multiple non-continuous memory regions. The upside of this large static allocation is very fast allocation times of O(1), but we recommend using TLSF only for devices with multiple memory regions. main_stack_size \u00b6 Minimum size of the application main stack: 3040 \u2208 { 256 .. 3040 .. 65536 } The ARM Cortex-M uses a descending stack mechanism which is placed so that it grows towards the beginning of RAM. In case of a stack overflow the hardware then attempts to stack into invalid memory which triggers a HardFault. A stack overflow will therefore never overwrite any static or heap memory and this protection works without the MPU and therefore also on ARM Cortex-M0 devices. If you enable either the LED or the logging HardFault option, a smaller stack is added above the main stack. This stack is only used by the HardFault handler when not enough memory remains in the main stack to preserve GDB backtrace behavior. This memory also acts as a small safety buffer against main stack underflow, which is not detected however. If the vector table is relocated into RAM, the start address needs to be aligned to the next highest power-of-two word depending on the total number of device interrupts. On devices where the table is relocated into the same memory as the main stack, an alignment buffer up to 1kB is added to the main stack. | ... | |---------------------------------| | Interrupt Vectors (in RAM) | | (if re-mapped) | <-- vector table origin |---------------------------------| <-- HardFault stack top | HardFault Stack | | (grows downwards) | | | | | v | |---------------------------------| <-- main stack top | Main Stack | | (grows downwards) | | | | | v | |---------------------------------| | Alignment buffer for vectors | | (overwritten by main stack!) | '---------------------------------' <-- RAM origin Warning The main stack size you provide is a minimum and may be enlarged to satisfy alignment requirements. Be aware that these requirements operate on the sum of HardFault and main stack. Disabling HardFault options may therefore decrease the alignment buffer added to the main stack size, which may make your application overflow stack. You need to increase your minimum main stack size in that case. Note The main stack is watermarked and you can get the maximum stack usage using the uint32_t modm::cortex::getMaximumStackUsage() function. vector_table_location \u00b6 Vector table location in ROM or RAM: rom \u2208 { ram, rom } The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions: void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector) uint32_t NVIC_GetVector(IRQn_Type IRQn) For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory. By default, the fastest option is chosen depending on the target memory architecture. This does not always mean the table is copied into RAM, and therefore may not be modifiable with this option! From the ARM Cortex-M4 Technical Reference Manual on exception handling: Processor state is automatically stored to the stack on an exception, and automatically restored from the stack at the end of the Interrupt Service Routine. The vector is fetched in parallel to the state saving, enabling efficient interrupt entry. Warning Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port. linkerscript.flash_offset \u00b6 Add an offset to the default start address of the flash memory. This might be required for bootloaders located there. WARNING: Not all offsets are compatible with the vector table relocation.: 0 \u2208 { 0 ... 2097152 } Content \u00b6 // Function void _delay_ms ( uint16_t ms ); void _delay_ns ( uint16_t ns ); void _delay_us ( uint16_t us ); Collectors \u00b6 linkerscript.memory \u00b6 Additions to the linkerscript's 'MEMORY' \u2208 String linkerscript.process_stack_size \u00b6 Maximum required size of the process stack \u2208 -Inf ... +Inf linkerscript.sections \u00b6 Additions to the linkerscript's 'SECTIONS' \u2208 String linkerscript.table_extern.copy \u00b6 Additions to the linkerscript's '.table.copy.extern' section \u2208 String linkerscript.table_extern.heap \u00b6 Additions to the linkerscript's '.table.heap' section \u2208 String linkerscript.table_extern.zero \u00b6 Additions to the linkerscript's '.table.zero.extern' section \u2208 String Queries \u00b6 linkerscript \u00b6 Computes linkerscript properties post-build : - process_stack_size: largest requested process stack size by any module - vector_table_location: ram or rom Stripped and newline-joined collector values of: - linkerscript_memory - linkerscript_sections - linkerscript_extern_zero - linkerscript_extern_copy - linkerscript_extern_heap Additional memory properties: - memories: unfiltered memory regions - regions: memory region names - ram_origin: Lowest SRAM origin address - ram_origin: Total size of all SRAM regions :returns: dictionary of linkerscript properties vector_table \u00b6 Computes vector table properties: - vector_table: [position] = Full vector name (ie. with _Handler or _IRQHandler suffix) - vector_table_location: rom or ram - highest_irq: highest IRQ number + 1 - core: cortex-m{0,3,4,7}{,+,f,fd} The system vectors start at -16, so you must add 16 to highest_irq to get the total number of vectors in the table! :returns: a dictionary of vector table properties Dependencies \u00b6 modm:platform:cortex-m modm_platform_cortex_m modm: platform: cortex-m modm_architecture_accessor modm: architecture: accessor modm_platform_cortex_m->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_platform_cortex_m->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_cortex_m->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_cortex_m->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_cortex_m->modm_architecture_delay modm_architecture_heap modm: architecture: heap modm_platform_cortex_m->modm_architecture_heap modm_architecture_interrupt modm: architecture: interrupt modm_platform_cortex_m->modm_architecture_interrupt modm_architecture_memory modm: architecture: memory modm_platform_cortex_m->modm_architecture_memory modm_architecture_unaligned modm: architecture: unaligned modm_platform_cortex_m->modm_architecture_unaligned modm_cmsis_device modm: cmsis: device modm_platform_cortex_m->modm_cmsis_device modm_platform modm: platform modm_platform_cortex_m->modm_platform modm_platform_clock modm: platform: clock modm_platform_cortex_m->modm_platform_clock modm_tlsf modm: tlsf modm_platform_cortex_m->modm_tlsf modm_platform_core modm: platform: core modm_platform_core->modm_platform_cortex_m","title":"modm:platform:cortex-m"},{"location":"reference/module/modm-platform-cortex-m/#modmplatformcortex-m-arm-cortex-m-core","text":"This module generates the startup code, the vector table, the linkerscript and provides runtime support for dynamic memory allocations on the heap and assertion handling.","title":"modm:platform:cortex-m: ARM Cortex-M Core"},{"location":"reference/module/modm-platform-cortex-m/#linkerscript","text":"The linkerscript is generated for the devices memory map.","title":"Linkerscript"},{"location":"reference/module/modm-platform-cortex-m/#placement-of-fastcode-section","text":"From the Cortex-M3 Technical Reference Manual: 14.5 System Interface: The system interface is a 32-bit AHB-Lite bus. Instruction and vector fetches, and data and debug accesses to the System memory space, 0x20000000 - 0xDFFFFFFF, 0xE0100000 - 0xFFFFFFFF, are performed over this bus. 14.5.6 Pipelined instruction fetches: To provide a clean timing interface on the System bus, instruction and vector fetch requests to this bus are registered. This results in an additional cycle of latency because instructions fetched from the System bus take two cycles. This also means that back-to-back instruction fetches from the System bus are not possible. Note: Instruction fetch requests to the ICode bus are not registered. Performance critical code must run from the ICode interface. So for STM32s where the CCM is not connected to the I-Bus, we execute .fastcode from Flash.","title":"Placement of .fastcode section"},{"location":"reference/module/modm-platform-cortex-m/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-cortex-m/#stack_execution_guard","text":"Fill the stack with relative jumps to fault handler to prevent accidental execution.: False \u2208 { True, False }","title":"stack_execution_guard"},{"location":"reference/module/modm-platform-cortex-m/#allocator","text":"Dynamic memory allocation strategy: newlib \u2208 { block, newlib, tlsf } By default, the arm-none-eabi toolchain ships with the newlib libc, which uses dlmalloc as the underlying allocator algorithm and only requires the implementation of the void * sbrk(ptrdiff_t size) hook. However, this limits the allocator to use just one memory region, which must then also be of continuous extend, since sbrk can only grow and shrink, but not jump. Therefore, when using the newlib strategy, only the largest memory region is used as heap! Depending on the device memory architecture this can leave large memory regions unused. For devices with very small memories, we recommend using the block allocator strategy, which uses a very light-weight and simple algorithm. This also only operates on one continuous memory region as heap. Note Memories can have different traits, such as DMA-ability or access time. The default memory allocator functions (malloc, new, etc) only return DMA-able memories, ordered by fastest access time. Similarly the search for the largest memory region only considers DMA-able memory. Warning For devices which contain separate memories laid out in a continuous way (often called SRAM1, SRAM2, etc.) the newlib and block strategies choose the largest continuous memory region, even though unaligned accesses across memory regions may not be supported in hardware and lead to a bus fault! Consider using the TLSF implementation, which does not suffer from this issue. To use all non-statically allocated memory for heap, use the TLSF strategy, which natively supports multiple memory regions. Our implementation treats all internal memories as separate regions, so unaligned accesses across memory boundaries are not an issue. To request heap memory of different traits, see modm::MemoryTraits . Note The TLSF implementation has a static overhead of about 1kB per memory trait group, however, these can then contain multiple non-continuous memory regions. The upside of this large static allocation is very fast allocation times of O(1), but we recommend using TLSF only for devices with multiple memory regions.","title":"allocator"},{"location":"reference/module/modm-platform-cortex-m/#main_stack_size","text":"Minimum size of the application main stack: 3040 \u2208 { 256 .. 3040 .. 65536 } The ARM Cortex-M uses a descending stack mechanism which is placed so that it grows towards the beginning of RAM. In case of a stack overflow the hardware then attempts to stack into invalid memory which triggers a HardFault. A stack overflow will therefore never overwrite any static or heap memory and this protection works without the MPU and therefore also on ARM Cortex-M0 devices. If you enable either the LED or the logging HardFault option, a smaller stack is added above the main stack. This stack is only used by the HardFault handler when not enough memory remains in the main stack to preserve GDB backtrace behavior. This memory also acts as a small safety buffer against main stack underflow, which is not detected however. If the vector table is relocated into RAM, the start address needs to be aligned to the next highest power-of-two word depending on the total number of device interrupts. On devices where the table is relocated into the same memory as the main stack, an alignment buffer up to 1kB is added to the main stack. | ... | |---------------------------------| | Interrupt Vectors (in RAM) | | (if re-mapped) | <-- vector table origin |---------------------------------| <-- HardFault stack top | HardFault Stack | | (grows downwards) | | | | | v | |---------------------------------| <-- main stack top | Main Stack | | (grows downwards) | | | | | v | |---------------------------------| | Alignment buffer for vectors | | (overwritten by main stack!) | '---------------------------------' <-- RAM origin Warning The main stack size you provide is a minimum and may be enlarged to satisfy alignment requirements. Be aware that these requirements operate on the sum of HardFault and main stack. Disabling HardFault options may therefore decrease the alignment buffer added to the main stack size, which may make your application overflow stack. You need to increase your minimum main stack size in that case. Note The main stack is watermarked and you can get the maximum stack usage using the uint32_t modm::cortex::getMaximumStackUsage() function.","title":"main_stack_size"},{"location":"reference/module/modm-platform-cortex-m/#vector_table_location","text":"Vector table location in ROM or RAM: rom \u2208 { ram, rom } The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions: void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector) uint32_t NVIC_GetVector(IRQn_Type IRQn) For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory. By default, the fastest option is chosen depending on the target memory architecture. This does not always mean the table is copied into RAM, and therefore may not be modifiable with this option! From the ARM Cortex-M4 Technical Reference Manual on exception handling: Processor state is automatically stored to the stack on an exception, and automatically restored from the stack at the end of the Interrupt Service Routine. The vector is fetched in parallel to the state saving, enabling efficient interrupt entry. Warning Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port.","title":"vector_table_location"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptflash_offset","text":"Add an offset to the default start address of the flash memory. This might be required for bootloaders located there. WARNING: Not all offsets are compatible with the vector table relocation.: 0 \u2208 { 0 ... 2097152 }","title":"linkerscript.flash_offset"},{"location":"reference/module/modm-platform-cortex-m/#content","text":"// Function void _delay_ms ( uint16_t ms ); void _delay_ns ( uint16_t ns ); void _delay_us ( uint16_t us );","title":"Content"},{"location":"reference/module/modm-platform-cortex-m/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptmemory","text":"Additions to the linkerscript's 'MEMORY' \u2208 String","title":"linkerscript.memory"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptprocess_stack_size","text":"Maximum required size of the process stack \u2208 -Inf ... +Inf","title":"linkerscript.process_stack_size"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptsections","text":"Additions to the linkerscript's 'SECTIONS' \u2208 String","title":"linkerscript.sections"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externcopy","text":"Additions to the linkerscript's '.table.copy.extern' section \u2208 String","title":"linkerscript.table_extern.copy"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externheap","text":"Additions to the linkerscript's '.table.heap' section \u2208 String","title":"linkerscript.table_extern.heap"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externzero","text":"Additions to the linkerscript's '.table.zero.extern' section \u2208 String","title":"linkerscript.table_extern.zero"},{"location":"reference/module/modm-platform-cortex-m/#queries","text":"","title":"Queries"},{"location":"reference/module/modm-platform-cortex-m/#linkerscript_1","text":"Computes linkerscript properties post-build : - process_stack_size: largest requested process stack size by any module - vector_table_location: ram or rom Stripped and newline-joined collector values of: - linkerscript_memory - linkerscript_sections - linkerscript_extern_zero - linkerscript_extern_copy - linkerscript_extern_heap Additional memory properties: - memories: unfiltered memory regions - regions: memory region names - ram_origin: Lowest SRAM origin address - ram_origin: Total size of all SRAM regions :returns: dictionary of linkerscript properties","title":"linkerscript"},{"location":"reference/module/modm-platform-cortex-m/#vector_table","text":"Computes vector table properties: - vector_table: [position] = Full vector name (ie. with _Handler or _IRQHandler suffix) - vector_table_location: rom or ram - highest_irq: highest IRQ number + 1 - core: cortex-m{0,3,4,7}{,+,f,fd} The system vectors start at -16, so you must add 16 to highest_irq to get the total number of vectors in the table! :returns: a dictionary of vector table properties","title":"vector_table"},{"location":"reference/module/modm-platform-cortex-m/#dependencies","text":"modm:platform:cortex-m modm_platform_cortex_m modm: platform: cortex-m modm_architecture_accessor modm: architecture: accessor modm_platform_cortex_m->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_platform_cortex_m->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_cortex_m->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_cortex_m->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_cortex_m->modm_architecture_delay modm_architecture_heap modm: architecture: heap modm_platform_cortex_m->modm_architecture_heap modm_architecture_interrupt modm: architecture: interrupt modm_platform_cortex_m->modm_architecture_interrupt modm_architecture_memory modm: architecture: memory modm_platform_cortex_m->modm_architecture_memory modm_architecture_unaligned modm: architecture: unaligned modm_platform_cortex_m->modm_architecture_unaligned modm_cmsis_device modm: cmsis: device modm_platform_cortex_m->modm_cmsis_device modm_platform modm: platform modm_platform_cortex_m->modm_platform modm_platform_clock modm: platform: clock modm_platform_cortex_m->modm_platform_clock modm_tlsf modm: tlsf modm_platform_cortex_m->modm_tlsf modm_platform_core modm: platform: core modm_platform_core->modm_platform_cortex_m","title":"Dependencies"},{"location":"reference/module/modm-platform-dma-1/","text":"These module docs are in beta and may be incomplete. modm:platform:dma:1: Instance 1 \u00b6 Content \u00b6 // Class class modm :: platform :: Dma1 :: Stream0 ; class modm :: platform :: Dma1 :: Stream1 ; class modm :: platform :: Dma1 :: Stream2 ; class modm :: platform :: Dma1 :: Stream3 ; class modm :: platform :: Dma1 :: Stream4 ; class modm :: platform :: Dma1 :: Stream5 ; class modm :: platform :: Dma1 :: Stream6 ; class modm :: platform :: Dma1 :: Stream7 ; class modm :: platform :: Dma1 ; Dependencies \u00b6 modm:platform:dma:1 modm_platform_dma_1 modm: platform: dma: 1 modm_platform_dma modm: platform: dma modm_platform_dma_1->modm_platform_dma","title":"modm:platform:dma:1"},{"location":"reference/module/modm-platform-dma-1/#modmplatformdma1-instance-1","text":"","title":"modm:platform:dma:1: Instance 1"},{"location":"reference/module/modm-platform-dma-1/#content","text":"// Class class modm :: platform :: Dma1 :: Stream0 ; class modm :: platform :: Dma1 :: Stream1 ; class modm :: platform :: Dma1 :: Stream2 ; class modm :: platform :: Dma1 :: Stream3 ; class modm :: platform :: Dma1 :: Stream4 ; class modm :: platform :: Dma1 :: Stream5 ; class modm :: platform :: Dma1 :: Stream6 ; class modm :: platform :: Dma1 :: Stream7 ; class modm :: platform :: Dma1 ;","title":"Content"},{"location":"reference/module/modm-platform-dma-1/#dependencies","text":"modm:platform:dma:1 modm_platform_dma_1 modm: platform: dma: 1 modm_platform_dma modm: platform: dma modm_platform_dma_1->modm_platform_dma","title":"Dependencies"},{"location":"reference/module/modm-platform-dma-2/","text":"These module docs are in beta and may be incomplete. modm:platform:dma:2: Instance 2 \u00b6 Content \u00b6 // Class class modm :: platform :: Dma2 :: Stream0 ; class modm :: platform :: Dma2 :: Stream1 ; class modm :: platform :: Dma2 :: Stream2 ; class modm :: platform :: Dma2 :: Stream3 ; class modm :: platform :: Dma2 :: Stream4 ; class modm :: platform :: Dma2 :: Stream5 ; class modm :: platform :: Dma2 :: Stream6 ; class modm :: platform :: Dma2 :: Stream7 ; class modm :: platform :: Dma2 ; Dependencies \u00b6 modm:platform:dma:2 modm_platform_dma_2 modm: platform: dma: 2 modm_platform_dma modm: platform: dma modm_platform_dma_2->modm_platform_dma","title":"modm:platform:dma:2"},{"location":"reference/module/modm-platform-dma-2/#modmplatformdma2-instance-2","text":"","title":"modm:platform:dma:2: Instance 2"},{"location":"reference/module/modm-platform-dma-2/#content","text":"// Class class modm :: platform :: Dma2 :: Stream0 ; class modm :: platform :: Dma2 :: Stream1 ; class modm :: platform :: Dma2 :: Stream2 ; class modm :: platform :: Dma2 :: Stream3 ; class modm :: platform :: Dma2 :: Stream4 ; class modm :: platform :: Dma2 :: Stream5 ; class modm :: platform :: Dma2 :: Stream6 ; class modm :: platform :: Dma2 :: Stream7 ; class modm :: platform :: Dma2 ;","title":"Content"},{"location":"reference/module/modm-platform-dma-2/#dependencies","text":"modm:platform:dma:2 modm_platform_dma_2 modm: platform: dma: 2 modm_platform_dma modm: platform: dma modm_platform_dma_2->modm_platform_dma","title":"Dependencies"},{"location":"reference/module/modm-platform-dma/","text":"These module docs are in beta and may be incomplete. modm:platform:dma: Direct Memory Access (DMA) \u00b6 Content \u00b6 // Class class modm :: platform :: Dma1 :: Stream0 ; class modm :: platform :: Dma1 :: Stream1 ; class modm :: platform :: Dma1 :: Stream2 ; class modm :: platform :: Dma1 :: Stream3 ; class modm :: platform :: Dma1 :: Stream4 ; class modm :: platform :: Dma1 :: Stream5 ; class modm :: platform :: Dma1 :: Stream6 ; class modm :: platform :: Dma1 :: Stream7 ; class modm :: platform :: Dma1 ; class modm :: platform :: Dma2 :: Stream0 ; class modm :: platform :: Dma2 :: Stream1 ; class modm :: platform :: Dma2 :: Stream2 ; class modm :: platform :: Dma2 :: Stream3 ; class modm :: platform :: Dma2 :: Stream4 ; class modm :: platform :: Dma2 :: Stream5 ; class modm :: platform :: Dma2 :: Stream6 ; class modm :: platform :: Dma2 :: Stream7 ; class modm :: platform :: Dma2 ; class modm :: platform :: DmaBase ; Dependencies \u00b6 modm:platform:dma modm_platform_dma modm: platform: dma modm_cmsis_device modm: cmsis: device modm_platform_dma->modm_cmsis_device modm_platform modm: platform modm_platform_dma->modm_platform modm_platform_rcc modm: platform: rcc modm_platform_dma->modm_platform_rcc modm_platform_dma_1 modm: platform: dma: 1 modm_platform_dma_1->modm_platform_dma modm_platform_dma_2 modm: platform: dma: 2 modm_platform_dma_2->modm_platform_dma","title":"modm:platform:dma"},{"location":"reference/module/modm-platform-dma/#modmplatformdma-direct-memory-access-dma","text":"","title":"modm:platform:dma: Direct Memory Access (DMA)"},{"location":"reference/module/modm-platform-dma/#content","text":"// Class class modm :: platform :: Dma1 :: Stream0 ; class modm :: platform :: Dma1 :: Stream1 ; class modm :: platform :: Dma1 :: Stream2 ; class modm :: platform :: Dma1 :: Stream3 ; class modm :: platform :: Dma1 :: Stream4 ; class modm :: platform :: Dma1 :: Stream5 ; class modm :: platform :: Dma1 :: Stream6 ; class modm :: platform :: Dma1 :: Stream7 ; class modm :: platform :: Dma1 ; class modm :: platform :: Dma2 :: Stream0 ; class modm :: platform :: Dma2 :: Stream1 ; class modm :: platform :: Dma2 :: Stream2 ; class modm :: platform :: Dma2 :: Stream3 ; class modm :: platform :: Dma2 :: Stream4 ; class modm :: platform :: Dma2 :: Stream5 ; class modm :: platform :: Dma2 :: Stream6 ; class modm :: platform :: Dma2 :: Stream7 ; class modm :: platform :: Dma2 ; class modm :: platform :: DmaBase ;","title":"Content"},{"location":"reference/module/modm-platform-dma/#dependencies","text":"modm:platform:dma modm_platform_dma modm: platform: dma modm_cmsis_device modm: cmsis: device modm_platform_dma->modm_cmsis_device modm_platform modm: platform modm_platform_dma->modm_platform modm_platform_rcc modm: platform: rcc modm_platform_dma->modm_platform_rcc modm_platform_dma_1 modm: platform: dma: 1 modm_platform_dma_1->modm_platform_dma modm_platform_dma_2 modm: platform: dma: 2 modm_platform_dma_2->modm_platform_dma","title":"Dependencies"},{"location":"reference/module/modm-platform-fault-cortex/","text":"These module docs are in beta and may be incomplete. modm:platform:fault.cortex: ARM Cortex-M Fault Handling \u00b6 Dealing with Fault handlers. Options \u00b6 led \u00b6 Toggle an LED on the specified pin: disabled \u2208 { A0, A1, A10, A11, A12, A13, A14, A15, A2, A3, A4, A5, A6, A7, A8, A9, B0, B1, B10, B11, B12, B13, B14, B15, B2, B3, B4, B5, B6, B7, B8, B9, C0, C1, C10, C11, C12, C13, C14, C15, C2, C3, C4, C5, C6, C7, C8, C9, D0, D1, D10, D11, D12, D13, D14, D15, D2, D3, D4, D5, D6, D7, D8, D9, E0, E1, E10, E11, E12, E13, E14, E15, E2, E3, E4, E5, E6, E7, E8, E9, F0, F1, F10, F11, F12, F13, F14, F15, F2, F3, F4, F5, F6, F7, F8, F9, G0, G1, G10, G11, G12, G13, G14, G15, G2, G3, G4, G5, G6, G7, G8, G9, H0, H1, H10, H11, H12, H13, H14, H15, H2, H3, H4, H5, H6, H7, H8, H9, I0, I1, I10, I11, I12, I13, I14, I15, I2, I3, I4, I5, I6, I7, I8, I9, J0, J1, J12, J13, J14, J15, J2, J3, J4, J5, K3, K4, K5, K6, K7, disabled } Dependencies \u00b6 modm:platform:fault.cortex modm_platform_fault_cortex modm: platform: fault.cortex modm_architecture_clock modm: architecture: clock modm_platform_fault_cortex->modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_fault_cortex->modm_cmsis_device modm_platform modm: platform modm_platform_fault_cortex->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_fault_cortex->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_fault_cortex->modm_platform_rcc","title":"modm:platform:fault.cortex"},{"location":"reference/module/modm-platform-fault-cortex/#modmplatformfaultcortex-arm-cortex-m-fault-handling","text":"Dealing with Fault handlers.","title":"modm:platform:fault.cortex: ARM Cortex-M Fault Handling"},{"location":"reference/module/modm-platform-fault-cortex/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-fault-cortex/#led","text":"Toggle an LED on the specified pin: disabled \u2208 { A0, A1, A10, A11, A12, A13, A14, A15, A2, A3, A4, A5, A6, A7, A8, A9, B0, B1, B10, B11, B12, B13, B14, B15, B2, B3, B4, B5, B6, B7, B8, B9, C0, C1, C10, C11, C12, C13, C14, C15, C2, C3, C4, C5, C6, C7, C8, C9, D0, D1, D10, D11, D12, D13, D14, D15, D2, D3, D4, D5, D6, D7, D8, D9, E0, E1, E10, E11, E12, E13, E14, E15, E2, E3, E4, E5, E6, E7, E8, E9, F0, F1, F10, F11, F12, F13, F14, F15, F2, F3, F4, F5, F6, F7, F8, F9, G0, G1, G10, G11, G12, G13, G14, G15, G2, G3, G4, G5, G6, G7, G8, G9, H0, H1, H10, H11, H12, H13, H14, H15, H2, H3, H4, H5, H6, H7, H8, H9, I0, I1, I10, I11, I12, I13, I14, I15, I2, I3, I4, I5, I6, I7, I8, I9, J0, J1, J12, J13, J14, J15, J2, J3, J4, J5, K3, K4, K5, K6, K7, disabled }","title":"led"},{"location":"reference/module/modm-platform-fault-cortex/#dependencies","text":"modm:platform:fault.cortex modm_platform_fault_cortex modm: platform: fault.cortex modm_architecture_clock modm: architecture: clock modm_platform_fault_cortex->modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_fault_cortex->modm_cmsis_device modm_platform modm: platform modm_platform_fault_cortex->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_fault_cortex->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_fault_cortex->modm_platform_rcc","title":"Dependencies"},{"location":"reference/module/modm-platform-gpio-common/","text":"These module docs are in beta and may be incomplete. modm:platform:gpio.common: GPIO Common \u00b6 Content \u00b6 // Class class modm :: platform :: GpioInverted < class Pin > ; Dependencies \u00b6 modm:platform:gpio.common modm_platform_gpio_common modm: platform: gpio.common modm_architecture_gpio modm: architecture: gpio modm_platform_gpio_common->modm_architecture_gpio modm_platform modm: platform modm_platform_gpio_common->modm_platform modm_utils modm: utils modm_platform_gpio_common->modm_utils modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_platform_gpio_common","title":"modm:platform:gpio.common"},{"location":"reference/module/modm-platform-gpio-common/#modmplatformgpiocommon-gpio-common","text":"","title":"modm:platform:gpio.common: GPIO Common"},{"location":"reference/module/modm-platform-gpio-common/#content","text":"// Class class modm :: platform :: GpioInverted < class Pin > ;","title":"Content"},{"location":"reference/module/modm-platform-gpio-common/#dependencies","text":"modm:platform:gpio.common modm_platform_gpio_common modm: platform: gpio.common modm_architecture_gpio modm: architecture: gpio modm_platform_gpio_common->modm_architecture_gpio modm_platform modm: platform modm_platform_gpio_common->modm_platform modm_utils modm: utils modm_platform_gpio_common->modm_utils modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_platform_gpio_common","title":"Dependencies"},{"location":"reference/module/modm-platform-gpio/","text":"These module docs are in beta and may be incomplete. modm:platform:gpio: General Purpose I/O (GPIO) \u00b6 Options \u00b6 enable_ports \u00b6 Enable clock for these GPIO ports during startup: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] \u2208 { A, B, C, D, E, F, G, H, I, J, K } Content \u00b6 // Class class modm :: platform :: GpioA0 ; class modm :: platform :: GpioA10 ; class modm :: platform :: GpioA11 ; class modm :: platform :: GpioA12 ; class modm :: platform :: GpioA13 ; class modm :: platform :: GpioA14 ; class modm :: platform :: GpioA15 ; class modm :: platform :: GpioA1 ; class modm :: platform :: GpioA2 ; class modm :: platform :: GpioA3 ; class modm :: platform :: GpioA4 ; class modm :: platform :: GpioA5 ; class modm :: platform :: GpioA6 ; class modm :: platform :: GpioA7 ; class modm :: platform :: GpioA8 ; class modm :: platform :: GpioA9 ; class modm :: platform :: GpioB0 ; class modm :: platform :: GpioB10 ; class modm :: platform :: GpioB11 ; class modm :: platform :: GpioB12 ; class modm :: platform :: GpioB13 ; class modm :: platform :: GpioB14 ; class modm :: platform :: GpioB15 ; class modm :: platform :: GpioB1 ; class modm :: platform :: GpioB2 ; class modm :: platform :: GpioB3 ; class modm :: platform :: GpioB4 ; class modm :: platform :: GpioB5 ; class modm :: platform :: GpioB6 ; class modm :: platform :: GpioB7 ; class modm :: platform :: GpioB8 ; class modm :: platform :: GpioB9 ; class modm :: platform :: GpioC0 ; class modm :: platform :: GpioC10 ; class modm :: platform :: GpioC11 ; class modm :: platform :: GpioC12 ; class modm :: platform :: GpioC13 ; class modm :: platform :: GpioC14 ; class modm :: platform :: GpioC15 ; class modm :: platform :: GpioC1 ; class modm :: platform :: GpioC2 ; class modm :: platform :: GpioC3 ; class modm :: platform :: GpioC4 ; class modm :: platform :: GpioC5 ; class modm :: platform :: GpioC6 ; class modm :: platform :: GpioC7 ; class modm :: platform :: GpioC8 ; class modm :: platform :: GpioC9 ; class modm :: platform :: GpioD0 ; class modm :: platform :: GpioD10 ; class modm :: platform :: GpioD11 ; class modm :: platform :: GpioD12 ; class modm :: platform :: GpioD13 ; class modm :: platform :: GpioD14 ; class modm :: platform :: GpioD15 ; class modm :: platform :: GpioD1 ; class modm :: platform :: GpioD2 ; class modm :: platform :: GpioD3 ; class modm :: platform :: GpioD4 ; class modm :: platform :: GpioD5 ; class modm :: platform :: GpioD6 ; class modm :: platform :: GpioD7 ; class modm :: platform :: GpioD8 ; class modm :: platform :: GpioD9 ; class modm :: platform :: GpioE0 ; class modm :: platform :: GpioE10 ; class modm :: platform :: GpioE11 ; class modm :: platform :: GpioE12 ; class modm :: platform :: GpioE13 ; class modm :: platform :: GpioE14 ; class modm :: platform :: GpioE15 ; class modm :: platform :: GpioE1 ; class modm :: platform :: GpioE2 ; class modm :: platform :: GpioE3 ; class modm :: platform :: GpioE4 ; class modm :: platform :: GpioE5 ; class modm :: platform :: GpioE6 ; class modm :: platform :: GpioE7 ; class modm :: platform :: GpioE8 ; class modm :: platform :: GpioE9 ; class modm :: platform :: GpioF0 ; class modm :: platform :: GpioF10 ; class modm :: platform :: GpioF11 ; class modm :: platform :: GpioF12 ; class modm :: platform :: GpioF13 ; class modm :: platform :: GpioF14 ; class modm :: platform :: GpioF15 ; class modm :: platform :: GpioF1 ; class modm :: platform :: GpioF2 ; class modm :: platform :: GpioF3 ; class modm :: platform :: GpioF4 ; class modm :: platform :: GpioF5 ; class modm :: platform :: GpioF6 ; class modm :: platform :: GpioF7 ; class modm :: platform :: GpioF8 ; class modm :: platform :: GpioF9 ; class modm :: platform :: GpioG0 ; class modm :: platform :: GpioG10 ; class modm :: platform :: GpioG11 ; class modm :: platform :: GpioG12 ; class modm :: platform :: GpioG13 ; class modm :: platform :: GpioG14 ; class modm :: platform :: GpioG15 ; class modm :: platform :: GpioG1 ; class modm :: platform :: GpioG2 ; class modm :: platform :: GpioG3 ; class modm :: platform :: GpioG4 ; class modm :: platform :: GpioG5 ; class modm :: platform :: GpioG6 ; class modm :: platform :: GpioG7 ; class modm :: platform :: GpioG8 ; class modm :: platform :: GpioG9 ; class modm :: platform :: GpioH0 ; class modm :: platform :: GpioH10 ; class modm :: platform :: GpioH11 ; class modm :: platform :: GpioH12 ; class modm :: platform :: GpioH13 ; class modm :: platform :: GpioH14 ; class modm :: platform :: GpioH15 ; class modm :: platform :: GpioH1 ; class modm :: platform :: GpioH2 ; class modm :: platform :: GpioH3 ; class modm :: platform :: GpioH4 ; class modm :: platform :: GpioH5 ; class modm :: platform :: GpioH6 ; class modm :: platform :: GpioH7 ; class modm :: platform :: GpioH8 ; class modm :: platform :: GpioH9 ; class modm :: platform :: GpioI0 ; class modm :: platform :: GpioI10 ; class modm :: platform :: GpioI11 ; class modm :: platform :: GpioI12 ; class modm :: platform :: GpioI13 ; class modm :: platform :: GpioI14 ; class modm :: platform :: GpioI15 ; class modm :: platform :: GpioI1 ; class modm :: platform :: GpioI2 ; class modm :: platform :: GpioI3 ; class modm :: platform :: GpioI4 ; class modm :: platform :: GpioI5 ; class modm :: platform :: GpioI6 ; class modm :: platform :: GpioI7 ; class modm :: platform :: GpioI8 ; class modm :: platform :: GpioI9 ; class modm :: platform :: GpioInverted < class Pin > ; class modm :: platform :: GpioJ0 ; class modm :: platform :: GpioJ12 ; class modm :: platform :: GpioJ13 ; class modm :: platform :: GpioJ14 ; class modm :: platform :: GpioJ15 ; class modm :: platform :: GpioJ1 ; class modm :: platform :: GpioJ2 ; class modm :: platform :: GpioJ3 ; class modm :: platform :: GpioJ4 ; class modm :: platform :: GpioJ5 ; class modm :: platform :: GpioK3 ; class modm :: platform :: GpioK4 ; class modm :: platform :: GpioK5 ; class modm :: platform :: GpioK6 ; class modm :: platform :: GpioK7 ; class modm :: platform :: GpioPort < class StartGpio , int8_t Width > ; class modm :: platform :: GpioSet < class ... Gpios > ; class modm :: platform :: GpioUnused ; class modm :: platform :: SoftwareGpioPort < class ... Gpios > ; // Struct struct modm :: platform :: Gpio ; // Enum enum Peripheral ; Dependencies \u00b6 modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio->modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils modm_platform modm: platform modm_platform_gpio->modm_platform modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio->modm_platform_gpio_common modm_platform_rcc modm: platform: rcc modm_platform_gpio->modm_platform_rcc modm_platform_rcc->modm_platform_gpio modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_gpio modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_platform_gpio modm_platform_adc modm: platform: adc modm_platform_adc->modm_platform_gpio modm_platform_can modm: platform: can modm_platform_can->modm_platform_gpio modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_platform_gpio modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_platform_gpio modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_platform_gpio modm_platform_spi modm: platform: spi modm_platform_spi->modm_platform_gpio modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_platform_gpio modm_platform_timer modm: platform: timer modm_platform_timer->modm_platform_gpio modm_platform_uart modm: platform: uart modm_platform_uart->modm_platform_gpio modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_platform_gpio","title":"modm:platform:gpio"},{"location":"reference/module/modm-platform-gpio/#modmplatformgpio-general-purpose-io-gpio","text":"","title":"modm:platform:gpio: General Purpose I/O (GPIO)"},{"location":"reference/module/modm-platform-gpio/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-gpio/#enable_ports","text":"Enable clock for these GPIO ports during startup: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] \u2208 { A, B, C, D, E, F, G, H, I, J, K }","title":"enable_ports"},{"location":"reference/module/modm-platform-gpio/#content","text":"// Class class modm :: platform :: GpioA0 ; class modm :: platform :: GpioA10 ; class modm :: platform :: GpioA11 ; class modm :: platform :: GpioA12 ; class modm :: platform :: GpioA13 ; class modm :: platform :: GpioA14 ; class modm :: platform :: GpioA15 ; class modm :: platform :: GpioA1 ; class modm :: platform :: GpioA2 ; class modm :: platform :: GpioA3 ; class modm :: platform :: GpioA4 ; class modm :: platform :: GpioA5 ; class modm :: platform :: GpioA6 ; class modm :: platform :: GpioA7 ; class modm :: platform :: GpioA8 ; class modm :: platform :: GpioA9 ; class modm :: platform :: GpioB0 ; class modm :: platform :: GpioB10 ; class modm :: platform :: GpioB11 ; class modm :: platform :: GpioB12 ; class modm :: platform :: GpioB13 ; class modm :: platform :: GpioB14 ; class modm :: platform :: GpioB15 ; class modm :: platform :: GpioB1 ; class modm :: platform :: GpioB2 ; class modm :: platform :: GpioB3 ; class modm :: platform :: GpioB4 ; class modm :: platform :: GpioB5 ; class modm :: platform :: GpioB6 ; class modm :: platform :: GpioB7 ; class modm :: platform :: GpioB8 ; class modm :: platform :: GpioB9 ; class modm :: platform :: GpioC0 ; class modm :: platform :: GpioC10 ; class modm :: platform :: GpioC11 ; class modm :: platform :: GpioC12 ; class modm :: platform :: GpioC13 ; class modm :: platform :: GpioC14 ; class modm :: platform :: GpioC15 ; class modm :: platform :: GpioC1 ; class modm :: platform :: GpioC2 ; class modm :: platform :: GpioC3 ; class modm :: platform :: GpioC4 ; class modm :: platform :: GpioC5 ; class modm :: platform :: GpioC6 ; class modm :: platform :: GpioC7 ; class modm :: platform :: GpioC8 ; class modm :: platform :: GpioC9 ; class modm :: platform :: GpioD0 ; class modm :: platform :: GpioD10 ; class modm :: platform :: GpioD11 ; class modm :: platform :: GpioD12 ; class modm :: platform :: GpioD13 ; class modm :: platform :: GpioD14 ; class modm :: platform :: GpioD15 ; class modm :: platform :: GpioD1 ; class modm :: platform :: GpioD2 ; class modm :: platform :: GpioD3 ; class modm :: platform :: GpioD4 ; class modm :: platform :: GpioD5 ; class modm :: platform :: GpioD6 ; class modm :: platform :: GpioD7 ; class modm :: platform :: GpioD8 ; class modm :: platform :: GpioD9 ; class modm :: platform :: GpioE0 ; class modm :: platform :: GpioE10 ; class modm :: platform :: GpioE11 ; class modm :: platform :: GpioE12 ; class modm :: platform :: GpioE13 ; class modm :: platform :: GpioE14 ; class modm :: platform :: GpioE15 ; class modm :: platform :: GpioE1 ; class modm :: platform :: GpioE2 ; class modm :: platform :: GpioE3 ; class modm :: platform :: GpioE4 ; class modm :: platform :: GpioE5 ; class modm :: platform :: GpioE6 ; class modm :: platform :: GpioE7 ; class modm :: platform :: GpioE8 ; class modm :: platform :: GpioE9 ; class modm :: platform :: GpioF0 ; class modm :: platform :: GpioF10 ; class modm :: platform :: GpioF11 ; class modm :: platform :: GpioF12 ; class modm :: platform :: GpioF13 ; class modm :: platform :: GpioF14 ; class modm :: platform :: GpioF15 ; class modm :: platform :: GpioF1 ; class modm :: platform :: GpioF2 ; class modm :: platform :: GpioF3 ; class modm :: platform :: GpioF4 ; class modm :: platform :: GpioF5 ; class modm :: platform :: GpioF6 ; class modm :: platform :: GpioF7 ; class modm :: platform :: GpioF8 ; class modm :: platform :: GpioF9 ; class modm :: platform :: GpioG0 ; class modm :: platform :: GpioG10 ; class modm :: platform :: GpioG11 ; class modm :: platform :: GpioG12 ; class modm :: platform :: GpioG13 ; class modm :: platform :: GpioG14 ; class modm :: platform :: GpioG15 ; class modm :: platform :: GpioG1 ; class modm :: platform :: GpioG2 ; class modm :: platform :: GpioG3 ; class modm :: platform :: GpioG4 ; class modm :: platform :: GpioG5 ; class modm :: platform :: GpioG6 ; class modm :: platform :: GpioG7 ; class modm :: platform :: GpioG8 ; class modm :: platform :: GpioG9 ; class modm :: platform :: GpioH0 ; class modm :: platform :: GpioH10 ; class modm :: platform :: GpioH11 ; class modm :: platform :: GpioH12 ; class modm :: platform :: GpioH13 ; class modm :: platform :: GpioH14 ; class modm :: platform :: GpioH15 ; class modm :: platform :: GpioH1 ; class modm :: platform :: GpioH2 ; class modm :: platform :: GpioH3 ; class modm :: platform :: GpioH4 ; class modm :: platform :: GpioH5 ; class modm :: platform :: GpioH6 ; class modm :: platform :: GpioH7 ; class modm :: platform :: GpioH8 ; class modm :: platform :: GpioH9 ; class modm :: platform :: GpioI0 ; class modm :: platform :: GpioI10 ; class modm :: platform :: GpioI11 ; class modm :: platform :: GpioI12 ; class modm :: platform :: GpioI13 ; class modm :: platform :: GpioI14 ; class modm :: platform :: GpioI15 ; class modm :: platform :: GpioI1 ; class modm :: platform :: GpioI2 ; class modm :: platform :: GpioI3 ; class modm :: platform :: GpioI4 ; class modm :: platform :: GpioI5 ; class modm :: platform :: GpioI6 ; class modm :: platform :: GpioI7 ; class modm :: platform :: GpioI8 ; class modm :: platform :: GpioI9 ; class modm :: platform :: GpioInverted < class Pin > ; class modm :: platform :: GpioJ0 ; class modm :: platform :: GpioJ12 ; class modm :: platform :: GpioJ13 ; class modm :: platform :: GpioJ14 ; class modm :: platform :: GpioJ15 ; class modm :: platform :: GpioJ1 ; class modm :: platform :: GpioJ2 ; class modm :: platform :: GpioJ3 ; class modm :: platform :: GpioJ4 ; class modm :: platform :: GpioJ5 ; class modm :: platform :: GpioK3 ; class modm :: platform :: GpioK4 ; class modm :: platform :: GpioK5 ; class modm :: platform :: GpioK6 ; class modm :: platform :: GpioK7 ; class modm :: platform :: GpioPort < class StartGpio , int8_t Width > ; class modm :: platform :: GpioSet < class ... Gpios > ; class modm :: platform :: GpioUnused ; class modm :: platform :: SoftwareGpioPort < class ... Gpios > ; // Struct struct modm :: platform :: Gpio ; // Enum enum Peripheral ;","title":"Content"},{"location":"reference/module/modm-platform-gpio/#dependencies","text":"modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio->modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils modm_platform modm: platform modm_platform_gpio->modm_platform modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio->modm_platform_gpio_common modm_platform_rcc modm: platform: rcc modm_platform_gpio->modm_platform_rcc modm_platform_rcc->modm_platform_gpio modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_gpio modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_platform_gpio modm_platform_adc modm: platform: adc modm_platform_adc->modm_platform_gpio modm_platform_can modm: platform: can modm_platform_can->modm_platform_gpio modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_platform_gpio modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_platform_gpio modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_platform_gpio modm_platform_spi modm: platform: spi modm_platform_spi->modm_platform_gpio modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_platform_gpio modm_platform_timer modm: platform: timer modm_platform_timer->modm_platform_gpio modm_platform_uart modm: platform: uart modm_platform_uart->modm_platform_gpio modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_platform_gpio","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-1/","text":"These module docs are in beta and may be incomplete. modm:platform:i2c:1: Instance 1 \u00b6 Options \u00b6 buffer.transaction \u00b6 Default: 8 \u2208 { 1 .. 8 .. 65534 } Content \u00b6 // Class class modm :: platform :: I2cMaster1 ; Dependencies \u00b6 modm:platform:i2c:1 modm_platform_i2c_1 modm: platform: i2c: 1 modm_platform_i2c modm: platform: i2c modm_platform_i2c_1->modm_platform_i2c modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_i2c_1","title":"modm:platform:i2c:1"},{"location":"reference/module/modm-platform-i2c-1/#modmplatformi2c1-instance-1","text":"","title":"modm:platform:i2c:1: Instance 1"},{"location":"reference/module/modm-platform-i2c-1/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-i2c-1/#buffertransaction","text":"Default: 8 \u2208 { 1 .. 8 .. 65534 }","title":"buffer.transaction"},{"location":"reference/module/modm-platform-i2c-1/#content","text":"// Class class modm :: platform :: I2cMaster1 ;","title":"Content"},{"location":"reference/module/modm-platform-i2c-1/#dependencies","text":"modm:platform:i2c:1 modm_platform_i2c_1 modm: platform: i2c: 1 modm_platform_i2c modm: platform: i2c modm_platform_i2c_1->modm_platform_i2c modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_i2c_1","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-2/","text":"These module docs are in beta and may be incomplete. modm:platform:i2c:2: Instance 2 \u00b6 Options \u00b6 buffer.transaction \u00b6 Default: 8 \u2208 { 1 .. 8 .. 65534 } Content \u00b6 // Class class modm :: platform :: I2cMaster2 ; Dependencies \u00b6 modm:platform:i2c:2 modm_platform_i2c_2 modm: platform: i2c: 2 modm_platform_i2c modm: platform: i2c modm_platform_i2c_2->modm_platform_i2c","title":"modm:platform:i2c:2"},{"location":"reference/module/modm-platform-i2c-2/#modmplatformi2c2-instance-2","text":"","title":"modm:platform:i2c:2: Instance 2"},{"location":"reference/module/modm-platform-i2c-2/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-i2c-2/#buffertransaction","text":"Default: 8 \u2208 { 1 .. 8 .. 65534 }","title":"buffer.transaction"},{"location":"reference/module/modm-platform-i2c-2/#content","text":"// Class class modm :: platform :: I2cMaster2 ;","title":"Content"},{"location":"reference/module/modm-platform-i2c-2/#dependencies","text":"modm:platform:i2c:2 modm_platform_i2c_2 modm: platform: i2c: 2 modm_platform_i2c modm: platform: i2c modm_platform_i2c_2->modm_platform_i2c","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-3/","text":"These module docs are in beta and may be incomplete. modm:platform:i2c:3: Instance 3 \u00b6 Options \u00b6 buffer.transaction \u00b6 Default: 8 \u2208 { 1 .. 8 .. 65534 } Content \u00b6 // Class class modm :: platform :: I2cMaster3 ; Dependencies \u00b6 modm:platform:i2c:3 modm_platform_i2c_3 modm: platform: i2c: 3 modm_platform_i2c modm: platform: i2c modm_platform_i2c_3->modm_platform_i2c","title":"modm:platform:i2c:3"},{"location":"reference/module/modm-platform-i2c-3/#modmplatformi2c3-instance-3","text":"","title":"modm:platform:i2c:3: Instance 3"},{"location":"reference/module/modm-platform-i2c-3/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-i2c-3/#buffertransaction","text":"Default: 8 \u2208 { 1 .. 8 .. 65534 }","title":"buffer.transaction"},{"location":"reference/module/modm-platform-i2c-3/#content","text":"// Class class modm :: platform :: I2cMaster3 ;","title":"Content"},{"location":"reference/module/modm-platform-i2c-3/#dependencies","text":"modm:platform:i2c:3 modm_platform_i2c_3 modm: platform: i2c: 3 modm_platform_i2c modm: platform: i2c modm_platform_i2c_3->modm_platform_i2c","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-bitbang/","text":"These module docs are in beta and may be incomplete. modm:platform:i2c.bitbang: Software Inter-Integrated Circuit (I\u00b2C) \u00b6 Content \u00b6 // Class class modm :: platform :: BitBangI2cMaster < class Scl , class Sda > ; Dependencies \u00b6 modm:platform:i2c.bitbang modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_architecture_delay modm: architecture: delay modm_platform_i2c_bitbang->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_platform_i2c_bitbang->modm_architecture_gpio modm_architecture_i2c modm: architecture: i2c modm_platform_i2c_bitbang->modm_architecture_i2c modm_platform modm: platform modm_platform_i2c_bitbang->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_i2c_bitbang->modm_platform_gpio","title":"modm:platform:i2c.bitbang"},{"location":"reference/module/modm-platform-i2c-bitbang/#modmplatformi2cbitbang-software-inter-integrated-circuit-i2c","text":"","title":"modm:platform:i2c.bitbang: Software Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-platform-i2c-bitbang/#content","text":"// Class class modm :: platform :: BitBangI2cMaster < class Scl , class Sda > ;","title":"Content"},{"location":"reference/module/modm-platform-i2c-bitbang/#dependencies","text":"modm:platform:i2c.bitbang modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_architecture_delay modm: architecture: delay modm_platform_i2c_bitbang->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_platform_i2c_bitbang->modm_architecture_gpio modm_architecture_i2c modm: architecture: i2c modm_platform_i2c_bitbang->modm_architecture_i2c modm_platform modm: platform modm_platform_i2c_bitbang->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_i2c_bitbang->modm_platform_gpio","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c/","text":"These module docs are in beta and may be incomplete. modm:platform:i2c: Inter-Integrated Circuit (I\u00b2C) \u00b6 Content \u00b6 // Class class modm :: platform :: BitBangI2cMaster < class Scl , class Sda > ; class modm :: platform :: I2cMaster1 ; class modm :: platform :: I2cMaster2 ; class modm :: platform :: I2cMaster3 ; Dependencies \u00b6 modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c->modm_architecture_atomic modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c->modm_cmsis_device modm_container modm: container modm_platform_i2c->modm_container modm_platform modm: platform modm_platform_i2c->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_platform_i2c_1->modm_platform_i2c modm_platform_i2c_2 modm: platform: i2c: 2 modm_platform_i2c_2->modm_platform_i2c modm_platform_i2c_3 modm: platform: i2c: 3 modm_platform_i2c_3->modm_platform_i2c","title":"modm:platform:i2c"},{"location":"reference/module/modm-platform-i2c/#modmplatformi2c-inter-integrated-circuit-i2c","text":"","title":"modm:platform:i2c: Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-platform-i2c/#content","text":"// Class class modm :: platform :: BitBangI2cMaster < class Scl , class Sda > ; class modm :: platform :: I2cMaster1 ; class modm :: platform :: I2cMaster2 ; class modm :: platform :: I2cMaster3 ;","title":"Content"},{"location":"reference/module/modm-platform-i2c/#dependencies","text":"modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c->modm_architecture_atomic modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c->modm_cmsis_device modm_container modm: container modm_platform_i2c->modm_container modm_platform modm: platform modm_platform_i2c->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_platform_i2c_1->modm_platform_i2c modm_platform_i2c_2 modm: platform: i2c: 2 modm_platform_i2c_2->modm_platform_i2c modm_platform_i2c_3 modm: platform: i2c: 3 modm_platform_i2c_3->modm_platform_i2c","title":"Dependencies"},{"location":"reference/module/modm-platform-id/","text":"These module docs are in beta and may be incomplete. modm:platform:id: Unique ID \u00b6 Content \u00b6 // Function static uint32_t modm :: platform :: getUniqueId ( uint8_t offset ); Dependencies \u00b6 modm:platform:id modm_platform_id modm: platform: id modm_platform modm: platform modm_platform_id->modm_platform","title":"modm:platform:id"},{"location":"reference/module/modm-platform-id/#modmplatformid-unique-id","text":"","title":"modm:platform:id: Unique ID"},{"location":"reference/module/modm-platform-id/#content","text":"// Function static uint32_t modm :: platform :: getUniqueId ( uint8_t offset );","title":"Content"},{"location":"reference/module/modm-platform-id/#dependencies","text":"modm:platform:id modm_platform_id modm: platform: id modm_platform modm: platform modm_platform_id->modm_platform","title":"Dependencies"},{"location":"reference/module/modm-platform-random/","text":"These module docs are in beta and may be incomplete. modm:platform:random: Random Number Generator (RNG) \u00b6 Content \u00b6 // Class class modm :: platform :: RandomNumberGenerator ; Dependencies \u00b6 modm:platform:random modm_platform_random modm: platform: random modm_cmsis_device modm: cmsis: device modm_platform_random->modm_cmsis_device modm_platform modm: platform modm_platform_random->modm_platform modm_platform_rcc modm: platform: rcc modm_platform_random->modm_platform_rcc","title":"modm:platform:random"},{"location":"reference/module/modm-platform-random/#modmplatformrandom-random-number-generator-rng","text":"","title":"modm:platform:random: Random Number Generator (RNG)"},{"location":"reference/module/modm-platform-random/#content","text":"// Class class modm :: platform :: RandomNumberGenerator ;","title":"Content"},{"location":"reference/module/modm-platform-random/#dependencies","text":"modm:platform:random modm_platform_random modm: platform: random modm_cmsis_device modm: cmsis: device modm_platform_random->modm_cmsis_device modm_platform modm: platform modm_platform_random->modm_platform modm_platform_rcc modm: platform: rcc modm_platform_random->modm_platform_rcc","title":"Dependencies"},{"location":"reference/module/modm-platform-rcc/","text":"These module docs are in beta and may be incomplete. modm:platform:rcc: Reset and Clock Control (RCC) \u00b6 Content \u00b6 // Class class modm :: platform :: Rcc ; // Struct struct modm :: platform :: Rcc :: flash_latency ; // Typedef using modm :: platform :: instead = typedef Rcc ; Dependencies \u00b6 modm:platform:rcc modm_platform_rcc modm: platform: rcc modm_cmsis_device modm: cmsis: device modm_platform_rcc->modm_cmsis_device modm_platform modm: platform modm_platform_rcc->modm_platform modm_platform_clock modm: platform: clock modm_platform_rcc->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_rcc->modm_platform_gpio modm_utils modm: utils modm_platform_rcc->modm_utils modm_platform_gpio->modm_platform_rcc modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_rcc modm_platform_adc modm: platform: adc modm_platform_adc->modm_platform_rcc modm_platform_can modm: platform: can modm_platform_can->modm_platform_rcc modm_platform_dma modm: platform: dma modm_platform_dma->modm_platform_rcc modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_platform_rcc modm_platform_random modm: platform: random modm_platform_random->modm_platform_rcc modm_platform_spi modm: platform: spi modm_platform_spi->modm_platform_rcc modm_platform_timer modm: platform: timer modm_platform_timer->modm_platform_rcc modm_platform_uart modm: platform: uart modm_platform_uart->modm_platform_rcc","title":"modm:platform:rcc"},{"location":"reference/module/modm-platform-rcc/#modmplatformrcc-reset-and-clock-control-rcc","text":"","title":"modm:platform:rcc: Reset and Clock Control (RCC)"},{"location":"reference/module/modm-platform-rcc/#content","text":"// Class class modm :: platform :: Rcc ; // Struct struct modm :: platform :: Rcc :: flash_latency ; // Typedef using modm :: platform :: instead = typedef Rcc ;","title":"Content"},{"location":"reference/module/modm-platform-rcc/#dependencies","text":"modm:platform:rcc modm_platform_rcc modm: platform: rcc modm_cmsis_device modm: cmsis: device modm_platform_rcc->modm_cmsis_device modm_platform modm: platform modm_platform_rcc->modm_platform modm_platform_clock modm: platform: clock modm_platform_rcc->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_rcc->modm_platform_gpio modm_utils modm: utils modm_platform_rcc->modm_utils modm_platform_gpio->modm_platform_rcc modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_rcc modm_platform_adc modm: platform: adc modm_platform_adc->modm_platform_rcc modm_platform_can modm: platform: can modm_platform_can->modm_platform_rcc modm_platform_dma modm: platform: dma modm_platform_dma->modm_platform_rcc modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_platform_rcc modm_platform_random modm: platform: random modm_platform_random->modm_platform_rcc modm_platform_spi modm: platform: spi modm_platform_spi->modm_platform_rcc modm_platform_timer modm: platform: timer modm_platform_timer->modm_platform_rcc modm_platform_uart modm: platform: uart modm_platform_uart->modm_platform_rcc","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-1/","text":"These module docs are in beta and may be incomplete. modm:platform:spi:1: Instance 1 \u00b6 Content \u00b6 // Class class modm :: platform :: SpiHal1 ; class modm :: platform :: SpiMaster1 ; Dependencies \u00b6 modm:platform:spi:1 modm_platform_spi_1 modm: platform: spi: 1 modm_platform_spi modm: platform: spi modm_platform_spi_1->modm_platform_spi","title":"modm:platform:spi:1"},{"location":"reference/module/modm-platform-spi-1/#modmplatformspi1-instance-1","text":"","title":"modm:platform:spi:1: Instance 1"},{"location":"reference/module/modm-platform-spi-1/#content","text":"// Class class modm :: platform :: SpiHal1 ; class modm :: platform :: SpiMaster1 ;","title":"Content"},{"location":"reference/module/modm-platform-spi-1/#dependencies","text":"modm:platform:spi:1 modm_platform_spi_1 modm: platform: spi: 1 modm_platform_spi modm: platform: spi modm_platform_spi_1->modm_platform_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-2/","text":"These module docs are in beta and may be incomplete. modm:platform:spi:2: Instance 2 \u00b6 Content \u00b6 // Class class modm :: platform :: SpiHal2 ; class modm :: platform :: SpiMaster2 ; Dependencies \u00b6 modm:platform:spi:2 modm_platform_spi_2 modm: platform: spi: 2 modm_platform_spi modm: platform: spi modm_platform_spi_2->modm_platform_spi","title":"modm:platform:spi:2"},{"location":"reference/module/modm-platform-spi-2/#modmplatformspi2-instance-2","text":"","title":"modm:platform:spi:2: Instance 2"},{"location":"reference/module/modm-platform-spi-2/#content","text":"// Class class modm :: platform :: SpiHal2 ; class modm :: platform :: SpiMaster2 ;","title":"Content"},{"location":"reference/module/modm-platform-spi-2/#dependencies","text":"modm:platform:spi:2 modm_platform_spi_2 modm: platform: spi: 2 modm_platform_spi modm: platform: spi modm_platform_spi_2->modm_platform_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-3/","text":"These module docs are in beta and may be incomplete. modm:platform:spi:3: Instance 3 \u00b6 Content \u00b6 // Class class modm :: platform :: SpiHal3 ; class modm :: platform :: SpiMaster3 ; Dependencies \u00b6 modm:platform:spi:3 modm_platform_spi_3 modm: platform: spi: 3 modm_platform_spi modm: platform: spi modm_platform_spi_3->modm_platform_spi","title":"modm:platform:spi:3"},{"location":"reference/module/modm-platform-spi-3/#modmplatformspi3-instance-3","text":"","title":"modm:platform:spi:3: Instance 3"},{"location":"reference/module/modm-platform-spi-3/#content","text":"// Class class modm :: platform :: SpiHal3 ; class modm :: platform :: SpiMaster3 ;","title":"Content"},{"location":"reference/module/modm-platform-spi-3/#dependencies","text":"modm:platform:spi:3 modm_platform_spi_3 modm: platform: spi: 3 modm_platform_spi modm: platform: spi modm_platform_spi_3->modm_platform_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-4/","text":"These module docs are in beta and may be incomplete. modm:platform:spi:4: Instance 4 \u00b6 Content \u00b6 // Class class modm :: platform :: SpiHal4 ; class modm :: platform :: SpiMaster4 ; Dependencies \u00b6 modm:platform:spi:4 modm_platform_spi_4 modm: platform: spi: 4 modm_platform_spi modm: platform: spi modm_platform_spi_4->modm_platform_spi","title":"modm:platform:spi:4"},{"location":"reference/module/modm-platform-spi-4/#modmplatformspi4-instance-4","text":"","title":"modm:platform:spi:4: Instance 4"},{"location":"reference/module/modm-platform-spi-4/#content","text":"// Class class modm :: platform :: SpiHal4 ; class modm :: platform :: SpiMaster4 ;","title":"Content"},{"location":"reference/module/modm-platform-spi-4/#dependencies","text":"modm:platform:spi:4 modm_platform_spi_4 modm: platform: spi: 4 modm_platform_spi modm: platform: spi modm_platform_spi_4->modm_platform_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-5/","text":"These module docs are in beta and may be incomplete. modm:platform:spi:5: Instance 5 \u00b6 Content \u00b6 // Class class modm :: platform :: SpiHal5 ; class modm :: platform :: SpiMaster5 ; Dependencies \u00b6 modm:platform:spi:5 modm_platform_spi_5 modm: platform: spi: 5 modm_platform_spi modm: platform: spi modm_platform_spi_5->modm_platform_spi","title":"modm:platform:spi:5"},{"location":"reference/module/modm-platform-spi-5/#modmplatformspi5-instance-5","text":"","title":"modm:platform:spi:5: Instance 5"},{"location":"reference/module/modm-platform-spi-5/#content","text":"// Class class modm :: platform :: SpiHal5 ; class modm :: platform :: SpiMaster5 ;","title":"Content"},{"location":"reference/module/modm-platform-spi-5/#dependencies","text":"modm:platform:spi:5 modm_platform_spi_5 modm: platform: spi: 5 modm_platform_spi modm: platform: spi modm_platform_spi_5->modm_platform_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-6/","text":"These module docs are in beta and may be incomplete. modm:platform:spi:6: Instance 6 \u00b6 Content \u00b6 // Class class modm :: platform :: SpiHal6 ; class modm :: platform :: SpiMaster6 ; Dependencies \u00b6 modm:platform:spi:6 modm_platform_spi_6 modm: platform: spi: 6 modm_platform_spi modm: platform: spi modm_platform_spi_6->modm_platform_spi","title":"modm:platform:spi:6"},{"location":"reference/module/modm-platform-spi-6/#modmplatformspi6-instance-6","text":"","title":"modm:platform:spi:6: Instance 6"},{"location":"reference/module/modm-platform-spi-6/#content","text":"// Class class modm :: platform :: SpiHal6 ; class modm :: platform :: SpiMaster6 ;","title":"Content"},{"location":"reference/module/modm-platform-spi-6/#dependencies","text":"modm:platform:spi:6 modm_platform_spi_6 modm: platform: spi: 6 modm_platform_spi modm: platform: spi modm_platform_spi_6->modm_platform_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-bitbang/","text":"These module docs are in beta and may be incomplete. modm:platform:spi.bitbang: Software Serial Peripheral Interface (SPI) \u00b6 Content \u00b6 // Class class modm :: platform :: BitBangSpiMaster < typename Sck , typename Mosi , typename Miso = GpioUnused > ; Dependencies \u00b6 modm:platform:spi.bitbang modm_platform_spi_bitbang modm: platform: spi.bitbang modm_architecture_delay modm: architecture: delay modm_platform_spi_bitbang->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_platform_spi_bitbang->modm_architecture_spi modm_platform modm: platform modm_platform_spi_bitbang->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_spi_bitbang->modm_platform_gpio","title":"modm:platform:spi.bitbang"},{"location":"reference/module/modm-platform-spi-bitbang/#modmplatformspibitbang-software-serial-peripheral-interface-spi","text":"","title":"modm:platform:spi.bitbang: Software Serial Peripheral Interface (SPI)"},{"location":"reference/module/modm-platform-spi-bitbang/#content","text":"// Class class modm :: platform :: BitBangSpiMaster < typename Sck , typename Mosi , typename Miso = GpioUnused > ;","title":"Content"},{"location":"reference/module/modm-platform-spi-bitbang/#dependencies","text":"modm:platform:spi.bitbang modm_platform_spi_bitbang modm: platform: spi.bitbang modm_architecture_delay modm: architecture: delay modm_platform_spi_bitbang->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_platform_spi_bitbang->modm_architecture_spi modm_platform modm: platform modm_platform_spi_bitbang->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_spi_bitbang->modm_platform_gpio","title":"Dependencies"},{"location":"reference/module/modm-platform-spi/","text":"These module docs are in beta and may be incomplete. modm:platform:spi: Serial Peripheral Interface (SPI) \u00b6 Content \u00b6 // Class class modm :: platform :: BitBangSpiMaster < typename Sck , typename Mosi , typename Miso = GpioUnused > ; class modm :: platform :: SpiBase ; class modm :: platform :: SpiHal1 ; class modm :: platform :: SpiHal2 ; class modm :: platform :: SpiHal3 ; class modm :: platform :: SpiHal4 ; class modm :: platform :: SpiHal5 ; class modm :: platform :: SpiHal6 ; class modm :: platform :: SpiMaster1 ; class modm :: platform :: SpiMaster2 ; class modm :: platform :: SpiMaster3 ; class modm :: platform :: SpiMaster4 ; class modm :: platform :: SpiMaster5 ; class modm :: platform :: SpiMaster6 ; Dependencies \u00b6 modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_register modm: architecture: register modm_platform_spi->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi->modm_cmsis_device modm_platform modm: platform modm_platform_spi->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_spi->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_spi->modm_platform_rcc modm_platform_spi_1 modm: platform: spi: 1 modm_platform_spi_1->modm_platform_spi modm_platform_spi_2 modm: platform: spi: 2 modm_platform_spi_2->modm_platform_spi modm_platform_spi_3 modm: platform: spi: 3 modm_platform_spi_3->modm_platform_spi modm_platform_spi_4 modm: platform: spi: 4 modm_platform_spi_4->modm_platform_spi modm_platform_spi_5 modm: platform: spi: 5 modm_platform_spi_5->modm_platform_spi modm_platform_spi_6 modm: platform: spi: 6 modm_platform_spi_6->modm_platform_spi","title":"modm:platform:spi"},{"location":"reference/module/modm-platform-spi/#modmplatformspi-serial-peripheral-interface-spi","text":"","title":"modm:platform:spi: Serial Peripheral Interface (SPI)"},{"location":"reference/module/modm-platform-spi/#content","text":"// Class class modm :: platform :: BitBangSpiMaster < typename Sck , typename Mosi , typename Miso = GpioUnused > ; class modm :: platform :: SpiBase ; class modm :: platform :: SpiHal1 ; class modm :: platform :: SpiHal2 ; class modm :: platform :: SpiHal3 ; class modm :: platform :: SpiHal4 ; class modm :: platform :: SpiHal5 ; class modm :: platform :: SpiHal6 ; class modm :: platform :: SpiMaster1 ; class modm :: platform :: SpiMaster2 ; class modm :: platform :: SpiMaster3 ; class modm :: platform :: SpiMaster4 ; class modm :: platform :: SpiMaster5 ; class modm :: platform :: SpiMaster6 ;","title":"Content"},{"location":"reference/module/modm-platform-spi/#dependencies","text":"modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_register modm: architecture: register modm_platform_spi->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi->modm_cmsis_device modm_platform modm: platform modm_platform_spi->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_spi->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_spi->modm_platform_rcc modm_platform_spi_1 modm: platform: spi: 1 modm_platform_spi_1->modm_platform_spi modm_platform_spi_2 modm: platform: spi: 2 modm_platform_spi_2->modm_platform_spi modm_platform_spi_3 modm: platform: spi: 3 modm_platform_spi_3->modm_platform_spi modm_platform_spi_4 modm: platform: spi: 4 modm_platform_spi_4->modm_platform_spi modm_platform_spi_5 modm: platform: spi: 5 modm_platform_spi_5->modm_platform_spi modm_platform_spi_6 modm: platform: spi: 6 modm_platform_spi_6->modm_platform_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-systick/","text":"These module docs are in beta and may be incomplete. modm:platform:systick: ARM Cortex-M SysTick \u00b6 Content \u00b6 // Class class modm :: platform :: SysTickTimer ; // Typedef typedef void ( * modm :: platform :: InterruptHandler ) ( void ))( void ); using modm :: cortex :: instead = typedef :: modm :: platform :: SysTickTimer ; Dependencies \u00b6 modm:platform:systick modm_platform_systick modm: platform: systick modm_architecture_clock modm: architecture: clock modm_platform_systick->modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_systick->modm_cmsis_device modm_platform modm: platform modm_platform_systick->modm_platform modm_platform_core modm: platform: core modm_platform_core->modm_platform_systick","title":"modm:platform:systick"},{"location":"reference/module/modm-platform-systick/#modmplatformsystick-arm-cortex-m-systick","text":"","title":"modm:platform:systick: ARM Cortex-M SysTick"},{"location":"reference/module/modm-platform-systick/#content","text":"// Class class modm :: platform :: SysTickTimer ; // Typedef typedef void ( * modm :: platform :: InterruptHandler ) ( void ))( void ); using modm :: cortex :: instead = typedef :: modm :: platform :: SysTickTimer ;","title":"Content"},{"location":"reference/module/modm-platform-systick/#dependencies","text":"modm:platform:systick modm_platform_systick modm: platform: systick modm_architecture_clock modm: architecture: clock modm_platform_systick->modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_systick->modm_cmsis_device modm_platform modm: platform modm_platform_systick->modm_platform modm_platform_core modm: platform: core modm_platform_core->modm_platform_systick","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-1/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:1: Instance 1 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer10 ; class modm :: platform :: Timer11 ; class modm :: platform :: Timer12 ; class modm :: platform :: Timer13 ; class modm :: platform :: Timer14 ; class modm :: platform :: Timer1 ; Dependencies \u00b6 modm:platform:timer:1 modm_platform_timer_1 modm: platform: timer: 1 modm_platform_timer modm: platform: timer modm_platform_timer_1->modm_platform_timer","title":"modm:platform:timer:1"},{"location":"reference/module/modm-platform-timer-1/#modmplatformtimer1-instance-1","text":"","title":"modm:platform:timer:1: Instance 1"},{"location":"reference/module/modm-platform-timer-1/#content","text":"// Class class modm :: platform :: Timer10 ; class modm :: platform :: Timer11 ; class modm :: platform :: Timer12 ; class modm :: platform :: Timer13 ; class modm :: platform :: Timer14 ; class modm :: platform :: Timer1 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-1/#dependencies","text":"modm:platform:timer:1 modm_platform_timer_1 modm: platform: timer: 1 modm_platform_timer modm: platform: timer modm_platform_timer_1->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-10/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:10: Instance 10 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer10 ; Dependencies \u00b6 modm:platform:timer:10 modm_platform_timer_10 modm: platform: timer: 10 modm_platform_timer modm: platform: timer modm_platform_timer_10->modm_platform_timer","title":"modm:platform:timer:10"},{"location":"reference/module/modm-platform-timer-10/#modmplatformtimer10-instance-10","text":"","title":"modm:platform:timer:10: Instance 10"},{"location":"reference/module/modm-platform-timer-10/#content","text":"// Class class modm :: platform :: Timer10 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-10/#dependencies","text":"modm:platform:timer:10 modm_platform_timer_10 modm: platform: timer: 10 modm_platform_timer modm: platform: timer modm_platform_timer_10->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-11/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:11: Instance 11 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer11 ; Dependencies \u00b6 modm:platform:timer:11 modm_platform_timer_11 modm: platform: timer: 11 modm_platform_timer modm: platform: timer modm_platform_timer_11->modm_platform_timer","title":"modm:platform:timer:11"},{"location":"reference/module/modm-platform-timer-11/#modmplatformtimer11-instance-11","text":"","title":"modm:platform:timer:11: Instance 11"},{"location":"reference/module/modm-platform-timer-11/#content","text":"// Class class modm :: platform :: Timer11 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-11/#dependencies","text":"modm:platform:timer:11 modm_platform_timer_11 modm: platform: timer: 11 modm_platform_timer modm: platform: timer modm_platform_timer_11->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-12/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:12: Instance 12 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer12 ; Dependencies \u00b6 modm:platform:timer:12 modm_platform_timer_12 modm: platform: timer: 12 modm_platform_timer modm: platform: timer modm_platform_timer_12->modm_platform_timer","title":"modm:platform:timer:12"},{"location":"reference/module/modm-platform-timer-12/#modmplatformtimer12-instance-12","text":"","title":"modm:platform:timer:12: Instance 12"},{"location":"reference/module/modm-platform-timer-12/#content","text":"// Class class modm :: platform :: Timer12 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-12/#dependencies","text":"modm:platform:timer:12 modm_platform_timer_12 modm: platform: timer: 12 modm_platform_timer modm: platform: timer modm_platform_timer_12->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-13/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:13: Instance 13 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer13 ; Dependencies \u00b6 modm:platform:timer:13 modm_platform_timer_13 modm: platform: timer: 13 modm_platform_timer modm: platform: timer modm_platform_timer_13->modm_platform_timer","title":"modm:platform:timer:13"},{"location":"reference/module/modm-platform-timer-13/#modmplatformtimer13-instance-13","text":"","title":"modm:platform:timer:13: Instance 13"},{"location":"reference/module/modm-platform-timer-13/#content","text":"// Class class modm :: platform :: Timer13 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-13/#dependencies","text":"modm:platform:timer:13 modm_platform_timer_13 modm: platform: timer: 13 modm_platform_timer modm: platform: timer modm_platform_timer_13->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-14/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:14: Instance 14 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer14 ; Dependencies \u00b6 modm:platform:timer:14 modm_platform_timer_14 modm: platform: timer: 14 modm_platform_timer modm: platform: timer modm_platform_timer_14->modm_platform_timer","title":"modm:platform:timer:14"},{"location":"reference/module/modm-platform-timer-14/#modmplatformtimer14-instance-14","text":"","title":"modm:platform:timer:14: Instance 14"},{"location":"reference/module/modm-platform-timer-14/#content","text":"// Class class modm :: platform :: Timer14 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-14/#dependencies","text":"modm:platform:timer:14 modm_platform_timer_14 modm: platform: timer: 14 modm_platform_timer modm: platform: timer modm_platform_timer_14->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-2/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:2: Instance 2 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer2 ; Dependencies \u00b6 modm:platform:timer:2 modm_platform_timer_2 modm: platform: timer: 2 modm_platform_timer modm: platform: timer modm_platform_timer_2->modm_platform_timer","title":"modm:platform:timer:2"},{"location":"reference/module/modm-platform-timer-2/#modmplatformtimer2-instance-2","text":"","title":"modm:platform:timer:2: Instance 2"},{"location":"reference/module/modm-platform-timer-2/#content","text":"// Class class modm :: platform :: Timer2 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-2/#dependencies","text":"modm:platform:timer:2 modm_platform_timer_2 modm: platform: timer: 2 modm_platform_timer modm: platform: timer modm_platform_timer_2->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-3/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:3: Instance 3 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer3 ; Dependencies \u00b6 modm:platform:timer:3 modm_platform_timer_3 modm: platform: timer: 3 modm_platform_timer modm: platform: timer modm_platform_timer_3->modm_platform_timer","title":"modm:platform:timer:3"},{"location":"reference/module/modm-platform-timer-3/#modmplatformtimer3-instance-3","text":"","title":"modm:platform:timer:3: Instance 3"},{"location":"reference/module/modm-platform-timer-3/#content","text":"// Class class modm :: platform :: Timer3 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-3/#dependencies","text":"modm:platform:timer:3 modm_platform_timer_3 modm: platform: timer: 3 modm_platform_timer modm: platform: timer modm_platform_timer_3->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-4/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:4: Instance 4 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer4 ; Dependencies \u00b6 modm:platform:timer:4 modm_platform_timer_4 modm: platform: timer: 4 modm_platform_timer modm: platform: timer modm_platform_timer_4->modm_platform_timer","title":"modm:platform:timer:4"},{"location":"reference/module/modm-platform-timer-4/#modmplatformtimer4-instance-4","text":"","title":"modm:platform:timer:4: Instance 4"},{"location":"reference/module/modm-platform-timer-4/#content","text":"// Class class modm :: platform :: Timer4 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-4/#dependencies","text":"modm:platform:timer:4 modm_platform_timer_4 modm: platform: timer: 4 modm_platform_timer modm: platform: timer modm_platform_timer_4->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-5/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:5: Instance 5 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer5 ; Dependencies \u00b6 modm:platform:timer:5 modm_platform_timer_5 modm: platform: timer: 5 modm_platform_timer modm: platform: timer modm_platform_timer_5->modm_platform_timer","title":"modm:platform:timer:5"},{"location":"reference/module/modm-platform-timer-5/#modmplatformtimer5-instance-5","text":"","title":"modm:platform:timer:5: Instance 5"},{"location":"reference/module/modm-platform-timer-5/#content","text":"// Class class modm :: platform :: Timer5 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-5/#dependencies","text":"modm:platform:timer:5 modm_platform_timer_5 modm: platform: timer: 5 modm_platform_timer modm: platform: timer modm_platform_timer_5->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-6/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:6: Instance 6 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer6 ; Dependencies \u00b6 modm:platform:timer:6 modm_platform_timer_6 modm: platform: timer: 6 modm_platform_timer modm: platform: timer modm_platform_timer_6->modm_platform_timer","title":"modm:platform:timer:6"},{"location":"reference/module/modm-platform-timer-6/#modmplatformtimer6-instance-6","text":"","title":"modm:platform:timer:6: Instance 6"},{"location":"reference/module/modm-platform-timer-6/#content","text":"// Class class modm :: platform :: Timer6 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-6/#dependencies","text":"modm:platform:timer:6 modm_platform_timer_6 modm: platform: timer: 6 modm_platform_timer modm: platform: timer modm_platform_timer_6->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-7/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:7: Instance 7 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer7 ; Dependencies \u00b6 modm:platform:timer:7 modm_platform_timer_7 modm: platform: timer: 7 modm_platform_timer modm: platform: timer modm_platform_timer_7->modm_platform_timer","title":"modm:platform:timer:7"},{"location":"reference/module/modm-platform-timer-7/#modmplatformtimer7-instance-7","text":"","title":"modm:platform:timer:7: Instance 7"},{"location":"reference/module/modm-platform-timer-7/#content","text":"// Class class modm :: platform :: Timer7 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-7/#dependencies","text":"modm:platform:timer:7 modm_platform_timer_7 modm: platform: timer: 7 modm_platform_timer modm: platform: timer modm_platform_timer_7->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-8/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:8: Instance 8 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer8 ; Dependencies \u00b6 modm:platform:timer:8 modm_platform_timer_8 modm: platform: timer: 8 modm_platform_timer modm: platform: timer modm_platform_timer_8->modm_platform_timer","title":"modm:platform:timer:8"},{"location":"reference/module/modm-platform-timer-8/#modmplatformtimer8-instance-8","text":"","title":"modm:platform:timer:8: Instance 8"},{"location":"reference/module/modm-platform-timer-8/#content","text":"// Class class modm :: platform :: Timer8 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-8/#dependencies","text":"modm:platform:timer:8 modm_platform_timer_8 modm: platform: timer: 8 modm_platform_timer modm: platform: timer modm_platform_timer_8->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer-9/","text":"These module docs are in beta and may be incomplete. modm:platform:timer:9: Instance 9 \u00b6 Content \u00b6 // Class class modm :: platform :: Timer9 ; Dependencies \u00b6 modm:platform:timer:9 modm_platform_timer_9 modm: platform: timer: 9 modm_platform_timer modm: platform: timer modm_platform_timer_9->modm_platform_timer","title":"modm:platform:timer:9"},{"location":"reference/module/modm-platform-timer-9/#modmplatformtimer9-instance-9","text":"","title":"modm:platform:timer:9: Instance 9"},{"location":"reference/module/modm-platform-timer-9/#content","text":"// Class class modm :: platform :: Timer9 ;","title":"Content"},{"location":"reference/module/modm-platform-timer-9/#dependencies","text":"modm:platform:timer:9 modm_platform_timer_9 modm: platform: timer: 9 modm_platform_timer modm: platform: timer modm_platform_timer_9->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-timer/","text":"These module docs are in beta and may be incomplete. modm:platform:timer: Timers (TIM) \u00b6 Content \u00b6 // Class class modm :: platform :: AdvancedControlTimer ; class modm :: platform :: BasicTimer ; class modm :: platform :: GeneralPurposeTimer ; class modm :: platform :: Timer10 ; class modm :: platform :: Timer11 ; class modm :: platform :: Timer12 ; class modm :: platform :: Timer13 ; class modm :: platform :: Timer14 ; class modm :: platform :: Timer1 ; class modm :: platform :: Timer2 ; class modm :: platform :: Timer3 ; class modm :: platform :: Timer4 ; class modm :: platform :: Timer5 ; class modm :: platform :: Timer6 ; class modm :: platform :: Timer7 ; class modm :: platform :: Timer8 ; class modm :: platform :: Timer9 ; Dependencies \u00b6 modm:platform:timer modm_platform_timer modm: platform: timer modm_architecture_register modm: architecture: register modm_platform_timer->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_timer->modm_cmsis_device modm_platform modm: platform modm_platform_timer->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_timer->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_timer->modm_platform_rcc modm_platform_timer_1 modm: platform: timer: 1 modm_platform_timer_1->modm_platform_timer modm_platform_timer_10 modm: platform: timer: 10 modm_platform_timer_10->modm_platform_timer modm_platform_timer_11 modm: platform: timer: 11 modm_platform_timer_11->modm_platform_timer modm_platform_timer_12 modm: platform: timer: 12 modm_platform_timer_12->modm_platform_timer modm_platform_timer_13 modm: platform: timer: 13 modm_platform_timer_13->modm_platform_timer modm_platform_timer_14 modm: platform: timer: 14 modm_platform_timer_14->modm_platform_timer modm_platform_timer_2 modm: platform: timer: 2 modm_platform_timer_2->modm_platform_timer modm_platform_timer_3 modm: platform: timer: 3 modm_platform_timer_3->modm_platform_timer modm_platform_timer_4 modm: platform: timer: 4 modm_platform_timer_4->modm_platform_timer modm_platform_timer_5 modm: platform: timer: 5 modm_platform_timer_5->modm_platform_timer modm_platform_timer_6 modm: platform: timer: 6 modm_platform_timer_6->modm_platform_timer modm_platform_timer_7 modm: platform: timer: 7 modm_platform_timer_7->modm_platform_timer modm_platform_timer_8 modm: platform: timer: 8 modm_platform_timer_8->modm_platform_timer modm_platform_timer_9 modm: platform: timer: 9 modm_platform_timer_9->modm_platform_timer","title":"modm:platform:timer"},{"location":"reference/module/modm-platform-timer/#modmplatformtimer-timers-tim","text":"","title":"modm:platform:timer: Timers (TIM)"},{"location":"reference/module/modm-platform-timer/#content","text":"// Class class modm :: platform :: AdvancedControlTimer ; class modm :: platform :: BasicTimer ; class modm :: platform :: GeneralPurposeTimer ; class modm :: platform :: Timer10 ; class modm :: platform :: Timer11 ; class modm :: platform :: Timer12 ; class modm :: platform :: Timer13 ; class modm :: platform :: Timer14 ; class modm :: platform :: Timer1 ; class modm :: platform :: Timer2 ; class modm :: platform :: Timer3 ; class modm :: platform :: Timer4 ; class modm :: platform :: Timer5 ; class modm :: platform :: Timer6 ; class modm :: platform :: Timer7 ; class modm :: platform :: Timer8 ; class modm :: platform :: Timer9 ;","title":"Content"},{"location":"reference/module/modm-platform-timer/#dependencies","text":"modm:platform:timer modm_platform_timer modm: platform: timer modm_architecture_register modm: architecture: register modm_platform_timer->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_timer->modm_cmsis_device modm_platform modm: platform modm_platform_timer->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_timer->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_timer->modm_platform_rcc modm_platform_timer_1 modm: platform: timer: 1 modm_platform_timer_1->modm_platform_timer modm_platform_timer_10 modm: platform: timer: 10 modm_platform_timer_10->modm_platform_timer modm_platform_timer_11 modm: platform: timer: 11 modm_platform_timer_11->modm_platform_timer modm_platform_timer_12 modm: platform: timer: 12 modm_platform_timer_12->modm_platform_timer modm_platform_timer_13 modm: platform: timer: 13 modm_platform_timer_13->modm_platform_timer modm_platform_timer_14 modm: platform: timer: 14 modm_platform_timer_14->modm_platform_timer modm_platform_timer_2 modm: platform: timer: 2 modm_platform_timer_2->modm_platform_timer modm_platform_timer_3 modm: platform: timer: 3 modm_platform_timer_3->modm_platform_timer modm_platform_timer_4 modm: platform: timer: 4 modm_platform_timer_4->modm_platform_timer modm_platform_timer_5 modm: platform: timer: 5 modm_platform_timer_5->modm_platform_timer modm_platform_timer_6 modm: platform: timer: 6 modm_platform_timer_6->modm_platform_timer modm_platform_timer_7 modm: platform: timer: 7 modm_platform_timer_7->modm_platform_timer modm_platform_timer_8 modm: platform: timer: 8 modm_platform_timer_8->modm_platform_timer modm_platform_timer_9 modm: platform: timer: 9 modm_platform_timer_9->modm_platform_timer","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-1/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:1: Instance 1 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Usart1 ; class modm :: platform :: UsartHal1 ; Dependencies \u00b6 modm:platform:uart:1 modm_platform_uart_1 modm: platform: uart: 1 modm_platform_uart modm: platform: uart modm_platform_uart_1->modm_platform_uart modm_platform_uart_spi_1 modm: platform: uart.spi: 1 modm_platform_uart_spi_1->modm_platform_uart_1","title":"modm:platform:uart:1"},{"location":"reference/module/modm-platform-uart-1/#modmplatformuart1-instance-1","text":"","title":"modm:platform:uart:1: Instance 1"},{"location":"reference/module/modm-platform-uart-1/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-1/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-1/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-1/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-1/#content","text":"// Class class modm :: platform :: Usart1 ; class modm :: platform :: UsartHal1 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-1/#dependencies","text":"modm:platform:uart:1 modm_platform_uart_1 modm: platform: uart: 1 modm_platform_uart modm: platform: uart modm_platform_uart_1->modm_platform_uart modm_platform_uart_spi_1 modm: platform: uart.spi: 1 modm_platform_uart_spi_1->modm_platform_uart_1","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-2/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:2: Instance 2 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Usart2 ; class modm :: platform :: UsartHal2 ; Dependencies \u00b6 modm:platform:uart:2 modm_platform_uart_2 modm: platform: uart: 2 modm_platform_uart modm: platform: uart modm_platform_uart_2->modm_platform_uart modm_platform_uart_spi_2 modm: platform: uart.spi: 2 modm_platform_uart_spi_2->modm_platform_uart_2","title":"modm:platform:uart:2"},{"location":"reference/module/modm-platform-uart-2/#modmplatformuart2-instance-2","text":"","title":"modm:platform:uart:2: Instance 2"},{"location":"reference/module/modm-platform-uart-2/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-2/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-2/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-2/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-2/#content","text":"// Class class modm :: platform :: Usart2 ; class modm :: platform :: UsartHal2 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-2/#dependencies","text":"modm:platform:uart:2 modm_platform_uart_2 modm: platform: uart: 2 modm_platform_uart modm: platform: uart modm_platform_uart_2->modm_platform_uart modm_platform_uart_spi_2 modm: platform: uart.spi: 2 modm_platform_uart_spi_2->modm_platform_uart_2","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-3/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:3: Instance 3 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Usart3 ; class modm :: platform :: UsartHal3 ; Dependencies \u00b6 modm:platform:uart:3 modm_platform_uart_3 modm: platform: uart: 3 modm_platform_uart modm: platform: uart modm_platform_uart_3->modm_platform_uart modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_uart_3 modm_platform_uart_spi_3 modm: platform: uart.spi: 3 modm_platform_uart_spi_3->modm_platform_uart_3","title":"modm:platform:uart:3"},{"location":"reference/module/modm-platform-uart-3/#modmplatformuart3-instance-3","text":"","title":"modm:platform:uart:3: Instance 3"},{"location":"reference/module/modm-platform-uart-3/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-3/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-3/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-3/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-3/#content","text":"// Class class modm :: platform :: Usart3 ; class modm :: platform :: UsartHal3 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-3/#dependencies","text":"modm:platform:uart:3 modm_platform_uart_3 modm: platform: uart: 3 modm_platform_uart modm: platform: uart modm_platform_uart_3->modm_platform_uart modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_platform_uart_3 modm_platform_uart_spi_3 modm: platform: uart.spi: 3 modm_platform_uart_spi_3->modm_platform_uart_3","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-4/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:4: Instance 4 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Uart4 ; class modm :: platform :: UartHal4 ; Dependencies \u00b6 modm:platform:uart:4 modm_platform_uart_4 modm: platform: uart: 4 modm_platform_uart modm: platform: uart modm_platform_uart_4->modm_platform_uart","title":"modm:platform:uart:4"},{"location":"reference/module/modm-platform-uart-4/#modmplatformuart4-instance-4","text":"","title":"modm:platform:uart:4: Instance 4"},{"location":"reference/module/modm-platform-uart-4/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-4/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-4/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-4/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-4/#content","text":"// Class class modm :: platform :: Uart4 ; class modm :: platform :: UartHal4 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-4/#dependencies","text":"modm:platform:uart:4 modm_platform_uart_4 modm: platform: uart: 4 modm_platform_uart modm: platform: uart modm_platform_uart_4->modm_platform_uart","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-5/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:5: Instance 5 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Uart5 ; class modm :: platform :: UartHal5 ; Dependencies \u00b6 modm:platform:uart:5 modm_platform_uart_5 modm: platform: uart: 5 modm_platform_uart modm: platform: uart modm_platform_uart_5->modm_platform_uart","title":"modm:platform:uart:5"},{"location":"reference/module/modm-platform-uart-5/#modmplatformuart5-instance-5","text":"","title":"modm:platform:uart:5: Instance 5"},{"location":"reference/module/modm-platform-uart-5/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-5/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-5/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-5/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-5/#content","text":"// Class class modm :: platform :: Uart5 ; class modm :: platform :: UartHal5 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-5/#dependencies","text":"modm:platform:uart:5 modm_platform_uart_5 modm: platform: uart: 5 modm_platform_uart modm: platform: uart modm_platform_uart_5->modm_platform_uart","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-6/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:6: Instance 6 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Usart6 ; class modm :: platform :: UsartHal6 ; Dependencies \u00b6 modm:platform:uart:6 modm_platform_uart_6 modm: platform: uart: 6 modm_platform_uart modm: platform: uart modm_platform_uart_6->modm_platform_uart modm_platform_uart_spi_6 modm: platform: uart.spi: 6 modm_platform_uart_spi_6->modm_platform_uart_6","title":"modm:platform:uart:6"},{"location":"reference/module/modm-platform-uart-6/#modmplatformuart6-instance-6","text":"","title":"modm:platform:uart:6: Instance 6"},{"location":"reference/module/modm-platform-uart-6/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-6/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-6/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-6/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-6/#content","text":"// Class class modm :: platform :: Usart6 ; class modm :: platform :: UsartHal6 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-6/#dependencies","text":"modm:platform:uart:6 modm_platform_uart_6 modm: platform: uart: 6 modm_platform_uart modm: platform: uart modm_platform_uart_6->modm_platform_uart modm_platform_uart_spi_6 modm: platform: uart.spi: 6 modm_platform_uart_spi_6->modm_platform_uart_6","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-7/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:7: Instance 7 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Uart7 ; class modm :: platform :: UartHal7 ; Dependencies \u00b6 modm:platform:uart:7 modm_platform_uart_7 modm: platform: uart: 7 modm_platform_uart modm: platform: uart modm_platform_uart_7->modm_platform_uart","title":"modm:platform:uart:7"},{"location":"reference/module/modm-platform-uart-7/#modmplatformuart7-instance-7","text":"","title":"modm:platform:uart:7: Instance 7"},{"location":"reference/module/modm-platform-uart-7/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-7/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-7/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-7/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-7/#content","text":"// Class class modm :: platform :: Uart7 ; class modm :: platform :: UartHal7 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-7/#dependencies","text":"modm:platform:uart:7 modm_platform_uart_7 modm: platform: uart: 7 modm_platform_uart modm: platform: uart modm_platform_uart_7->modm_platform_uart","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-8/","text":"These module docs are in beta and may be incomplete. modm:platform:uart:8: Instance 8 \u00b6 Options \u00b6 buffered \u00b6 Default: True \u2208 { True, False } buffer.tx \u00b6 Default: 250 \u2208 { 1 .. 250 .. 65534 } buffer.rx \u00b6 Default: 16 \u2208 { 1 .. 16 .. 65534 } Content \u00b6 // Class class modm :: platform :: Uart8 ; class modm :: platform :: UartHal8 ; Dependencies \u00b6 modm:platform:uart:8 modm_platform_uart_8 modm: platform: uart: 8 modm_platform_uart modm: platform: uart modm_platform_uart_8->modm_platform_uart","title":"modm:platform:uart:8"},{"location":"reference/module/modm-platform-uart-8/#modmplatformuart8-instance-8","text":"","title":"modm:platform:uart:8: Instance 8"},{"location":"reference/module/modm-platform-uart-8/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-8/#buffered","text":"Default: True \u2208 { True, False }","title":"buffered"},{"location":"reference/module/modm-platform-uart-8/#buffertx","text":"Default: 250 \u2208 { 1 .. 250 .. 65534 }","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-8/#bufferrx","text":"Default: 16 \u2208 { 1 .. 16 .. 65534 }","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-8/#content","text":"// Class class modm :: platform :: Uart8 ; class modm :: platform :: UartHal8 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-8/#dependencies","text":"modm:platform:uart:8 modm_platform_uart_8 modm: platform: uart: 8 modm_platform_uart modm: platform: uart modm_platform_uart_8->modm_platform_uart","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-spi-1/","text":"These module docs are in beta and may be incomplete. modm:platform:uart.spi:1: Instance 1 \u00b6 Content \u00b6 // Class class modm :: platform :: UartSpiMaster1 ; Dependencies \u00b6 modm:platform:uart.spi:1 modm_platform_uart_spi_1 modm: platform: uart.spi: 1 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_1->modm_platform_uart_spi modm_platform_uart_1 modm: platform: uart: 1 modm_platform_uart_spi_1->modm_platform_uart_1","title":"modm:platform:uart.spi:1"},{"location":"reference/module/modm-platform-uart-spi-1/#modmplatformuartspi1-instance-1","text":"","title":"modm:platform:uart.spi:1: Instance 1"},{"location":"reference/module/modm-platform-uart-spi-1/#content","text":"// Class class modm :: platform :: UartSpiMaster1 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-spi-1/#dependencies","text":"modm:platform:uart.spi:1 modm_platform_uart_spi_1 modm: platform: uart.spi: 1 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_1->modm_platform_uart_spi modm_platform_uart_1 modm: platform: uart: 1 modm_platform_uart_spi_1->modm_platform_uart_1","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-spi-2/","text":"These module docs are in beta and may be incomplete. modm:platform:uart.spi:2: Instance 2 \u00b6 Content \u00b6 // Class class modm :: platform :: UartSpiMaster2 ; Dependencies \u00b6 modm:platform:uart.spi:2 modm_platform_uart_spi_2 modm: platform: uart.spi: 2 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_2->modm_platform_uart_spi modm_platform_uart_2 modm: platform: uart: 2 modm_platform_uart_spi_2->modm_platform_uart_2","title":"modm:platform:uart.spi:2"},{"location":"reference/module/modm-platform-uart-spi-2/#modmplatformuartspi2-instance-2","text":"","title":"modm:platform:uart.spi:2: Instance 2"},{"location":"reference/module/modm-platform-uart-spi-2/#content","text":"// Class class modm :: platform :: UartSpiMaster2 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-spi-2/#dependencies","text":"modm:platform:uart.spi:2 modm_platform_uart_spi_2 modm: platform: uart.spi: 2 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_2->modm_platform_uart_spi modm_platform_uart_2 modm: platform: uart: 2 modm_platform_uart_spi_2->modm_platform_uart_2","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-spi-3/","text":"These module docs are in beta and may be incomplete. modm:platform:uart.spi:3: Instance 3 \u00b6 Content \u00b6 // Class class modm :: platform :: UartSpiMaster3 ; Dependencies \u00b6 modm:platform:uart.spi:3 modm_platform_uart_spi_3 modm: platform: uart.spi: 3 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_3->modm_platform_uart_spi modm_platform_uart_3 modm: platform: uart: 3 modm_platform_uart_spi_3->modm_platform_uart_3","title":"modm:platform:uart.spi:3"},{"location":"reference/module/modm-platform-uart-spi-3/#modmplatformuartspi3-instance-3","text":"","title":"modm:platform:uart.spi:3: Instance 3"},{"location":"reference/module/modm-platform-uart-spi-3/#content","text":"// Class class modm :: platform :: UartSpiMaster3 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-spi-3/#dependencies","text":"modm:platform:uart.spi:3 modm_platform_uart_spi_3 modm: platform: uart.spi: 3 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_3->modm_platform_uart_spi modm_platform_uart_3 modm: platform: uart: 3 modm_platform_uart_spi_3->modm_platform_uart_3","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-spi-6/","text":"These module docs are in beta and may be incomplete. modm:platform:uart.spi:6: Instance 6 \u00b6 Content \u00b6 // Class class modm :: platform :: UartSpiMaster6 ; Dependencies \u00b6 modm:platform:uart.spi:6 modm_platform_uart_spi_6 modm: platform: uart.spi: 6 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_6->modm_platform_uart_spi modm_platform_uart_6 modm: platform: uart: 6 modm_platform_uart_spi_6->modm_platform_uart_6","title":"modm:platform:uart.spi:6"},{"location":"reference/module/modm-platform-uart-spi-6/#modmplatformuartspi6-instance-6","text":"","title":"modm:platform:uart.spi:6: Instance 6"},{"location":"reference/module/modm-platform-uart-spi-6/#content","text":"// Class class modm :: platform :: UartSpiMaster6 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-spi-6/#dependencies","text":"modm:platform:uart.spi:6 modm_platform_uart_spi_6 modm: platform: uart.spi: 6 modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi_6->modm_platform_uart_spi modm_platform_uart_6 modm: platform: uart: 6 modm_platform_uart_spi_6->modm_platform_uart_6","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-spi/","text":"These module docs are in beta and may be incomplete. modm:platform:uart.spi: USART in SPI Mode \u00b6 Content \u00b6 // Class class modm :: platform :: UartSpiMaster1 ; class modm :: platform :: UartSpiMaster2 ; class modm :: platform :: UartSpiMaster3 ; class modm :: platform :: UartSpiMaster6 ; Dependencies \u00b6 modm:platform:uart.spi modm_platform_uart_spi modm: platform: uart.spi modm_architecture_spi modm: architecture: spi modm_platform_uart_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_uart_spi->modm_cmsis_device modm_platform modm: platform modm_platform_uart_spi->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_uart_spi->modm_platform_gpio modm_platform_uart modm: platform: uart modm_platform_uart_spi->modm_platform_uart modm_platform_uart_spi_1 modm: platform: uart.spi: 1 modm_platform_uart_spi_1->modm_platform_uart_spi modm_platform_uart_spi_2 modm: platform: uart.spi: 2 modm_platform_uart_spi_2->modm_platform_uart_spi modm_platform_uart_spi_3 modm: platform: uart.spi: 3 modm_platform_uart_spi_3->modm_platform_uart_spi modm_platform_uart_spi_6 modm: platform: uart.spi: 6 modm_platform_uart_spi_6->modm_platform_uart_spi","title":"modm:platform:uart.spi"},{"location":"reference/module/modm-platform-uart-spi/#modmplatformuartspi-usart-in-spi-mode","text":"","title":"modm:platform:uart.spi: USART in SPI Mode"},{"location":"reference/module/modm-platform-uart-spi/#content","text":"// Class class modm :: platform :: UartSpiMaster1 ; class modm :: platform :: UartSpiMaster2 ; class modm :: platform :: UartSpiMaster3 ; class modm :: platform :: UartSpiMaster6 ;","title":"Content"},{"location":"reference/module/modm-platform-uart-spi/#dependencies","text":"modm:platform:uart.spi modm_platform_uart_spi modm: platform: uart.spi modm_architecture_spi modm: architecture: spi modm_platform_uart_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_uart_spi->modm_cmsis_device modm_platform modm: platform modm_platform_uart_spi->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_uart_spi->modm_platform_gpio modm_platform_uart modm: platform: uart modm_platform_uart_spi->modm_platform_uart modm_platform_uart_spi_1 modm: platform: uart.spi: 1 modm_platform_uart_spi_1->modm_platform_uart_spi modm_platform_uart_spi_2 modm: platform: uart.spi: 2 modm_platform_uart_spi_2->modm_platform_uart_spi modm_platform_uart_spi_3 modm: platform: uart.spi: 3 modm_platform_uart_spi_3->modm_platform_uart_spi modm_platform_uart_spi_6 modm: platform: uart.spi: 6 modm_platform_uart_spi_6->modm_platform_uart_spi","title":"Dependencies"},{"location":"reference/module/modm-platform-uart/","text":"These module docs are in beta and may be incomplete. modm:platform:uart: Universal Asynchronous Receiver Transmitter (UART) \u00b6 Content \u00b6 // Class class modm :: platform :: Uart4 ; class modm :: platform :: Uart5 ; class modm :: platform :: Uart7 ; class modm :: platform :: Uart8 ; class modm :: platform :: UartBase ; class modm :: platform :: UartBaudrate ; class modm :: platform :: UartHal4 ; class modm :: platform :: UartHal5 ; class modm :: platform :: UartHal7 ; class modm :: platform :: UartHal8 ; class modm :: platform :: UartSpiMaster1 ; class modm :: platform :: UartSpiMaster2 ; class modm :: platform :: UartSpiMaster3 ; class modm :: platform :: UartSpiMaster6 ; class modm :: platform :: Usart1 ; class modm :: platform :: Usart2 ; class modm :: platform :: Usart3 ; class modm :: platform :: Usart6 ; class modm :: platform :: UsartHal1 ; class modm :: platform :: UsartHal2 ; class modm :: platform :: UsartHal3 ; class modm :: platform :: UsartHal6 ; Dependencies \u00b6 modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart->modm_architecture_atomic modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart->modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_uart->modm_architecture_register modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart->modm_cmsis_device modm_platform modm: platform modm_platform_uart->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_uart->modm_platform_rcc modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_platform_uart modm_platform_uart_1 modm: platform: uart: 1 modm_platform_uart_1->modm_platform_uart modm_platform_uart_2 modm: platform: uart: 2 modm_platform_uart_2->modm_platform_uart modm_platform_uart_3 modm: platform: uart: 3 modm_platform_uart_3->modm_platform_uart modm_platform_uart_4 modm: platform: uart: 4 modm_platform_uart_4->modm_platform_uart modm_platform_uart_5 modm: platform: uart: 5 modm_platform_uart_5->modm_platform_uart modm_platform_uart_6 modm: platform: uart: 6 modm_platform_uart_6->modm_platform_uart modm_platform_uart_7 modm: platform: uart: 7 modm_platform_uart_7->modm_platform_uart modm_platform_uart_8 modm: platform: uart: 8 modm_platform_uart_8->modm_platform_uart","title":"modm:platform:uart"},{"location":"reference/module/modm-platform-uart/#modmplatformuart-universal-asynchronous-receiver-transmitter-uart","text":"","title":"modm:platform:uart: Universal Asynchronous Receiver Transmitter (UART)"},{"location":"reference/module/modm-platform-uart/#content","text":"// Class class modm :: platform :: Uart4 ; class modm :: platform :: Uart5 ; class modm :: platform :: Uart7 ; class modm :: platform :: Uart8 ; class modm :: platform :: UartBase ; class modm :: platform :: UartBaudrate ; class modm :: platform :: UartHal4 ; class modm :: platform :: UartHal5 ; class modm :: platform :: UartHal7 ; class modm :: platform :: UartHal8 ; class modm :: platform :: UartSpiMaster1 ; class modm :: platform :: UartSpiMaster2 ; class modm :: platform :: UartSpiMaster3 ; class modm :: platform :: UartSpiMaster6 ; class modm :: platform :: Usart1 ; class modm :: platform :: Usart2 ; class modm :: platform :: Usart3 ; class modm :: platform :: Usart6 ; class modm :: platform :: UsartHal1 ; class modm :: platform :: UsartHal2 ; class modm :: platform :: UsartHal3 ; class modm :: platform :: UsartHal6 ;","title":"Content"},{"location":"reference/module/modm-platform-uart/#dependencies","text":"modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart->modm_architecture_atomic modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart->modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_uart->modm_architecture_register modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart->modm_cmsis_device modm_platform modm: platform modm_platform_uart->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_uart->modm_platform_rcc modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_platform_uart modm_platform_uart_1 modm: platform: uart: 1 modm_platform_uart_1->modm_platform_uart modm_platform_uart_2 modm: platform: uart: 2 modm_platform_uart_2->modm_platform_uart modm_platform_uart_3 modm: platform: uart: 3 modm_platform_uart_3->modm_platform_uart modm_platform_uart_4 modm: platform: uart: 4 modm_platform_uart_4->modm_platform_uart modm_platform_uart_5 modm: platform: uart: 5 modm_platform_uart_5->modm_platform_uart modm_platform_uart_6 modm: platform: uart: 6 modm_platform_uart_6->modm_platform_uart modm_platform_uart_7 modm: platform: uart: 7 modm_platform_uart_7->modm_platform_uart modm_platform_uart_8 modm: platform: uart: 8 modm_platform_uart_8->modm_platform_uart","title":"Dependencies"},{"location":"reference/module/modm-platform/","text":"These module docs are in beta and may be incomplete. modm:platform: Platform HAL \u00b6 Target-specific implementation of the Hardware Abstraction Layer. Content \u00b6 // Class class modm :: CanBitTiming < int32_t Clk , int32_t Bitrate > ; class modm :: platform :: Adc1 ; class modm :: platform :: Adc2 ; class modm :: platform :: Adc3 ; class modm :: platform :: AdcInterrupt1 ; class modm :: platform :: AdcInterrupt2 ; class modm :: platform :: AdcInterrupt3 ; class modm :: platform :: AdvancedControlTimer ; class modm :: platform :: BasicTimer ; class modm :: platform :: BitBangI2cMaster < class Scl , class Sda > ; class modm :: platform :: BitBangOneWireMaster < typename Pin > ; class modm :: platform :: BitBangSpiMaster < typename Sck , typename Mosi , typename Miso = GpioUnused > ; class modm :: platform :: Can1 ; class modm :: platform :: Can2 ; class modm :: platform :: CanFilter ; class modm :: platform :: Dma1 :: Stream0 ; class modm :: platform :: Dma1 :: Stream1 ; class modm :: platform :: Dma1 :: Stream2 ; class modm :: platform :: Dma1 :: Stream3 ; class modm :: platform :: Dma1 :: Stream4 ; class modm :: platform :: Dma1 :: Stream5 ; class modm :: platform :: Dma1 :: Stream6 ; class modm :: platform :: Dma1 :: Stream7 ; class modm :: platform :: Dma1 ; class modm :: platform :: Dma2 :: Stream0 ; class modm :: platform :: Dma2 :: Stream1 ; class modm :: platform :: Dma2 :: Stream2 ; class modm :: platform :: Dma2 :: Stream3 ; class modm :: platform :: Dma2 :: Stream4 ; class modm :: platform :: Dma2 :: Stream5 ; class modm :: platform :: Dma2 :: Stream6 ; class modm :: platform :: Dma2 :: Stream7 ; class modm :: platform :: Dma2 ; class modm :: platform :: DmaBase ; class modm :: platform :: GeneralPurposeTimer ; class modm :: platform :: GpioA0 ; class modm :: platform :: GpioA10 ; class modm :: platform :: GpioA11 ; class modm :: platform :: GpioA12 ; class modm :: platform :: GpioA13 ; class modm :: platform :: GpioA14 ; class modm :: platform :: GpioA15 ; class modm :: platform :: GpioA1 ; class modm :: platform :: GpioA2 ; class modm :: platform :: GpioA3 ; class modm :: platform :: GpioA4 ; class modm :: platform :: GpioA5 ; class modm :: platform :: GpioA6 ; class modm :: platform :: GpioA7 ; class modm :: platform :: GpioA8 ; class modm :: platform :: GpioA9 ; class modm :: platform :: GpioB0 ; class modm :: platform :: GpioB10 ; class modm :: platform :: GpioB11 ; class modm :: platform :: GpioB12 ; class modm :: platform :: GpioB13 ; class modm :: platform :: GpioB14 ; class modm :: platform :: GpioB15 ; class modm :: platform :: GpioB1 ; class modm :: platform :: GpioB2 ; class modm :: platform :: GpioB3 ; class modm :: platform :: GpioB4 ; class modm :: platform :: GpioB5 ; class modm :: platform :: GpioB6 ; class modm :: platform :: GpioB7 ; class modm :: platform :: GpioB8 ; class modm :: platform :: GpioB9 ; class modm :: platform :: GpioC0 ; class modm :: platform :: GpioC10 ; class modm :: platform :: GpioC11 ; class modm :: platform :: GpioC12 ; class modm :: platform :: GpioC13 ; class modm :: platform :: GpioC14 ; class modm :: platform :: GpioC15 ; class modm :: platform :: GpioC1 ; class modm :: platform :: GpioC2 ; class modm :: platform :: GpioC3 ; class modm :: platform :: GpioC4 ; class modm :: platform :: GpioC5 ; class modm :: platform :: GpioC6 ; class modm :: platform :: GpioC7 ; class modm :: platform :: GpioC8 ; class modm :: platform :: GpioC9 ; class modm :: platform :: GpioD0 ; class modm :: platform :: GpioD10 ; class modm :: platform :: GpioD11 ; class modm :: platform :: GpioD12 ; class modm :: platform :: GpioD13 ; class modm :: platform :: GpioD14 ; class modm :: platform :: GpioD15 ; class modm :: platform :: GpioD1 ; class modm :: platform :: GpioD2 ; class modm :: platform :: GpioD3 ; class modm :: platform :: GpioD4 ; class modm :: platform :: GpioD5 ; class modm :: platform :: GpioD6 ; class modm :: platform :: GpioD7 ; class modm :: platform :: GpioD8 ; class modm :: platform :: GpioD9 ; class modm :: platform :: GpioE0 ; class modm :: platform :: GpioE10 ; class modm :: platform :: GpioE11 ; class modm :: platform :: GpioE12 ; class modm :: platform :: GpioE13 ; class modm :: platform :: GpioE14 ; class modm :: platform :: GpioE15 ; class modm :: platform :: GpioE1 ; class modm :: platform :: GpioE2 ; class modm :: platform :: GpioE3 ; class modm :: platform :: GpioE4 ; class modm :: platform :: GpioE5 ; class modm :: platform :: GpioE6 ; class modm :: platform :: GpioE7 ; class modm :: platform :: GpioE8 ; class modm :: platform :: GpioE9 ; class modm :: platform :: GpioF0 ; class modm :: platform :: GpioF10 ; class modm :: platform :: GpioF11 ; class modm :: platform :: GpioF12 ; class modm :: platform :: GpioF13 ; class modm :: platform :: GpioF14 ; class modm :: platform :: GpioF15 ; class modm :: platform :: GpioF1 ; class modm :: platform :: GpioF2 ; class modm :: platform :: GpioF3 ; class modm :: platform :: GpioF4 ; class modm :: platform :: GpioF5 ; class modm :: platform :: GpioF6 ; class modm :: platform :: GpioF7 ; class modm :: platform :: GpioF8 ; class modm :: platform :: GpioF9 ; class modm :: platform :: GpioG0 ; class modm :: platform :: GpioG10 ; class modm :: platform :: GpioG11 ; class modm :: platform :: GpioG12 ; class modm :: platform :: GpioG13 ; class modm :: platform :: GpioG14 ; class modm :: platform :: GpioG15 ; class modm :: platform :: GpioG1 ; class modm :: platform :: GpioG2 ; class modm :: platform :: GpioG3 ; class modm :: platform :: GpioG4 ; class modm :: platform :: GpioG5 ; class modm :: platform :: GpioG6 ; class modm :: platform :: GpioG7 ; class modm :: platform :: GpioG8 ; class modm :: platform :: GpioG9 ; class modm :: platform :: GpioH0 ; class modm :: platform :: GpioH10 ; class modm :: platform :: GpioH11 ; class modm :: platform :: GpioH12 ; class modm :: platform :: GpioH13 ; class modm :: platform :: GpioH14 ; class modm :: platform :: GpioH15 ; class modm :: platform :: GpioH1 ; class modm :: platform :: GpioH2 ; class modm :: platform :: GpioH3 ; class modm :: platform :: GpioH4 ; class modm :: platform :: GpioH5 ; class modm :: platform :: GpioH6 ; class modm :: platform :: GpioH7 ; class modm :: platform :: GpioH8 ; class modm :: platform :: GpioH9 ; class modm :: platform :: GpioI0 ; class modm :: platform :: GpioI10 ; class modm :: platform :: GpioI11 ; class modm :: platform :: GpioI12 ; class modm :: platform :: GpioI13 ; class modm :: platform :: GpioI14 ; class modm :: platform :: GpioI15 ; class modm :: platform :: GpioI1 ; class modm :: platform :: GpioI2 ; class modm :: platform :: GpioI3 ; class modm :: platform :: GpioI4 ; class modm :: platform :: GpioI5 ; class modm :: platform :: GpioI6 ; class modm :: platform :: GpioI7 ; class modm :: platform :: GpioI8 ; class modm :: platform :: GpioI9 ; class modm :: platform :: GpioInverted < class Pin > ; class modm :: platform :: GpioJ0 ; class modm :: platform :: GpioJ12 ; class modm :: platform :: GpioJ13 ; class modm :: platform :: GpioJ14 ; class modm :: platform :: GpioJ15 ; class modm :: platform :: GpioJ1 ; class modm :: platform :: GpioJ2 ; class modm :: platform :: GpioJ3 ; class modm :: platform :: GpioJ4 ; class modm :: platform :: GpioJ5 ; class modm :: platform :: GpioK3 ; class modm :: platform :: GpioK4 ; class modm :: platform :: GpioK5 ; class modm :: platform :: GpioK6 ; class modm :: platform :: GpioK7 ; class modm :: platform :: GpioPort < class StartGpio , int8_t Width > ; class modm :: platform :: GpioSet < class ... Gpios > ; class modm :: platform :: GpioUnused ; class modm :: platform :: I2cMaster1 ; class modm :: platform :: I2cMaster2 ; class modm :: platform :: I2cMaster3 ; class modm :: platform :: RandomNumberGenerator ; class modm :: platform :: Rcc ; class modm :: platform :: SoftwareGpioPort < class ... Gpios > ; class modm :: platform :: SpiBase ; class modm :: platform :: SpiHal1 ; class modm :: platform :: SpiHal2 ; class modm :: platform :: SpiHal3 ; class modm :: platform :: SpiHal4 ; class modm :: platform :: SpiHal5 ; class modm :: platform :: SpiHal6 ; class modm :: platform :: SpiMaster1 ; class modm :: platform :: SpiMaster2 ; class modm :: platform :: SpiMaster3 ; class modm :: platform :: SpiMaster4 ; class modm :: platform :: SpiMaster5 ; class modm :: platform :: SpiMaster6 ; class modm :: platform :: SysTickTimer ; class modm :: platform :: Timer10 ; class modm :: platform :: Timer11 ; class modm :: platform :: Timer12 ; class modm :: platform :: Timer13 ; class modm :: platform :: Timer14 ; class modm :: platform :: Timer1 ; class modm :: platform :: Timer2 ; class modm :: platform :: Timer3 ; class modm :: platform :: Timer4 ; class modm :: platform :: Timer5 ; class modm :: platform :: Timer6 ; class modm :: platform :: Timer7 ; class modm :: platform :: Timer8 ; class modm :: platform :: Timer9 ; class modm :: platform :: Uart4 ; class modm :: platform :: Uart5 ; class modm :: platform :: Uart7 ; class modm :: platform :: Uart8 ; class modm :: platform :: UartBase ; class modm :: platform :: UartBaudrate ; class modm :: platform :: UartHal4 ; class modm :: platform :: UartHal5 ; class modm :: platform :: UartHal7 ; class modm :: platform :: UartHal8 ; class modm :: platform :: UartSpiMaster1 ; class modm :: platform :: UartSpiMaster2 ; class modm :: platform :: UartSpiMaster3 ; class modm :: platform :: UartSpiMaster6 ; class modm :: platform :: Usart1 ; class modm :: platform :: Usart2 ; class modm :: platform :: Usart3 ; class modm :: platform :: Usart6 ; class modm :: platform :: UsartHal1 ; class modm :: platform :: UsartHal2 ; class modm :: platform :: UsartHal3 ; class modm :: platform :: UsartHal6 ; // Struct struct modm :: CanBitTiming :: CanBitTimingConfiguration ; struct modm :: platform :: CanFilter :: ExtendedFilterMask ; struct modm :: platform :: CanFilter :: ExtendedFilterMaskShort ; struct modm :: platform :: CanFilter :: ExtendedIdentifier ; struct modm :: platform :: CanFilter :: ExtendedIdentifierShort ; struct modm :: platform :: CanFilter :: Identifier ; struct modm :: platform :: CanFilter :: IdentifierShort ; struct modm :: platform :: CanFilter :: StandardFilterMask ; struct modm :: platform :: CanFilter :: StandardFilterMaskShort ; struct modm :: platform :: CanFilter :: StandardIdentifier ; struct modm :: platform :: CanFilter :: StandardIdentifierShort ; struct modm :: platform :: Gpio ; struct modm :: platform :: Rcc :: flash_latency ; // Function static uint32_t modm :: platform :: getUniqueId ( uint8_t offset ); void _delay_ms ( uint16_t ms ); void _delay_ns ( uint16_t ns ); void _delay_us ( uint16_t us ); // Enum enum ErrorCode ; enum Peripheral ; // Typedef typedef void ( * modm :: platform :: InterruptHandler ) ( void ))( void ); using modm :: cortex :: instead = typedef :: modm :: platform :: SysTickTimer ; using modm :: platform :: instead = typedef Rcc ; Dependencies \u00b6 modm:platform modm_platform modm: platform modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_platform modm_platform_adc modm: platform: adc modm_platform_adc->modm_platform modm_platform_can modm: platform: can modm_platform_can->modm_platform modm_platform_can_common modm: platform: can.common modm_platform_can_common->modm_platform modm_platform_clock modm: platform: clock modm_platform_clock->modm_platform modm_platform_core modm: platform: core modm_platform_core->modm_platform modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_platform modm_platform_dma modm: platform: dma modm_platform_dma->modm_platform modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_platform modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio_common->modm_platform modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_platform modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_platform modm_platform_id modm: platform: id modm_platform_id->modm_platform modm_platform_random modm: platform: random modm_platform_random->modm_platform modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_platform modm_platform_spi modm: platform: spi modm_platform_spi->modm_platform modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_platform modm_platform_systick modm: platform: systick modm_platform_systick->modm_platform modm_platform_timer modm: platform: timer modm_platform_timer->modm_platform modm_platform_uart modm: platform: uart modm_platform_uart->modm_platform modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_platform","title":"modm:platform"},{"location":"reference/module/modm-platform/#modmplatform-platform-hal","text":"Target-specific implementation of the Hardware Abstraction Layer.","title":"modm:platform: Platform HAL"},{"location":"reference/module/modm-platform/#content","text":"// Class class modm :: CanBitTiming < int32_t Clk , int32_t Bitrate > ; class modm :: platform :: Adc1 ; class modm :: platform :: Adc2 ; class modm :: platform :: Adc3 ; class modm :: platform :: AdcInterrupt1 ; class modm :: platform :: AdcInterrupt2 ; class modm :: platform :: AdcInterrupt3 ; class modm :: platform :: AdvancedControlTimer ; class modm :: platform :: BasicTimer ; class modm :: platform :: BitBangI2cMaster < class Scl , class Sda > ; class modm :: platform :: BitBangOneWireMaster < typename Pin > ; class modm :: platform :: BitBangSpiMaster < typename Sck , typename Mosi , typename Miso = GpioUnused > ; class modm :: platform :: Can1 ; class modm :: platform :: Can2 ; class modm :: platform :: CanFilter ; class modm :: platform :: Dma1 :: Stream0 ; class modm :: platform :: Dma1 :: Stream1 ; class modm :: platform :: Dma1 :: Stream2 ; class modm :: platform :: Dma1 :: Stream3 ; class modm :: platform :: Dma1 :: Stream4 ; class modm :: platform :: Dma1 :: Stream5 ; class modm :: platform :: Dma1 :: Stream6 ; class modm :: platform :: Dma1 :: Stream7 ; class modm :: platform :: Dma1 ; class modm :: platform :: Dma2 :: Stream0 ; class modm :: platform :: Dma2 :: Stream1 ; class modm :: platform :: Dma2 :: Stream2 ; class modm :: platform :: Dma2 :: Stream3 ; class modm :: platform :: Dma2 :: Stream4 ; class modm :: platform :: Dma2 :: Stream5 ; class modm :: platform :: Dma2 :: Stream6 ; class modm :: platform :: Dma2 :: Stream7 ; class modm :: platform :: Dma2 ; class modm :: platform :: DmaBase ; class modm :: platform :: GeneralPurposeTimer ; class modm :: platform :: GpioA0 ; class modm :: platform :: GpioA10 ; class modm :: platform :: GpioA11 ; class modm :: platform :: GpioA12 ; class modm :: platform :: GpioA13 ; class modm :: platform :: GpioA14 ; class modm :: platform :: GpioA15 ; class modm :: platform :: GpioA1 ; class modm :: platform :: GpioA2 ; class modm :: platform :: GpioA3 ; class modm :: platform :: GpioA4 ; class modm :: platform :: GpioA5 ; class modm :: platform :: GpioA6 ; class modm :: platform :: GpioA7 ; class modm :: platform :: GpioA8 ; class modm :: platform :: GpioA9 ; class modm :: platform :: GpioB0 ; class modm :: platform :: GpioB10 ; class modm :: platform :: GpioB11 ; class modm :: platform :: GpioB12 ; class modm :: platform :: GpioB13 ; class modm :: platform :: GpioB14 ; class modm :: platform :: GpioB15 ; class modm :: platform :: GpioB1 ; class modm :: platform :: GpioB2 ; class modm :: platform :: GpioB3 ; class modm :: platform :: GpioB4 ; class modm :: platform :: GpioB5 ; class modm :: platform :: GpioB6 ; class modm :: platform :: GpioB7 ; class modm :: platform :: GpioB8 ; class modm :: platform :: GpioB9 ; class modm :: platform :: GpioC0 ; class modm :: platform :: GpioC10 ; class modm :: platform :: GpioC11 ; class modm :: platform :: GpioC12 ; class modm :: platform :: GpioC13 ; class modm :: platform :: GpioC14 ; class modm :: platform :: GpioC15 ; class modm :: platform :: GpioC1 ; class modm :: platform :: GpioC2 ; class modm :: platform :: GpioC3 ; class modm :: platform :: GpioC4 ; class modm :: platform :: GpioC5 ; class modm :: platform :: GpioC6 ; class modm :: platform :: GpioC7 ; class modm :: platform :: GpioC8 ; class modm :: platform :: GpioC9 ; class modm :: platform :: GpioD0 ; class modm :: platform :: GpioD10 ; class modm :: platform :: GpioD11 ; class modm :: platform :: GpioD12 ; class modm :: platform :: GpioD13 ; class modm :: platform :: GpioD14 ; class modm :: platform :: GpioD15 ; class modm :: platform :: GpioD1 ; class modm :: platform :: GpioD2 ; class modm :: platform :: GpioD3 ; class modm :: platform :: GpioD4 ; class modm :: platform :: GpioD5 ; class modm :: platform :: GpioD6 ; class modm :: platform :: GpioD7 ; class modm :: platform :: GpioD8 ; class modm :: platform :: GpioD9 ; class modm :: platform :: GpioE0 ; class modm :: platform :: GpioE10 ; class modm :: platform :: GpioE11 ; class modm :: platform :: GpioE12 ; class modm :: platform :: GpioE13 ; class modm :: platform :: GpioE14 ; class modm :: platform :: GpioE15 ; class modm :: platform :: GpioE1 ; class modm :: platform :: GpioE2 ; class modm :: platform :: GpioE3 ; class modm :: platform :: GpioE4 ; class modm :: platform :: GpioE5 ; class modm :: platform :: GpioE6 ; class modm :: platform :: GpioE7 ; class modm :: platform :: GpioE8 ; class modm :: platform :: GpioE9 ; class modm :: platform :: GpioF0 ; class modm :: platform :: GpioF10 ; class modm :: platform :: GpioF11 ; class modm :: platform :: GpioF12 ; class modm :: platform :: GpioF13 ; class modm :: platform :: GpioF14 ; class modm :: platform :: GpioF15 ; class modm :: platform :: GpioF1 ; class modm :: platform :: GpioF2 ; class modm :: platform :: GpioF3 ; class modm :: platform :: GpioF4 ; class modm :: platform :: GpioF5 ; class modm :: platform :: GpioF6 ; class modm :: platform :: GpioF7 ; class modm :: platform :: GpioF8 ; class modm :: platform :: GpioF9 ; class modm :: platform :: GpioG0 ; class modm :: platform :: GpioG10 ; class modm :: platform :: GpioG11 ; class modm :: platform :: GpioG12 ; class modm :: platform :: GpioG13 ; class modm :: platform :: GpioG14 ; class modm :: platform :: GpioG15 ; class modm :: platform :: GpioG1 ; class modm :: platform :: GpioG2 ; class modm :: platform :: GpioG3 ; class modm :: platform :: GpioG4 ; class modm :: platform :: GpioG5 ; class modm :: platform :: GpioG6 ; class modm :: platform :: GpioG7 ; class modm :: platform :: GpioG8 ; class modm :: platform :: GpioG9 ; class modm :: platform :: GpioH0 ; class modm :: platform :: GpioH10 ; class modm :: platform :: GpioH11 ; class modm :: platform :: GpioH12 ; class modm :: platform :: GpioH13 ; class modm :: platform :: GpioH14 ; class modm :: platform :: GpioH15 ; class modm :: platform :: GpioH1 ; class modm :: platform :: GpioH2 ; class modm :: platform :: GpioH3 ; class modm :: platform :: GpioH4 ; class modm :: platform :: GpioH5 ; class modm :: platform :: GpioH6 ; class modm :: platform :: GpioH7 ; class modm :: platform :: GpioH8 ; class modm :: platform :: GpioH9 ; class modm :: platform :: GpioI0 ; class modm :: platform :: GpioI10 ; class modm :: platform :: GpioI11 ; class modm :: platform :: GpioI12 ; class modm :: platform :: GpioI13 ; class modm :: platform :: GpioI14 ; class modm :: platform :: GpioI15 ; class modm :: platform :: GpioI1 ; class modm :: platform :: GpioI2 ; class modm :: platform :: GpioI3 ; class modm :: platform :: GpioI4 ; class modm :: platform :: GpioI5 ; class modm :: platform :: GpioI6 ; class modm :: platform :: GpioI7 ; class modm :: platform :: GpioI8 ; class modm :: platform :: GpioI9 ; class modm :: platform :: GpioInverted < class Pin > ; class modm :: platform :: GpioJ0 ; class modm :: platform :: GpioJ12 ; class modm :: platform :: GpioJ13 ; class modm :: platform :: GpioJ14 ; class modm :: platform :: GpioJ15 ; class modm :: platform :: GpioJ1 ; class modm :: platform :: GpioJ2 ; class modm :: platform :: GpioJ3 ; class modm :: platform :: GpioJ4 ; class modm :: platform :: GpioJ5 ; class modm :: platform :: GpioK3 ; class modm :: platform :: GpioK4 ; class modm :: platform :: GpioK5 ; class modm :: platform :: GpioK6 ; class modm :: platform :: GpioK7 ; class modm :: platform :: GpioPort < class StartGpio , int8_t Width > ; class modm :: platform :: GpioSet < class ... Gpios > ; class modm :: platform :: GpioUnused ; class modm :: platform :: I2cMaster1 ; class modm :: platform :: I2cMaster2 ; class modm :: platform :: I2cMaster3 ; class modm :: platform :: RandomNumberGenerator ; class modm :: platform :: Rcc ; class modm :: platform :: SoftwareGpioPort < class ... Gpios > ; class modm :: platform :: SpiBase ; class modm :: platform :: SpiHal1 ; class modm :: platform :: SpiHal2 ; class modm :: platform :: SpiHal3 ; class modm :: platform :: SpiHal4 ; class modm :: platform :: SpiHal5 ; class modm :: platform :: SpiHal6 ; class modm :: platform :: SpiMaster1 ; class modm :: platform :: SpiMaster2 ; class modm :: platform :: SpiMaster3 ; class modm :: platform :: SpiMaster4 ; class modm :: platform :: SpiMaster5 ; class modm :: platform :: SpiMaster6 ; class modm :: platform :: SysTickTimer ; class modm :: platform :: Timer10 ; class modm :: platform :: Timer11 ; class modm :: platform :: Timer12 ; class modm :: platform :: Timer13 ; class modm :: platform :: Timer14 ; class modm :: platform :: Timer1 ; class modm :: platform :: Timer2 ; class modm :: platform :: Timer3 ; class modm :: platform :: Timer4 ; class modm :: platform :: Timer5 ; class modm :: platform :: Timer6 ; class modm :: platform :: Timer7 ; class modm :: platform :: Timer8 ; class modm :: platform :: Timer9 ; class modm :: platform :: Uart4 ; class modm :: platform :: Uart5 ; class modm :: platform :: Uart7 ; class modm :: platform :: Uart8 ; class modm :: platform :: UartBase ; class modm :: platform :: UartBaudrate ; class modm :: platform :: UartHal4 ; class modm :: platform :: UartHal5 ; class modm :: platform :: UartHal7 ; class modm :: platform :: UartHal8 ; class modm :: platform :: UartSpiMaster1 ; class modm :: platform :: UartSpiMaster2 ; class modm :: platform :: UartSpiMaster3 ; class modm :: platform :: UartSpiMaster6 ; class modm :: platform :: Usart1 ; class modm :: platform :: Usart2 ; class modm :: platform :: Usart3 ; class modm :: platform :: Usart6 ; class modm :: platform :: UsartHal1 ; class modm :: platform :: UsartHal2 ; class modm :: platform :: UsartHal3 ; class modm :: platform :: UsartHal6 ; // Struct struct modm :: CanBitTiming :: CanBitTimingConfiguration ; struct modm :: platform :: CanFilter :: ExtendedFilterMask ; struct modm :: platform :: CanFilter :: ExtendedFilterMaskShort ; struct modm :: platform :: CanFilter :: ExtendedIdentifier ; struct modm :: platform :: CanFilter :: ExtendedIdentifierShort ; struct modm :: platform :: CanFilter :: Identifier ; struct modm :: platform :: CanFilter :: IdentifierShort ; struct modm :: platform :: CanFilter :: StandardFilterMask ; struct modm :: platform :: CanFilter :: StandardFilterMaskShort ; struct modm :: platform :: CanFilter :: StandardIdentifier ; struct modm :: platform :: CanFilter :: StandardIdentifierShort ; struct modm :: platform :: Gpio ; struct modm :: platform :: Rcc :: flash_latency ; // Function static uint32_t modm :: platform :: getUniqueId ( uint8_t offset ); void _delay_ms ( uint16_t ms ); void _delay_ns ( uint16_t ns ); void _delay_us ( uint16_t us ); // Enum enum ErrorCode ; enum Peripheral ; // Typedef typedef void ( * modm :: platform :: InterruptHandler ) ( void ))( void ); using modm :: cortex :: instead = typedef :: modm :: platform :: SysTickTimer ; using modm :: platform :: instead = typedef Rcc ;","title":"Content"},{"location":"reference/module/modm-platform/#dependencies","text":"modm:platform modm_platform modm: platform modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_platform_1_wire_bitbang->modm_platform modm_platform_adc modm: platform: adc modm_platform_adc->modm_platform modm_platform_can modm: platform: can modm_platform_can->modm_platform modm_platform_can_common modm: platform: can.common modm_platform_can_common->modm_platform modm_platform_clock modm: platform: clock modm_platform_clock->modm_platform modm_platform_core modm: platform: core modm_platform_core->modm_platform modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_platform modm_platform_dma modm: platform: dma modm_platform_dma->modm_platform modm_platform_fault_cortex modm: platform: fault.cortex modm_platform_fault_cortex->modm_platform modm_platform_gpio modm: platform: gpio modm_platform_gpio->modm_platform modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio_common->modm_platform modm_platform_i2c modm: platform: i2c modm_platform_i2c->modm_platform modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_platform_i2c_bitbang->modm_platform modm_platform_id modm: platform: id modm_platform_id->modm_platform modm_platform_random modm: platform: random modm_platform_random->modm_platform modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_platform modm_platform_spi modm: platform: spi modm_platform_spi->modm_platform modm_platform_spi_bitbang modm: platform: spi.bitbang modm_platform_spi_bitbang->modm_platform modm_platform_systick modm: platform: systick modm_platform_systick->modm_platform modm_platform_timer modm: platform: timer modm_platform_timer->modm_platform modm_platform_uart modm: platform: uart modm_platform_uart->modm_platform modm_platform_uart_spi modm: platform: uart.spi modm_platform_uart_spi->modm_platform","title":"Dependencies"},{"location":"reference/module/modm-processing-protothread/","text":"These module docs are in beta and may be incomplete. modm:processing:protothread: Protothreads \u00b6 Protothreads are extremely lightweight stackless threads designed for severely memory constrained systems, such as small embedded systems or wireless sensor network nodes. Protothreads provide linear code execution for event-driven systems implemented in C. Protothreads can be used with or without an underlying operating system to provide blocking event-handlers. Protothreads provide sequential flow of control without complex state machines or full multi-threading. Since they implement some kind of cooperative multi-threading, Protothreads are non-preemptable. Therefore, a context switch can only take place on blocking operations, which means you don't need complex synchronization. Protothreads are also stackless, so local variables are not preserved across context switches, and must instead become member variables of the modm::Protothread subclass A protothread runs within a single function ( modm::Protothread::run() ) and cannot span over other functions. A protothread may call normal functions, but cannot block inside a called function. Blocking inside nested function calls is instead made by spawning a separate protothread for each potentially blocking function. The protothread concept was developed by Adam Dunkels and Oliver Schmidt: http://dunkels.com/adam/pt Originally ported to C++ for use by Hamilton Jet ( www.hamiltonjet.co.nz ) by Ben Hoyt, but stripped down for public release. Example \u00b6 #include <modm/processing/protothread.hpp> using Led = GpioB0 ; class BlinkingLight : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { timeout . restart ( 100 ); Led :: set (); PT_WAIT_UNTIL ( timeout . isExpired ()); timeout . restart ( 200 ); Led :: reset (); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } private : modm :: ShortTimeout timeout ; }; // ... BlinkingLight light ; while ( 1 ) { light . run (); } Content \u00b6 // Class class modm :: pt :: Protothread ; class modm :: pt :: Semaphore ; // Define #define PT_BEGIN #define PT_CALL(resumable) #define PT_END #define PT_EXIT #define PT_RESTART #define PT_SPAWN(child) #define PT_WAIT_THREAD(child) #define PT_WAIT_UNTIL(condition) #define PT_WAIT_WHILE(condition) #define PT_YIELD Dependencies \u00b6 modm:processing:protothread modm_processing_protothread modm: processing: protothread modm_architecture modm: architecture modm_processing_protothread->modm_architecture modm_processing modm: processing modm_processing_protothread->modm_processing modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_processing_protothread modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_processing_protothread modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_processing_protothread modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_processing_protothread modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_processing_protothread modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_processing_protothread modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_processing_protothread","title":"modm:processing:protothread"},{"location":"reference/module/modm-processing-protothread/#modmprocessingprotothread-protothreads","text":"Protothreads are extremely lightweight stackless threads designed for severely memory constrained systems, such as small embedded systems or wireless sensor network nodes. Protothreads provide linear code execution for event-driven systems implemented in C. Protothreads can be used with or without an underlying operating system to provide blocking event-handlers. Protothreads provide sequential flow of control without complex state machines or full multi-threading. Since they implement some kind of cooperative multi-threading, Protothreads are non-preemptable. Therefore, a context switch can only take place on blocking operations, which means you don't need complex synchronization. Protothreads are also stackless, so local variables are not preserved across context switches, and must instead become member variables of the modm::Protothread subclass A protothread runs within a single function ( modm::Protothread::run() ) and cannot span over other functions. A protothread may call normal functions, but cannot block inside a called function. Blocking inside nested function calls is instead made by spawning a separate protothread for each potentially blocking function. The protothread concept was developed by Adam Dunkels and Oliver Schmidt: http://dunkels.com/adam/pt Originally ported to C++ for use by Hamilton Jet ( www.hamiltonjet.co.nz ) by Ben Hoyt, but stripped down for public release.","title":"modm:processing:protothread: Protothreads"},{"location":"reference/module/modm-processing-protothread/#example","text":"#include <modm/processing/protothread.hpp> using Led = GpioB0 ; class BlinkingLight : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { timeout . restart ( 100 ); Led :: set (); PT_WAIT_UNTIL ( timeout . isExpired ()); timeout . restart ( 200 ); Led :: reset (); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } private : modm :: ShortTimeout timeout ; }; // ... BlinkingLight light ; while ( 1 ) { light . run (); }","title":"Example"},{"location":"reference/module/modm-processing-protothread/#content","text":"// Class class modm :: pt :: Protothread ; class modm :: pt :: Semaphore ; // Define #define PT_BEGIN #define PT_CALL(resumable) #define PT_END #define PT_EXIT #define PT_RESTART #define PT_SPAWN(child) #define PT_WAIT_THREAD(child) #define PT_WAIT_UNTIL(condition) #define PT_WAIT_WHILE(condition) #define PT_YIELD","title":"Content"},{"location":"reference/module/modm-processing-protothread/#dependencies","text":"modm:processing:protothread modm_processing_protothread modm: processing: protothread modm_architecture modm: architecture modm_processing_protothread->modm_architecture modm_processing modm: processing modm_processing_protothread->modm_processing modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_processing_protothread modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_processing_protothread modm_driver_ds1631 modm: driver: ds1631 modm_driver_ds1631->modm_processing_protothread modm_driver_hmc6343 modm: driver: hmc6343 modm_driver_hmc6343->modm_processing_protothread modm_driver_tmp102 modm: driver: tmp102 modm_driver_tmp102->modm_processing_protothread modm_driver_tmp175 modm: driver: tmp175 modm_driver_tmp175->modm_processing_protothread modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_processing_protothread","title":"Dependencies"},{"location":"reference/module/modm-processing-resumable/","text":"These module docs are in beta and may be incomplete. modm:processing:resumable: Resumable Functions \u00b6 An implementation of lightweight resumable functions which allow for nested calling. This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality. Note that you should call resumable functions within a protothreads, with the PT_CALL(group.resumable()) macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the RF_CALL(group.resumable()) . You may use the RF_CALL_BLOCKING(group.resumable()) macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended. Resumable functions are not thread-safe! Use an external mutex to arbitrate access if two Protothreads access the same resumable function. You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group's functions. So you need to inherit your group from modm::Resumable<#Functions> , and from modm::NestedResumable<#Functions> respectively. Independent operation \u00b6 You must begin each resumable function using RF_BEGIN(index) where index is the unique index of your resumable function starting at zero. You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) . Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the NestedResumable class for mutually exclusive resumable functions, which also require a little less memory. Nested operation \u00b6 You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the resumable.begin.nesting assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code. The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return modm::rf::WrongState . Using the RF_CALL(resumable()) macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases. You must begin each resumable function using RF_BEGIN() . You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) . Example \u00b6 Here is a (slightly over-engineered) example: #include <modm/platform/platform.hpp> #include <modm/processing/processing.hpp> using Led = GpioOutputB0 ; class BlinkingLight : public modm :: pt :: Protothread , private modm :: NestedResumable < 2 > { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { Led :: set (); PT_CALL ( waitForTimer ()); Led :: reset (); PT_CALL ( setTimer ( 200 )); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } modm :: ResumableResult < bool > waitForTimer () { RF_BEGIN (); // nested calling is allowed if ( RF_CALL ( setTimer ( 100 ))) { RF_WAIT_UNTIL ( timeout . isExpired ()); RF_RETURN ( true ); } RF_END_RETURN ( false ); } modm :: ResumableResult < bool > setTimer ( uint16_t new_timeout ) { RF_BEGIN (); timeout . restart ( new_timeout ); if ( timeout . isArmed ()) { RF_RETURN ( true ); } // clean up code goes here RF_END_RETURN ( false ); } private : modm :: ShortTimeout timeout ; }; BlinkingLight light ; while ( 1 ) { light . run (); } For other examples take a look in the examples folder in the modm root folder. The given example is in modm/examples/generic/resumable . Options \u00b6 check_nesting_depth \u00b6 Check nesting call depth: True \u2208 { True, False } Nested resumable functions protect against memory corruption by checking if the nesting level is within the allocated nesting level depth, on first entry to the function. If the allocated nesting level is exceeded, the assertion resumable.begin.nesting fails. You may disable this behavior by disabling this check, then instead of the assertion, the function on entry returns the modm::rf::NestingError state value. PT_CALL() and RF_CALL() macros will respond to this error by stopping function polling and just continuing program execution. Performance Penalty This check is performed during the call to RF_BEGIN(N) , so exactly once on function entry and not during every polling call, so the performance penalty is relatively small. Content \u00b6 // Class class modm :: NestedResumable < uint8_t Levels = 1 > ; class modm :: Resumable < uint8_t Functions = 1 > ; // Struct struct modm :: ResumableResult < typename T > ; // Define #define MODM_RESUMABLE_MODULE_NAME #define RF_BEGIN #define RF_BEGIN(index) #define RF_CALL(resumable) #define RF_CALL_BLOCKING(resumable) #define RF_END #define RF_END_RETURN(result) #define RF_END_RETURN_CALL(resumable) #define RF_RETURN #define RF_RETURN(result) #define RF_RETURN_CALL(resumable) #define RF_WAIT_THREAD(child) #define RF_WAIT_UNTIL(condition) #define RF_WAIT_WHILE(condition) #define RF_YIELD Dependencies \u00b6 modm:processing:resumable modm_processing_resumable modm: processing: resumable modm_architecture_assert modm: architecture: assert modm_processing_resumable->modm_architecture_assert modm_processing modm: processing modm_processing_resumable->modm_processing modm_architecture_block_device modm: architecture: block.device modm_architecture_block_device->modm_processing_resumable modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_processing_resumable modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c_device->modm_processing_resumable modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_processing_resumable modm_architecture_spi modm: architecture: spi modm_architecture_spi->modm_processing_resumable modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_processing_resumable modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_processing_resumable modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_processing_resumable modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_processing_resumable modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_processing_resumable modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_processing_resumable modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_processing_resumable modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_processing_resumable modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_processing_resumable modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_processing_resumable modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_processing_resumable","title":"modm:processing:resumable"},{"location":"reference/module/modm-processing-resumable/#modmprocessingresumable-resumable-functions","text":"An implementation of lightweight resumable functions which allow for nested calling. This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality. Note that you should call resumable functions within a protothreads, with the PT_CALL(group.resumable()) macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the RF_CALL(group.resumable()) . You may use the RF_CALL_BLOCKING(group.resumable()) macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended. Resumable functions are not thread-safe! Use an external mutex to arbitrate access if two Protothreads access the same resumable function. You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group's functions. So you need to inherit your group from modm::Resumable<#Functions> , and from modm::NestedResumable<#Functions> respectively.","title":"modm:processing:resumable: Resumable Functions"},{"location":"reference/module/modm-processing-resumable/#independent-operation","text":"You must begin each resumable function using RF_BEGIN(index) where index is the unique index of your resumable function starting at zero. You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) . Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the NestedResumable class for mutually exclusive resumable functions, which also require a little less memory.","title":"Independent operation"},{"location":"reference/module/modm-processing-resumable/#nested-operation","text":"You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the resumable.begin.nesting assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code. The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return modm::rf::WrongState . Using the RF_CALL(resumable()) macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases. You must begin each resumable function using RF_BEGIN() . You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) .","title":"Nested operation"},{"location":"reference/module/modm-processing-resumable/#example","text":"Here is a (slightly over-engineered) example: #include <modm/platform/platform.hpp> #include <modm/processing/processing.hpp> using Led = GpioOutputB0 ; class BlinkingLight : public modm :: pt :: Protothread , private modm :: NestedResumable < 2 > { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { Led :: set (); PT_CALL ( waitForTimer ()); Led :: reset (); PT_CALL ( setTimer ( 200 )); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } modm :: ResumableResult < bool > waitForTimer () { RF_BEGIN (); // nested calling is allowed if ( RF_CALL ( setTimer ( 100 ))) { RF_WAIT_UNTIL ( timeout . isExpired ()); RF_RETURN ( true ); } RF_END_RETURN ( false ); } modm :: ResumableResult < bool > setTimer ( uint16_t new_timeout ) { RF_BEGIN (); timeout . restart ( new_timeout ); if ( timeout . isArmed ()) { RF_RETURN ( true ); } // clean up code goes here RF_END_RETURN ( false ); } private : modm :: ShortTimeout timeout ; }; BlinkingLight light ; while ( 1 ) { light . run (); } For other examples take a look in the examples folder in the modm root folder. The given example is in modm/examples/generic/resumable .","title":"Example"},{"location":"reference/module/modm-processing-resumable/#options","text":"","title":"Options"},{"location":"reference/module/modm-processing-resumable/#check_nesting_depth","text":"Check nesting call depth: True \u2208 { True, False } Nested resumable functions protect against memory corruption by checking if the nesting level is within the allocated nesting level depth, on first entry to the function. If the allocated nesting level is exceeded, the assertion resumable.begin.nesting fails. You may disable this behavior by disabling this check, then instead of the assertion, the function on entry returns the modm::rf::NestingError state value. PT_CALL() and RF_CALL() macros will respond to this error by stopping function polling and just continuing program execution. Performance Penalty This check is performed during the call to RF_BEGIN(N) , so exactly once on function entry and not during every polling call, so the performance penalty is relatively small.","title":"check_nesting_depth"},{"location":"reference/module/modm-processing-resumable/#content","text":"// Class class modm :: NestedResumable < uint8_t Levels = 1 > ; class modm :: Resumable < uint8_t Functions = 1 > ; // Struct struct modm :: ResumableResult < typename T > ; // Define #define MODM_RESUMABLE_MODULE_NAME #define RF_BEGIN #define RF_BEGIN(index) #define RF_CALL(resumable) #define RF_CALL_BLOCKING(resumable) #define RF_END #define RF_END_RETURN(result) #define RF_END_RETURN_CALL(resumable) #define RF_RETURN #define RF_RETURN(result) #define RF_RETURN_CALL(resumable) #define RF_WAIT_THREAD(child) #define RF_WAIT_UNTIL(condition) #define RF_WAIT_WHILE(condition) #define RF_YIELD","title":"Content"},{"location":"reference/module/modm-processing-resumable/#dependencies","text":"modm:processing:resumable modm_processing_resumable modm: processing: resumable modm_architecture_assert modm: architecture: assert modm_processing_resumable->modm_architecture_assert modm_processing modm: processing modm_processing_resumable->modm_processing modm_architecture_block_device modm: architecture: block.device modm_architecture_block_device->modm_processing_resumable modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio_expander->modm_processing_resumable modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c_device->modm_processing_resumable modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c_multiplexer->modm_processing_resumable modm_architecture_spi modm: architecture: spi modm_architecture_spi->modm_processing_resumable modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_processing_resumable modm_driver_ad7928 modm: driver: ad7928 modm_driver_ad7928->modm_processing_resumable modm_driver_drv832x_spi modm: driver: drv832x_spi modm_driver_drv832x_spi->modm_processing_resumable modm_driver_l3gd20 modm: driver: l3gd20 modm_driver_l3gd20->modm_processing_resumable modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3_transport->modm_processing_resumable modm_driver_lis302dl modm: driver: lis302dl modm_driver_lis302dl->modm_processing_resumable modm_driver_ltc2984 modm: driver: ltc2984 modm_driver_ltc2984->modm_processing_resumable modm_driver_mcp23x17 modm: driver: mcp23x17 modm_driver_mcp23x17->modm_processing_resumable modm_driver_pca8574 modm: driver: pca8574 modm_driver_pca8574->modm_processing_resumable modm_driver_pca9535 modm: driver: pca9535 modm_driver_pca9535->modm_processing_resumable modm_driver_pca9548a modm: driver: pca9548a modm_driver_pca9548a->modm_processing_resumable","title":"Dependencies"},{"location":"reference/module/modm-processing-rtos/","text":"These module docs are in beta and may be incomplete. modm:processing:rtos: RTOS Abstractions \u00b6 Basic building blocks of an RTOS abstracted as C++ classes and implemented either with FreeRTOS or stdlibc++. Content \u00b6 // Class class modm :: rtos :: BinarySemaphore ; class modm :: rtos :: Mutex ; class modm :: rtos :: MutexGuard ; class modm :: rtos :: Queue < typename T > ; class modm :: rtos :: QueueBase ; class modm :: rtos :: Scheduler ; class modm :: rtos :: Semaphore ; class modm :: rtos :: SemaphoreBase ; class modm :: rtos :: Thread :: Lock ; class modm :: rtos :: Thread ; // Define #define MILLISECONDS #define TIME_LOOP(frequency) Dependencies \u00b6 modm:processing:rtos modm_processing_rtos modm: processing: rtos modm_freertos modm: freertos modm_processing_rtos->modm_freertos modm_processing modm: processing modm_processing_rtos->modm_processing","title":"modm:processing:rtos"},{"location":"reference/module/modm-processing-rtos/#modmprocessingrtos-rtos-abstractions","text":"Basic building blocks of an RTOS abstracted as C++ classes and implemented either with FreeRTOS or stdlibc++.","title":"modm:processing:rtos: RTOS Abstractions"},{"location":"reference/module/modm-processing-rtos/#content","text":"// Class class modm :: rtos :: BinarySemaphore ; class modm :: rtos :: Mutex ; class modm :: rtos :: MutexGuard ; class modm :: rtos :: Queue < typename T > ; class modm :: rtos :: QueueBase ; class modm :: rtos :: Scheduler ; class modm :: rtos :: Semaphore ; class modm :: rtos :: SemaphoreBase ; class modm :: rtos :: Thread :: Lock ; class modm :: rtos :: Thread ; // Define #define MILLISECONDS #define TIME_LOOP(frequency)","title":"Content"},{"location":"reference/module/modm-processing-rtos/#dependencies","text":"modm:processing:rtos modm_processing_rtos modm: processing: rtos modm_freertos modm: freertos modm_processing_rtos->modm_freertos modm_processing modm: processing modm_processing_rtos->modm_processing","title":"Dependencies"},{"location":"reference/module/modm-processing-scheduler/","text":"These module docs are in beta and may be incomplete. modm:processing:scheduler: Generic Scheduler \u00b6 Priority task scheduling Content \u00b6 // Class class modm :: Scheduler :: Task ; class modm :: Scheduler ; // Struct struct modm :: Scheduler :: TaskListItem ; Dependencies \u00b6 modm:processing:scheduler modm_processing_scheduler modm: processing: scheduler modm_architecture_accessor modm: architecture: accessor modm_processing_scheduler->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_processing_scheduler->modm_architecture_atomic modm_processing modm: processing modm_processing_scheduler->modm_processing","title":"modm:processing:scheduler"},{"location":"reference/module/modm-processing-scheduler/#modmprocessingscheduler-generic-scheduler","text":"Priority task scheduling","title":"modm:processing:scheduler: Generic Scheduler"},{"location":"reference/module/modm-processing-scheduler/#content","text":"// Class class modm :: Scheduler :: Task ; class modm :: Scheduler ; // Struct struct modm :: Scheduler :: TaskListItem ;","title":"Content"},{"location":"reference/module/modm-processing-scheduler/#dependencies","text":"modm:processing:scheduler modm_processing_scheduler modm: processing: scheduler modm_architecture_accessor modm: architecture: accessor modm_processing_scheduler->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_processing_scheduler->modm_architecture_atomic modm_processing modm: processing modm_processing_scheduler->modm_processing","title":"Dependencies"},{"location":"reference/module/modm-processing-timer/","text":"These module docs are in beta and may be incomplete. modm:processing:timer: Software Timers \u00b6 An implementation of lightweight software timeouts and periodic timers. modm::Timestamp containing a time in millisecond resolution up to 49 days. modm::Timeout for timeouts up to 24 days. modm::PeriodicTimer for periodic timeouts up to 24 days periods. There are also 16-bit versions of these, in case you need to preserve memory: modm::ShortTimestamp containing a time in millisecond resolution up to 65 seconds. modm::ShortTimeout for timeouts up to 32 seconds. modm::ShortPeriodicTimer for periodic timeouts up to 32 second periods. These classes default to using modm::Clock , which must be implemented on your system to return a time with millisecond resolution. You may also create your own timers with custom time bases and resolutions using these classes: modm::GenericTimestamp . modm::GenericTimeout . modm::GenericPeriodicTimer . Warning Never use these classes when a precise timebase is needed! Timeouts \u00b6 The modm::GenericTimeout classes allow for a signal to be generated after a period of time, which can also be used to execute code once after timeout expiration. Its behavior can be described by the following annotated waveform: C: Default Constructor S: (Re-)Start timeout E: Timeout Expired H: Code handler ( execute() returned true ) P: Stop timeout Event: C S E H P S E H _____________ ______________ Expired: ______________/ \\_______________________/ ... ______ __________ Armed: _______/ \\__________________________/ \\______________... _______ ____________ Stopped: \\____________________/ \\_________________________... _ _ Handle: ___________________/ \\_______________________________/ \\___________... Remaining: 0 | + | - | 0 | + | - The default constructor initializes the timeout in the Stopped state, in which isExpired() and execute() never return true . If you need a timeout to expire immidiately after construction, you need to explicitly initialize the constructor with time 0 , which has the same behavior as restart(0) . If you want to execute code once after the timeout expired, poll the execute() method, which returns true exactly once after expiration. if ( timeout . execute ()) { // called once after timeout Led :: toggle (); } Be aware, however, that since this method is polled, it cannot execute exactly at the time of expiration, but some time after expiration, as indicated in the above waveform graph. The remaining() time until expiration is signed positive before, and negative after expiration. This means Clock::now() + Timeout::remaining() will yield the timestamp of the expiration. If the timeout is stopped, remaining() returns zero. Periodic Timers \u00b6 The modm::GenericPeriodicTimer class allows for periodic code execution. Its behavior can be described by the following annotated waveform: C: Constructor S: (Re-)Start timer I: Period interval H: Code handler ( execute() returned true ) P: Stop timer Event: C IH I I H I S IH I IH P _ _____________ __ _ ______ Expired: __________/ \\_______/ \\_____/ \\____/ \\__/ \\____... __________ _______ _____ ____ __ _ Armed: \\_/ \\_____________/ \\__/ \\_/ \\______/ \\__... __ Stopped: ______________________________________________________________/ ... _ _ _ _ Handle: __________/ \\___________________/ \\_____________/ \\_______/ \\____... Remaining: + |0| + | - |0| + | -| + |0| +| - |0|+| 0 * * If you want to execute code once per period interval, poll the * execute() method, which returns true exactly once after expiration. * * @code * if (timer.execute()) * { * // periodically called once * Led::toggle(); * } * @endcode * * Be aware, however, that since this method is polled, it cannot execute * exactly at the time of expiration, but some time after expiration, as * indicated in the above waveform graph. * If one or several periods are missed when polling execute() , these * code executions are discarded and will not be caught up. * Instead, execute() returns true once and then reschedules itself * for the next period, without any period skewing. * * @warning Never use this class when a precise timebase is needed! * * Notice, that the PeriodicTimerState::Expired is reset to * PeriodicTimerState::Armed only after execute() has returned true . * This is different to the behavior of GenericTimeout, where calls to * GenericTimeout::execute() have no impact on class state. * * The remaining() time until period expiration is signed positive before, * and negative after period expiration until execute() is called. * If the timer is stopped, remaining() returns zero. Content \u00b6 // Class class modm :: GenericPeriodicTimer < class Clock , typename TimestampType = modm :: Timestamp > ; class modm :: GenericTimeout < class Clock , class TimestampType = modm :: Timestamp > ; class modm :: GenericTimestamp < typename T > ; // Function IOStream & modm :: operator << ( IOStream & os , const GenericTimestamp < T > & t ); // Enum enum PeriodicTimerState ; enum TimeoutState ; // Typedef using modm :: PeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , Timestamp > ; using modm :: ShortPeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimeout = typedef GenericTimeout < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimestamp = typedef GenericTimestamp < uint16_t > ; using modm :: Timeout = typedef GenericTimeout < :: modm :: Clock , Timestamp > ; using modm :: Timestamp = typedef GenericTimestamp < uint32_t > ; Dependencies \u00b6 modm:processing:timer modm_processing_timer modm: processing: timer modm_architecture_clock modm: architecture: clock modm_processing_timer->modm_architecture_clock modm_io modm: io modm_processing_timer->modm_io modm_math_utils modm: math: utils modm_processing_timer->modm_math_utils modm_processing modm: processing modm_processing_timer->modm_processing modm_architecture_clock->modm_processing_timer modm_communication_ros modm: communication: ros modm_communication_ros->modm_processing_timer modm_communication_sab modm: communication: sab modm_communication_sab->modm_processing_timer modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_processing_timer modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_processing_timer modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_processing_timer modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_processing_timer modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_processing_timer modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_processing_timer modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_processing_timer modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_processing_timer modm_ui_gui modm: ui: gui modm_ui_gui->modm_processing_timer modm_ui_led modm: ui: led modm_ui_led->modm_processing_timer modm_ui_menu modm: ui: menu modm_ui_menu->modm_processing_timer","title":"modm:processing:timer"},{"location":"reference/module/modm-processing-timer/#modmprocessingtimer-software-timers","text":"An implementation of lightweight software timeouts and periodic timers. modm::Timestamp containing a time in millisecond resolution up to 49 days. modm::Timeout for timeouts up to 24 days. modm::PeriodicTimer for periodic timeouts up to 24 days periods. There are also 16-bit versions of these, in case you need to preserve memory: modm::ShortTimestamp containing a time in millisecond resolution up to 65 seconds. modm::ShortTimeout for timeouts up to 32 seconds. modm::ShortPeriodicTimer for periodic timeouts up to 32 second periods. These classes default to using modm::Clock , which must be implemented on your system to return a time with millisecond resolution. You may also create your own timers with custom time bases and resolutions using these classes: modm::GenericTimestamp . modm::GenericTimeout . modm::GenericPeriodicTimer . Warning Never use these classes when a precise timebase is needed!","title":"modm:processing:timer: Software Timers"},{"location":"reference/module/modm-processing-timer/#timeouts","text":"The modm::GenericTimeout classes allow for a signal to be generated after a period of time, which can also be used to execute code once after timeout expiration. Its behavior can be described by the following annotated waveform: C: Default Constructor S: (Re-)Start timeout E: Timeout Expired H: Code handler ( execute() returned true ) P: Stop timeout Event: C S E H P S E H _____________ ______________ Expired: ______________/ \\_______________________/ ... ______ __________ Armed: _______/ \\__________________________/ \\______________... _______ ____________ Stopped: \\____________________/ \\_________________________... _ _ Handle: ___________________/ \\_______________________________/ \\___________... Remaining: 0 | + | - | 0 | + | - The default constructor initializes the timeout in the Stopped state, in which isExpired() and execute() never return true . If you need a timeout to expire immidiately after construction, you need to explicitly initialize the constructor with time 0 , which has the same behavior as restart(0) . If you want to execute code once after the timeout expired, poll the execute() method, which returns true exactly once after expiration. if ( timeout . execute ()) { // called once after timeout Led :: toggle (); } Be aware, however, that since this method is polled, it cannot execute exactly at the time of expiration, but some time after expiration, as indicated in the above waveform graph. The remaining() time until expiration is signed positive before, and negative after expiration. This means Clock::now() + Timeout::remaining() will yield the timestamp of the expiration. If the timeout is stopped, remaining() returns zero.","title":"Timeouts"},{"location":"reference/module/modm-processing-timer/#periodic-timers","text":"The modm::GenericPeriodicTimer class allows for periodic code execution. Its behavior can be described by the following annotated waveform: C: Constructor S: (Re-)Start timer I: Period interval H: Code handler ( execute() returned true ) P: Stop timer Event: C IH I I H I S IH I IH P _ _____________ __ _ ______ Expired: __________/ \\_______/ \\_____/ \\____/ \\__/ \\____... __________ _______ _____ ____ __ _ Armed: \\_/ \\_____________/ \\__/ \\_/ \\______/ \\__... __ Stopped: ______________________________________________________________/ ... _ _ _ _ Handle: __________/ \\___________________/ \\_____________/ \\_______/ \\____... Remaining: + |0| + | - |0| + | -| + |0| +| - |0|+| 0 * * If you want to execute code once per period interval, poll the * execute() method, which returns true exactly once after expiration. * * @code * if (timer.execute()) * { * // periodically called once * Led::toggle(); * } * @endcode * * Be aware, however, that since this method is polled, it cannot execute * exactly at the time of expiration, but some time after expiration, as * indicated in the above waveform graph. * If one or several periods are missed when polling execute() , these * code executions are discarded and will not be caught up. * Instead, execute() returns true once and then reschedules itself * for the next period, without any period skewing. * * @warning Never use this class when a precise timebase is needed! * * Notice, that the PeriodicTimerState::Expired is reset to * PeriodicTimerState::Armed only after execute() has returned true . * This is different to the behavior of GenericTimeout, where calls to * GenericTimeout::execute() have no impact on class state. * * The remaining() time until period expiration is signed positive before, * and negative after period expiration until execute() is called. * If the timer is stopped, remaining() returns zero.","title":"Periodic Timers"},{"location":"reference/module/modm-processing-timer/#content","text":"// Class class modm :: GenericPeriodicTimer < class Clock , typename TimestampType = modm :: Timestamp > ; class modm :: GenericTimeout < class Clock , class TimestampType = modm :: Timestamp > ; class modm :: GenericTimestamp < typename T > ; // Function IOStream & modm :: operator << ( IOStream & os , const GenericTimestamp < T > & t ); // Enum enum PeriodicTimerState ; enum TimeoutState ; // Typedef using modm :: PeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , Timestamp > ; using modm :: ShortPeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimeout = typedef GenericTimeout < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimestamp = typedef GenericTimestamp < uint16_t > ; using modm :: Timeout = typedef GenericTimeout < :: modm :: Clock , Timestamp > ; using modm :: Timestamp = typedef GenericTimestamp < uint32_t > ;","title":"Content"},{"location":"reference/module/modm-processing-timer/#dependencies","text":"modm:processing:timer modm_processing_timer modm: processing: timer modm_architecture_clock modm: architecture: clock modm_processing_timer->modm_architecture_clock modm_io modm: io modm_processing_timer->modm_io modm_math_utils modm: math: utils modm_processing_timer->modm_math_utils modm_processing modm: processing modm_processing_timer->modm_processing modm_architecture_clock->modm_processing_timer modm_communication_ros modm: communication: ros modm_communication_ros->modm_processing_timer modm_communication_sab modm: communication: sab modm_communication_sab->modm_processing_timer modm_communication_sab2 modm: communication: sab2 modm_communication_sab2->modm_processing_timer modm_communication_xpcc modm: communication: xpcc modm_communication_xpcc->modm_processing_timer modm_driver_bme280 modm: driver: bme280 modm_driver_bme280->modm_processing_timer modm_driver_bmp085 modm: driver: bmp085 modm_driver_bmp085->modm_processing_timer modm_driver_nrf24 modm: driver: nrf24 modm_driver_nrf24->modm_processing_timer modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_processing_timer modm_driver_vl53l0 modm: driver: vl53l0 modm_driver_vl53l0->modm_processing_timer modm_driver_vl6180 modm: driver: vl6180 modm_driver_vl6180->modm_processing_timer modm_ui_gui modm: ui: gui modm_ui_gui->modm_processing_timer modm_ui_led modm: ui: led modm_ui_led->modm_processing_timer modm_ui_menu modm: ui: menu modm_ui_menu->modm_processing_timer","title":"Dependencies"},{"location":"reference/module/modm-processing/","text":"These module docs are in beta and may be incomplete. modm:processing: Processing \u00b6 Constructs to influence program flow execution, timing, synchronization and delegation. Content \u00b6 // Class class modm :: GenericPeriodicTimer < class Clock , typename TimestampType = modm :: Timestamp > ; class modm :: GenericTimeout < class Clock , class TimestampType = modm :: Timestamp > ; class modm :: GenericTimestamp < typename T > ; class modm :: NestedResumable < uint8_t Levels = 1 > ; class modm :: Resumable < uint8_t Functions = 1 > ; class modm :: Scheduler :: Task ; class modm :: Scheduler ; class modm :: Task ; class modm :: pt :: Protothread ; class modm :: pt :: Semaphore ; class modm :: rtos :: BinarySemaphore ; class modm :: rtos :: Mutex ; class modm :: rtos :: MutexGuard ; class modm :: rtos :: Queue < typename T > ; class modm :: rtos :: QueueBase ; class modm :: rtos :: Scheduler ; class modm :: rtos :: Semaphore ; class modm :: rtos :: SemaphoreBase ; class modm :: rtos :: Thread :: Lock ; class modm :: rtos :: Thread ; // Struct struct modm :: ResumableResult < typename T > ; struct modm :: Scheduler :: TaskListItem ; // Function IOStream & modm :: operator << ( IOStream & os , const GenericTimestamp < T > & t ); // Enum enum PeriodicTimerState ; enum TimeoutState ; // Typedef using modm :: PeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , Timestamp > ; using modm :: ShortPeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimeout = typedef GenericTimeout < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimestamp = typedef GenericTimestamp < uint16_t > ; using modm :: Timeout = typedef GenericTimeout < :: modm :: Clock , Timestamp > ; using modm :: Timestamp = typedef GenericTimestamp < uint32_t > ; // Define #define MILLISECONDS #define MODM_RESUMABLE_MODULE_NAME #define PT_BEGIN #define PT_CALL(resumable) #define PT_END #define PT_EXIT #define PT_RESTART #define PT_SPAWN(child) #define PT_WAIT_THREAD(child) #define PT_WAIT_UNTIL(condition) #define PT_WAIT_WHILE(condition) #define PT_YIELD #define RF_BEGIN #define RF_BEGIN(index) #define RF_CALL(resumable) #define RF_CALL_BLOCKING(resumable) #define RF_END #define RF_END_RETURN(result) #define RF_END_RETURN_CALL(resumable) #define RF_RETURN #define RF_RETURN(result) #define RF_RETURN_CALL(resumable) #define RF_WAIT_THREAD(child) #define RF_WAIT_UNTIL(condition) #define RF_WAIT_WHILE(condition) #define RF_YIELD #define TIME_LOOP(frequency) Dependencies \u00b6 modm:processing modm_processing modm: processing modm_processing_protothread modm: processing: protothread modm_processing_protothread->modm_processing modm_processing_resumable modm: processing: resumable modm_processing_resumable->modm_processing modm_processing_rtos modm: processing: rtos modm_processing_rtos->modm_processing modm_processing_scheduler modm: processing: scheduler modm_processing_scheduler->modm_processing modm_processing_timer modm: processing: timer modm_processing_timer->modm_processing","title":"modm:processing"},{"location":"reference/module/modm-processing/#modmprocessing-processing","text":"Constructs to influence program flow execution, timing, synchronization and delegation.","title":"modm:processing: Processing"},{"location":"reference/module/modm-processing/#content","text":"// Class class modm :: GenericPeriodicTimer < class Clock , typename TimestampType = modm :: Timestamp > ; class modm :: GenericTimeout < class Clock , class TimestampType = modm :: Timestamp > ; class modm :: GenericTimestamp < typename T > ; class modm :: NestedResumable < uint8_t Levels = 1 > ; class modm :: Resumable < uint8_t Functions = 1 > ; class modm :: Scheduler :: Task ; class modm :: Scheduler ; class modm :: Task ; class modm :: pt :: Protothread ; class modm :: pt :: Semaphore ; class modm :: rtos :: BinarySemaphore ; class modm :: rtos :: Mutex ; class modm :: rtos :: MutexGuard ; class modm :: rtos :: Queue < typename T > ; class modm :: rtos :: QueueBase ; class modm :: rtos :: Scheduler ; class modm :: rtos :: Semaphore ; class modm :: rtos :: SemaphoreBase ; class modm :: rtos :: Thread :: Lock ; class modm :: rtos :: Thread ; // Struct struct modm :: ResumableResult < typename T > ; struct modm :: Scheduler :: TaskListItem ; // Function IOStream & modm :: operator << ( IOStream & os , const GenericTimestamp < T > & t ); // Enum enum PeriodicTimerState ; enum TimeoutState ; // Typedef using modm :: PeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , Timestamp > ; using modm :: ShortPeriodicTimer = typedef GenericPeriodicTimer < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimeout = typedef GenericTimeout < :: modm :: Clock , ShortTimestamp > ; using modm :: ShortTimestamp = typedef GenericTimestamp < uint16_t > ; using modm :: Timeout = typedef GenericTimeout < :: modm :: Clock , Timestamp > ; using modm :: Timestamp = typedef GenericTimestamp < uint32_t > ; // Define #define MILLISECONDS #define MODM_RESUMABLE_MODULE_NAME #define PT_BEGIN #define PT_CALL(resumable) #define PT_END #define PT_EXIT #define PT_RESTART #define PT_SPAWN(child) #define PT_WAIT_THREAD(child) #define PT_WAIT_UNTIL(condition) #define PT_WAIT_WHILE(condition) #define PT_YIELD #define RF_BEGIN #define RF_BEGIN(index) #define RF_CALL(resumable) #define RF_CALL_BLOCKING(resumable) #define RF_END #define RF_END_RETURN(result) #define RF_END_RETURN_CALL(resumable) #define RF_RETURN #define RF_RETURN(result) #define RF_RETURN_CALL(resumable) #define RF_WAIT_THREAD(child) #define RF_WAIT_UNTIL(condition) #define RF_WAIT_WHILE(condition) #define RF_YIELD #define TIME_LOOP(frequency)","title":"Content"},{"location":"reference/module/modm-processing/#dependencies","text":"modm:processing modm_processing modm: processing modm_processing_protothread modm: processing: protothread modm_processing_protothread->modm_processing modm_processing_resumable modm: processing: resumable modm_processing_resumable->modm_processing modm_processing_rtos modm: processing: rtos modm_processing_rtos->modm_processing modm_processing_scheduler modm: processing: scheduler modm_processing_scheduler->modm_processing modm_processing_timer modm: processing: timer modm_processing_timer->modm_processing","title":"Dependencies"},{"location":"reference/module/modm-ros/","text":"These module docs are in beta and may be incomplete. modm:ros: ROS Library \u00b6 Repository of generated messages headers for rosserial. See https://github.com/modm-io/ros-lib .","title":"modm:ros"},{"location":"reference/module/modm-ros/#modmros-ros-library","text":"Repository of generated messages headers for rosserial. See https://github.com/modm-io/ros-lib .","title":"modm:ros: ROS Library"},{"location":"reference/module/modm-tlsf/","text":"These module docs are in beta and may be incomplete. modm:tlsf: TLSF Allocator \u00b6 Two-Level Segregated Fit memory allocator implementation. Written by Matthew Conte ( matt@baisoku.org ). Released under the BSD license. https://github.com/mattconte/tlsf Features \u00b6 O(1) cost for malloc, free, realloc, memalign Extremely low overhead per allocation (4 bytes) Low overhead per TLSF management of pools (~3kB) Low fragmentation Compiles to only a few kB of code and data Support for adding and removing memory pool regions on the fly Caveats \u00b6 Currently, assumes architecture can make 4-byte aligned accesses Not designed to be thread safe; the user must provide this Notes \u00b6 This code was based on the TLSF 1.4 spec and documentation found at: http://rtportal.upv.es/rtmalloc/allocators/tlsf/index.shtml It also leverages the TLSF 2.0 improvement to shrink the per-block overhead from 8 to 4 bytes. History \u00b6 2016/04/10 - v3.1 * Code moved to github * tlsfbits.h rolled into tlsf.c * License changed to BSD 2014/02/08 - v3.0 * This version is based on improvements from 3DInteractive GmbH * Interface changed to allow more than one memory pool * Separated pool handling from control structure (adding, removing, debugging) * Control structure and pools can still be constructed in the same memory block * Memory blocks for control structure and pools are checked for alignment * Added functions to retrieve control structure size, alignment size, min and max block size, overhead of pool structure, and overhead of a single allocation * Minimal Pool size is tlsf_block_size_min() + tlsf_pool_overhead() * Pool must be empty when it is removed, in order to allow O(1) removal 2011/10/20 - v2.0 * 64-bit support * More compiler intrinsics for ffs/fls * ffs/fls verification during TLSF creation in debug builds 2008/04/04 - v1.9 * Add tlsf_heap_check, a heap integrity check * Support a predefined tlsf_assert macro * Fix realloc case where block should shrink; if adjacent block is in use, execution would go down the slow path 2007/02/08 - v1.8 * Fix for unnecessary reallocation in tlsf_realloc 2007/02/03 - v1.7 * tlsf_heap_walk takes a callback * tlsf_realloc now returns NULL on failure * tlsf_memalign optimization for 4-byte alignment * Usage of size_t where appropriate 2006/11/21 - v1.6 * ffs/fls broken out into tlsfbits.h * tlsf_overhead queries per-pool overhead 2006/11/07 - v1.5 * Smart realloc implementation * Smart memalign implementation 2006/10/11 - v1.4 * Add some ffs/fls implementations * Minor code footprint reduction 2006/09/14 - v1.3 * Profiling indicates heavy use of blocks of size 1-128, so implement small block handling * Reduce pool overhead by about 1kb * Reduce minimum block size from 32 to 12 bytes * Realloc bug fix 2006/09/09 - v1.2 * Add tlsf_block_size * Static assertion mechanism for invariants * Minor bugfixes 2006/09/01 - v1.1 * Add tlsf_realloc * Add tlsf_walk_heap 2006/08/25 - v1.0 * First release Options \u00b6 subdivisions \u00b6 Number of subdivisions per memory pool: 16 \u2208 { 16, 32 } minimum_pool_size \u00b6 Minimum pool size in byte: 524288 \u2208 { 4096 .. 524288 .. 536870912 } Dependencies \u00b6 modm:tlsf modm_tlsf modm: tlsf modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_tlsf","title":"modm:tlsf"},{"location":"reference/module/modm-tlsf/#modmtlsf-tlsf-allocator","text":"Two-Level Segregated Fit memory allocator implementation. Written by Matthew Conte ( matt@baisoku.org ). Released under the BSD license. https://github.com/mattconte/tlsf","title":"modm:tlsf: TLSF Allocator"},{"location":"reference/module/modm-tlsf/#features","text":"O(1) cost for malloc, free, realloc, memalign Extremely low overhead per allocation (4 bytes) Low overhead per TLSF management of pools (~3kB) Low fragmentation Compiles to only a few kB of code and data Support for adding and removing memory pool regions on the fly","title":"Features"},{"location":"reference/module/modm-tlsf/#caveats","text":"Currently, assumes architecture can make 4-byte aligned accesses Not designed to be thread safe; the user must provide this","title":"Caveats"},{"location":"reference/module/modm-tlsf/#notes","text":"This code was based on the TLSF 1.4 spec and documentation found at: http://rtportal.upv.es/rtmalloc/allocators/tlsf/index.shtml It also leverages the TLSF 2.0 improvement to shrink the per-block overhead from 8 to 4 bytes.","title":"Notes"},{"location":"reference/module/modm-tlsf/#history","text":"2016/04/10 - v3.1 * Code moved to github * tlsfbits.h rolled into tlsf.c * License changed to BSD 2014/02/08 - v3.0 * This version is based on improvements from 3DInteractive GmbH * Interface changed to allow more than one memory pool * Separated pool handling from control structure (adding, removing, debugging) * Control structure and pools can still be constructed in the same memory block * Memory blocks for control structure and pools are checked for alignment * Added functions to retrieve control structure size, alignment size, min and max block size, overhead of pool structure, and overhead of a single allocation * Minimal Pool size is tlsf_block_size_min() + tlsf_pool_overhead() * Pool must be empty when it is removed, in order to allow O(1) removal 2011/10/20 - v2.0 * 64-bit support * More compiler intrinsics for ffs/fls * ffs/fls verification during TLSF creation in debug builds 2008/04/04 - v1.9 * Add tlsf_heap_check, a heap integrity check * Support a predefined tlsf_assert macro * Fix realloc case where block should shrink; if adjacent block is in use, execution would go down the slow path 2007/02/08 - v1.8 * Fix for unnecessary reallocation in tlsf_realloc 2007/02/03 - v1.7 * tlsf_heap_walk takes a callback * tlsf_realloc now returns NULL on failure * tlsf_memalign optimization for 4-byte alignment * Usage of size_t where appropriate 2006/11/21 - v1.6 * ffs/fls broken out into tlsfbits.h * tlsf_overhead queries per-pool overhead 2006/11/07 - v1.5 * Smart realloc implementation * Smart memalign implementation 2006/10/11 - v1.4 * Add some ffs/fls implementations * Minor code footprint reduction 2006/09/14 - v1.3 * Profiling indicates heavy use of blocks of size 1-128, so implement small block handling * Reduce pool overhead by about 1kb * Reduce minimum block size from 32 to 12 bytes * Realloc bug fix 2006/09/09 - v1.2 * Add tlsf_block_size * Static assertion mechanism for invariants * Minor bugfixes 2006/09/01 - v1.1 * Add tlsf_realloc * Add tlsf_walk_heap 2006/08/25 - v1.0 * First release","title":"History"},{"location":"reference/module/modm-tlsf/#options","text":"","title":"Options"},{"location":"reference/module/modm-tlsf/#subdivisions","text":"Number of subdivisions per memory pool: 16 \u2208 { 16, 32 }","title":"subdivisions"},{"location":"reference/module/modm-tlsf/#minimum_pool_size","text":"Minimum pool size in byte: 524288 \u2208 { 4096 .. 524288 .. 536870912 }","title":"minimum_pool_size"},{"location":"reference/module/modm-tlsf/#dependencies","text":"modm:tlsf modm_tlsf modm: tlsf modm_platform_cortex_m modm: platform: cortex-m modm_platform_cortex_m->modm_tlsf","title":"Dependencies"},{"location":"reference/module/modm-ui-animation/","text":"These module docs are in beta and may be incomplete. modm:ui:animation: Animators \u00b6 Various classes for animating values. Content \u00b6 // Class class modm :: ui :: Animation < typename T = uint8_t > ; class modm :: ui :: FastRamp < typename T = uint8_t > ; class modm :: ui :: Indicator < typename T = uint8_t > ; class modm :: ui :: KeyFrameAnimation < typename T = uint8_t , uint8_t N = 1 > ; class modm :: ui :: Pulse < typename T = uint8_t > ; class modm :: ui :: Strobe < typename T = uint8_t > ; // Struct struct modm :: ui :: FastRamp :: Computations < Type , uint16_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint32_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint8_t > ; struct modm :: ui :: FastRamp :: Computations < typename Type , typename Unsigned > ; struct modm :: ui :: KeyFrame < typename T = uint8_t , uint8_t N = 1 > ; // Enum enum KeyFrameAnimationMode ; Dependencies \u00b6 modm:ui:animation modm_ui_animation modm: ui: animation modm_architecture_clock modm: architecture: clock modm_ui_animation->modm_architecture_clock modm_math_utils modm: math: utils modm_ui_animation->modm_math_utils modm_ui modm: ui modm_ui_animation->modm_ui modm_ui_led modm: ui: led modm_ui_led->modm_ui_animation","title":"modm:ui:animation"},{"location":"reference/module/modm-ui-animation/#modmuianimation-animators","text":"Various classes for animating values.","title":"modm:ui:animation: Animators"},{"location":"reference/module/modm-ui-animation/#content","text":"// Class class modm :: ui :: Animation < typename T = uint8_t > ; class modm :: ui :: FastRamp < typename T = uint8_t > ; class modm :: ui :: Indicator < typename T = uint8_t > ; class modm :: ui :: KeyFrameAnimation < typename T = uint8_t , uint8_t N = 1 > ; class modm :: ui :: Pulse < typename T = uint8_t > ; class modm :: ui :: Strobe < typename T = uint8_t > ; // Struct struct modm :: ui :: FastRamp :: Computations < Type , uint16_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint32_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint8_t > ; struct modm :: ui :: FastRamp :: Computations < typename Type , typename Unsigned > ; struct modm :: ui :: KeyFrame < typename T = uint8_t , uint8_t N = 1 > ; // Enum enum KeyFrameAnimationMode ;","title":"Content"},{"location":"reference/module/modm-ui-animation/#dependencies","text":"modm:ui:animation modm_ui_animation modm: ui: animation modm_architecture_clock modm: architecture: clock modm_ui_animation->modm_architecture_clock modm_math_utils modm: math: utils modm_ui_animation->modm_math_utils modm_ui modm: ui modm_ui_animation->modm_ui modm_ui_led modm: ui: led modm_ui_led->modm_ui_animation","title":"Dependencies"},{"location":"reference/module/modm-ui-button/","text":"These module docs are in beta and may be incomplete. modm:ui:button: Debouncing Buttons \u00b6 The modm::ButtonGroup class is able to debounce eight buttons at the same time. The buttons have to be low-active. If this isn't the case invert their signal before passing it to the update() method. The update() method needs to be called periodically for example every 10ms. Preferred in a timer interrupt function. The detection for long or repeated presses works only correctly for one key at a time. This constraint only applies to buttons listed in the mask variable. Mode 1: Timeline ----> __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressed() ----X-------X----------------------X------- isRepeated() --------------------X--X--X--X------------- isReleased() -------X----------------------X-------X---- | |__|__| |_______| \\ / \\ interval timeout Mode 2: __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressedShort() -------X------------------------------X---- isPressedLong() --------------------X---------------------- isReleased() -------X----------------------X-------X---- This implementation is based on the C functions written by Peter Dannegger (see http://www.mikrocontroller.net/topic/48465 ). Content \u00b6 // Class class modm :: Button < typename PIN > ; class modm :: ButtonGroup < typename T = uint8_t > ; Dependencies \u00b6 modm:ui:button modm_ui_button modm: ui: button modm_architecture_atomic modm: architecture: atomic modm_ui_button->modm_architecture_atomic modm_ui modm: ui modm_ui_button->modm_ui","title":"modm:ui:button"},{"location":"reference/module/modm-ui-button/#modmuibutton-debouncing-buttons","text":"The modm::ButtonGroup class is able to debounce eight buttons at the same time. The buttons have to be low-active. If this isn't the case invert their signal before passing it to the update() method. The update() method needs to be called periodically for example every 10ms. Preferred in a timer interrupt function. The detection for long or repeated presses works only correctly for one key at a time. This constraint only applies to buttons listed in the mask variable. Mode 1: Timeline ----> __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressed() ----X-------X----------------------X------- isRepeated() --------------------X--X--X--X------------- isReleased() -------X----------------------X-------X---- | |__|__| |_______| \\ / \\ interval timeout Mode 2: __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressedShort() -------X------------------------------X---- isPressedLong() --------------------X---------------------- isReleased() -------X----------------------X-------X---- This implementation is based on the C functions written by Peter Dannegger (see http://www.mikrocontroller.net/topic/48465 ).","title":"modm:ui:button: Debouncing Buttons"},{"location":"reference/module/modm-ui-button/#content","text":"// Class class modm :: Button < typename PIN > ; class modm :: ButtonGroup < typename T = uint8_t > ;","title":"Content"},{"location":"reference/module/modm-ui-button/#dependencies","text":"modm:ui:button modm_ui_button modm: ui: button modm_architecture_atomic modm: architecture: atomic modm_ui_button->modm_architecture_atomic modm_ui modm: ui modm_ui_button->modm_ui","title":"Dependencies"},{"location":"reference/module/modm-ui-color/","text":"These module docs are in beta and may be incomplete. modm:ui:color: Color \u00b6 RGB and HSV containers and converters. Content \u00b6 // Class class modm :: color :: HsvT < class UnderlyingType = uint8_t > ; class modm :: color :: RgbT < class UnderlyingType = uint8_t > ; // Function IOStream & modm :: color :: operator << ( IOStream & os , const color :: RgbT < UnderlyingType > & color ); // Typedef typedef HsvT modm :: color :: Hsv ; typedef RgbT modm :: color :: Rgb ; Dependencies \u00b6 modm:ui:color modm_ui_color modm: ui: color modm_io modm: io modm_ui_color->modm_io modm_math_utils modm: math: utils modm_ui_color->modm_math_utils modm_ui modm: ui modm_ui_color->modm_ui modm_driver_tcs3414 modm: driver: tcs3414 modm_driver_tcs3414->modm_ui_color modm_driver_tcs3472 modm: driver: tcs3472 modm_driver_tcs3472->modm_ui_color modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_ui_color modm_ui_led modm: ui: led modm_ui_led->modm_ui_color","title":"modm:ui:color"},{"location":"reference/module/modm-ui-color/#modmuicolor-color","text":"RGB and HSV containers and converters.","title":"modm:ui:color: Color"},{"location":"reference/module/modm-ui-color/#content","text":"// Class class modm :: color :: HsvT < class UnderlyingType = uint8_t > ; class modm :: color :: RgbT < class UnderlyingType = uint8_t > ; // Function IOStream & modm :: color :: operator << ( IOStream & os , const color :: RgbT < UnderlyingType > & color ); // Typedef typedef HsvT modm :: color :: Hsv ; typedef RgbT modm :: color :: Rgb ;","title":"Content"},{"location":"reference/module/modm-ui-color/#dependencies","text":"modm:ui:color modm_ui_color modm: ui: color modm_io modm: io modm_ui_color->modm_io modm_math_utils modm: math: utils modm_ui_color->modm_math_utils modm_ui modm: ui modm_ui_color->modm_ui modm_driver_tcs3414 modm: driver: tcs3414 modm_driver_tcs3414->modm_ui_color modm_driver_tcs3472 modm: driver: tcs3472 modm_driver_tcs3472->modm_ui_color modm_driver_ws2812 modm: driver: ws2812 modm_driver_ws2812->modm_ui_color modm_ui_led modm: ui: led modm_ui_led->modm_ui_color","title":"Dependencies"},{"location":"reference/module/modm-ui-display/","text":"These module docs are in beta and may be incomplete. modm:ui:display: Display Graphics \u00b6 Code for writing and drawing on character and graphical displays. Coordinate System \u00b6 (0, 0) +---------------------+ | ----> X | | | | | | | | V Y | | | | | | | +---------------------+ e.g. (127, 63) The size (width and height) of a graphics primitive always correspond to its mathematical model, ignoring the rendered with. As everything is drawn one pixel wide, the pixels will be rendered to the right and below the mathematically defined points. Content \u00b6 // Class class modm :: CharacterDisplay :: Writer ; class modm :: CharacterDisplay ; class modm :: GraphicDisplay :: Writer ; class modm :: GraphicDisplay ; class modm :: MonochromeGraphicDisplayBufferedHorizontal < int16_t Width , int16_t Height > ; class modm :: MonochromeGraphicDisplayBufferedVertical < int16_t Width , int16_t Height > ; class modm :: VirtualGraphicDisplay ; class modm :: glcd :: Color ; // Variable const uint8_t bitmap :: home_16x16 [] ; const uint8_t bitmap :: logo_eurobot_90x64 [] ; const uint8_t bitmap :: logo_rca_90x64 [] ; const uint8_t bitmap :: skull_64x64 [] ; const uint8_t modm :: font :: AllCaps3x5 [] ; const uint8_t modm :: font :: ArcadeClassic [] ; const uint8_t modm :: font :: Assertion [] ; const uint8_t modm :: font :: FixedWidth5x8 [] ; const uint8_t modm :: font :: Matrix8x8 [] ; const uint8_t modm :: font :: Numbers14x32 [] ; const uint8_t modm :: font :: Numbers40x57 [] ; const uint8_t modm :: font :: Numbers46x64 [] ; const uint8_t modm :: font :: ScriptoNarrow [] ; const uint8_t modm :: font :: Ubuntu_36 [] ; // Typedef typedef Vector < int16_t , 2 > modm :: glcd :: Point ; Dependencies \u00b6 modm:ui:display modm_ui_display modm: ui: display modm_architecture_accessor modm: architecture: accessor modm_ui_display->modm_architecture_accessor modm_io modm: io modm_ui_display->modm_io modm_math_geometry modm: math: geometry modm_ui_display->modm_math_geometry modm_math_utils modm: math: utils modm_ui_display->modm_math_utils modm_ui modm: ui modm_ui_display->modm_ui modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_ui_display modm_driver_ads7843 modm: driver: ads7843 modm_driver_ads7843->modm_ui_display modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_ui_display modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_ui_display modm_driver_max7219 modm: driver: max7219 modm_driver_max7219->modm_ui_display modm_driver_nokia5110 modm: driver: nokia5110 modm_driver_nokia5110->modm_ui_display modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_driver_parallel_tft_display->modm_ui_display modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_ui_display modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_ui_display modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_ui_display modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_display modm_ui_menu modm: ui: menu modm_ui_menu->modm_ui_display","title":"modm:ui:display"},{"location":"reference/module/modm-ui-display/#modmuidisplay-display-graphics","text":"Code for writing and drawing on character and graphical displays.","title":"modm:ui:display: Display Graphics"},{"location":"reference/module/modm-ui-display/#coordinate-system","text":"(0, 0) +---------------------+ | ----> X | | | | | | | | V Y | | | | | | | +---------------------+ e.g. (127, 63) The size (width and height) of a graphics primitive always correspond to its mathematical model, ignoring the rendered with. As everything is drawn one pixel wide, the pixels will be rendered to the right and below the mathematically defined points.","title":"Coordinate System"},{"location":"reference/module/modm-ui-display/#content","text":"// Class class modm :: CharacterDisplay :: Writer ; class modm :: CharacterDisplay ; class modm :: GraphicDisplay :: Writer ; class modm :: GraphicDisplay ; class modm :: MonochromeGraphicDisplayBufferedHorizontal < int16_t Width , int16_t Height > ; class modm :: MonochromeGraphicDisplayBufferedVertical < int16_t Width , int16_t Height > ; class modm :: VirtualGraphicDisplay ; class modm :: glcd :: Color ; // Variable const uint8_t bitmap :: home_16x16 [] ; const uint8_t bitmap :: logo_eurobot_90x64 [] ; const uint8_t bitmap :: logo_rca_90x64 [] ; const uint8_t bitmap :: skull_64x64 [] ; const uint8_t modm :: font :: AllCaps3x5 [] ; const uint8_t modm :: font :: ArcadeClassic [] ; const uint8_t modm :: font :: Assertion [] ; const uint8_t modm :: font :: FixedWidth5x8 [] ; const uint8_t modm :: font :: Matrix8x8 [] ; const uint8_t modm :: font :: Numbers14x32 [] ; const uint8_t modm :: font :: Numbers40x57 [] ; const uint8_t modm :: font :: Numbers46x64 [] ; const uint8_t modm :: font :: ScriptoNarrow [] ; const uint8_t modm :: font :: Ubuntu_36 [] ; // Typedef typedef Vector < int16_t , 2 > modm :: glcd :: Point ;","title":"Content"},{"location":"reference/module/modm-ui-display/#dependencies","text":"modm:ui:display modm_ui_display modm: ui: display modm_architecture_accessor modm: architecture: accessor modm_ui_display->modm_architecture_accessor modm_io modm: io modm_ui_display->modm_io modm_math_geometry modm: math: geometry modm_ui_display->modm_math_geometry modm_math_utils modm: math: utils modm_ui_display->modm_math_utils modm_ui modm: ui modm_ui_display->modm_ui modm_board_disco_f469ni modm: board: disco-f469ni modm_board_disco_f469ni->modm_ui_display modm_driver_ads7843 modm: driver: ads7843 modm_driver_ads7843->modm_ui_display modm_driver_ea_dog modm: driver: ea_dog modm_driver_ea_dog->modm_ui_display modm_driver_hd44780 modm: driver: hd44780 modm_driver_hd44780->modm_ui_display modm_driver_max7219 modm: driver: max7219 modm_driver_max7219->modm_ui_display modm_driver_nokia5110 modm: driver: nokia5110 modm_driver_nokia5110->modm_ui_display modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_driver_parallel_tft_display->modm_ui_display modm_driver_siemens_s65 modm: driver: siemens_s65 modm_driver_siemens_s65->modm_ui_display modm_driver_siemens_s75 modm: driver: siemens_s75 modm_driver_siemens_s75->modm_ui_display modm_driver_ssd1306 modm: driver: ssd1306 modm_driver_ssd1306->modm_ui_display modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_display modm_ui_menu modm: ui: menu modm_ui_menu->modm_ui_display","title":"Dependencies"},{"location":"reference/module/modm-ui-gui/","text":"These module docs are in beta and may be incomplete. modm:ui:gui: Graphical User Interface \u00b6 Various classes for creating GUI applications. Content \u00b6 // Class class modm :: gui :: ArrowButton ; class modm :: gui :: AsyncEvent ; class modm :: gui :: ButtonWidget ; class modm :: gui :: CheckboxWidget ; class modm :: gui :: ColorPalette ; class modm :: gui :: FilledAreaButton ; class modm :: gui :: FloatField ; class modm :: gui :: GuiViewStack ; class modm :: gui :: InputEvent ; class modm :: gui :: Label ; class modm :: gui :: NumberField < typename T > ; class modm :: gui :: NumberRocker < typename T = int16_t > ; class modm :: gui :: StringField ; class modm :: gui :: StringRocker ; class modm :: gui :: TabPanel ; class modm :: gui :: View ; class modm :: gui :: Widget ; class modm :: gui :: WidgetGroup ; // Struct struct modm :: gui :: Dimension ; // Enum enum Color ; // Variable ColorPalette modm :: gui :: DefaultColorPalette ; int16_t modm :: gui :: uid_global = 0 ; // Typedef typedef NumberField < int16_t > modm :: gui :: IntegerField ; typedef NumberRocker < float > modm :: gui :: FloatRocker ; typedef NumberRocker < int16_t > modm :: gui :: IntegerRocker ; typedef modm :: DoublyLinkedList < AsyncEvent *> modm :: gui :: AsyncEventList ; typedef modm :: DynamicArray < Widget *> modm :: gui :: WidgetContainer ; typedef modm :: Queue < InputEvent * , modm :: LinkedList < InputEvent *> > modm :: gui :: inputQueue ; typedef modm :: glcd :: Point modm :: gui :: Point ; typedef struct modm :: gui :: Dimension modm :: gui :: Dimension ; typedef void ( * modm :: gui :: eventCallback ) ( const InputEvent & , Widget * , void * ))( const InputEvent & , Widget * , void * ); typedef void ( * modm :: gui :: genericCallback ) ( void * ))( void * ); // Define #define NULL Dependencies \u00b6 modm:ui:gui modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_gui modm_ui_gui->modm_ui_gui modm_container modm: container modm_ui_gui->modm_container modm_debug modm: debug modm_ui_gui->modm_debug modm_processing_timer modm: processing: timer modm_ui_gui->modm_processing_timer modm_ui modm: ui modm_ui_gui->modm_ui modm_ui_display modm: ui: display modm_ui_gui->modm_ui_display modm_ui_menu modm: ui: menu modm_ui_gui->modm_ui_menu","title":"modm:ui:gui"},{"location":"reference/module/modm-ui-gui/#modmuigui-graphical-user-interface","text":"Various classes for creating GUI applications.","title":"modm:ui:gui: Graphical User Interface"},{"location":"reference/module/modm-ui-gui/#content","text":"// Class class modm :: gui :: ArrowButton ; class modm :: gui :: AsyncEvent ; class modm :: gui :: ButtonWidget ; class modm :: gui :: CheckboxWidget ; class modm :: gui :: ColorPalette ; class modm :: gui :: FilledAreaButton ; class modm :: gui :: FloatField ; class modm :: gui :: GuiViewStack ; class modm :: gui :: InputEvent ; class modm :: gui :: Label ; class modm :: gui :: NumberField < typename T > ; class modm :: gui :: NumberRocker < typename T = int16_t > ; class modm :: gui :: StringField ; class modm :: gui :: StringRocker ; class modm :: gui :: TabPanel ; class modm :: gui :: View ; class modm :: gui :: Widget ; class modm :: gui :: WidgetGroup ; // Struct struct modm :: gui :: Dimension ; // Enum enum Color ; // Variable ColorPalette modm :: gui :: DefaultColorPalette ; int16_t modm :: gui :: uid_global = 0 ; // Typedef typedef NumberField < int16_t > modm :: gui :: IntegerField ; typedef NumberRocker < float > modm :: gui :: FloatRocker ; typedef NumberRocker < int16_t > modm :: gui :: IntegerRocker ; typedef modm :: DoublyLinkedList < AsyncEvent *> modm :: gui :: AsyncEventList ; typedef modm :: DynamicArray < Widget *> modm :: gui :: WidgetContainer ; typedef modm :: Queue < InputEvent * , modm :: LinkedList < InputEvent *> > modm :: gui :: inputQueue ; typedef modm :: glcd :: Point modm :: gui :: Point ; typedef struct modm :: gui :: Dimension modm :: gui :: Dimension ; typedef void ( * modm :: gui :: eventCallback ) ( const InputEvent & , Widget * , void * ))( const InputEvent & , Widget * , void * ); typedef void ( * modm :: gui :: genericCallback ) ( void * ))( void * ); // Define #define NULL","title":"Content"},{"location":"reference/module/modm-ui-gui/#dependencies","text":"modm:ui:gui modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_gui modm_ui_gui->modm_ui_gui modm_container modm: container modm_ui_gui->modm_container modm_debug modm: debug modm_ui_gui->modm_debug modm_processing_timer modm: processing: timer modm_ui_gui->modm_processing_timer modm_ui modm: ui modm_ui_gui->modm_ui modm_ui_display modm: ui: display modm_ui_gui->modm_ui_display modm_ui_menu modm: ui: menu modm_ui_gui->modm_ui_menu","title":"Dependencies"},{"location":"reference/module/modm-ui-led/","text":"These module docs are in beta and may be incomplete. modm:ui:led: LED Animation and Gamma Correction \u00b6 Header: #include <modm/ui/led.hpp> This module provides abstractions for animating LEDs by wrapping the modm:ui:animation module and providing look-up tables for performing gamma correction of LED brightness. The main functionality is part of the modm::ui::Led class, which provides a basic interface to fade an LED with an 8-bit value. Note that this class does not do any gamma correction on it's own, it just wraps an 8-bit modm::ui::Animation and a 8-bit value. You must provide a function handler which gets called whenever the LED value needs updating, at most every 1ms, but only when the value has actually changed. The implementation of this function is up to you. void led_handler ( uint8_t brightness ) { // LED control implementation = brightness } modm :: ui :: Led led_function ( led_handler ); // You may also use a lambda function for brevity modm :: ui :: Led led_lambda ([]( uint8_t brightness ) { // LED control implementation = brightness }); Animating LEDs \u00b6 To animate the LED you need to call the modm::ui::Led::update() member function regularly. The function updates the LED value at most every 1ms, however you may call it more often than that. If the function is called less regularly, it will automatically catch up the skipped milliseconds, and execute the brightness handler at most once if the value has changed. Depending on how smooth you require your animation to be, you may call the update function with intervals of up to 250ms. You can also pass the modm::ui::Led class directly into the modm::ui::KeyFrameAnimation class and it's derivatives, to animate it's brightness by interpolating between key frames. Note that you only need to call the update() member of the animator! modm :: ui :: Led led ; modm :: ui :: Indicator < uint8_t > indicator ( led ); indicator . start (); while ( 1 ) { indicator . update (); } If you want to animate a lot of LEDs it is more efficient to execute all update methods inside a 1ms modm::PeriodicTimer : modm :: PeriodicTimer update_timer ( 1 ); while ( 1 ) { if ( update_timer . execute ()) { led1 . update (); led2 . update (); // ... ledN . update (); } } Using Gamma Correction \u00b6 In order to map the linearly animated brightness value to a gamma-corrected value, this module by default generates look-up tables for a gamma value of 2.2 mapping from a 256 input range to 7, 8, 10, 12 and 16 bit resolution output ranges. The generated tables have this naming schema: modm::ui::table{gamma}_{output_bits}_{input_range} . For example, you can set up a timer to output 16-bit PWM to drive your LED, and use the modm::ui::table22_16_256 table to map the linear LED animation values to a gamma corrected 16-bit value: modm :: ui :: Led led_timer ([]( uint8_t brightness ) { Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_256 [ brightness ]); }); You may also generate other tables using the module options, for example, if you want to map a percentage (0-100%) to LED brightness, without scaling this to the full 256 value range, you can also generate a 100 value look-up table: <option name= \"modm:ui:led:range\" > 100,256 </option> <option name= \"modm:ui:led:bit\" > 8,16 </option> This module generated the product of these options, in this case 4 look-up tables. The linker will throw out those you don't use. namespace modm :: ui { /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 100 steps at 100 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_100 ; /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 256 steps at 256 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_256 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 100 steps at 200 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_100 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 256 steps at 512 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_256 ; } You can then animate your LED in the 0-99 value range: modm :: ui :: Led led_percentage ([]( uint8_t brightness ) { if ( brightness >= 100 ) brightness = 99 ; Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_100 [ brightness ]); }); uint8_t percent = 50 ; // fade to 50% brightness within 1 second led_percentage . fadeTo ( percent , 1000 ); Note that you can also use the handler to animate LEDs which are connected externally, for example, via a WS2812 LED chain. Here you can use a helper function to map the values into an array which then transferred into the WS2812 LED chain. uint8_t ws2812_values [ 3 ]; void ws2812_setter ( uint8_t index , uint8_t brightness ) { ws2812_values [ index ] = modm :: ui :: table22_8_256 [ brightness ]; } // Construct an array of LED animators modm :: ui :: Led leds [ 3 ] = { { []( uint8_t b ) { ws2812_setter ( 0 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 1 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 2 , b ); } }, }; // Group them together as one RGB LED modm :: ui :: RgbLed rgb ( leds [ 1 ], leds [ 0 ], leds [ 2 ]); // animate to orange within 2 seconds rgb . fadeTo ( modm :: ui :: Rgb ( 95 , 177 , 147 ), 2000 ); Options \u00b6 gamma \u00b6 Gamma correction of values: ['2.2'] \u2208 { 1.0 ... 3.0 } bit \u00b6 Resolution of target values: ['7', '8', '12', '16'] \u2208 { 2 ... 16 } range \u00b6 Range of input values: ['256'] \u2208 { 2 ... 1024 } Content \u00b6 // Class class modm :: ui :: Led ; class modm :: ui :: RgbLed ; // Variable modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_12_256 ; modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_16_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_7_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_8_256 ; Dependencies \u00b6 modm:ui:led modm_ui_led modm: ui: led modm_architecture_accessor modm: architecture: accessor modm_ui_led->modm_architecture_accessor modm_architecture_clock modm: architecture: clock modm_ui_led->modm_architecture_clock modm_processing_timer modm: processing: timer modm_ui_led->modm_processing_timer modm_ui modm: ui modm_ui_led->modm_ui modm_ui_animation modm: ui: animation modm_ui_led->modm_ui_animation modm_ui_color modm: ui: color modm_ui_led->modm_ui_color","title":"modm:ui:led"},{"location":"reference/module/modm-ui-led/#modmuiled-led-animation-and-gamma-correction","text":"Header: #include <modm/ui/led.hpp> This module provides abstractions for animating LEDs by wrapping the modm:ui:animation module and providing look-up tables for performing gamma correction of LED brightness. The main functionality is part of the modm::ui::Led class, which provides a basic interface to fade an LED with an 8-bit value. Note that this class does not do any gamma correction on it's own, it just wraps an 8-bit modm::ui::Animation and a 8-bit value. You must provide a function handler which gets called whenever the LED value needs updating, at most every 1ms, but only when the value has actually changed. The implementation of this function is up to you. void led_handler ( uint8_t brightness ) { // LED control implementation = brightness } modm :: ui :: Led led_function ( led_handler ); // You may also use a lambda function for brevity modm :: ui :: Led led_lambda ([]( uint8_t brightness ) { // LED control implementation = brightness });","title":"modm:ui:led: LED Animation and Gamma Correction"},{"location":"reference/module/modm-ui-led/#animating-leds","text":"To animate the LED you need to call the modm::ui::Led::update() member function regularly. The function updates the LED value at most every 1ms, however you may call it more often than that. If the function is called less regularly, it will automatically catch up the skipped milliseconds, and execute the brightness handler at most once if the value has changed. Depending on how smooth you require your animation to be, you may call the update function with intervals of up to 250ms. You can also pass the modm::ui::Led class directly into the modm::ui::KeyFrameAnimation class and it's derivatives, to animate it's brightness by interpolating between key frames. Note that you only need to call the update() member of the animator! modm :: ui :: Led led ; modm :: ui :: Indicator < uint8_t > indicator ( led ); indicator . start (); while ( 1 ) { indicator . update (); } If you want to animate a lot of LEDs it is more efficient to execute all update methods inside a 1ms modm::PeriodicTimer : modm :: PeriodicTimer update_timer ( 1 ); while ( 1 ) { if ( update_timer . execute ()) { led1 . update (); led2 . update (); // ... ledN . update (); } }","title":"Animating LEDs"},{"location":"reference/module/modm-ui-led/#using-gamma-correction","text":"In order to map the linearly animated brightness value to a gamma-corrected value, this module by default generates look-up tables for a gamma value of 2.2 mapping from a 256 input range to 7, 8, 10, 12 and 16 bit resolution output ranges. The generated tables have this naming schema: modm::ui::table{gamma}_{output_bits}_{input_range} . For example, you can set up a timer to output 16-bit PWM to drive your LED, and use the modm::ui::table22_16_256 table to map the linear LED animation values to a gamma corrected 16-bit value: modm :: ui :: Led led_timer ([]( uint8_t brightness ) { Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_256 [ brightness ]); }); You may also generate other tables using the module options, for example, if you want to map a percentage (0-100%) to LED brightness, without scaling this to the full 256 value range, you can also generate a 100 value look-up table: <option name= \"modm:ui:led:range\" > 100,256 </option> <option name= \"modm:ui:led:bit\" > 8,16 </option> This module generated the product of these options, in this case 4 look-up tables. The linker will throw out those you don't use. namespace modm :: ui { /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 100 steps at 100 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_100 ; /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 256 steps at 256 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_256 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 100 steps at 200 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_100 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 256 steps at 512 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_256 ; } You can then animate your LED in the 0-99 value range: modm :: ui :: Led led_percentage ([]( uint8_t brightness ) { if ( brightness >= 100 ) brightness = 99 ; Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_100 [ brightness ]); }); uint8_t percent = 50 ; // fade to 50% brightness within 1 second led_percentage . fadeTo ( percent , 1000 ); Note that you can also use the handler to animate LEDs which are connected externally, for example, via a WS2812 LED chain. Here you can use a helper function to map the values into an array which then transferred into the WS2812 LED chain. uint8_t ws2812_values [ 3 ]; void ws2812_setter ( uint8_t index , uint8_t brightness ) { ws2812_values [ index ] = modm :: ui :: table22_8_256 [ brightness ]; } // Construct an array of LED animators modm :: ui :: Led leds [ 3 ] = { { []( uint8_t b ) { ws2812_setter ( 0 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 1 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 2 , b ); } }, }; // Group them together as one RGB LED modm :: ui :: RgbLed rgb ( leds [ 1 ], leds [ 0 ], leds [ 2 ]); // animate to orange within 2 seconds rgb . fadeTo ( modm :: ui :: Rgb ( 95 , 177 , 147 ), 2000 );","title":"Using Gamma Correction"},{"location":"reference/module/modm-ui-led/#options","text":"","title":"Options"},{"location":"reference/module/modm-ui-led/#gamma","text":"Gamma correction of values: ['2.2'] \u2208 { 1.0 ... 3.0 }","title":"gamma"},{"location":"reference/module/modm-ui-led/#bit","text":"Resolution of target values: ['7', '8', '12', '16'] \u2208 { 2 ... 16 }","title":"bit"},{"location":"reference/module/modm-ui-led/#range","text":"Range of input values: ['256'] \u2208 { 2 ... 1024 }","title":"range"},{"location":"reference/module/modm-ui-led/#content","text":"// Class class modm :: ui :: Led ; class modm :: ui :: RgbLed ; // Variable modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_12_256 ; modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_16_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_7_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_8_256 ;","title":"Content"},{"location":"reference/module/modm-ui-led/#dependencies","text":"modm:ui:led modm_ui_led modm: ui: led modm_architecture_accessor modm: architecture: accessor modm_ui_led->modm_architecture_accessor modm_architecture_clock modm: architecture: clock modm_ui_led->modm_architecture_clock modm_processing_timer modm: processing: timer modm_ui_led->modm_processing_timer modm_ui modm: ui modm_ui_led->modm_ui modm_ui_animation modm: ui: animation modm_ui_led->modm_ui_animation modm_ui_color modm: ui: color modm_ui_led->modm_ui_color","title":"Dependencies"},{"location":"reference/module/modm-ui-menu/","text":"These module docs are in beta and may be incomplete. modm:ui:menu: Display Menu \u00b6 Simple to use classes for implementing menu structures on graphic displays. Some convenience classes for implementing menus. The menus are using a stack to allow stepping forward and backwards through the screens. The menus are based on the usage of five buttons. Inside most of the screens these buttons have the following functions: Left: Go back one screen. Right: Go to next screen. Up: Go to previous selected entry on screen Down: Go to next entry on screen OK: Edit selected entry Warning Some classes currently only work with the font modm::font::FixedWidth5x8 ! Content \u00b6 // Class class modm :: AbstractMenu ; class modm :: AbstractView ; class modm :: ChoiceMenu ; class modm :: ChoiceMenuEntry ; class modm :: CommunicatingView ; class modm :: CommunicatingViewStack ; class modm :: MenuEntryCallback ; class modm :: ScrollableText ; class modm :: StandardMenu ; class modm :: ViewStack ; // Struct struct modm :: MenuEntry ; // Enum enum Button ; Dependencies \u00b6 modm:ui:menu modm_ui_menu modm: ui: menu modm_communication_xpcc modm: communication: xpcc modm_ui_menu->modm_communication_xpcc modm_container modm: container modm_ui_menu->modm_container modm_processing_timer modm: processing: timer modm_ui_menu->modm_processing_timer modm_ui modm: ui modm_ui_menu->modm_ui modm_ui_display modm: ui: display modm_ui_menu->modm_ui_display modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_menu","title":"modm:ui:menu"},{"location":"reference/module/modm-ui-menu/#modmuimenu-display-menu","text":"Simple to use classes for implementing menu structures on graphic displays. Some convenience classes for implementing menus. The menus are using a stack to allow stepping forward and backwards through the screens. The menus are based on the usage of five buttons. Inside most of the screens these buttons have the following functions: Left: Go back one screen. Right: Go to next screen. Up: Go to previous selected entry on screen Down: Go to next entry on screen OK: Edit selected entry Warning Some classes currently only work with the font modm::font::FixedWidth5x8 !","title":"modm:ui:menu: Display Menu"},{"location":"reference/module/modm-ui-menu/#content","text":"// Class class modm :: AbstractMenu ; class modm :: AbstractView ; class modm :: ChoiceMenu ; class modm :: ChoiceMenuEntry ; class modm :: CommunicatingView ; class modm :: CommunicatingViewStack ; class modm :: MenuEntryCallback ; class modm :: ScrollableText ; class modm :: StandardMenu ; class modm :: ViewStack ; // Struct struct modm :: MenuEntry ; // Enum enum Button ;","title":"Content"},{"location":"reference/module/modm-ui-menu/#dependencies","text":"modm:ui:menu modm_ui_menu modm: ui: menu modm_communication_xpcc modm: communication: xpcc modm_ui_menu->modm_communication_xpcc modm_container modm: container modm_ui_menu->modm_container modm_processing_timer modm: processing: timer modm_ui_menu->modm_processing_timer modm_ui modm: ui modm_ui_menu->modm_ui modm_ui_display modm: ui: display modm_ui_menu->modm_ui_display modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_menu","title":"Dependencies"},{"location":"reference/module/modm-ui-time/","text":"These module docs are in beta and may be incomplete. modm:ui:time: Date and Time \u00b6 Content \u00b6 // Class class modm :: Date ; class modm :: UnixTime ; Dependencies \u00b6 modm:ui:time modm_ui_time modm: ui: time modm_architecture_accessor modm: architecture: accessor modm_ui_time->modm_architecture_accessor modm_ui modm: ui modm_ui_time->modm_ui","title":"modm:ui:time"},{"location":"reference/module/modm-ui-time/#modmuitime-date-and-time","text":"","title":"modm:ui:time: Date and Time"},{"location":"reference/module/modm-ui-time/#content","text":"// Class class modm :: Date ; class modm :: UnixTime ;","title":"Content"},{"location":"reference/module/modm-ui-time/#dependencies","text":"modm:ui:time modm_ui_time modm: ui: time modm_architecture_accessor modm: architecture: accessor modm_ui_time->modm_architecture_accessor modm_ui modm: ui modm_ui_time->modm_ui","title":"Dependencies"},{"location":"reference/module/modm-ui/","text":"These module docs are in beta and may be incomplete. modm:ui: User interface \u00b6 Interfacing with human users. Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures. Content \u00b6 // Class class modm :: AbstractMenu ; class modm :: AbstractView ; class modm :: Button < typename PIN > ; class modm :: ButtonGroup < typename T = uint8_t > ; class modm :: CharacterDisplay :: Writer ; class modm :: CharacterDisplay ; class modm :: ChoiceMenu ; class modm :: ChoiceMenuEntry ; class modm :: CommunicatingView ; class modm :: CommunicatingViewStack ; class modm :: Date ; class modm :: GraphicDisplay :: Writer ; class modm :: GraphicDisplay ; class modm :: MenuEntryCallback ; class modm :: MonochromeGraphicDisplayBufferedHorizontal < int16_t Width , int16_t Height > ; class modm :: MonochromeGraphicDisplayBufferedVertical < int16_t Width , int16_t Height > ; class modm :: ScrollableText ; class modm :: StandardMenu ; class modm :: UnixTime ; class modm :: ViewStack ; class modm :: VirtualGraphicDisplay ; class modm :: color :: HsvT < class UnderlyingType = uint8_t > ; class modm :: color :: RgbT < class UnderlyingType = uint8_t > ; class modm :: glcd :: Color ; class modm :: gui :: ArrowButton ; class modm :: gui :: AsyncEvent ; class modm :: gui :: ButtonWidget ; class modm :: gui :: CheckboxWidget ; class modm :: gui :: ColorPalette ; class modm :: gui :: FilledAreaButton ; class modm :: gui :: FloatField ; class modm :: gui :: GuiViewStack ; class modm :: gui :: InputEvent ; class modm :: gui :: Label ; class modm :: gui :: NumberField < typename T > ; class modm :: gui :: NumberRocker < typename T = int16_t > ; class modm :: gui :: StringField ; class modm :: gui :: StringRocker ; class modm :: gui :: TabPanel ; class modm :: gui :: View ; class modm :: gui :: Widget ; class modm :: gui :: WidgetGroup ; class modm :: ui :: Animation < typename T = uint8_t > ; class modm :: ui :: FastRamp < typename T = uint8_t > ; class modm :: ui :: Indicator < typename T = uint8_t > ; class modm :: ui :: KeyFrameAnimation < typename T = uint8_t , uint8_t N = 1 > ; class modm :: ui :: Led ; class modm :: ui :: Pulse < typename T = uint8_t > ; class modm :: ui :: RgbLed ; class modm :: ui :: Strobe < typename T = uint8_t > ; // Struct struct modm :: MenuEntry ; struct modm :: gui :: Dimension ; struct modm :: ui :: FastRamp :: Computations < Type , uint16_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint32_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint8_t > ; struct modm :: ui :: FastRamp :: Computations < typename Type , typename Unsigned > ; struct modm :: ui :: KeyFrame < typename T = uint8_t , uint8_t N = 1 > ; // Function IOStream & modm :: color :: operator << ( IOStream & os , const color :: RgbT < UnderlyingType > & color ); // Enum enum Button ; enum Color ; enum KeyFrameAnimationMode ; // Variable ColorPalette modm :: gui :: DefaultColorPalette ; const uint8_t bitmap :: home_16x16 [] ; const uint8_t bitmap :: logo_eurobot_90x64 [] ; const uint8_t bitmap :: logo_rca_90x64 [] ; const uint8_t bitmap :: skull_64x64 [] ; const uint8_t modm :: font :: AllCaps3x5 [] ; const uint8_t modm :: font :: ArcadeClassic [] ; const uint8_t modm :: font :: Assertion [] ; const uint8_t modm :: font :: FixedWidth5x8 [] ; const uint8_t modm :: font :: Matrix8x8 [] ; const uint8_t modm :: font :: Numbers14x32 [] ; const uint8_t modm :: font :: Numbers40x57 [] ; const uint8_t modm :: font :: Numbers46x64 [] ; const uint8_t modm :: font :: ScriptoNarrow [] ; const uint8_t modm :: font :: Ubuntu_36 [] ; int16_t modm :: gui :: uid_global = 0 ; modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_12_256 ; modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_16_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_7_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_8_256 ; // Typedef typedef HsvT modm :: color :: Hsv ; typedef NumberField < int16_t > modm :: gui :: IntegerField ; typedef NumberRocker < float > modm :: gui :: FloatRocker ; typedef NumberRocker < int16_t > modm :: gui :: IntegerRocker ; typedef RgbT modm :: color :: Rgb ; typedef Vector < int16_t , 2 > modm :: glcd :: Point ; typedef modm :: DoublyLinkedList < AsyncEvent *> modm :: gui :: AsyncEventList ; typedef modm :: DynamicArray < Widget *> modm :: gui :: WidgetContainer ; typedef modm :: Queue < InputEvent * , modm :: LinkedList < InputEvent *> > modm :: gui :: inputQueue ; typedef modm :: glcd :: Point modm :: gui :: Point ; typedef struct modm :: gui :: Dimension modm :: gui :: Dimension ; typedef void ( * modm :: gui :: eventCallback ) ( const InputEvent & , Widget * , void * ))( const InputEvent & , Widget * , void * ); typedef void ( * modm :: gui :: genericCallback ) ( void * ))( void * ); // Define #define NULL Dependencies \u00b6 modm:ui modm_ui modm: ui modm_ui_animation modm: ui: animation modm_ui_animation->modm_ui modm_ui_button modm: ui: button modm_ui_button->modm_ui modm_ui_color modm: ui: color modm_ui_color->modm_ui modm_ui_display modm: ui: display modm_ui_display->modm_ui modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui modm_ui_led modm: ui: led modm_ui_led->modm_ui modm_ui_menu modm: ui: menu modm_ui_menu->modm_ui modm_ui_time modm: ui: time modm_ui_time->modm_ui","title":"modm:ui"},{"location":"reference/module/modm-ui/#modmui-user-interface","text":"Interfacing with human users. Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures.","title":"modm:ui: User interface"},{"location":"reference/module/modm-ui/#content","text":"// Class class modm :: AbstractMenu ; class modm :: AbstractView ; class modm :: Button < typename PIN > ; class modm :: ButtonGroup < typename T = uint8_t > ; class modm :: CharacterDisplay :: Writer ; class modm :: CharacterDisplay ; class modm :: ChoiceMenu ; class modm :: ChoiceMenuEntry ; class modm :: CommunicatingView ; class modm :: CommunicatingViewStack ; class modm :: Date ; class modm :: GraphicDisplay :: Writer ; class modm :: GraphicDisplay ; class modm :: MenuEntryCallback ; class modm :: MonochromeGraphicDisplayBufferedHorizontal < int16_t Width , int16_t Height > ; class modm :: MonochromeGraphicDisplayBufferedVertical < int16_t Width , int16_t Height > ; class modm :: ScrollableText ; class modm :: StandardMenu ; class modm :: UnixTime ; class modm :: ViewStack ; class modm :: VirtualGraphicDisplay ; class modm :: color :: HsvT < class UnderlyingType = uint8_t > ; class modm :: color :: RgbT < class UnderlyingType = uint8_t > ; class modm :: glcd :: Color ; class modm :: gui :: ArrowButton ; class modm :: gui :: AsyncEvent ; class modm :: gui :: ButtonWidget ; class modm :: gui :: CheckboxWidget ; class modm :: gui :: ColorPalette ; class modm :: gui :: FilledAreaButton ; class modm :: gui :: FloatField ; class modm :: gui :: GuiViewStack ; class modm :: gui :: InputEvent ; class modm :: gui :: Label ; class modm :: gui :: NumberField < typename T > ; class modm :: gui :: NumberRocker < typename T = int16_t > ; class modm :: gui :: StringField ; class modm :: gui :: StringRocker ; class modm :: gui :: TabPanel ; class modm :: gui :: View ; class modm :: gui :: Widget ; class modm :: gui :: WidgetGroup ; class modm :: ui :: Animation < typename T = uint8_t > ; class modm :: ui :: FastRamp < typename T = uint8_t > ; class modm :: ui :: Indicator < typename T = uint8_t > ; class modm :: ui :: KeyFrameAnimation < typename T = uint8_t , uint8_t N = 1 > ; class modm :: ui :: Led ; class modm :: ui :: Pulse < typename T = uint8_t > ; class modm :: ui :: RgbLed ; class modm :: ui :: Strobe < typename T = uint8_t > ; // Struct struct modm :: MenuEntry ; struct modm :: gui :: Dimension ; struct modm :: ui :: FastRamp :: Computations < Type , uint16_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint32_t > ; struct modm :: ui :: FastRamp :: Computations < Type , uint8_t > ; struct modm :: ui :: FastRamp :: Computations < typename Type , typename Unsigned > ; struct modm :: ui :: KeyFrame < typename T = uint8_t , uint8_t N = 1 > ; // Function IOStream & modm :: color :: operator << ( IOStream & os , const color :: RgbT < UnderlyingType > & color ); // Enum enum Button ; enum Color ; enum KeyFrameAnimationMode ; // Variable ColorPalette modm :: gui :: DefaultColorPalette ; const uint8_t bitmap :: home_16x16 [] ; const uint8_t bitmap :: logo_eurobot_90x64 [] ; const uint8_t bitmap :: logo_rca_90x64 [] ; const uint8_t bitmap :: skull_64x64 [] ; const uint8_t modm :: font :: AllCaps3x5 [] ; const uint8_t modm :: font :: ArcadeClassic [] ; const uint8_t modm :: font :: Assertion [] ; const uint8_t modm :: font :: FixedWidth5x8 [] ; const uint8_t modm :: font :: Matrix8x8 [] ; const uint8_t modm :: font :: Numbers14x32 [] ; const uint8_t modm :: font :: Numbers40x57 [] ; const uint8_t modm :: font :: Numbers46x64 [] ; const uint8_t modm :: font :: ScriptoNarrow [] ; const uint8_t modm :: font :: Ubuntu_36 [] ; int16_t modm :: gui :: uid_global = 0 ; modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_12_256 ; modm :: accessor :: Flash < uint16_t > modm :: ui :: table22_16_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_7_256 ; modm :: accessor :: Flash < uint8_t > modm :: ui :: table22_8_256 ; // Typedef typedef HsvT modm :: color :: Hsv ; typedef NumberField < int16_t > modm :: gui :: IntegerField ; typedef NumberRocker < float > modm :: gui :: FloatRocker ; typedef NumberRocker < int16_t > modm :: gui :: IntegerRocker ; typedef RgbT modm :: color :: Rgb ; typedef Vector < int16_t , 2 > modm :: glcd :: Point ; typedef modm :: DoublyLinkedList < AsyncEvent *> modm :: gui :: AsyncEventList ; typedef modm :: DynamicArray < Widget *> modm :: gui :: WidgetContainer ; typedef modm :: Queue < InputEvent * , modm :: LinkedList < InputEvent *> > modm :: gui :: inputQueue ; typedef modm :: glcd :: Point modm :: gui :: Point ; typedef struct modm :: gui :: Dimension modm :: gui :: Dimension ; typedef void ( * modm :: gui :: eventCallback ) ( const InputEvent & , Widget * , void * ))( const InputEvent & , Widget * , void * ); typedef void ( * modm :: gui :: genericCallback ) ( void * ))( void * ); // Define #define NULL","title":"Content"},{"location":"reference/module/modm-ui/#dependencies","text":"modm:ui modm_ui modm: ui modm_ui_animation modm: ui: animation modm_ui_animation->modm_ui modm_ui_button modm: ui: button modm_ui_button->modm_ui modm_ui_color modm: ui: color modm_ui_color->modm_ui modm_ui_display modm: ui: display modm_ui_display->modm_ui modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui modm_ui_led modm: ui: led modm_ui_led->modm_ui modm_ui_menu modm: ui: menu modm_ui_menu->modm_ui modm_ui_time modm: ui: time modm_ui_time->modm_ui","title":"Dependencies"},{"location":"reference/module/modm-unittest/","text":"These module docs are in beta and may be incomplete. modm:unittest: Unit Tests \u00b6 Lightweight library for on-device unit testing. Content \u00b6 // Class class unittest :: Controller ; class unittest :: CountType ; class unittest :: Reporter ; class unittest :: TestSuite ; // Define #define TEST_ASSERT_DIFFERS(x, y) #define TEST_ASSERT_EQUALS(x, y) #define TEST_ASSERT_EQUALS_ARRAY(x, y, count, start) #define TEST_ASSERT_EQUALS_DELTA(x, y, d) #define TEST_ASSERT_EQUALS_FLOAT(x, y) #define TEST_ASSERT_EQUALS_RANGE(value, lower, upper) #define TEST_ASSERT_EQUALS_STRING(x, y) #define TEST_ASSERT_FALSE(expr) #define TEST_ASSERT_TRUE(expr) #define TEST_FAIL(msg) Dependencies \u00b6 modm:unittest modm_unittest modm: unittest modm_architecture_accessor modm: architecture: accessor modm_unittest->modm_architecture_accessor modm_io modm: io modm_unittest->modm_io","title":"modm:unittest"},{"location":"reference/module/modm-unittest/#modmunittest-unit-tests","text":"Lightweight library for on-device unit testing.","title":"modm:unittest: Unit Tests"},{"location":"reference/module/modm-unittest/#content","text":"// Class class unittest :: Controller ; class unittest :: CountType ; class unittest :: Reporter ; class unittest :: TestSuite ; // Define #define TEST_ASSERT_DIFFERS(x, y) #define TEST_ASSERT_EQUALS(x, y) #define TEST_ASSERT_EQUALS_ARRAY(x, y, count, start) #define TEST_ASSERT_EQUALS_DELTA(x, y, d) #define TEST_ASSERT_EQUALS_FLOAT(x, y) #define TEST_ASSERT_EQUALS_RANGE(value, lower, upper) #define TEST_ASSERT_EQUALS_STRING(x, y) #define TEST_ASSERT_FALSE(expr) #define TEST_ASSERT_TRUE(expr) #define TEST_FAIL(msg)","title":"Content"},{"location":"reference/module/modm-unittest/#dependencies","text":"modm:unittest modm_unittest modm: unittest modm_architecture_accessor modm: architecture: accessor modm_unittest->modm_architecture_accessor modm_io modm: io modm_unittest->modm_io","title":"Dependencies"},{"location":"reference/module/modm-utils/","text":"These module docs are in beta and may be incomplete. modm:utils: Utilities \u00b6 Content \u00b6 // Class class modm :: allocator :: AllocatorBase < typename T > ; class modm :: allocator :: Block < typename T , std :: size_t BLOCKSIZE > ; class modm :: allocator :: Dynamic < typename T > ; class modm :: allocator :: Static < typename T , std :: size_t N > ; // Struct struct modm :: allocator :: Block :: rebind < typename U > ; struct modm :: allocator :: Dynamic :: rebind < typename U > ; struct modm :: allocator :: Static :: rebind < typename U > ; // Function void modm :: dummy (); Dependencies \u00b6 modm:utils modm_utils modm: utils modm_architecture modm: architecture modm_utils->modm_architecture modm_architecture_atomic modm: architecture: atomic modm_architecture_atomic->modm_utils modm_architecture_heap modm: architecture: heap modm_architecture_heap->modm_utils modm_container modm: container modm_container->modm_utils modm_debug modm: debug modm_debug->modm_utils modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_utils modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_utils modm_driver_block_device_heap modm: driver: block.device: heap modm_driver_block_device_heap->modm_utils modm_math_matrix modm: math: matrix modm_math_matrix->modm_utils modm_platform_adc modm: platform: adc modm_platform_adc->modm_utils modm_platform_can modm: platform: can modm_platform_can->modm_utils modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio_common->modm_utils modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_utils","title":"modm:utils"},{"location":"reference/module/modm-utils/#modmutils-utilities","text":"","title":"modm:utils: Utilities"},{"location":"reference/module/modm-utils/#content","text":"// Class class modm :: allocator :: AllocatorBase < typename T > ; class modm :: allocator :: Block < typename T , std :: size_t BLOCKSIZE > ; class modm :: allocator :: Dynamic < typename T > ; class modm :: allocator :: Static < typename T , std :: size_t N > ; // Struct struct modm :: allocator :: Block :: rebind < typename U > ; struct modm :: allocator :: Dynamic :: rebind < typename U > ; struct modm :: allocator :: Static :: rebind < typename U > ; // Function void modm :: dummy ();","title":"Content"},{"location":"reference/module/modm-utils/#dependencies","text":"modm:utils modm_utils modm: utils modm_architecture modm: architecture modm_utils->modm_architecture modm_architecture_atomic modm: architecture: atomic modm_architecture_atomic->modm_utils modm_architecture_heap modm: architecture: heap modm_architecture_heap->modm_utils modm_container modm: container modm_container->modm_utils modm_debug modm: debug modm_debug->modm_utils modm_driver_ad7280a modm: driver: ad7280a modm_driver_ad7280a->modm_utils modm_driver_adc_sampler modm: driver: adc_sampler modm_driver_adc_sampler->modm_utils modm_driver_block_device_heap modm: driver: block.device: heap modm_driver_block_device_heap->modm_utils modm_math_matrix modm: math: matrix modm_math_matrix->modm_utils modm_platform_adc modm: platform: adc modm_platform_adc->modm_utils modm_platform_can modm: platform: can modm_platform_can->modm_utils modm_platform_gpio_common modm: platform: gpio.common modm_platform_gpio_common->modm_utils modm_platform_rcc modm: platform: rcc modm_platform_rcc->modm_utils","title":"Dependencies"}]}