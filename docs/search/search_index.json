{
    "docs": [
        {
            "location": "/",
            "text": "We're still porting this website over from \nxpcc.io\n. Please check the banner at the top of every page.\n\n\n\n\n\n\nThis page has been refactored and is up-to-date.\n\n\n\n\nmodm: a barebone embedded library generator\n\u00b6\n\n\n\n\n\n\n\n\nmodm (Modular Object-oriented Development for Microcontrollers) is a toolbox for\nbuilding custom C++14 libraries tailored to your embedded device.\nmodm generates startup code, HALs and their implementations, communication\nprotocols, drivers for external devices, BSPs, etc\u2026 in a modular, customizable\nprocess that you can fine-tune for your needs.\n\n\n\n\nFeast your eyes on lots of working examples\n.\n\n\n\n\n\nOur CI checks every contribution\n: \n\n\n\n\n\n\nThis project also has \nGetting Started guide\n as well as a \ntechnical blog\n to document larger design concepts.\n\n\n\n\nYou found a bug? \nOpen up an issue, we don't bite\n.\n\n\nYou want to contribute? \nRead the contribution guidelines\n and \nopen a pull request\n.\n\n\n\n\n\nmodm is optimized for the harsh requirements of the \nEurobot competition\n,\nwhere our robots need to run reliably and completely autonomously for the game's\n100 second duration. Our robots contain a lot of different microcontrollers, some\nwithout a lot of resources, so modm needs to fulfill a diverse set of objectives,\nlike small code size with small memory consumption, predictable program flow,\nextreme portability.\n\n\nThe source code is freely available under the MPLv2 license, so feel\nfree to fork this project and adapt it to your needs.\nThe only thing we ask of you is to contribute your changes back so everyone benefits.\n\n\nFeatures\n\u00b6\n\n\n\n\nEfficient and fast object-oriented C++14 API.\n\n\nSupport for hundreds of AVR and ARM Cortex-M microcontrollers from Atmel and ST.\n\n\nBuild system agnostic: We use SCons by default, but you don't have to.\n\n\nData-driven HAL generation using the library-builder engine.\n\n\nNo memory allocations in HAL with very low overall RAM consumption.\n\n\nHighly-configurable modules with sensible defaults and lots of documentation.\n\n\nCross platform peripheral interfaces incl. bit banging:\n\n\nGPIO and GPIO expanders.\n\n\nADC and Analog.\n\n\nUART, I\n2\nC, SPI, CAN.\n\n\n\n\n\n\nInterfaces and drivers for many external I2C and SPI sensors and devices.\n\n\nDebug/logging system with IOStream interface.\n\n\nLightweight, stackless threads and resumable functions using cooperative multitasking.\n\n\nUseful filter, interpolation and geometric algorithms.\n\n\nLightweight unit testing system (suitable for AVRs).\n\n\nGraphical user interface for small binary and color displays.\n\n\nHundreds of tests to ensure correct functionality.\n\n\n\n\nTargets\n\u00b6\n\n\nmodm can generate code for \n76\n AVR  and\n\n858\n STM32 devices, however,\nthere are different levels of support and testing.\n\n\n\n\n\n\n\n\n\n\nDevice Family\n\n\nSupport\n\n\nDevice Family\n\n\nSupport\n\n\n\n\n\n\n\n\n\n\nAVR\n\n\n\u2605\u2605\u2605\n\n\nSTM32F3\n\n\n\u2605\u2605\u2605\u2605\u2605\n\n\n\n\n\n\nSTM32F0\n\n\n\u2605\u2605\u2605\u2605\n\n\nSTM32F4\n\n\n\u2605\u2605\u2605\u2605\u2605\n\n\n\n\n\n\nSTM32F1\n\n\n\u2605\u2605\u2605\u2605\n\n\nSTM32F7\n\n\n\u2605\u2605\u2605\u2605\n\n\n\n\n\n\nSTM32F2\n\n\n\u2605\u2605\u2605\n\n\nSTM32L4\n\n\n\u2605\u2605\u2605\u2605\n\n\n\n\n\n\n\n\n\n\nAll of these targets are compiling and booting correctly\n(\u2605)\nand have GPIO and UART working\n(\u2605\u2605).\nMost targets have support for basic peripherals, like I2C, SPI and ADC\n(\u2605\u2605\u2605)\nas well as complicated peripherals, like Timers, CAN and external memory\n(\u2605\u2605\u2605\u2605).\nWe also use a few targets in everyday development, which are very well tested\n(\u2605\u2605\u2605\u2605\u2605).\n\n\nWe are only a small team of developers and are limited in the amount of targets\nwe can support and test in hardware. We have prepared, but currently not finished\nsupport for STM32F2, STM32L0 and STM32L1. \nOpen an issue\n to ask if your\nspecific target is supported out-of-the-box and what you can do if it's not.\n\n\nBoards\n\u00b6\n\n\nWe have out-of-box support for \nseveral development boards\n including\ndocumentation.\n\n\n\n\n\n\n\n\nAL-AVREB-CAN\n\n\nArduino Uno\n\n\nBlue Pill\n\n\nDISCO-F051R8\n\n\n\n\nDISCO-F072RB\n\n\nDISCO-F100RB\n\n\nDISCO-F303VC\n\n\nDISCO-F407VG\n\n\n\n\nDISCO-F429ZI\n\n\nDISCO-F469NI\n\n\nDISCO-F746NG\n\n\nDISCO-F769NI\n\n\n\n\nDISCO-L476VG\n\n\nNUCLEO-F031K6\n\n\nNUCLEO-F103RB\n\n\nNUCLEO-F303K8\n\n\n\n\nNUCLEO-F401RE\n\n\nNUCLEO-F411RE\n\n\nNUCLEO-F429ZI\n\n\nNUCLEO-L476RG\n\n\n\n\nOLIMEXINO-STM32\n\n\nSTM32F030F4P6-DEMO\n\n\n\n\n\n\n\n\nDrivers\n\u00b6\n\n\nWe also have a number of completely target-independent \ndrivers for external \ndevices\n connected via I\n2\nC, SPI, UART, BitBang, etc.\nMost of these also give you access to the entire device so you \ncan easily configure them for you specific needs.\n\n\n\n\n\n\n\n\n\n\nAD7280A\n\n\nAD7928\n\n\nADNS9800\n\n\nADS7843\n\n\nAMSYS5915\n\n\nSPI-FLASH\n\n\n\n\nBME280\n\n\nBMP085\n\n\nDS1302\n\n\nDS1631\n\n\nDS18B20\n\n\nEA-DOG\n\n\n\n\nFT245\n\n\nFT6X06\n\n\nHCLAx\n\n\nHD44780\n\n\nHMC58x\n\n\nHMC6343\n\n\n\n\nI2C-EEPROM\n\n\nITG3200\n\n\nL3GD20\n\n\nLAWICEL\n\n\nLIS302DL\n\n\nLIS3DSH\n\n\n\n\nLM75\n\n\nLSM303A\n\n\nLTC2984\n\n\nMAX6966\n\n\nMAX7219\n\n\nMCP23X17\n\n\n\n\nMCP2515\n\n\nNOKIA5110\n\n\nNRF24\n\n\nTFT-DISPLAY\n\n\nPCA8574\n\n\nPCA9535\n\n\n\n\nPCA9685\n\n\nSIEMENS-S65\n\n\nSIEMENS-S75\n\n\nSSD1306\n\n\nTCS3414\n\n\nTCS3472\n\n\n\n\nTMP102\n\n\nTMP175\n\n\nVL53L0\n\n\nVL6180\n\n\n\n\n\n\n\n\n\n\nExamples\n\u00b6\n\n\nWe have a \nhuge number of examples\n which are always up-to-date and\ncompilable as enforced by our CI.\n\n\n\n\n\n\n\n\nArduino Uno: basic/analog_read_serial\n\n\nArduino Uno: basic/blink\n\n\n\n\nArduino Uno: basic/digital_read_serial\n\n\nArduino Uno: basic/read_analog_voltage\n\n\n\n\nAVR: 1-wire/ds18b20\n\n\nAVR: adc/basic\n\n\n\n\nAVR: adc/oversample\n\n\nAVR: app_can2usb\n\n\n\n\nAVR: assert\n\n\nAVR: block_device_mirror\n\n\n\n\nAVR: can/mcp2515\n\n\nAVR: can/mcp2515_uart\n\n\n\n\nAVR: communication/receiver\n\n\nAVR: communication/sender\n\n\n\n\nAVR: display/dogm128/benchmark\n\n\nAVR: display/dogm128/caged_ball\n\n\n\n\nAVR: display/dogm128/draw\n\n\nAVR: display/dogm128/image\n\n\n\n\nAVR: display/dogm128/text\n\n\nAVR: display/dogm128/touch\n\n\n\n\nAVR: display/dogm132\n\n\nAVR: display/dogm163\n\n\n\n\nAVR: display/hd44780\n\n\nAVR: display/siemens_s65\n\n\n\n\nAVR: flash\n\n\nAVR: gpio/basic\n\n\n\n\nAVR: gpio/blinking\n\n\nAVR: gpio/button_group\n\n\n\n\nAVR: logger\n\n\nAVR: protothread\n\n\n\n\nAVR: pwm/pca9685\n\n\nAVR: sab/master\n\n\n\n\nAVR: sab/slave\n\n\nAVR: timeout\n\n\n\n\nAVR: uart/basic\n\n\nAVR: uart/extended\n\n\n\n\nGeneric: blinky\n\n\nGeneric: resumable\n\n\n\n\nGeneric: ros/environment\n\n\nGeneric: ros/sub_pub\n\n\n\n\nGeneric: rtc_ds1302\n\n\nLinux: assert\n\n\n\n\nLinux: block_device/file\n\n\nLinux: block_device/mirror\n\n\n\n\nLinux: block_device/ram\n\n\nLinux: build_info\n\n\n\n\nLinux: can_debugger\n\n\nLinux: communication/basic\n\n\n\n\nLinux: git\n\n\nLinux: gui/basic\n\n\n\n\nLinux: logger\n\n\nLinux: printf\n\n\n\n\nLinux: serial_interface\n\n\nLinux: static_serial_interface\n\n\n\n\nLinux: threads\n\n\nNUCLEO-F031K6: blink\n\n\n\n\nNUCLEO-F103RB: blink\n\n\nNUCLEO-F303K8: blink\n\n\n\n\nNUCLEO-F401RE: blink\n\n\nNUCLEO-F401RE: distance_vl53l0\n\n\n\n\nNUCLEO-F411RE: blink\n\n\nNUCLEO-F429ZI: blink\n\n\n\n\nNUCLEO-F429ZI: spi_flash\n\n\nNUCLEO-L476RG: adc\n\n\n\n\nNUCLEO-L476RG: blink\n\n\nNUCLEO-L476RG: i2c_test\n\n\n\n\nOLIMEXINO-STM32: blink\n\n\nSTM32F030F4P6-DEMO-BOARD: blink\n\n\n\n\nSTM32F072-DISCOVERY: blink\n\n\nSTM32F072-DISCOVERY: can\n\n\n\n\nSTM32F072-DISCOVERY: hard_fault\n\n\nSTM32F072-DISCOVERY: rotation\n\n\n\n\nSTM32F072-DISCOVERY: uart\n\n\nSTM32F072-DISCOVERY: unaligned_access\n\n\n\n\nSTM32F0-DISCOVERY: blink\n\n\nSTM32F0-DISCOVERY: logger\n\n\n\n\nSTM32F103C8T6-Blue Pill: adns_9800\n\n\nSTM32F103C8T6-Blue Pill: blink\n\n\n\n\nSTM32F103C8T6-Blue Pill: can\n\n\nSTM32F103C8T6-Blue Pill: environment\n\n\n\n\nSTM32F103C8T6-Blue Pill: logger\n\n\nSTM32F1-DISCOVERY: blink\n\n\n\n\nSTM32F1-DISCOVERY: logger\n\n\nSTM32F3-DISCOVERY: accelerometer\n\n\n\n\nSTM32F3-DISCOVERY: adc/continous\n\n\nSTM32F3-DISCOVERY: adc/interrupt\n\n\n\n\nSTM32F3-DISCOVERY: adc/simple\n\n\nSTM32F3-DISCOVERY: blink\n\n\n\n\nSTM32F3-DISCOVERY: can\n\n\nSTM32F3-DISCOVERY: ft245\n\n\n\n\nSTM32F3-DISCOVERY: gdb\n\n\nSTM32F3-DISCOVERY: hard_fault\n\n\n\n\nSTM32F3-DISCOVERY: rotation\n\n\nSTM32F3-DISCOVERY: timer/basic\n\n\n\n\nSTM32F3-DISCOVERY: uart/hal\n\n\nSTM32F3-DISCOVERY: uart/logger\n\n\n\n\nSTM32F429-DISCOVERY: blink\n\n\nSTM32F429-DISCOVERY: logger\n\n\n\n\nSTM32F469-DISCOVERY: assert\n\n\nSTM32F469-DISCOVERY: blink\n\n\n\n\nSTM32F469-DISCOVERY: display\n\n\nSTM32F469-DISCOVERY: game_of_life\n\n\n\n\nSTM32F469-DISCOVERY: tlsf-allocator\n\n\nSTM32F469-DISCOVERY: touchscreen\n\n\n\n\nSTM32F4-DISCOVERY: accelerometer\n\n\nSTM32F4-DISCOVERY: adc/interrupt\n\n\n\n\nSTM32F4-DISCOVERY: adc/oversample\n\n\nSTM32F4-DISCOVERY: adc/simple\n\n\n\n\nSTM32F4-DISCOVERY: app_uart_sniffer\n\n\nSTM32F4-DISCOVERY: barometer_bmp085_bmp180\n\n\n\n\nSTM32F4-DISCOVERY: blink\n\n\nSTM32F4-DISCOVERY: can\n\n\n\n\nSTM32F4-DISCOVERY: colour_tcs3414\n\n\nSTM32F4-DISCOVERY: display/hd44780\n\n\n\n\nSTM32F4-DISCOVERY: display/nokia_5110\n\n\nSTM32F4-DISCOVERY: display/ssd1306\n\n\n\n\nSTM32F4-DISCOVERY: distance_vl6180\n\n\nSTM32F4-DISCOVERY: exti\n\n\n\n\nSTM32F4-DISCOVERY: fpu\n\n\nSTM32F4-DISCOVERY: fsmc\n\n\n\n\nSTM32F4-DISCOVERY: hard_fault\n\n\nSTM32F4-DISCOVERY: led_matrix_display\n\n\n\n\nSTM32F4-DISCOVERY: open407v-d/gui\n\n\nSTM32F4-DISCOVERY: open407v-d/touchscreen\n\n\n\n\nSTM32F4-DISCOVERY: pressure_amsys5915\n\n\nSTM32F4-DISCOVERY: protothreads\n\n\n\n\nSTM32F4-DISCOVERY: radio/nrf24-basic-comm\n\n\nSTM32F4-DISCOVERY: radio/nrf24-data/rx\n\n\n\n\nSTM32F4-DISCOVERY: radio/nrf24-data/tx\n\n\nSTM32F4-DISCOVERY: radio/nrf24-phy-test\n\n\n\n\nSTM32F4-DISCOVERY: radio/nrf24-scanner\n\n\nSTM32F4-DISCOVERY: rtos/float_check\n\n\n\n\nSTM32F4-DISCOVERY: spi\n\n\nSTM32F4-DISCOVERY: temperature_ltc2984\n\n\n\n\nSTM32F4-DISCOVERY: timer\n\n\nSTM32F4-DISCOVERY: timer_test\n\n\n\n\nSTM32F4-DISCOVERY: uart\n\n\nSTM32F4-DISCOVERY: uart_spi\n\n\n\n\nSTM32F746G-DISCOVERY: adc_ad7928\n\n\nSTM32F746G-DISCOVERY: blink\n\n\n\n\nSTM32F769I-DISCOVERY: blink\n\n\nSTM32L476-DISCOVERY: blink\n\n\n\n\nWindows: build_info\n\n\nZMQ: 1_stm32\n\n\n\n\nZMQ: 2_zmq_gateway\n\n\nZMQ: 3_zmq_app\n\n\n\n\nZMQ: 4_zmq_backtoback",
            "title": "Introduction"
        },
        {
            "location": "/#modm-a-barebone-embedded-library-generator",
            "text": "modm (Modular Object-oriented Development for Microcontrollers) is a toolbox for\nbuilding custom C++14 libraries tailored to your embedded device.\nmodm generates startup code, HALs and their implementations, communication\nprotocols, drivers for external devices, BSPs, etc\u2026 in a modular, customizable\nprocess that you can fine-tune for your needs.   Feast your eyes on lots of working examples .   Our CI checks every contribution :     This project also has  Getting Started guide  as well as a  technical blog  to document larger design concepts.   You found a bug?  Open up an issue, we don't bite .  You want to contribute?  Read the contribution guidelines  and  open a pull request .   modm is optimized for the harsh requirements of the  Eurobot competition ,\nwhere our robots need to run reliably and completely autonomously for the game's\n100 second duration. Our robots contain a lot of different microcontrollers, some\nwithout a lot of resources, so modm needs to fulfill a diverse set of objectives,\nlike small code size with small memory consumption, predictable program flow,\nextreme portability.  The source code is freely available under the MPLv2 license, so feel\nfree to fork this project and adapt it to your needs.\nThe only thing we ask of you is to contribute your changes back so everyone benefits.",
            "title": "modm: a barebone embedded library generator"
        },
        {
            "location": "/#features",
            "text": "Efficient and fast object-oriented C++14 API.  Support for hundreds of AVR and ARM Cortex-M microcontrollers from Atmel and ST.  Build system agnostic: We use SCons by default, but you don't have to.  Data-driven HAL generation using the library-builder engine.  No memory allocations in HAL with very low overall RAM consumption.  Highly-configurable modules with sensible defaults and lots of documentation.  Cross platform peripheral interfaces incl. bit banging:  GPIO and GPIO expanders.  ADC and Analog.  UART, I 2 C, SPI, CAN.    Interfaces and drivers for many external I2C and SPI sensors and devices.  Debug/logging system with IOStream interface.  Lightweight, stackless threads and resumable functions using cooperative multitasking.  Useful filter, interpolation and geometric algorithms.  Lightweight unit testing system (suitable for AVRs).  Graphical user interface for small binary and color displays.  Hundreds of tests to ensure correct functionality.",
            "title": "Features"
        },
        {
            "location": "/#targets",
            "text": "modm can generate code for  76  AVR  and 858  STM32 devices, however,\nthere are different levels of support and testing.      Device Family  Support  Device Family  Support      AVR  \u2605\u2605\u2605  STM32F3  \u2605\u2605\u2605\u2605\u2605    STM32F0  \u2605\u2605\u2605\u2605  STM32F4  \u2605\u2605\u2605\u2605\u2605    STM32F1  \u2605\u2605\u2605\u2605  STM32F7  \u2605\u2605\u2605\u2605    STM32F2  \u2605\u2605\u2605  STM32L4  \u2605\u2605\u2605\u2605      All of these targets are compiling and booting correctly\n(\u2605)\nand have GPIO and UART working\n(\u2605\u2605).\nMost targets have support for basic peripherals, like I2C, SPI and ADC\n(\u2605\u2605\u2605)\nas well as complicated peripherals, like Timers, CAN and external memory\n(\u2605\u2605\u2605\u2605).\nWe also use a few targets in everyday development, which are very well tested\n(\u2605\u2605\u2605\u2605\u2605).  We are only a small team of developers and are limited in the amount of targets\nwe can support and test in hardware. We have prepared, but currently not finished\nsupport for STM32F2, STM32L0 and STM32L1.  Open an issue  to ask if your\nspecific target is supported out-of-the-box and what you can do if it's not.",
            "title": "Targets"
        },
        {
            "location": "/#boards",
            "text": "We have out-of-box support for  several development boards  including\ndocumentation.     AL-AVREB-CAN  Arduino Uno  Blue Pill  DISCO-F051R8   DISCO-F072RB  DISCO-F100RB  DISCO-F303VC  DISCO-F407VG   DISCO-F429ZI  DISCO-F469NI  DISCO-F746NG  DISCO-F769NI   DISCO-L476VG  NUCLEO-F031K6  NUCLEO-F103RB  NUCLEO-F303K8   NUCLEO-F401RE  NUCLEO-F411RE  NUCLEO-F429ZI  NUCLEO-L476RG   OLIMEXINO-STM32  STM32F030F4P6-DEMO",
            "title": "Boards"
        },
        {
            "location": "/#drivers",
            "text": "We also have a number of completely target-independent  drivers for external \ndevices  connected via I 2 C, SPI, UART, BitBang, etc.\nMost of these also give you access to the entire device so you \ncan easily configure them for you specific needs.      AD7280A  AD7928  ADNS9800  ADS7843  AMSYS5915  SPI-FLASH   BME280  BMP085  DS1302  DS1631  DS18B20  EA-DOG   FT245  FT6X06  HCLAx  HD44780  HMC58x  HMC6343   I2C-EEPROM  ITG3200  L3GD20  LAWICEL  LIS302DL  LIS3DSH   LM75  LSM303A  LTC2984  MAX6966  MAX7219  MCP23X17   MCP2515  NOKIA5110  NRF24  TFT-DISPLAY  PCA8574  PCA9535   PCA9685  SIEMENS-S65  SIEMENS-S75  SSD1306  TCS3414  TCS3472   TMP102  TMP175  VL53L0  VL6180",
            "title": "Drivers"
        },
        {
            "location": "/#examples",
            "text": "We have a  huge number of examples  which are always up-to-date and\ncompilable as enforced by our CI.     Arduino Uno: basic/analog_read_serial  Arduino Uno: basic/blink   Arduino Uno: basic/digital_read_serial  Arduino Uno: basic/read_analog_voltage   AVR: 1-wire/ds18b20  AVR: adc/basic   AVR: adc/oversample  AVR: app_can2usb   AVR: assert  AVR: block_device_mirror   AVR: can/mcp2515  AVR: can/mcp2515_uart   AVR: communication/receiver  AVR: communication/sender   AVR: display/dogm128/benchmark  AVR: display/dogm128/caged_ball   AVR: display/dogm128/draw  AVR: display/dogm128/image   AVR: display/dogm128/text  AVR: display/dogm128/touch   AVR: display/dogm132  AVR: display/dogm163   AVR: display/hd44780  AVR: display/siemens_s65   AVR: flash  AVR: gpio/basic   AVR: gpio/blinking  AVR: gpio/button_group   AVR: logger  AVR: protothread   AVR: pwm/pca9685  AVR: sab/master   AVR: sab/slave  AVR: timeout   AVR: uart/basic  AVR: uart/extended   Generic: blinky  Generic: resumable   Generic: ros/environment  Generic: ros/sub_pub   Generic: rtc_ds1302  Linux: assert   Linux: block_device/file  Linux: block_device/mirror   Linux: block_device/ram  Linux: build_info   Linux: can_debugger  Linux: communication/basic   Linux: git  Linux: gui/basic   Linux: logger  Linux: printf   Linux: serial_interface  Linux: static_serial_interface   Linux: threads  NUCLEO-F031K6: blink   NUCLEO-F103RB: blink  NUCLEO-F303K8: blink   NUCLEO-F401RE: blink  NUCLEO-F401RE: distance_vl53l0   NUCLEO-F411RE: blink  NUCLEO-F429ZI: blink   NUCLEO-F429ZI: spi_flash  NUCLEO-L476RG: adc   NUCLEO-L476RG: blink  NUCLEO-L476RG: i2c_test   OLIMEXINO-STM32: blink  STM32F030F4P6-DEMO-BOARD: blink   STM32F072-DISCOVERY: blink  STM32F072-DISCOVERY: can   STM32F072-DISCOVERY: hard_fault  STM32F072-DISCOVERY: rotation   STM32F072-DISCOVERY: uart  STM32F072-DISCOVERY: unaligned_access   STM32F0-DISCOVERY: blink  STM32F0-DISCOVERY: logger   STM32F103C8T6-Blue Pill: adns_9800  STM32F103C8T6-Blue Pill: blink   STM32F103C8T6-Blue Pill: can  STM32F103C8T6-Blue Pill: environment   STM32F103C8T6-Blue Pill: logger  STM32F1-DISCOVERY: blink   STM32F1-DISCOVERY: logger  STM32F3-DISCOVERY: accelerometer   STM32F3-DISCOVERY: adc/continous  STM32F3-DISCOVERY: adc/interrupt   STM32F3-DISCOVERY: adc/simple  STM32F3-DISCOVERY: blink   STM32F3-DISCOVERY: can  STM32F3-DISCOVERY: ft245   STM32F3-DISCOVERY: gdb  STM32F3-DISCOVERY: hard_fault   STM32F3-DISCOVERY: rotation  STM32F3-DISCOVERY: timer/basic   STM32F3-DISCOVERY: uart/hal  STM32F3-DISCOVERY: uart/logger   STM32F429-DISCOVERY: blink  STM32F429-DISCOVERY: logger   STM32F469-DISCOVERY: assert  STM32F469-DISCOVERY: blink   STM32F469-DISCOVERY: display  STM32F469-DISCOVERY: game_of_life   STM32F469-DISCOVERY: tlsf-allocator  STM32F469-DISCOVERY: touchscreen   STM32F4-DISCOVERY: accelerometer  STM32F4-DISCOVERY: adc/interrupt   STM32F4-DISCOVERY: adc/oversample  STM32F4-DISCOVERY: adc/simple   STM32F4-DISCOVERY: app_uart_sniffer  STM32F4-DISCOVERY: barometer_bmp085_bmp180   STM32F4-DISCOVERY: blink  STM32F4-DISCOVERY: can   STM32F4-DISCOVERY: colour_tcs3414  STM32F4-DISCOVERY: display/hd44780   STM32F4-DISCOVERY: display/nokia_5110  STM32F4-DISCOVERY: display/ssd1306   STM32F4-DISCOVERY: distance_vl6180  STM32F4-DISCOVERY: exti   STM32F4-DISCOVERY: fpu  STM32F4-DISCOVERY: fsmc   STM32F4-DISCOVERY: hard_fault  STM32F4-DISCOVERY: led_matrix_display   STM32F4-DISCOVERY: open407v-d/gui  STM32F4-DISCOVERY: open407v-d/touchscreen   STM32F4-DISCOVERY: pressure_amsys5915  STM32F4-DISCOVERY: protothreads   STM32F4-DISCOVERY: radio/nrf24-basic-comm  STM32F4-DISCOVERY: radio/nrf24-data/rx   STM32F4-DISCOVERY: radio/nrf24-data/tx  STM32F4-DISCOVERY: radio/nrf24-phy-test   STM32F4-DISCOVERY: radio/nrf24-scanner  STM32F4-DISCOVERY: rtos/float_check   STM32F4-DISCOVERY: spi  STM32F4-DISCOVERY: temperature_ltc2984   STM32F4-DISCOVERY: timer  STM32F4-DISCOVERY: timer_test   STM32F4-DISCOVERY: uart  STM32F4-DISCOVERY: uart_spi   STM32F746G-DISCOVERY: adc_ad7928  STM32F746G-DISCOVERY: blink   STM32F769I-DISCOVERY: blink  STM32L476-DISCOVERY: blink   Windows: build_info  ZMQ: 1_stm32   ZMQ: 2_zmq_gateway  ZMQ: 3_zmq_app   ZMQ: 4_zmq_backtoback",
            "title": "Examples"
        },
        {
            "location": "/how-modm-works/",
            "text": "This page has been refactored and is up-to-date.\n\n\n\n\nHow modm works\n\u00b6\n\n\nmodm is an umbrella project for a handful of stand-alone projects and acts as\na curated toolbox for creating custom C++ libraries for embedded targets.\nThree of these projects form the heart of modm:\n\n\n\n\nmodm-devices\n contains hardware descriptions like memories, peripherals and pins of many devices.\n\n\nmodm\n provides configurable modules to translate this data into code, tests and documentation.\n\n\nlbuild\n links these two together using the Jinja2 template engine in Python to create a custom library for your target.\n\n\n\n\nAs a developer you can use lbuild to explore the modm modules, configure them \nspecifically for your targets and needs and generate a custom library.\nYou can generate more than just code, in this example, lbuild also generates a \nbuild system which then compiles and links the application into a executable.\n\n\n\n\n\n\n\n\nWe've also put a lot of thought into modm-devices, about what data to extract,\nhow to format and store it. We automated the entire process to get the high\nquality data we use to build our library.\nYou can read all \nabout modm-devices in this blog post\n.\n\n\n\n\nmodm is highly modular\n\u00b6\n\n\nmodm's modules are kept small in scope on purpose and declare their dependencies,\nso that lbuild can build a minimal library from the initial modules you specified.\nSo if you only want to use our UART drivers for example, lbuild will only include\ncode from that module and its dependencies.\nThis makes it easier to understand what parts of modm you actually use, either\nby looking at the dependency graph before, or by inspecting the generated code\nafter calling lbuild, and gives you the opportunity to only use the parts of\nmodm you really like.\n\n\n\n\nA lbuild module is just a few lines of Python code. Here we can see the code for\nthe \nmodm:platform:uart\n module from the example above. It declares its name,\nits dependencies and then which files it wants to generate where to using the \ndata from modm-devices, by just setting the \nenv.substitutions\n to the device's\nproperties and calling \nenv.template\n with the input and output file names.\n\n\ndef\n \ninit\n(\nmodule\n):\n\n    \nmodule\n.\nname\n \n=\n \n\"uart\"\n\n    \nmodule\n.\nparent\n \n=\n \n\"platform\"\n\n\n\ndef\n \nprepare\n(\nmodule\n,\n \noptions\n):\n\n    \nmodule\n.\ndepends\n(\n\":architecture:interrupt\"\n,\n \n\":architecture:register\"\n,\n \n                   \n\":architecture:atomic\"\n,\n \n\":architecture:uart\"\n,\n \n\":platform:gpio\"\n)\n\n    \nreturn\n \nTrue\n\n\n\ndef\n \nbuild\n(\nenv\n):\n\n    \ndevice\n \n=\n \nenv\n[\n\":target\"\n]\n\n    \nenv\n.\nsubstitutions\n \n=\n \ndevice\n.\nproperties\n\n    \nenv\n.\noutbasepath\n \n=\n \n\"src/modm/platform/uart\"\n\n    \nfor\n \ninstance\n \nin\n \ndevice\n.\nget_driver\n(\n\"uart:stm32*\"\n)[\n\"instance\"\n]:\n\n        \nenv\n.\ntemplate\n(\n\"uart.hpp.in\"\n,\n \n\"uart_{}.hpp\"\n.\nformat\n(\ninstance\n))\n\n        \nenv\n.\ntemplate\n(\n\"uart.cpp.in\"\n,\n \n\"uart_{}.cpp\"\n.\nformat\n(\ninstance\n))\n\n\n\n\n\nThe input template then can access all the devices properties, and generate\nthe correct code for this device. Here the template on left is passed to the \n\nJinja2 engine\n which outputs the code on the right.\n\n\n\n\n\n\n\n\n\n\nvoid {{ name }}::write(uint8_t data)\n{\n%% if \"extended\" in driver[\"type\"]\n    {{ peripheral }}->TDR = data;\n%% else\n    {{ peripheral }}->DR = data;\n%% endif\n}\n\n\n\n\n\n\n\nvoid\n \nUart4\n::\nwrite\n(\nuint8_t\n \ndata\n)\n\n\n{\n\n    \nUART4\n->\nDR\n \n=\n \ndata\n;\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nThis example is simple, but since it's based on Python, \nanything more \ncomplicated is possible\n.\nLooking at the data excerpt from a STM32 device the above module will generate a\nonly three classes of this type for this target. However, a similar driver will\ngenerate classes for the four USART peripherals.\n\n\n...\n\n<driver\n \nname=\n\"uart\"\n \ntype=\n\"stm32\"\n>\n\n  \n<instance\n \nvalue=\n\"4\"\n/>\n\n  \n<instance\n \nvalue=\n\"5\"\n/>\n\n  \n<instance\n \nvalue=\n\"7\"\n/>\n\n\n</driver>\n\n\n<driver\n \nname=\n\"usart\"\n \ntype=\n\"stm32\"\n>\n\n  \n<instance\n \nvalue=\n\"1\"\n/>\n\n  \n<instance\n \nvalue=\n\"2\"\n/>\n\n  \n<instance\n \nvalue=\n\"3\"\n/>\n\n  \n<instance\n \nvalue=\n\"6\"\n/>\n\n\n</driver>\n\n...\n\n\n\n\nWith these techiques we can generate a target specific HAL for hundreds of devices.\nDon't believe us? \nCheck out our CI doing just that\n.\n\n\n\n\n\n\n\n\nmodm asserts at compile-time\n\u00b6\n\n\nmodm stands out for its extensive use of generated static C++ (template) classes.\nConsider this data from the GPIO peripheral, which shows the signal map for the\n\nPA0\n pin on a STM32 device.\n\n\n...\n\n<driver\n \nname=\n\"gpio\"\n \ntype=\n\"stm32\"\n>\n\n  \n<gpio\n \nport=\n\"a\"\n \npin=\n\"0\"\n>\n\n    \n<signal\n \ndriver=\n\"adc\"\n \ninstance=\n\"1\"\n \nname=\n\"in0\"\n/>\n\n    \n<signal\n \ndriver=\n\"adc\"\n \ninstance=\n\"2\"\n \nname=\n\"in0\"\n/>\n\n    \n<signal\n \ndriver=\n\"adc\"\n \ninstance=\n\"3\"\n \nname=\n\"in0\"\n/>\n\n    \n<signal\n \naf=\n\"1\"\n \ndriver=\n\"tim\"\n \ninstance=\n\"2\"\n \nname=\n\"ch1\"\n/>\n\n    \n<signal\n \naf=\n\"2\"\n \ndriver=\n\"tim\"\n \ninstance=\n\"5\"\n \nname=\n\"ch1\"\n/>\n\n    \n<signal\n \naf=\n\"8\"\n \ndriver=\n\"uart\"\n \ninstance=\n\"4\"\n \nname=\n\"tx\"\n/>\n\n    ...\n\n\n\n\nWe use this data in the \nmodm:platform:gpio\n module to generate type-safe \nsignal connections, which will then assert that the signal you want to connect\nactually exists on this pin and even gives you a helpful (!) error message at \ncompile time.\n\n\nclass\n \nGpioA0\n\n\n{\n\n\n...\n\n    \ntemplate\n<\n \nPeripheral\n \nperipheral\n \n>\n\n    \nstruct\n \nTx\n \n{\n\n        \nstatic_assert\n(\n\n            \n(\nperipheral\n \n==\n \nPeripheral\n::\nUart4\n),\n\n            \n\"GpioA0::Tx only connects to Uart4!\"\n);\n\n    \n};\n\n    \ntemplate\n<\n \nPeripheral\n \nperipheral\n \n>\n\n    \nstruct\n \nCh1\n \n{\n\n        \nstatic_assert\n(\n\n            \n(\nperipheral\n \n==\n \nPeripheral\n::\nTim2\n)\n \n||\n\n            \n(\nperipheral\n \n==\n \nPeripheral\n::\nTim5\n),\n\n            \n\"GpioA0::Ch1 only connects to Tim2 or Tim5!\"\n);\n\n    \n};\n\n    \ntemplate\n<\n \nPeripheral\n \nperipheral\n \n>\n\n    \nstruct\n \nIn0\n \n{\n\n        \nstatic_assert\n(\n\n            \n(\nperipheral\n \n==\n \nPeripheral\n::\nAdc1\n)\n \n||\n\n            \n(\nperipheral\n \n==\n \nPeripheral\n::\nAdc2\n)\n \n||\n\n            \n(\nperipheral\n \n==\n \nPeripheral\n::\nAdc3\n),\n\n            \n\"GpioA0::In0 only connects to Adc1 or Adc2 or Adc3!\"\n);\n\n    \n};\n\n\n...\n\n\n};\n\n\n\n\n\nContinuing with this technique, we can even check if your signal groups are \nconflict free of overlaps or invalid configurations and again give you a \nhelpful error message!\n\n\n\n\n\n\n\n\n\n\nUart4\n::\nconnect\n<\nGpioA0\n::\nTx\n>\n();\n\n\nAdc1\n::\nconnect\n<\nGpioA0\n::\nIn0\n,\n \nGpioA1\n::\nIn1\n>\n();\n\n\nTim2\n::\nconnect\n<\nGpioA0\n::\nCh1\n,\n \nGpioA1\n::\nCh2\n,\n \n              \nGpioA2\n::\nCh3\n,\n \nGpioA3\n::\nCh4\n>\n();\n\n\nTim5\n::\nconnect\n<\nGpioA0\n::\nCh1\n,\n \nGpioA1\n::\nCh2\n,\n \n              \nGpioA2\n::\nCh3\n,\n \nGpioA3\n::\nCh4\n>\n();\n\n\n\n\n\n\n\n\nMaps to GpioA0::setAlternateFunction(8);\nMaps to GpioAx::setAnalogInput();\nEach pin in group called with their\n    respective Alternate Function ID\nSame API, but for Timer5 different \n    Alternate Function IDs are used\n\n\n\n\n\n\n\n\n\n\n\nUart4\n::\nconnect\n<\nGpioA0\n::\nRx\n>\n();\n\n\n\n\n\n\n\n\nerror: 'Rx' is not a member of 'GpioA0'\n\n\n\n\n\n\n\n\n\n\n\nUart4\n::\nconnect\n<\nGpioA2\n::\nTx\n>\n();\n\n\n\n\n\n\n\n\nerror: GpioA2::Tx only connects to Usart2!\n\n\n\n\n\n\n\n\n\n\n\nUsart1\n::\nconnect\n<\nGpioA9\n::\nTx\n,\n \nGpioB7\n::\nRx\n>\n();\n\n\n\n\n\n\n\n\nerror: This pin set contains conflicting remap groups!\nAvailable groups for Usart1 are:\n Usart1 | 0  | 1\n--------|----|----\n   A9   | Tx |\n  A10   | Rx |\n   B6   |    | Tx\n   B7   |    | Rx\n\n\n\n\n\n\n\n\n\n\n\nWe use a similar technique to \ncompute baudrates at compile time\n\nand make sure the resulting baudrates remains within the specified error tolerances.\nIn addition the executable now only contains prescaler values which are written\ndirectly to the hardware without any computation required. This is very helpful\nfor keeping code size in check on very resource constrained targets, like the AVRs.\n\n\nUart4\n::\nconnect\n<\nGpioA0\n::\nTx\n,\n \nGpioA1\n::\nRx\n>\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n \n// pull-up in RX pin\n\n\nUart4\n::\ninitialize\n<\nBoard\n::\nsystemClock\n,\n \n115\n'\n200\n>\n();\n \n// Within 1% default tolerance\n\n\nUart4\n::\ninitialize\n<\nBoard\n::\nsystemClock\n,\n \n115\n'\n200\n,\n \nTolerance\n::\nExact\n>\n();\n\n\n// error: The closest available baudrate exceeds the tolerance of the requested baudrate!\n\n\n\n\n\nmodm is fast and usable\n\u00b6\n\n\nmodm's APIs are kept simple and fast by splitting up functionality into\nseparate, small, static functions, which implement the same behavior on all\nplatforms.\nAnd with our code generation capabilities, we can hide the crazy\nimplementation details of the hardware without compromising on performance.\nFor example, on different AVRs, simple things like enabling the internal pull-up resistor,\ndealing with external interrupts or even just toggling a pin is done quite dissimilarly in hardware, yet we can wrap this in the same API for every target.\n\n\nSince we\u2018re using static inlined functions that often just compile to a handful of instructions  we can call our GPIOs at \nludicrous speed\n.\n\n\n// All pin functions follow a common naming scheme\n\n\nusing\n \nLed\n \n=\n \nGpioB1\n;\n\n\nLed\n::\nsetOutput\n();\n\n\nLed\n::\nset\n();\n \nLed\n::\nreset\n();\n\n\nLed\n::\ntoggle\n();\n\n\nusing\n \nButton\n \n=\n \nGpioA0\n;\n\n\nButton\n::\nsetInput\n();\n\n\nbool\n \nstate\n \n=\n \nButton\n::\nread\n();\n\n\n\n// Depending on your targets, additional functions are available\n\n\nLed\n::\nsetOutput\n(\nGpio\n::\nOutputType\n::\nOpenDrain\n);\n\n\nButton\n::\nsetInput\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n\n\nButton\n::\nsetInputTrigger\n(\nGpio\n::\nInputTrigger\n::\nRisingEdge\n);\n\n\nButton\n::\nenableExternalInterrupt\n();\n\n\nButton\n::\nacknowledgeExternalInterruptFlag\n();\n\n\n\n\n\nYou can use these GPIOs as building blocks for more complex drivers and\nperipherals and still maintain access speed without sacrificing usability:\n\n\n// Create a hardware accelerated port of 4 bit width.\n\n\nusing\n \nPort4\n \n=\n \nGpioPort\n<\n \nGpioC0\n,\n \n4\n \n>\n;\n        \n// MSB -> C3, C2, C1, C0 <- LSB\n\n\nusing\n \nReadWrite\n \n=\n \nGpioC4\n;\n                   \n// \"name\" your GPIOs.\n\n\nusing\n \nReset\n \n=\n \nGpioOutputC5\n;\n\n\nusing\n \nEnable\n \n=\n \nGpioOutputC6\n;\n\n\n\n// Build a super fast character display driver using these inlined GPIOs.\n\n\nmodm\n::\nHd44780\n<\nPort4\n,\n \nReadWrite\n,\n \nReset\n,\n \nEnable\n>\n \ndisplay\n;\n\n\ndisplay\n.\ninitialize\n();\n   \n// driver knows to initialize for a 4 bit bus!\n\n\ndisplay\n \n<<\n \n\"Hello World!\"\n \n<<\n \nmodm\n::\nendl\n;\n    \n// Yes, ostreams. Deal with it.\n\n\ndisplay\n.\nprintf\n(\n\"You don't really have to use %s!\"\n,\n \n\"OStreams\"\n);\n\n\n\n\n\nAll drivers in modm follow the same principle of building up your hardware drivers from other parts of the HAL by passing them as template parameters. This works surprisingly well to reduce both code size and execution time. For example, here is how you assemble and initialize a driver for the MCP23x17 GPIO expander and then use its pins.\n\n\nusing\n \nTransport\n \n=\n \nmodm\n::\nMcp23TransportSpi\n<\n \nSpiMaster1\n,\n \nGpioA0\n \n>\n;\n\n\nusing\n \nGpioExpander\n \n=\n \nmodm\n::\nMcp23x17\n<\n \nTransport\n \n>\n;\n\n\nGpioExpander\n \nexpander\n;\n\n\n// Connect and initialize the peripherals\n\n\nSpiMaster1\n::\nconnect\n<\nGpioA0\n::\nSck\n,\n \nGpioA1\n::\nMosi\n,\n \nGpioA2\n::\nMiso\n>\n();\n\n\nSpiMaster1\n::\ninitialize\n<\nBoard\n::\nsystemClock\n,\n \n1\nMHz\n>\n();\n\n\nexpander\n.\ninitialize\n();\n\n\n// Bind the expander pins to a simpler name\n\n\nusing\n \nPin0\n \n=\n \nGpioExpander\n::\nP0\n<\n \nexpander\n \n>\n;\n\n\nusing\n \nPin1\n \n=\n \nGpioExpander\n::\nP1\n<\n \nexpander\n \n>\n;\n\n\n// Oh, look, same API\n\n\nPin0\n::\nsetOutput\n();\n\n\nPin0\n::\ntoggle\n();\n\n\nPin1\n::\nsetInput\n();\n\n\nbool\n \nstate\n \n=\n \nPin1\n::\nread\n();\n\n\n\n\n\nmodm is memory-efficient\n\u00b6\n\n\nOur HAL does not allocate memory dynamically \u2013 everything is either\nstatically allocated or must explicitly be allocated by the user.\nThis is a strong requirement for running modm on AVRs, which have\nlittle if any memory to spare for dynamic allocations.\n\n\nWe took great care to make sure this constraint remains usable, making \nconfiguration options first-class citizens in lbuild for you to easily discover\nand safely change. When we do need to allocate static memory, we choose a \nsensible default size for its purpose.\n\n\n $ lbuild discover-module-options\n...\nmodm:platform:core:main_stack_size = 3040  [256 ... 65536]\n\n  Minimum size of the application main stack\n...\nmodm:platform:uart:1:buffer.rx = 16  [1 ... 65534]\nmodm:platform:uart:1:buffer.tx = 250  [1 ... 65534]\n\n\n\n\nWe transparently show you how much static memory your application is using,\nso you get an idea of how much certain functionality costs you in resources.\nThis is the size of the accelerometer example on the STM32F4 discovery board:\n\n\n $ cd examples/stm32f4_discovery/accelerometer\n $ scons\n...\nMemory usage\u00b7\u00b7\u00b7 build/stm32f4_discovery/accelerometer/project.elf\n\nProgram:    8144B (0.8% used)\n(.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern +\n .table.section_heap + .table.zero.intern + .text)\n\nData:       3464B (1.7% used) = 424B static (0.2%) + 3040B stack (1.5%)\n(.bss + .fastdata + .stack)\n\nHeap:     197240B (98.3% available)\n(.heap0 + .heap1 + .heap2 + .heap5)\n\n\n\n\n\nmodm does multitasking\n\u00b6\n\n\n\n\n\nmodm uses stackless cooperative multitasking, for which we have ported\nprotothreads to C++ and extended them with resumable functions.\nThis enables you to split up your application into separate tasks, and use\nsynchronous APIs in all of them, without sacrificing overall responsiveness.\nThis works on even the most resource restricted AVRs, since each task only\nrequires 2 bytes of static RAM!\n\n\nAll our IC drivers are implemented using resumable functions, which can be\ncalled from within protothreads or explicitly blocking outside of them.\nHere is an example of \nreading out the accelerometer\n:\n\n\nclass\n \nReaderThread\n \n:\n \npublic\n \nmodm\n::\npt\n::\nProtothread\n\n\n{\n\n\npublic\n:\n\n    \nbool\n \nrun\n()\n\n    \n{\n\n        \nPT_BEGIN\n();\n\n        \n// The driver does several I2C transfer here to initialize and configure the\n\n        \n// external sensor. The CPU is free to do other things while this happens though.\n\n        \nPT_CALL\n(\naccelerometer\n.\nconfigure\n(\naccelerometer\n.\nScale\n::\nG2\n));\n\n\n        \nwhile\n \n(\ntrue\n)\n    \n// this feels quite similar to regular threads\n\n        \n{\n\n            \n// this resumable function will defer execution back to other protothreads\n\n            \nPT_CALL\n(\naccelerometer\n.\nreadAcceleration\n());\n\n\n            \n// smooth out the acceleration data a little bit\n\n            \naverageX\n.\nupdate\n(\naccelerometer\n.\ngetData\n().\ngetX\n());\n\n            \naverageY\n.\nupdate\n(\naccelerometer\n.\ngetData\n().\ngetY\n());\n\n\n            \n// set the boards LEDs depending on the acceleration values\n\n            \nLedUp\n::\nset\n(\n   \naverageX\n.\ngetValue\n()\n \n<\n \n-\n0.2\n);\n\n            \nLedDown\n::\nset\n(\n \naverageX\n.\ngetValue\n()\n \n>\n  \n0.2\n);\n\n            \nLedLeft\n::\nset\n(\n \naverageY\n.\ngetValue\n()\n \n<\n \n-\n0.2\n);\n\n            \nLedRight\n::\nset\n(\naverageY\n.\ngetValue\n()\n \n>\n  \n0.2\n);\n\n\n            \n// defer back to other protothreads until the timer fires\n\n            \nPT_WAIT_UNTIL\n(\ntimer\n.\nexecute\n());\n\n        \n}\n\n        \nPT_END\n();\n\n    \n}\n\n\nprivate\n:\n\n    \n// This accelerometer is connected via I2C.\n\n    \nmodm\n::\nLis3dsh\n<\n \nmodm\n::\nLis3TransportI2c\n<\n \nI2cMaster\n \n>\n \n>\n \naccelerometer\n;\n\n    \nmodm\n::\nPeriodicTimer\n \ntimer\n \n=\n \nmodm\n::\nPeriodicTimer\n(\n5\n);\n \n// 5ms periodic timer.\n\n    \nmodm\n::\nfilter\n::\nMovingAverage\n<\nfloat\n,\n \n25\n>\n \naverageX\n;\n\n    \nmodm\n::\nfilter\n::\nMovingAverage\n<\nfloat\n,\n \n25\n>\n \naverageY\n;\n\n\n};\n\n\nReaderThread\n \nreader\n;\n    \n// Protothread is statically allocated!\n\n\n\nint\n \nmain\n()\n \n// Execution entry point.\n\n\n{\n\n    \nwhile\n(\ntrue\n)\n\n    \n{\n   \n// the main loop with implicit round robin cooperative scheduling.\n\n        \nreader\n.\nrun\n();\n\n        \notherProtothreads\n.\nrun\n();\n\n    \n}\n\n    \nreturn\n \n0\n;\n\n\n}",
            "title": "How modm works"
        },
        {
            "location": "/how-modm-works/#how-modm-works",
            "text": "modm is an umbrella project for a handful of stand-alone projects and acts as\na curated toolbox for creating custom C++ libraries for embedded targets.\nThree of these projects form the heart of modm:   modm-devices  contains hardware descriptions like memories, peripherals and pins of many devices.  modm  provides configurable modules to translate this data into code, tests and documentation.  lbuild  links these two together using the Jinja2 template engine in Python to create a custom library for your target.   As a developer you can use lbuild to explore the modm modules, configure them \nspecifically for your targets and needs and generate a custom library.\nYou can generate more than just code, in this example, lbuild also generates a \nbuild system which then compiles and links the application into a executable.     We've also put a lot of thought into modm-devices, about what data to extract,\nhow to format and store it. We automated the entire process to get the high\nquality data we use to build our library.\nYou can read all  about modm-devices in this blog post .",
            "title": "How modm works"
        },
        {
            "location": "/how-modm-works/#modm-is-highly-modular",
            "text": "modm's modules are kept small in scope on purpose and declare their dependencies,\nso that lbuild can build a minimal library from the initial modules you specified.\nSo if you only want to use our UART drivers for example, lbuild will only include\ncode from that module and its dependencies.\nThis makes it easier to understand what parts of modm you actually use, either\nby looking at the dependency graph before, or by inspecting the generated code\nafter calling lbuild, and gives you the opportunity to only use the parts of\nmodm you really like.   A lbuild module is just a few lines of Python code. Here we can see the code for\nthe  modm:platform:uart  module from the example above. It declares its name,\nits dependencies and then which files it wants to generate where to using the \ndata from modm-devices, by just setting the  env.substitutions  to the device's\nproperties and calling  env.template  with the input and output file names.  def   init ( module ): \n     module . name   =   \"uart\" \n     module . parent   =   \"platform\"  def   prepare ( module ,   options ): \n     module . depends ( \":architecture:interrupt\" ,   \":architecture:register\" ,  \n                    \":architecture:atomic\" ,   \":architecture:uart\" ,   \":platform:gpio\" ) \n     return   True  def   build ( env ): \n     device   =   env [ \":target\" ] \n     env . substitutions   =   device . properties \n     env . outbasepath   =   \"src/modm/platform/uart\" \n     for   instance   in   device . get_driver ( \"uart:stm32*\" )[ \"instance\" ]: \n         env . template ( \"uart.hpp.in\" ,   \"uart_{}.hpp\" . format ( instance )) \n         env . template ( \"uart.cpp.in\" ,   \"uart_{}.cpp\" . format ( instance ))   The input template then can access all the devices properties, and generate\nthe correct code for this device. Here the template on left is passed to the  Jinja2 engine  which outputs the code on the right.      void {{ name }}::write(uint8_t data)\n{\n%% if \"extended\" in driver[\"type\"]\n    {{ peripheral }}->TDR = data;\n%% else\n    {{ peripheral }}->DR = data;\n%% endif\n}    void   Uart4 :: write ( uint8_t   data )  { \n     UART4 -> DR   =   data ;  }       This example is simple, but since it's based on Python,  anything more \ncomplicated is possible .\nLooking at the data excerpt from a STM32 device the above module will generate a\nonly three classes of this type for this target. However, a similar driver will\ngenerate classes for the four USART peripherals.  ... <driver   name= \"uart\"   type= \"stm32\" > \n   <instance   value= \"4\" /> \n   <instance   value= \"5\" /> \n   <instance   value= \"7\" />  </driver>  <driver   name= \"usart\"   type= \"stm32\" > \n   <instance   value= \"1\" /> \n   <instance   value= \"2\" /> \n   <instance   value= \"3\" /> \n   <instance   value= \"6\" />  </driver> \n...  With these techiques we can generate a target specific HAL for hundreds of devices.\nDon't believe us?  Check out our CI doing just that .",
            "title": "modm is highly modular"
        },
        {
            "location": "/how-modm-works/#modm-asserts-at-compile-time",
            "text": "modm stands out for its extensive use of generated static C++ (template) classes.\nConsider this data from the GPIO peripheral, which shows the signal map for the PA0  pin on a STM32 device.  ... <driver   name= \"gpio\"   type= \"stm32\" > \n   <gpio   port= \"a\"   pin= \"0\" > \n     <signal   driver= \"adc\"   instance= \"1\"   name= \"in0\" /> \n     <signal   driver= \"adc\"   instance= \"2\"   name= \"in0\" /> \n     <signal   driver= \"adc\"   instance= \"3\"   name= \"in0\" /> \n     <signal   af= \"1\"   driver= \"tim\"   instance= \"2\"   name= \"ch1\" /> \n     <signal   af= \"2\"   driver= \"tim\"   instance= \"5\"   name= \"ch1\" /> \n     <signal   af= \"8\"   driver= \"uart\"   instance= \"4\"   name= \"tx\" /> \n    ...  We use this data in the  modm:platform:gpio  module to generate type-safe \nsignal connections, which will then assert that the signal you want to connect\nactually exists on this pin and even gives you a helpful (!) error message at \ncompile time.  class   GpioA0  {  ... \n     template <   Peripheral   peripheral   > \n     struct   Tx   { \n         static_assert ( \n             ( peripheral   ==   Peripheral :: Uart4 ), \n             \"GpioA0::Tx only connects to Uart4!\" ); \n     }; \n     template <   Peripheral   peripheral   > \n     struct   Ch1   { \n         static_assert ( \n             ( peripheral   ==   Peripheral :: Tim2 )   || \n             ( peripheral   ==   Peripheral :: Tim5 ), \n             \"GpioA0::Ch1 only connects to Tim2 or Tim5!\" ); \n     }; \n     template <   Peripheral   peripheral   > \n     struct   In0   { \n         static_assert ( \n             ( peripheral   ==   Peripheral :: Adc1 )   || \n             ( peripheral   ==   Peripheral :: Adc2 )   || \n             ( peripheral   ==   Peripheral :: Adc3 ), \n             \"GpioA0::In0 only connects to Adc1 or Adc2 or Adc3!\" ); \n     };  ...  };   Continuing with this technique, we can even check if your signal groups are \nconflict free of overlaps or invalid configurations and again give you a \nhelpful error message!      Uart4 :: connect < GpioA0 :: Tx > ();  Adc1 :: connect < GpioA0 :: In0 ,   GpioA1 :: In1 > ();  Tim2 :: connect < GpioA0 :: Ch1 ,   GpioA1 :: Ch2 ,  \n               GpioA2 :: Ch3 ,   GpioA3 :: Ch4 > ();  Tim5 :: connect < GpioA0 :: Ch1 ,   GpioA1 :: Ch2 ,  \n               GpioA2 :: Ch3 ,   GpioA3 :: Ch4 > ();     Maps to GpioA0::setAlternateFunction(8);\nMaps to GpioAx::setAnalogInput();\nEach pin in group called with their\n    respective Alternate Function ID\nSame API, but for Timer5 different \n    Alternate Function IDs are used      Uart4 :: connect < GpioA0 :: Rx > ();     error: 'Rx' is not a member of 'GpioA0'      Uart4 :: connect < GpioA2 :: Tx > ();     error: GpioA2::Tx only connects to Usart2!      Usart1 :: connect < GpioA9 :: Tx ,   GpioB7 :: Rx > ();     error: This pin set contains conflicting remap groups!\nAvailable groups for Usart1 are:\n Usart1 | 0  | 1\n--------|----|----\n   A9   | Tx |\n  A10   | Rx |\n   B6   |    | Tx\n   B7   |    | Rx      We use a similar technique to  compute baudrates at compile time \nand make sure the resulting baudrates remains within the specified error tolerances.\nIn addition the executable now only contains prescaler values which are written\ndirectly to the hardware without any computation required. This is very helpful\nfor keeping code size in check on very resource constrained targets, like the AVRs.  Uart4 :: connect < GpioA0 :: Tx ,   GpioA1 :: Rx > ( Gpio :: InputType :: PullUp );   // pull-up in RX pin  Uart4 :: initialize < Board :: systemClock ,   115 ' 200 > ();   // Within 1% default tolerance  Uart4 :: initialize < Board :: systemClock ,   115 ' 200 ,   Tolerance :: Exact > ();  // error: The closest available baudrate exceeds the tolerance of the requested baudrate!",
            "title": "modm asserts at compile-time"
        },
        {
            "location": "/how-modm-works/#modm-is-fast-and-usable",
            "text": "modm's APIs are kept simple and fast by splitting up functionality into\nseparate, small, static functions, which implement the same behavior on all\nplatforms.\nAnd with our code generation capabilities, we can hide the crazy\nimplementation details of the hardware without compromising on performance.\nFor example, on different AVRs, simple things like enabling the internal pull-up resistor,\ndealing with external interrupts or even just toggling a pin is done quite dissimilarly in hardware, yet we can wrap this in the same API for every target.  Since we\u2018re using static inlined functions that often just compile to a handful of instructions  we can call our GPIOs at  ludicrous speed .  // All pin functions follow a common naming scheme  using   Led   =   GpioB1 ;  Led :: setOutput ();  Led :: set ();   Led :: reset ();  Led :: toggle ();  using   Button   =   GpioA0 ;  Button :: setInput ();  bool   state   =   Button :: read ();  // Depending on your targets, additional functions are available  Led :: setOutput ( Gpio :: OutputType :: OpenDrain );  Button :: setInput ( Gpio :: InputType :: PullUp );  Button :: setInputTrigger ( Gpio :: InputTrigger :: RisingEdge );  Button :: enableExternalInterrupt ();  Button :: acknowledgeExternalInterruptFlag ();   You can use these GPIOs as building blocks for more complex drivers and\nperipherals and still maintain access speed without sacrificing usability:  // Create a hardware accelerated port of 4 bit width.  using   Port4   =   GpioPort <   GpioC0 ,   4   > ;          // MSB -> C3, C2, C1, C0 <- LSB  using   ReadWrite   =   GpioC4 ;                     // \"name\" your GPIOs.  using   Reset   =   GpioOutputC5 ;  using   Enable   =   GpioOutputC6 ;  // Build a super fast character display driver using these inlined GPIOs.  modm :: Hd44780 < Port4 ,   ReadWrite ,   Reset ,   Enable >   display ;  display . initialize ();     // driver knows to initialize for a 4 bit bus!  display   <<   \"Hello World!\"   <<   modm :: endl ;      // Yes, ostreams. Deal with it.  display . printf ( \"You don't really have to use %s!\" ,   \"OStreams\" );   All drivers in modm follow the same principle of building up your hardware drivers from other parts of the HAL by passing them as template parameters. This works surprisingly well to reduce both code size and execution time. For example, here is how you assemble and initialize a driver for the MCP23x17 GPIO expander and then use its pins.  using   Transport   =   modm :: Mcp23TransportSpi <   SpiMaster1 ,   GpioA0   > ;  using   GpioExpander   =   modm :: Mcp23x17 <   Transport   > ;  GpioExpander   expander ;  // Connect and initialize the peripherals  SpiMaster1 :: connect < GpioA0 :: Sck ,   GpioA1 :: Mosi ,   GpioA2 :: Miso > ();  SpiMaster1 :: initialize < Board :: systemClock ,   1 MHz > ();  expander . initialize ();  // Bind the expander pins to a simpler name  using   Pin0   =   GpioExpander :: P0 <   expander   > ;  using   Pin1   =   GpioExpander :: P1 <   expander   > ;  // Oh, look, same API  Pin0 :: setOutput ();  Pin0 :: toggle ();  Pin1 :: setInput ();  bool   state   =   Pin1 :: read ();",
            "title": "modm is fast and usable"
        },
        {
            "location": "/how-modm-works/#modm-is-memory-efficient",
            "text": "Our HAL does not allocate memory dynamically \u2013 everything is either\nstatically allocated or must explicitly be allocated by the user.\nThis is a strong requirement for running modm on AVRs, which have\nlittle if any memory to spare for dynamic allocations.  We took great care to make sure this constraint remains usable, making \nconfiguration options first-class citizens in lbuild for you to easily discover\nand safely change. When we do need to allocate static memory, we choose a \nsensible default size for its purpose.   $ lbuild discover-module-options\n...\nmodm:platform:core:main_stack_size = 3040  [256 ... 65536]\n\n  Minimum size of the application main stack\n...\nmodm:platform:uart:1:buffer.rx = 16  [1 ... 65534]\nmodm:platform:uart:1:buffer.tx = 250  [1 ... 65534]  We transparently show you how much static memory your application is using,\nso you get an idea of how much certain functionality costs you in resources.\nThis is the size of the accelerometer example on the STM32F4 discovery board:   $ cd examples/stm32f4_discovery/accelerometer\n $ scons\n...\nMemory usage\u00b7\u00b7\u00b7 build/stm32f4_discovery/accelerometer/project.elf\n\nProgram:    8144B (0.8% used)\n(.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern +\n .table.section_heap + .table.zero.intern + .text)\n\nData:       3464B (1.7% used) = 424B static (0.2%) + 3040B stack (1.5%)\n(.bss + .fastdata + .stack)\n\nHeap:     197240B (98.3% available)\n(.heap0 + .heap1 + .heap2 + .heap5)",
            "title": "modm is memory-efficient"
        },
        {
            "location": "/how-modm-works/#modm-does-multitasking",
            "text": "modm uses stackless cooperative multitasking, for which we have ported\nprotothreads to C++ and extended them with resumable functions.\nThis enables you to split up your application into separate tasks, and use\nsynchronous APIs in all of them, without sacrificing overall responsiveness.\nThis works on even the most resource restricted AVRs, since each task only\nrequires 2 bytes of static RAM!  All our IC drivers are implemented using resumable functions, which can be\ncalled from within protothreads or explicitly blocking outside of them.\nHere is an example of  reading out the accelerometer :  class   ReaderThread   :   public   modm :: pt :: Protothread  {  public : \n     bool   run () \n     { \n         PT_BEGIN (); \n         // The driver does several I2C transfer here to initialize and configure the \n         // external sensor. The CPU is free to do other things while this happens though. \n         PT_CALL ( accelerometer . configure ( accelerometer . Scale :: G2 )); \n\n         while   ( true )      // this feels quite similar to regular threads \n         { \n             // this resumable function will defer execution back to other protothreads \n             PT_CALL ( accelerometer . readAcceleration ()); \n\n             // smooth out the acceleration data a little bit \n             averageX . update ( accelerometer . getData (). getX ()); \n             averageY . update ( accelerometer . getData (). getY ()); \n\n             // set the boards LEDs depending on the acceleration values \n             LedUp :: set (     averageX . getValue ()   <   - 0.2 ); \n             LedDown :: set (   averageX . getValue ()   >    0.2 ); \n             LedLeft :: set (   averageY . getValue ()   <   - 0.2 ); \n             LedRight :: set ( averageY . getValue ()   >    0.2 ); \n\n             // defer back to other protothreads until the timer fires \n             PT_WAIT_UNTIL ( timer . execute ()); \n         } \n         PT_END (); \n     }  private : \n     // This accelerometer is connected via I2C. \n     modm :: Lis3dsh <   modm :: Lis3TransportI2c <   I2cMaster   >   >   accelerometer ; \n     modm :: PeriodicTimer   timer   =   modm :: PeriodicTimer ( 5 );   // 5ms periodic timer. \n     modm :: filter :: MovingAverage < float ,   25 >   averageX ; \n     modm :: filter :: MovingAverage < float ,   25 >   averageY ;  };  ReaderThread   reader ;      // Protothread is statically allocated!  int   main ()   // Execution entry point.  { \n     while ( true ) \n     {     // the main loop with implicit round robin cooperative scheduling. \n         reader . run (); \n         otherProtothreads . run (); \n     } \n     return   0 ;  }",
            "title": "modm does multitasking"
        },
        {
            "location": "/who-we-are/",
            "text": "This page has been refactored and is up-to-date.\n\n\n\n\nWho we are\n\u00b6\n\n\nThe modm project is maintained by\nNiklas Hauser (\n@salkinium\n) with significant contributions from\nSascha Schade (\n@strongly-typed\n),\nFabian Greif (\n@dergraaf\n),\nKevin L\u00e4ufer (\n@ekiwi\n),\nMartin Rosekeit (\n@thundernail\n),\nDaniel Krebs (\n@daniel-k\n) and\nGeorgi Grinshpun (\n@georgi-g\n).\n\n\nWe all are or used to be members of the \nRoboterclub Aachen e.V.\n.\n\n\n\n\n\nHistory\n\u00b6\n\n\nIn the mid-2000s the \nRoboterclub Aachen e.V.\n has developed a software\nlibrary called XPCC for communication among components that are distributed on\nPCs and microcontrollers. This library was initially used only in autonomous\nrobots for the \nEurobot competition\n.\n\n\nIn 2009, XPCC became a separate project and over the years grew from a communication\nlibrary to a general purpose framework (called lowercase xpcc) suitable for all\nkinds of embedded applications.\n\n\nBetween 2016 and 2018, Niklas and Fabian refactored xpcc into modm by completely\nrewriting the way the library generates its HAL. This also gave us the tools to\nfix some larger architectural issues in xpcc's HAL as well as significantly\nimprove customizability of the HAL and its documentation.\nAll xpcc authors agreed to relicense their contributions from BSD to MPLv2 in modm.\n\n\nEurobot\n\u00b6\n\n\n\n\n\nAll our robots have been running modm successfully as their only OS for many years now.\nHere they are competing in the quarter finals of the \nEurobot 2015 competition\n.",
            "title": "Who we are"
        },
        {
            "location": "/who-we-are/#who-we-are",
            "text": "The modm project is maintained by\nNiklas Hauser ( @salkinium ) with significant contributions from\nSascha Schade ( @strongly-typed ),\nFabian Greif ( @dergraaf ),\nKevin L\u00e4ufer ( @ekiwi ),\nMartin Rosekeit ( @thundernail ),\nDaniel Krebs ( @daniel-k ) and\nGeorgi Grinshpun ( @georgi-g ).  We all are or used to be members of the  Roboterclub Aachen e.V. .",
            "title": "Who we are"
        },
        {
            "location": "/who-we-are/#history",
            "text": "In the mid-2000s the  Roboterclub Aachen e.V.  has developed a software\nlibrary called XPCC for communication among components that are distributed on\nPCs and microcontrollers. This library was initially used only in autonomous\nrobots for the  Eurobot competition .  In 2009, XPCC became a separate project and over the years grew from a communication\nlibrary to a general purpose framework (called lowercase xpcc) suitable for all\nkinds of embedded applications.  Between 2016 and 2018, Niklas and Fabian refactored xpcc into modm by completely\nrewriting the way the library generates its HAL. This also gave us the tools to\nfix some larger architectural issues in xpcc's HAL as well as significantly\nimprove customizability of the HAL and its documentation.\nAll xpcc authors agreed to relicense their contributions from BSD to MPLv2 in modm.",
            "title": "History"
        },
        {
            "location": "/who-we-are/#eurobot",
            "text": "All our robots have been running modm successfully as their only OS for many years now.\nHere they are competing in the quarter finals of the  Eurobot 2015 competition .",
            "title": "Eurobot"
        },
        {
            "location": "/guide/installation/",
            "text": "This page has been refactored and is up-to-date.\n\n\n\n\nInstallation\n\u00b6\n\n\nThis is the required software for generating, compiling and programming projects with modm:\n\n\n\n\nPython 3\n\n\nSoftware Construct\n\n\nLibrary Builder\n\n\nAVR toolchain: \navr-gcc\n and \navrdude\n\n\nARM toolchain: \ngcc-arm-toolchain\n and \nOpenOCD\n.\n\n\ndoxygen\n\n\n\n\nNote that the modm examples use the SCons build system by default, however,\nyou are not \nrequired\n to use it. See \nthe reference manual\n for\nadditional build system documentation.\n\n\n\n\nUse GCC 7 or newer\n\n\nmodm uses C++14, so you need \nat least\n GCC 5, preferably GCC 7.\n\n\n\n\n\n\nBeware of AVRs\n\n\nWe \nstrongly discourage\n using AVRs for new designs, due to\na significant lack of commitment from Atmel on keeping their AVR toolchain up-to-date.\n\n\n\n\n\n\nCheck your Locale\n\n\nIf you get a \nUnicodeEncodeError\n when calling \nlbuild\n, you may need to add\n\nexport LC_ALL=C.UTF-8\n to your \n.bashrc\n. Consult the internet until\n\npython3 -c \"import sys; print(sys.stdout.encoding)\"\n returns \nUTF-8\n.\n\n\n\n\nPlease \nhelp us keep these instructions up-to-date\n!\n\n\nmacOS\n\u00b6\n\n\nWe will use \nHomebrew\n to install the minimal build system:\n\n\nbrew install python3 scons git doxygen\npip3 install --user git+https://github.com/dergraaf/library-builder \\\n                    jinja2 configparser pyelftools\n\n\n\n\n\nInstall the \nAVR toolchain from source\n:\n\n\nbrew tap osx-cross/avr\nbrew install avr-gcc\n\n\n\n\n\nAnd the \nofficial ARM toolchain\n as well:\n\n\nbrew tap ARMmbed/formulae\nbrew install arm-none-eabi-gcc\nbrew install openocd --HEAD\n\n\n\n\n\nFor compiling modm on your computer you need to install boost:\n\n\nbrew install boost\n\n\n\n\n\nLinux\n\u00b6\n\n\nFor Ubuntu 16.04LTS, these commands install the basic build system:\n\n\nsudo apt-get install python3 python3-pip scons git\nsudo apt-get --no-install-recommends install doxygen\npip3 install --user git+https://github.com/dergraaf/library-builder \\\n                    jinja2 configparser pyelftools\n\n\n\n\n\nInstall the AVR toochain:\n\n\nsudo apt-get install gcc-avr binutils-avr avr-libc avrdude\n\n\n\n\n\n\n\navr-gcc on Ubuntu\n\n\nUbuntu does not provide a more recent avr-gcc than v4.9, which does not fully support C++14.\nFor our CI \nwe've created a precompiled version of avr-gcc 7 for Ubuntu\n.\nUse at your own risk.\n\n\n\n\nAnd the official ARM toolchain as well:\n\n\nsudo add-apt-repository ppa:team-gcc-arm-embedded/ppa\nsudo apt-get update\nsudo apt-get install gcc-arm-embedded openocd\n\n\n\n\n\nFor compiling modm on your computer install these packets:\n\n\nsudo apt-get install gcc build-essential libboost-thread-dev \\\n                     libboost-system-dev libasio-dev\n\n\n\n\n\nWindows\n\u00b6\n\n\nWe will use Anaconda to create a new Python 3 environment and install all necessary packages.\n\n\nconda create --name modm python=3\nactivate modm\nconda install -c conda-forge jinja2 scons future pyelftools git git+https://github.com/dergraaf/library-builder\n\n\n\n\n\nFor ARM development install the Windows 32-bit build of the \nGNU Arm Embedded Toolchain\n.\nFor programming and debugging ARM Cortex-M devices install the pre-build \nOpenOCD binaries\n.\nYou'll need to add both \n/bin\n paths to your \nPATH\n variable manually.\n\n\n\n\nFor non-English speakers\n\n\nFor now project and build paths containing non-ASCII characters are not parsed correctly.\n\n\n\n\n\n\nDear Windows users\n\n\nWe don't regularly use Windows with modm, so we rely on YOU to keep these install instructions\nworking and up-to-date. Please \nopen a PR with improvements\n.",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#installation",
            "text": "This is the required software for generating, compiling and programming projects with modm:   Python 3  Software Construct  Library Builder  AVR toolchain:  avr-gcc  and  avrdude  ARM toolchain:  gcc-arm-toolchain  and  OpenOCD .  doxygen   Note that the modm examples use the SCons build system by default, however,\nyou are not  required  to use it. See  the reference manual  for\nadditional build system documentation.   Use GCC 7 or newer  modm uses C++14, so you need  at least  GCC 5, preferably GCC 7.    Beware of AVRs  We  strongly discourage  using AVRs for new designs, due to\na significant lack of commitment from Atmel on keeping their AVR toolchain up-to-date.    Check your Locale  If you get a  UnicodeEncodeError  when calling  lbuild , you may need to add export LC_ALL=C.UTF-8  to your  .bashrc . Consult the internet until python3 -c \"import sys; print(sys.stdout.encoding)\"  returns  UTF-8 .   Please  help us keep these instructions up-to-date !",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#macos",
            "text": "We will use  Homebrew  to install the minimal build system:  brew install python3 scons git doxygen\npip3 install --user git+https://github.com/dergraaf/library-builder \\\n                    jinja2 configparser pyelftools  Install the  AVR toolchain from source :  brew tap osx-cross/avr\nbrew install avr-gcc  And the  official ARM toolchain  as well:  brew tap ARMmbed/formulae\nbrew install arm-none-eabi-gcc\nbrew install openocd --HEAD  For compiling modm on your computer you need to install boost:  brew install boost",
            "title": "macOS"
        },
        {
            "location": "/guide/installation/#linux",
            "text": "For Ubuntu 16.04LTS, these commands install the basic build system:  sudo apt-get install python3 python3-pip scons git\nsudo apt-get --no-install-recommends install doxygen\npip3 install --user git+https://github.com/dergraaf/library-builder \\\n                    jinja2 configparser pyelftools  Install the AVR toochain:  sudo apt-get install gcc-avr binutils-avr avr-libc avrdude   avr-gcc on Ubuntu  Ubuntu does not provide a more recent avr-gcc than v4.9, which does not fully support C++14.\nFor our CI  we've created a precompiled version of avr-gcc 7 for Ubuntu .\nUse at your own risk.   And the official ARM toolchain as well:  sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa\nsudo apt-get update\nsudo apt-get install gcc-arm-embedded openocd  For compiling modm on your computer install these packets:  sudo apt-get install gcc build-essential libboost-thread-dev \\\n                     libboost-system-dev libasio-dev",
            "title": "Linux"
        },
        {
            "location": "/guide/installation/#windows",
            "text": "We will use Anaconda to create a new Python 3 environment and install all necessary packages.  conda create --name modm python=3\nactivate modm\nconda install -c conda-forge jinja2 scons future pyelftools git git+https://github.com/dergraaf/library-builder  For ARM development install the Windows 32-bit build of the  GNU Arm Embedded Toolchain .\nFor programming and debugging ARM Cortex-M devices install the pre-build  OpenOCD binaries .\nYou'll need to add both  /bin  paths to your  PATH  variable manually.   For non-English speakers  For now project and build paths containing non-ASCII characters are not parsed correctly.    Dear Windows users  We don't regularly use Windows with modm, so we rely on YOU to keep these install instructions\nworking and up-to-date. Please  open a PR with improvements .",
            "title": "Windows"
        },
        {
            "location": "/guide/getting-started/",
            "text": "This page has been refactored and is up-to-date.\n\n\n\n\nGetting Started\n\u00b6\n\n\nThe easiest way for you to learn about modm's APIs is to look at and \nexperiment with \nour examples\n, especially if you have a development \nboard that modm supports out-of-box.\n\n\nHere are our favorite examples for our supported development boards:\n\n\n\n\n\n\n\nArduino Uno:\n\nBlinky\n,\n\nButton & Serial\n,\n\nAnalog & Serial\n.\n\n\nNUCLEO-F031K6:\n\nBlinky & Serial\n.\n\n\nNUCLEO-F103RB:\n\nBlinky & Serial\n.\n\n\nSTM32F072 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nGyroscope\n.\n\n\nSTM32F3 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nAccelerometer\n,\n\nGyroscope\n,\n\nDebugging with GDB\n.\n\n\nSTM32F4 Discovery:\n\nBlinky\n,\n\nCAN\n,\n\nAccelerometer\n,\n\nTimer & LED Animations\n,\n\nDebugging hard faults\n.\n\n\nSTM32F469 Discovery:\n\nBlinky\n,\n\nDrawing on display\n,\n\nTouchscreen inputs\n,\n\nMulti-heap with external 16MB memory\n,\n\nGame of Life in Color with Multitouch\n\n\nSTM32F769 Discovery:\n\nFPU with double precision\n\n\n\n\nHere are some additional examples of displays and sensors we like:\n\n\n\n\nSSD1306 OLED display\n: Draws text and graphics onto I2C display.\n\n\nBMP085/BMP180 barometer\n: Reads atmospheric pressure and temperature from I2C sensor.\n\n\nBMP180/BME280 barometer\n: Reads atmospheric pressure and temperature from multiple I2C sensors.\n\n\nVL6180 time-of-flight distance sensor\n: Reads distance and ambient light from I2C sensor.\n\n\nVL53L0  time-of-flight distance sensor\n: Much improved version of the VL6180 sensor.\n\n\nADNS9800 motion sensor\n: Reads 2D motion from SPI sensor used in gaming mice.\n\n\nTCS3414 color sensor\n: Reads RGB color from I2C sensor.\n\n\nHD44780 over I2C-GPIO expander\n: Draws text via native GPIO port or I2C-GPIO expander port onto character display.\n\n\n\n\n\nHave a look at the \nbuild system references\n to \nsee how to compile and program your targets.\n\n\nYour own Project\n\u00b6\n\n\nTo generate a modm library for your own project, you need to define a \nproject.xml\n\nfile, which contains the path to where modm is, as well as repository and module options\nand of course which modules you want to have generated.\nmodm will generate a library that is self-contained, so you don't \nneed\n to add\nmodm as a submodule or similar to your repository. However we still recommend it.\n\n\nUsing a Board Support Package\n\u00b6\n\n\nWe recommend building on a BSP, where you can just inherit from an existing\nproject configuration, which contains the minimal set of modules to use the board\nas well as pre-defines several important options for this board.\nYou can then add all the modules you need and configure them as you want.\n\n\n<?xml version='1.0' encoding='UTF-8'?>\n\n\n<library>\n\n  \n<extends>\n../../../src/modm/board/disco_f469ni/board.xml\n</extends>\n\n  \n<options>\n\n    \n<option\n \nname=\n\":build.scons:build.path\"\n>\n../../../build/stm32f469_discovery/blink\n</option>\n\n  \n</options>\n\n  \n<modules>\n\n    \n<module>\n:build.scons\n</module>\n\n  \n</modules>\n\n\n</library>\n\n\n\n\n\n\n\nChose a build system\n\n\nOur BSPs do not specify a build system generator, so you need to add the \nmodule yourself if you want. Here we chose to use the SCons build system\ngenerator, but you \ncan choose others as well\n.\n\n\n\n\nOur board support packages provide their configuration in the \nBoard\n namespace,\nwhich you can use to initialize the target and several board subsystems.\nIf a serial connection is available on the board, you can directly use the modm\nlogging functions.\n\n\n#include\n \n<modm/board/board.hpp>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nBoard\n::\ninitialize\n();\n\n    \nBoard\n::\nLeds\n::\nsetOutput\n();\n\n\n    \nwhile\n \n(\n1\n)\n\n    \n{\n\n        \nBoard\n::\nLeds\n::\ntoggle\n();\n\n        \nmodm\n::\ndelayMilliseconds\n(\nBoard\n::\nButton\n::\nread\n()\n \n?\n \n250\n \n:\n \n500\n);\n\n\n#ifdef MODM_BOARD_HAS_LOGGER\n\n        \nstatic\n \nuint32_t\n \ncounter\n(\n0\n);\n\n        \nMODM_LOG_INFO\n \n<<\n \n\"Loop counter: \"\n \n<<\n \n(\ncounter\n++\n)\n \n<<\n \nmodm\n::\nendl\n;\n\n\n#endif\n\n    \n}\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\nDiscovering modm\n\u00b6\n\n\nTo generate your custom library, modm uses the \nLibrary Builder\n, which\nis the interface to discover available modules and their configuration options.\n\n\nTo list all available repository options call \nlbuild discover-repository\n.\nThis will show you how to \nspell\n the supported targets correctly.\n\n\n $ lbuild discover-repository\nmodm:target = [at90can128, at90can32, at90can64, at90pwm1, at90pwm161, at90pwm2, at90pwm216, at90pwm3, at90pwm316,\n               at90pwm81, at90usb1286, at90usb1287, at90usb162, at90usb646, at90usb647, at90usb82, atmega128,\n...\n               stm32l4s5ziy, stm32l4s7aii, stm32l4s7vit, stm32l4s7zit, stm32l4s9aii, stm32l4s9vit, stm32l4s9zij,\n               stm32l4s9zit, stm32l4s9ziy]\n\n\n\n\nOnce you've specified this repository option, you can call \nlbuild discover-modules\n,\nto list all available modules for this target.\n\n\n $ lbuild discover-modules\nmodm:architecture:adc\nmodm:board.disco-f469ni\n...\nmodm:ui:led\nmodm:utils\n\n\n\n\nlbuild discover-module-options\n lists all the module options with a short\ndescription and \n\n\n $ lbuild discover-module-options\n...\nmodm:platform:core:allocator = newlib  [block, newlib, tlsf]\n\n  Dynamic memory allocation strategy\n\nmodm:platform:core:main_stack_size = 3040  [256 ... 65536]\n\n  Minimum size of the application main stack\n\nmodm:platform:core:vector_table_location = fastest  [fastest, ram, rom]\n\n  Vector table location in ROM or RAM\n\n...\nmodm:platform:uart:1:buffer.rx = 16  [1 ... 65534]\nmodm:platform:uart:1:buffer.tx = 250  [1 ... 65534]\n\n\n\n\nCall \nlbuild discover-option -o \"modm:platform:core:main_stack_size\"\n to get a\ndetailed description of the option.\n\n\n $ lbuild discover-option -o \"modm:platform:core:main_stack_size\"\nmodm:platform:core:main_stack_size\n==================================\n\nCurrent value: 3040\nPossible values: 256 ... 65536\n\nMinimum size of the application main stack\n\nThe ARM Cortex-M uses a descending stack mechanism which is placed so that it\ngrows towards the beginning of RAM. In case of a stack overflow the hardware\nthen attempts to stack into invalid memory which triggers a HardFault. A stack\noverflow will therefore never overwrite any static or heap memory and this\nprotection works without the MPU and therefore also on ARM Cortex-M0 devices.\n...\n\n\n\n\n\n\nOptions are checked\n\n\nlbuild\n checks all your project options against the possible values in the\nmodule and outputs an error if they are incorrect.\n\n\n\n\n\n\nVisualize your dependencies\n\n\nCreate a dependency graph with \nlbuild dependencies | dot -Tsvg -Grankdir=BT -o dependencies.svg\n\nto help you understand what code is pulled in when you generate your library.\n\nlbuild dependencies -m \":module\"\n generates a smaller graph only for that module.\n\n\n\n\nCustom Configuration\n\u00b6\n\n\nIn case modm doesn't have a BSP for your board or the BSP uses the hardware in\nway you don't like, you can define your own completely custom configuration.\nHere a completely minimal library is generated for a STM32F469NIH device only\nwith the Cortex-M, GPIO and time modules and their dependencies.\nSince no build system generator module is specified, you will only get the raw\nsource code.\n\n\n<?xml version='1.0' encoding='UTF-8'?>\n\n\n<library\n \nxmlns:xsd=\n\"http://www.w3.org/2001/XMLSchema-instance\"\n\n         \nxsd:noNamespaceSchemaLocation=\n\"https://github.com/dergraaf/library-builder/lbuild/resources/configuration.xsd\"\n>\n\n  \n<repositories>\n\n    \n<repository>\n\n      \n<path>\n../../modm/repo.lb\n</path>\n\n    \n</repository>\n\n    \n<cache>\n.lbuild_cache\n</cache>\n\n  \n</repositories>\n\n\n  \n<options>\n\n    \n<option\n \nname=\n\"modm:target\"\n>\nstm32f469nih\n</option>\n\n  \n</options>\n\n  \n<modules>\n\n    \n<module>\nmodm:platform:clock\n</module>\n\n    \n<module>\nmodm:platform:core\n</module>\n\n    \n<module>\nmodm:platform:gpio\n</module>\n\n  \n</modules>\n\n\n</library>\n\n\n\n\n\nA minimal \nmain.cpp\n for this configuration would look like this:\n\n\n#include\n \n<modm/platform/platform.hpp>\n\n\nusing\n \nnamespace\n \nmodm\n::\nplatform\n;\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nGpioA0\n::\nsetOutput\n();\n\n    \nwhile\n(\n1\n)\n \n{\n\n        \nGpioA0\n::\ntoggle\n();\n\n        \nmodm\n::\ndelayMilliseconds\n(\n500\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nWe recommend to start your custom projects with a known-good configuration from\none of our examples and then work your way into your specialization.\n\n\nGenerate and Compile\n\u00b6\n\n\nOnce you have your \nproject.xml\n set up, you can call \nlbuild build\n, which \ngenerates the target and configuration specific library from modm.\nThis will create a number of files and folders:\n\n\n $ ls\nmain.cpp    project.xml\n $ lbuild build\n $ ls\nSConscript      ext             main.cpp        project.xml.log src\nSConstruct      link            project.xml     scons\n\n\n\n\nYou can add these folders and files to your \n.gitignore\n file, however, we \nrecommend eventually committing these files (yes, \nall\n these files) into your\nproject repository so that you don't have issues reproducing the build.\n\n\n\n\nGenerate custom documentation\n\n\nInclude the \n:docs\n module (or execute \nlbuild build --module \":docs\"\n), \nthen call \ndoxygen doxyfile\n inside the generated \ndocs\nfolder.\nThe documentation for your target and configuration will then be available\nin \ndocs/api/index.html\n.\n\n\n\n\nFor this project we included the \nmodm:build.scons\n generator, so we can just\ncall \nscons build size\n, which will compile the entire source code and output\nthe resource consumption:\n\n\n $ scons build size\nscons: Reading SConscript files ...\nscons: done reading SConscript files.\nscons: Building targets ...\nCompiling C++\u00b7\u00b7 build/main.o\n...\nIndexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/libmodm.a\nLinking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/project.elf\nMemory usage\u00b7\u00b7\u00b7 build/project.elf\n\nProgram:    3612B (0.3% used)\n(.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern +\n .table.section_heap + .table.zero.intern + .text)\n\nData:       3184B (1.6% used) = 144B static (0.1%) + 3040B stack (1.5%)\n(.bss + .fastdata + .stack)\n\nHeap:     197520B (98.4% available)\n(.heap0 + .heap1 + .heap2 + .heap5)\n\n\n\n\nYou can program your target by calling \nscons program\n.\n\n\nIf you have any questions, \nopen an issue\n or ping \n@salkinium\n.\n\n\nShow me the basics\n\u00b6\n\n\nAll modm code is either placed in the \nmodm\n namespace or prefixed with\n\nmodm_\n or \nMODM_\n to avoid clashes with other code.\nThe platform specific code is placed in the \nmodm::platform\n namespace and\nis the only place that contains target specific code.\n\n\nHere are a few snippets that work the same on all targets.\nWe assume \nusing namespace modm::platform;\n to make the code more readable.\n\n\n\n\nCheck the examples\n\n\nHave a look at the \nmodm/examples/\n folder\n for more advanced \nuse cases.\n\n\n\n\nGPIO\n\u00b6\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB0\n;\n\n\nLed\n::\nsetOutput\n();\n\n\nLed\n::\nset\n();\n    \n// 1 instruction on AVR\n\n\nLed\n::\nreset\n();\n  \n// 3 instructions on Cortex-M\n\n\nLed\n::\ntoggle\n();\n\n\n\nusing\n \nButton\n \n=\n \nGpioInputB0\n;\n\n\nButton\n::\nsetInput\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n\n\nbool\n \nstate\n \n=\n \nButton\n::\nread\n();\n\n\n\n\n\nBuffered UART\n\u00b6\n\n\nusing\n \nUart\n \n=\n \nUart0\n;\n\n\n// connect both pins with a pullup on the Rx\n\n\nUart\n::\nconnect\n<\nGpioOutputD1\n::\nTx\n,\n \nGpioInputD0\n::\nRx\n>\n(\nGpio\n::\nInputType\n::\nPullUp\n);\n\n\n// initialize to 115.2kBaud from the BSP clock configuration\n\n\nUart\n::\ninitialize\n<\nBoard\n::\nsystemClock\n,\n \n115200\n>\n();\n\n\n\nUart\n::\nwrite\n(\n'H'\n);\n  \n// Ohai there\n\n\nUart\n::\nwrite\n(\n'i'\n);\n\n\n\nuint8_t\n \nbuffer\n;\n\n\nwhile\n(\n1\n)\n \n{\n\n    \n// create a simple loopback\n\n    \nif\n \n(\nUart\n::\nread\n(\nbuffer\n))\n \n{\n\n        \nUart\n::\nwrite\n(\nbuffer\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nIOStream\n\u00b6\n\n\nusing\n \nUart\n \n=\n \nUart0\n;\n\n\n// Create a IODevice with the Uart\n\n\nmodm\n::\nIODeviceWrapper\n<\nUart\n>\n \ndevice\n;\n\n\nmodm\n::\nIOStream\n \nstream\n(\ndevice\n);\n\n\n\nUart\n::\nconnect\n<\nGpioOutputD1\n::\nTx\n>\n();\n\n\nUart\n::\ninitialize\n<\nBoard\n::\nsystemClock\n,\n \n115200\n>\n();\n\n\n\n// similar to std::ostream but without formatting features\n\n\nstream\n \n<<\n \n42\n \n<<\n \n\" is a nice number!\"\n \n<<\n \nmodm\n::\nendl\n;\n\n\n// printf has the most common formatting features\n\n\nstream\n.\nprintf\n(\n\"%d is a %s number!\n\\n\n\"\n,\n \n42\n,\n \n\"nice\"\n);\n\n\n\n\n\nSoftware Timers\n\u00b6\n\n\nusing\n \nLed\n \n=\n \nGpioOutputB0\n;\n\n\nmodm\n::\nTimeout\n \ntimeout\n(\n10000\n);\n   \n// 10s timeout\n\n\nmodm\n::\nPeriodicTimer\n \ntimer\n(\n250\n);\n \n// 250ms period\n\n\n\nLed\n::\nsetOutput\n(\nmodm\n::\nGpio\n::\nHigh\n);\n\n\n\nwhile\n(\n1\n)\n \n{\n\n    \nif\n \n(\ntimeout\n.\nexecute\n())\n \n{\n\n        \n// executes just once\n\n        \ntimer\n.\nstop\n();\n\n        \nLed\n::\nreset\n();\n\n    \n}\n\n    \nif\n \n(\ntimer\n.\nexecute\n())\n \n{\n\n        \n// executes once per period\n\n        \nLed\n::\ntoggle\n();\n\n    \n}\n\n\n}",
            "title": "Getting Started"
        },
        {
            "location": "/guide/getting-started/#getting-started",
            "text": "The easiest way for you to learn about modm's APIs is to look at and \nexperiment with  our examples , especially if you have a development \nboard that modm supports out-of-box.  Here are our favorite examples for our supported development boards:    Arduino Uno: Blinky , Button & Serial , Analog & Serial .  NUCLEO-F031K6: Blinky & Serial .  NUCLEO-F103RB: Blinky & Serial .  STM32F072 Discovery: Blinky , CAN , Gyroscope .  STM32F3 Discovery: Blinky , CAN , Accelerometer , Gyroscope , Debugging with GDB .  STM32F4 Discovery: Blinky , CAN , Accelerometer , Timer & LED Animations , Debugging hard faults .  STM32F469 Discovery: Blinky , Drawing on display , Touchscreen inputs , Multi-heap with external 16MB memory , Game of Life in Color with Multitouch  STM32F769 Discovery: FPU with double precision   Here are some additional examples of displays and sensors we like:   SSD1306 OLED display : Draws text and graphics onto I2C display.  BMP085/BMP180 barometer : Reads atmospheric pressure and temperature from I2C sensor.  BMP180/BME280 barometer : Reads atmospheric pressure and temperature from multiple I2C sensors.  VL6180 time-of-flight distance sensor : Reads distance and ambient light from I2C sensor.  VL53L0  time-of-flight distance sensor : Much improved version of the VL6180 sensor.  ADNS9800 motion sensor : Reads 2D motion from SPI sensor used in gaming mice.  TCS3414 color sensor : Reads RGB color from I2C sensor.  HD44780 over I2C-GPIO expander : Draws text via native GPIO port or I2C-GPIO expander port onto character display.   Have a look at the  build system references  to \nsee how to compile and program your targets.",
            "title": "Getting Started"
        },
        {
            "location": "/guide/getting-started/#your-own-project",
            "text": "To generate a modm library for your own project, you need to define a  project.xml \nfile, which contains the path to where modm is, as well as repository and module options\nand of course which modules you want to have generated.\nmodm will generate a library that is self-contained, so you don't  need  to add\nmodm as a submodule or similar to your repository. However we still recommend it.",
            "title": "Your own Project"
        },
        {
            "location": "/guide/getting-started/#using-a-board-support-package",
            "text": "We recommend building on a BSP, where you can just inherit from an existing\nproject configuration, which contains the minimal set of modules to use the board\nas well as pre-defines several important options for this board.\nYou can then add all the modules you need and configure them as you want.  <?xml version='1.0' encoding='UTF-8'?>  <library> \n   <extends> ../../../src/modm/board/disco_f469ni/board.xml </extends> \n   <options> \n     <option   name= \":build.scons:build.path\" > ../../../build/stm32f469_discovery/blink </option> \n   </options> \n   <modules> \n     <module> :build.scons </module> \n   </modules>  </library>    Chose a build system  Our BSPs do not specify a build system generator, so you need to add the \nmodule yourself if you want. Here we chose to use the SCons build system\ngenerator, but you  can choose others as well .   Our board support packages provide their configuration in the  Board  namespace,\nwhich you can use to initialize the target and several board subsystems.\nIf a serial connection is available on the board, you can directly use the modm\nlogging functions.  #include   <modm/board/board.hpp>  int   main ()  { \n     Board :: initialize (); \n     Board :: Leds :: setOutput (); \n\n     while   ( 1 ) \n     { \n         Board :: Leds :: toggle (); \n         modm :: delayMilliseconds ( Board :: Button :: read ()   ?   250   :   500 );  #ifdef MODM_BOARD_HAS_LOGGER \n         static   uint32_t   counter ( 0 ); \n         MODM_LOG_INFO   <<   \"Loop counter: \"   <<   ( counter ++ )   <<   modm :: endl ;  #endif \n     } \n     return   0 ;  }",
            "title": "Using a Board Support Package"
        },
        {
            "location": "/guide/getting-started/#discovering-modm",
            "text": "To generate your custom library, modm uses the  Library Builder , which\nis the interface to discover available modules and their configuration options.  To list all available repository options call  lbuild discover-repository .\nThis will show you how to  spell  the supported targets correctly.   $ lbuild discover-repository\nmodm:target = [at90can128, at90can32, at90can64, at90pwm1, at90pwm161, at90pwm2, at90pwm216, at90pwm3, at90pwm316,\n               at90pwm81, at90usb1286, at90usb1287, at90usb162, at90usb646, at90usb647, at90usb82, atmega128,\n...\n               stm32l4s5ziy, stm32l4s7aii, stm32l4s7vit, stm32l4s7zit, stm32l4s9aii, stm32l4s9vit, stm32l4s9zij,\n               stm32l4s9zit, stm32l4s9ziy]  Once you've specified this repository option, you can call  lbuild discover-modules ,\nto list all available modules for this target.   $ lbuild discover-modules\nmodm:architecture:adc\nmodm:board.disco-f469ni\n...\nmodm:ui:led\nmodm:utils  lbuild discover-module-options  lists all the module options with a short\ndescription and    $ lbuild discover-module-options\n...\nmodm:platform:core:allocator = newlib  [block, newlib, tlsf]\n\n  Dynamic memory allocation strategy\n\nmodm:platform:core:main_stack_size = 3040  [256 ... 65536]\n\n  Minimum size of the application main stack\n\nmodm:platform:core:vector_table_location = fastest  [fastest, ram, rom]\n\n  Vector table location in ROM or RAM\n\n...\nmodm:platform:uart:1:buffer.rx = 16  [1 ... 65534]\nmodm:platform:uart:1:buffer.tx = 250  [1 ... 65534]  Call  lbuild discover-option -o \"modm:platform:core:main_stack_size\"  to get a\ndetailed description of the option.   $ lbuild discover-option -o \"modm:platform:core:main_stack_size\"\nmodm:platform:core:main_stack_size\n==================================\n\nCurrent value: 3040\nPossible values: 256 ... 65536\n\nMinimum size of the application main stack\n\nThe ARM Cortex-M uses a descending stack mechanism which is placed so that it\ngrows towards the beginning of RAM. In case of a stack overflow the hardware\nthen attempts to stack into invalid memory which triggers a HardFault. A stack\noverflow will therefore never overwrite any static or heap memory and this\nprotection works without the MPU and therefore also on ARM Cortex-M0 devices.\n...   Options are checked  lbuild  checks all your project options against the possible values in the\nmodule and outputs an error if they are incorrect.    Visualize your dependencies  Create a dependency graph with  lbuild dependencies | dot -Tsvg -Grankdir=BT -o dependencies.svg \nto help you understand what code is pulled in when you generate your library. lbuild dependencies -m \":module\"  generates a smaller graph only for that module.",
            "title": "Discovering modm"
        },
        {
            "location": "/guide/getting-started/#custom-configuration",
            "text": "In case modm doesn't have a BSP for your board or the BSP uses the hardware in\nway you don't like, you can define your own completely custom configuration.\nHere a completely minimal library is generated for a STM32F469NIH device only\nwith the Cortex-M, GPIO and time modules and their dependencies.\nSince no build system generator module is specified, you will only get the raw\nsource code.  <?xml version='1.0' encoding='UTF-8'?>  <library   xmlns:xsd= \"http://www.w3.org/2001/XMLSchema-instance\" \n          xsd:noNamespaceSchemaLocation= \"https://github.com/dergraaf/library-builder/lbuild/resources/configuration.xsd\" > \n   <repositories> \n     <repository> \n       <path> ../../modm/repo.lb </path> \n     </repository> \n     <cache> .lbuild_cache </cache> \n   </repositories> \n\n   <options> \n     <option   name= \"modm:target\" > stm32f469nih </option> \n   </options> \n   <modules> \n     <module> modm:platform:clock </module> \n     <module> modm:platform:core </module> \n     <module> modm:platform:gpio </module> \n   </modules>  </library>   A minimal  main.cpp  for this configuration would look like this:  #include   <modm/platform/platform.hpp>  using   namespace   modm :: platform ;  int   main ()  { \n     GpioA0 :: setOutput (); \n     while ( 1 )   { \n         GpioA0 :: toggle (); \n         modm :: delayMilliseconds ( 500 ); \n     }  }   We recommend to start your custom projects with a known-good configuration from\none of our examples and then work your way into your specialization.",
            "title": "Custom Configuration"
        },
        {
            "location": "/guide/getting-started/#generate-and-compile",
            "text": "Once you have your  project.xml  set up, you can call  lbuild build , which \ngenerates the target and configuration specific library from modm.\nThis will create a number of files and folders:   $ ls\nmain.cpp    project.xml\n $ lbuild build\n $ ls\nSConscript      ext             main.cpp        project.xml.log src\nSConstruct      link            project.xml     scons  You can add these folders and files to your  .gitignore  file, however, we \nrecommend eventually committing these files (yes,  all  these files) into your\nproject repository so that you don't have issues reproducing the build.   Generate custom documentation  Include the  :docs  module (or execute  lbuild build --module \":docs\" ), \nthen call  doxygen doxyfile  inside the generated  docs folder.\nThe documentation for your target and configuration will then be available\nin  docs/api/index.html .   For this project we included the  modm:build.scons  generator, so we can just\ncall  scons build size , which will compile the entire source code and output\nthe resource consumption:   $ scons build size\nscons: Reading SConscript files ...\nscons: done reading SConscript files.\nscons: Building targets ...\nCompiling C++\u00b7\u00b7 build/main.o\n...\nIndexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/libmodm.a\nLinking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/project.elf\nMemory usage\u00b7\u00b7\u00b7 build/project.elf\n\nProgram:    3612B (0.3% used)\n(.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern +\n .table.section_heap + .table.zero.intern + .text)\n\nData:       3184B (1.6% used) = 144B static (0.1%) + 3040B stack (1.5%)\n(.bss + .fastdata + .stack)\n\nHeap:     197520B (98.4% available)\n(.heap0 + .heap1 + .heap2 + .heap5)  You can program your target by calling  scons program .  If you have any questions,  open an issue  or ping  @salkinium .",
            "title": "Generate and Compile"
        },
        {
            "location": "/guide/getting-started/#show-me-the-basics",
            "text": "All modm code is either placed in the  modm  namespace or prefixed with modm_  or  MODM_  to avoid clashes with other code.\nThe platform specific code is placed in the  modm::platform  namespace and\nis the only place that contains target specific code.  Here are a few snippets that work the same on all targets.\nWe assume  using namespace modm::platform;  to make the code more readable.   Check the examples  Have a look at the  modm/examples/  folder  for more advanced \nuse cases.",
            "title": "Show me the basics"
        },
        {
            "location": "/guide/getting-started/#gpio",
            "text": "using   Led   =   GpioOutputB0 ;  Led :: setOutput ();  Led :: set ();      // 1 instruction on AVR  Led :: reset ();    // 3 instructions on Cortex-M  Led :: toggle ();  using   Button   =   GpioInputB0 ;  Button :: setInput ( Gpio :: InputType :: PullUp );  bool   state   =   Button :: read ();",
            "title": "GPIO"
        },
        {
            "location": "/guide/getting-started/#buffered-uart",
            "text": "using   Uart   =   Uart0 ;  // connect both pins with a pullup on the Rx  Uart :: connect < GpioOutputD1 :: Tx ,   GpioInputD0 :: Rx > ( Gpio :: InputType :: PullUp );  // initialize to 115.2kBaud from the BSP clock configuration  Uart :: initialize < Board :: systemClock ,   115200 > ();  Uart :: write ( 'H' );    // Ohai there  Uart :: write ( 'i' );  uint8_t   buffer ;  while ( 1 )   { \n     // create a simple loopback \n     if   ( Uart :: read ( buffer ))   { \n         Uart :: write ( buffer ); \n     }  }",
            "title": "Buffered UART"
        },
        {
            "location": "/guide/getting-started/#iostream",
            "text": "using   Uart   =   Uart0 ;  // Create a IODevice with the Uart  modm :: IODeviceWrapper < Uart >   device ;  modm :: IOStream   stream ( device );  Uart :: connect < GpioOutputD1 :: Tx > ();  Uart :: initialize < Board :: systemClock ,   115200 > ();  // similar to std::ostream but without formatting features  stream   <<   42   <<   \" is a nice number!\"   <<   modm :: endl ;  // printf has the most common formatting features  stream . printf ( \"%d is a %s number! \\n \" ,   42 ,   \"nice\" );",
            "title": "IOStream"
        },
        {
            "location": "/guide/getting-started/#software-timers",
            "text": "using   Led   =   GpioOutputB0 ;  modm :: Timeout   timeout ( 10000 );     // 10s timeout  modm :: PeriodicTimer   timer ( 250 );   // 250ms period  Led :: setOutput ( modm :: Gpio :: High );  while ( 1 )   { \n     if   ( timeout . execute ())   { \n         // executes just once \n         timer . stop (); \n         Led :: reset (); \n     } \n     if   ( timer . execute ())   { \n         // executes once per period \n         Led :: toggle (); \n     }  }",
            "title": "Software Timers"
        },
        {
            "location": "/guide/qtcreator/",
            "text": "This page still has incorrect information!\n\n\n\n\nQt Creator integration\n\u00b6\n\n\n(\u26a1\ufe0f should mostly be fine, but needs new screenshots with modm in pic)\n\n\nThis tutorial shows how to adapt the Qt Creator IDE for comfortable developing and debugging of modm projects on STM32 microcontrollers.\n\n\nThis tutorial uses modm\u2019s \nhello-world\n example project of \nour \ngetting-started-with-modm\n repository\n for the STM32F4 Discovery board.\n\n\nInstallation\n\u00b6\n\n\nInstall \nQt Creator version 4.0 or above\n.\n\n\n# On Fedora 22 and up\n\nsudo dnf install qtcreator\n\n# On Ubuntu 16.04\n\nsudo apt-get install qtcreator\n\n# On OS X\n\nbrew cask install qtcreator\n\n\n\n\nGlobal setup\n\u00b6\n\n\nEnable Bare Metal plugin\n\u00b6\n\n\nOS X: \nQt Creator\n \u2192 \nAbout Plugins...\n\nLinux: \nHelp\n \u2192 \nAbout Plugins...\n\n\n\n\nEnable the BareMetal plugin and restart Qt Creator.\n\n\nCode Style\n\u00b6\n\n\nOS X: \nQt Creator\n \u2192 \nPreferences...\n\nLinux: Go to \nOptions\n dialog: \nTools\n \u2192 \nOptions...\n\n\nGo to Tab \nC++\n, create a copy of the \nQt [builtin]\n code style, name it \nmodm\n and click \nEdit...\n.\n\n\nSet \nTab policy\n to \nTabs only\n, save and exit.\n\n\nAdd debugger\n\u00b6\n\n\nRefer to the \nInstallation guide\n on how to install the arm-none-eabi toolchain.\n\n\nIn \nBuild & Run\n and sub-tab \nDebuggers\n click \nAdd\n to add the \narm-none-eabi-gdb\n debugger to Qt Creator:\n\n\nQt Creator requires the debugger to support Python scripting.\n\n\nIf you use the precompiled \narm-none-eabi toolchain from ARM\n you need to use \narm-none-eabi-gdb-py\n here!\n\n\nFor Linux distributions that ship the toolchain themselves and have Python scripting enabled by default, you can use \n/usr/bin/arm-none-eabi-gdb\n (without the \n-py\n).\n\n\nAdd OpenOCD server\n\u00b6\n\n\nIf you have not installed OpenOCD yet, do so now:\n\n\n# On Fedora 22 and up\nsudo dnf install openocd\n# On Ubuntu 16.04\nsudo apt-get install openocd\n# On OS X\nbrew install openocd --HEAD\n\n\n\n\nGo to tab \nBare Metal\n and select \nAdd\n \u2192 \nOpenOCD\n.\n\n\n\n\n\nUse the following settings:\n\n\n\n\nStartup mode: \nStartup in TCP/IP Mode\n\n\nExecutable file: Path to OpenOCD binary: \n/usr/local/bin/openocd\n (OS X), or \n/usr/bin/openocd\n (Linux)\n\n\nRoot scripts directory: Absolute path to OpenOCD script directory: \n/usr/local/share/openocd/scripts\n (OS X), or \n/usr/share/openocd/scripts\n (Linux)\n\n\nConfiguration File: \nboard/stm32f4discovery.cfg\n, do not worry if the text field turns red.\n\n\n\n\nIf you want to use other targets, create an \nOpenOCD provider\n, \nDevice\n and \nKit\n for each or them.\nHave a look at the OpenOCD script directory to find a configuration file for your target.\n\n\nAdd target device\n\u00b6\n\n\nFor the next step go to the \nDevices\n tab and \nAdd...\n a new \nBare Metal Device\n.\n\n\nUse the following settings:\n\n\nAgain, go to tab \nBuild & Run\n, sub-tab \nKits\n and click \nAdd\n to add a new so called Kit.\n\n\n\n\n\nDevice type: \nBare Metal Device\n\n\nDevice: \nSTM32F4-DISCO\n (the device we just created)\n\n\nCompiler: Irrelevant, we won't use it.\n\n\nDebugger: \narm-none-eabi-gdb\n\n\nQt version: \nNone\n\n\n\n\nClick \nOk\n.\n\n\nmodm project setup\n\u00b6\n\n\nCheck out the getting started repository:\n\ngit clone --recursive https://github.com/roboterclubaachen/getting-started-with-modm.git\n\n\n\nChange to the project folder and run \nscons qtcreator\n to generate the Qt creator project files for the modm project:\n\ncd\n getting-started-with-modm/hello-world\nscons\nscons qtcreator\n\nscons: Reading SConscript files ...\nscons: \ndone\n reading SConscript files.\nscons: Building targets ...\nTemplate: \n'getting-started-with-modm/modm/templates/qtcreator/project.creator.in'\n to \n'hello-world.creator'\n\nTemplate: \n'getting-started-with-modm/modm/templates/qtcreator/project.config.in'\n to \n'hello-world.config'\n\nTemplate: \n'getting-started-with-modm/modm/templates/qtcreator/project.files.in'\n to \n'hello-world.files'\n\nTemplate: \n'getting-started-with-modm/modm/templates/qtcreator/project.includes.in'\n to \n'hello-world.includes'\n\nscons: \ndone\n building targets.\n\n\n\nOpen project with Qt Creator: \nFile\n \u2192 \nOpen File or Project\n\n\n\n\n\nSelect the \nProjects\n view from the \nMode Selector\n on the left side (\nWindow\n \u2192 \nShow Mode Selector\n if not visible).\n\n\nFirst, click \nAdd Kit\n \u2192 \nSTM32F4-DISCO\n, then remove the created \nDefault\n using the icon to the right of it: \nDefault\n \u2192 \nRemove Kit\n.\n\n\n\nNext go to the \nBuild Settings\n and remove all existing \nBuild Steps\n and \nClean Steps\n and:\n\n\n\n\nadd a new \nCustom Process Step\n build step with command \nscons\n and argument \nprogram\n.\n\n\nadd a new \nCustom Process Step\n clean step with command \nscons\n and argument \n-c\n.\n\n\nadd a custom \nPATH\n to the \nSystem Environment\n, if you need to.\n\n\n\n\n\nSwitch to \nRun Settings\n and select \nRun on GDB server or hardware debugger\n as \nRun Configuration\n. Select the **.elf*-file as executable.\n\n\n\nCongratulations, you can now compile, program and debug your modm application comfortably in Qt Creator.",
            "title": "Qt Creator"
        },
        {
            "location": "/guide/qtcreator/#qt-creator-integration",
            "text": "(\u26a1\ufe0f should mostly be fine, but needs new screenshots with modm in pic)  This tutorial shows how to adapt the Qt Creator IDE for comfortable developing and debugging of modm projects on STM32 microcontrollers.  This tutorial uses modm\u2019s  hello-world  example project of  our  getting-started-with-modm  repository  for the STM32F4 Discovery board.",
            "title": "Qt Creator integration"
        },
        {
            "location": "/guide/qtcreator/#installation",
            "text": "Install  Qt Creator version 4.0 or above .  # On Fedora 22 and up \nsudo dnf install qtcreator # On Ubuntu 16.04 \nsudo apt-get install qtcreator # On OS X \nbrew cask install qtcreator",
            "title": "Installation"
        },
        {
            "location": "/guide/qtcreator/#global-setup",
            "text": "",
            "title": "Global setup"
        },
        {
            "location": "/guide/qtcreator/#enable-bare-metal-plugin",
            "text": "OS X:  Qt Creator  \u2192  About Plugins... \nLinux:  Help  \u2192  About Plugins...   Enable the BareMetal plugin and restart Qt Creator.",
            "title": "Enable Bare Metal plugin"
        },
        {
            "location": "/guide/qtcreator/#code-style",
            "text": "OS X:  Qt Creator  \u2192  Preferences... \nLinux: Go to  Options  dialog:  Tools  \u2192  Options...  Go to Tab  C++ , create a copy of the  Qt [builtin]  code style, name it  modm  and click  Edit... . \nSet  Tab policy  to  Tabs only , save and exit.",
            "title": "Code Style"
        },
        {
            "location": "/guide/qtcreator/#add-debugger",
            "text": "Refer to the  Installation guide  on how to install the arm-none-eabi toolchain.  In  Build & Run  and sub-tab  Debuggers  click  Add  to add the  arm-none-eabi-gdb  debugger to Qt Creator: \nQt Creator requires the debugger to support Python scripting.  If you use the precompiled  arm-none-eabi toolchain from ARM  you need to use  arm-none-eabi-gdb-py  here!  For Linux distributions that ship the toolchain themselves and have Python scripting enabled by default, you can use  /usr/bin/arm-none-eabi-gdb  (without the  -py ).",
            "title": "Add debugger"
        },
        {
            "location": "/guide/qtcreator/#add-openocd-server",
            "text": "If you have not installed OpenOCD yet, do so now:  # On Fedora 22 and up\nsudo dnf install openocd\n# On Ubuntu 16.04\nsudo apt-get install openocd\n# On OS X\nbrew install openocd --HEAD  Go to tab  Bare Metal  and select  Add  \u2192  OpenOCD .   Use the following settings:   Startup mode:  Startup in TCP/IP Mode  Executable file: Path to OpenOCD binary:  /usr/local/bin/openocd  (OS X), or  /usr/bin/openocd  (Linux)  Root scripts directory: Absolute path to OpenOCD script directory:  /usr/local/share/openocd/scripts  (OS X), or  /usr/share/openocd/scripts  (Linux)  Configuration File:  board/stm32f4discovery.cfg , do not worry if the text field turns red.   If you want to use other targets, create an  OpenOCD provider ,  Device  and  Kit  for each or them.\nHave a look at the OpenOCD script directory to find a configuration file for your target.",
            "title": "Add OpenOCD server"
        },
        {
            "location": "/guide/qtcreator/#add-target-device",
            "text": "For the next step go to the  Devices  tab and  Add...  a new  Bare Metal Device . \nUse the following settings: \nAgain, go to tab  Build & Run , sub-tab  Kits  and click  Add  to add a new so called Kit.   Device type:  Bare Metal Device  Device:  STM32F4-DISCO  (the device we just created)  Compiler: Irrelevant, we won't use it.  Debugger:  arm-none-eabi-gdb  Qt version:  None   Click  Ok .",
            "title": "Add target device"
        },
        {
            "location": "/guide/qtcreator/#modm-project-setup",
            "text": "Check out the getting started repository: git clone --recursive https://github.com/roboterclubaachen/getting-started-with-modm.git  Change to the project folder and run  scons qtcreator  to generate the Qt creator project files for the modm project: cd  getting-started-with-modm/hello-world\nscons\nscons qtcreator\n\nscons: Reading SConscript files ...\nscons:  done  reading SConscript files.\nscons: Building targets ...\nTemplate:  'getting-started-with-modm/modm/templates/qtcreator/project.creator.in'  to  'hello-world.creator' \nTemplate:  'getting-started-with-modm/modm/templates/qtcreator/project.config.in'  to  'hello-world.config' \nTemplate:  'getting-started-with-modm/modm/templates/qtcreator/project.files.in'  to  'hello-world.files' \nTemplate:  'getting-started-with-modm/modm/templates/qtcreator/project.includes.in'  to  'hello-world.includes' \nscons:  done  building targets.  Open project with Qt Creator:  File  \u2192  Open File or Project   \nSelect the  Projects  view from the  Mode Selector  on the left side ( Window  \u2192  Show Mode Selector  if not visible).  First, click  Add Kit  \u2192  STM32F4-DISCO , then remove the created  Default  using the icon to the right of it:  Default  \u2192  Remove Kit .  Next go to the  Build Settings  and remove all existing  Build Steps  and  Clean Steps  and:   add a new  Custom Process Step  build step with command  scons  and argument  program .  add a new  Custom Process Step  clean step with command  scons  and argument  -c .  add a custom  PATH  to the  System Environment , if you need to.   \nSwitch to  Run Settings  and select  Run on GDB server or hardware debugger  as  Run Configuration . Select the **.elf*-file as executable.  Congratulations, you can now compile, program and debug your modm application comfortably in Qt Creator.",
            "title": "modm project setup"
        },
        {
            "location": "/guide/testing/",
            "text": "This page has incorrect information!\n\n\n\n\nTesting modm\n\u00b6\n\n\n(\u26a1\ufe0f needs a complete rewrite to make it less informal)\n\n\nmodm has seen some significant changes in the past time and the level of\nmaturity of modm varies between \nuncompilable\n and \nvery reliable\n.\n\n\nThere are different explicit and implicit test strategies in place for\ntesting modm:\n\n\n\n\nManual Tests\n\n\nManual Integration Tests\n\n\nContinous Integration\n\n\nRelease Tests\n\n\nUnit Tests on hosted\n\n\nUnit Tests on targets\n\n\n\n\nManual Tests\n\u00b6\n\n\nWhen some new drivers were developed the developer often (not always!) tests the new driver with some real hardware (eval board) and a real peripheral at least on one platform with one compiler. The results on different platforms (AVR instead of ARM) and different hardware (eval board) may vary, although by design should not.\n\n\nMostly, these tests are only conducted when the development takes place.\n\n\nManual Integration Tests\n\u00b6\n\n\nmodm is the major platform for all programming efforts of the Robot Association Aachen (Roboterclub Aachen, RCA) at RWTH Aachen University. Some parts of modm run on real robots in real competitions. The maturity of these parts at least for RCA's hardware can be expected to be very high. This includes\n\n\n\n\nthe modm communication protocol\n\n\nthe target platforms used in the specific season, e.g.\n\n\nSTM32F407 in seasons 2014ff, but only under very specific test conditions, e.g.\n\n\nexternal 8 MHz oscillator\n\n\ncore running at exactly 168 MHz\n\n\nonly using UART0, not UART1,\n\n\net cetera\n\n\n\n\n\n\nthe hardware drivers build in the robots (e.g. CAN, VL6180, ...)\n\n\n\n\nThe test coverage is unknown but the system has proved to be reliable under conditions of the competition. Nevertheless, some unforseen problems may still occur at any time. Always fasten your seatbelt.\n\n\nContinous Integration\n\u00b6\n\n\nmodm on Github uses CircleCI for CI. A set of test jobs is run with every commit. These include release tests and unit tests.\n\n\nRelease Test\n\u00b6\n\n\nmodm covers many different platforms and a huge number of chips. To make sure that at the code at least compiles for all platforms a CircleCI test job is in place as part of the Continous Integration. This only tests compiling on the CircleCI Linux virtual machine. Compiling may fail with different compilers and on different hosts.\n\n\nTODO: Add\n\n\nUnit Tests on Hosted\n\u00b6\n\n\nSome parts of modm which do not access hardware directly (like communication protocols, mathematical and logical functions) are tested with a modm specific unit test framework.\n\n\nTests can be found in the \ntest\n directory, e.g. \ntest/modm/math/filter\n. These test check for logic errors in the components. They are compiled for the targed \nhosted\n (your computer) and run to check the expected result against a predifined and expected result. The test coverage of these tests vary.\n\n\nEvery new software component is expected to have these checks in place when contributed to modm.\n\n\nUnit tests for hosted can be run with:\n\n\n$ make test-hosted\n\n\n\n\n\nUnit Tests on Target Platform\n\u00b6\n\n\nA very unique feature of the modm unit test framework is that the unit tests can be run on the target platform. This matters because in most cases modm is used for cross compiling and the target platform differs at least in one of the following features\n\n\n\n\ncompiler\n\n\ngcc for x86 vs. arm-none-eabi-gcc vs. avr-gcc\n\n\nword size\n\n\n64 bits vs. 8 or 32 bits\n\n\nendianness\n\n\npresence of a FPU\n\n\ni7 vs. AVR vs. ARM Cortex-M4f\n\n\n\n\nTo cross-compile the set of unittests for STM32 run\n\n\n$ make test-stm32\n\n\n\n\n\nThis will create a binary \nbuild/unittest/stm32/project.elf\n that can be manually programmed to STM32 F4 Discovery board. After reset, the unit tests are run and the result of the test is echoed to the serial console (USART2 in case of the STM32 F4 Discovery Board, see runner.cpp for details). The test runner is created from \ntest/runner/stm32.cpp.in\n and located in \nbuild/unittest/stm32/main.cpp\n\n\nTheses tests have not been run for a long time at the time of writing this document. These test must be run and interpreted manually.\n\n\nAll platform and hardware drivers still lack these kind of tests, including external stimuli and waveform verification.\n\n\n$ make test-avr\n\n\n\n\n\nConclusions and Outlook\n\u00b6\n\n\nmodm has a varity of testing strategies in place, is being used on a regular basis by Roboterclub Aachen, receives updates and bug fixes frequently and test coverage is constantly improved.",
            "title": "Testing"
        },
        {
            "location": "/guide/testing/#testing-modm",
            "text": "(\u26a1\ufe0f needs a complete rewrite to make it less informal)  modm has seen some significant changes in the past time and the level of\nmaturity of modm varies between  uncompilable  and  very reliable .  There are different explicit and implicit test strategies in place for\ntesting modm:   Manual Tests  Manual Integration Tests  Continous Integration  Release Tests  Unit Tests on hosted  Unit Tests on targets",
            "title": "Testing modm"
        },
        {
            "location": "/guide/testing/#manual-tests",
            "text": "When some new drivers were developed the developer often (not always!) tests the new driver with some real hardware (eval board) and a real peripheral at least on one platform with one compiler. The results on different platforms (AVR instead of ARM) and different hardware (eval board) may vary, although by design should not.  Mostly, these tests are only conducted when the development takes place.",
            "title": "Manual Tests"
        },
        {
            "location": "/guide/testing/#manual-integration-tests",
            "text": "modm is the major platform for all programming efforts of the Robot Association Aachen (Roboterclub Aachen, RCA) at RWTH Aachen University. Some parts of modm run on real robots in real competitions. The maturity of these parts at least for RCA's hardware can be expected to be very high. This includes   the modm communication protocol  the target platforms used in the specific season, e.g.  STM32F407 in seasons 2014ff, but only under very specific test conditions, e.g.  external 8 MHz oscillator  core running at exactly 168 MHz  only using UART0, not UART1,  et cetera    the hardware drivers build in the robots (e.g. CAN, VL6180, ...)   The test coverage is unknown but the system has proved to be reliable under conditions of the competition. Nevertheless, some unforseen problems may still occur at any time. Always fasten your seatbelt.",
            "title": "Manual Integration Tests"
        },
        {
            "location": "/guide/testing/#continous-integration",
            "text": "modm on Github uses CircleCI for CI. A set of test jobs is run with every commit. These include release tests and unit tests.",
            "title": "Continous Integration"
        },
        {
            "location": "/guide/testing/#release-test",
            "text": "modm covers many different platforms and a huge number of chips. To make sure that at the code at least compiles for all platforms a CircleCI test job is in place as part of the Continous Integration. This only tests compiling on the CircleCI Linux virtual machine. Compiling may fail with different compilers and on different hosts.  TODO: Add",
            "title": "Release Test"
        },
        {
            "location": "/guide/testing/#unit-tests-on-hosted",
            "text": "Some parts of modm which do not access hardware directly (like communication protocols, mathematical and logical functions) are tested with a modm specific unit test framework.  Tests can be found in the  test  directory, e.g.  test/modm/math/filter . These test check for logic errors in the components. They are compiled for the targed  hosted  (your computer) and run to check the expected result against a predifined and expected result. The test coverage of these tests vary.  Every new software component is expected to have these checks in place when contributed to modm.  Unit tests for hosted can be run with:  $ make test-hosted",
            "title": "Unit Tests on Hosted"
        },
        {
            "location": "/guide/testing/#unit-tests-on-target-platform",
            "text": "A very unique feature of the modm unit test framework is that the unit tests can be run on the target platform. This matters because in most cases modm is used for cross compiling and the target platform differs at least in one of the following features   compiler  gcc for x86 vs. arm-none-eabi-gcc vs. avr-gcc  word size  64 bits vs. 8 or 32 bits  endianness  presence of a FPU  i7 vs. AVR vs. ARM Cortex-M4f   To cross-compile the set of unittests for STM32 run  $ make test-stm32  This will create a binary  build/unittest/stm32/project.elf  that can be manually programmed to STM32 F4 Discovery board. After reset, the unit tests are run and the result of the test is echoed to the serial console (USART2 in case of the STM32 F4 Discovery Board, see runner.cpp for details). The test runner is created from  test/runner/stm32.cpp.in  and located in  build/unittest/stm32/main.cpp  Theses tests have not been run for a long time at the time of writing this document. These test must be run and interpreted manually.  All platform and hardware drivers still lack these kind of tests, including external stimuli and waveform verification.  $ make test-avr",
            "title": "Unit Tests on Target Platform"
        },
        {
            "location": "/guide/testing/#conclusions-and-outlook",
            "text": "modm has a varity of testing strategies in place, is being used on a regular basis by Roboterclub Aachen, receives updates and bug fixes frequently and test coverage is constantly improved.",
            "title": "Conclusions and Outlook"
        },
        {
            "location": "/reference/overview/",
            "text": "modm Reference Manual\n\u00b6\n\n\n(\u26a1\ufe0f give an overview over module documentation system and introduce modm architecture conceptually)",
            "title": "Overview"
        },
        {
            "location": "/reference/overview/#modm-reference-manual",
            "text": "(\u26a1\ufe0f give an overview over module documentation system and introduce modm architecture conceptually)",
            "title": "modm Reference Manual"
        },
        {
            "location": "/reference/concepts/",
            "text": "Programming Concepts\n\u00b6\n\n\n\n\n(\u26a1\ufe0f HAL generated static methods)\n\n\n(\u26a1\ufe0f HAL stateless whenever)\n\n\n(\u26a1\ufe0f HAL template duck typing)\n\n\n(\u26a1\ufe0f architecture interface)\n\n\n(\u26a1\ufe0f driver split data)\n\n\n(\u26a1\ufe0f refer to blog for details)",
            "title": "Concepts"
        },
        {
            "location": "/reference/concepts/#programming-concepts",
            "text": "(\u26a1\ufe0f HAL generated static methods)  (\u26a1\ufe0f HAL stateless whenever)  (\u26a1\ufe0f HAL template duck typing)  (\u26a1\ufe0f architecture interface)  (\u26a1\ufe0f driver split data)  (\u26a1\ufe0f refer to blog for details)",
            "title": "Programming Concepts"
        },
        {
            "location": "/reference/modules/",
            "text": "Available Modules\n\u00b6\n\n\n(\u26a1\ufe0f generated dependency graph of modules for all boards here)",
            "title": "Modules"
        },
        {
            "location": "/reference/modules/#available-modules",
            "text": "(\u26a1\ufe0f generated dependency graph of modules for all boards here)",
            "title": "Available Modules"
        },
        {
            "location": "/reference/library-builder/",
            "text": "Library Builder\n\u00b6\n\n\n(\u26a1\ufe0f add overview for using lbuild)",
            "title": "Library Builder"
        },
        {
            "location": "/reference/library-builder/#library-builder",
            "text": "(\u26a1\ufe0f add overview for using lbuild)",
            "title": "Library Builder"
        },
        {
            "location": "/reference/build-systems/",
            "text": "Build Systems\n\u00b6\n\n\n\n\n\nmodm is best tested with the \nSCons\n build system, even though modm itself is \nbuild system agnostic.\nThis page describes how to use \nlbuild\n to automatically gather the data relevant\nto generate the files required for your build system.\n\n\nModule metadata\n\u00b6\n\n\nSCons\n\u00b6\n\n\nWe use \nSCons v3\n with \nmany custom tools\n based on work by \nthe DLR, which enable us to support so many different targets.",
            "title": "Build Systems"
        },
        {
            "location": "/reference/build-systems/#build-systems",
            "text": "modm is best tested with the  SCons  build system, even though modm itself is \nbuild system agnostic.\nThis page describes how to use  lbuild  to automatically gather the data relevant\nto generate the files required for your build system.",
            "title": "Build Systems"
        },
        {
            "location": "/reference/build-systems/#module-metadata",
            "text": "",
            "title": "Module metadata"
        },
        {
            "location": "/reference/build-systems/#scons",
            "text": "We use  SCons v3  with  many custom tools  based on work by \nthe DLR, which enable us to support so many different targets.",
            "title": "SCons"
        }
    ]
}