{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"modm: a barebone embedded library generator \u00b6 modm (pronounced like dial-up \"modem\") is a toolbox for building custom C++20 libraries tailored to your embedded device. modm generates startup code, HALs and their implementations, communication protocols, drivers for external devices, BSPs, etc\u2026 in a modular, customizable process that you can fine-tune to your needs. Install the toolchain and explore our examples . You can discover the modm library in more detail. Easily start your own completely custom project . Our CI checks every contribution for regressions. We care about testing modm . API reference is available here . We do quarterly releases with a curated changelog . This project also has a technical blog to document larger design concepts. You found a bug? Open up an issue, we don't bite . You want to contribute? Read the contribution guidelines and open a pull request . modm is optimized for the harsh requirements of the Eurobot competition , where our robots need to run reliably and completely autonomously for the game's 100 second duration. Our robots contain a lot of different microcontrollers, some without a lot of resources, so modm needs to fulfill a diverse set of objectives, like small code size with small memory consumption, predictable program flow, extreme portability. The library source code is licensed as MPLv2 with any external source code under compatible licenses (BSD, Apache2, MIT). So feel free to fork this project and adapt it to your needs. The only thing we ask of you is to contribute your changes back so everyone can benefit. Please clone modm recursively, you need all the submodules: git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git Features \u00b6 Efficient and fast object-oriented C++20 API. Support for hundreds of AVR and ARM Cortex-M microcontrollers from Atmel and ST. Build system agnostic: Choose SCons, CMake, Makefile or use your own. Data-driven, target-specific HAL generation using the lbuild engine. No memory allocations in HAL with very low overall RAM consumption. Highly configurable modules with sensible defaults and lots of documentation. Cross-platform peripheral interfaces incl. bit banging: GPIO, External Interrupt and IO expanders. ADC, DAC and Comparators. UART, I 2 C, SPI, CAN and Ethernet. Interfaces and drivers for many external I 2 C and SPI sensors and devices. Debug/logging system with IOStream and printf interface. Lightweight, stackless threads and resumable functions using cooperative multitasking. Functional (partial) libstdc++ implementation for AVRs. Useful filter, interpolation and geometric algorithms. Lightweight unit testing system (suitable for AVRs). Hundreds of tests to ensure correct functionality. Integration of useful third-party software: FreeRTOS and FreeRTOS+TCP . CMSIS and CMSIS-DSP . TinyUSB . FatFS . ROSserial . CrashCatcher . Microcontrollers \u00b6 modm can create a HAL for 3107 devices of these vendors: STMicroelectronics STM32: 2438 devices. Microchip SAM: 163 devices. Microchip AVR: 506 devices. Here is a table with all device families and the peripheral drivers they support: \u2705 Implemented as a software driver in modm. \u25cb Available in hardware but missing a software driver in modm. \u2717 Unavailable in hardware or device with that peripheral not supported by modm. Note that this is a summary overview and your specific device may not have all the peripherals in this table. Please discover modm's peripheral drivers for your specific device . STM32 SAM AT Peripheral F0 F1 F2 F3 F4 F7 G0 G4 L0 L1 L4 D21 90 Mega Tiny ADC \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u25cb \u25cb \u2705 \u2705 CAN \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2705 \u2717 \u2717 \u2705 \u2717 \u25cb \u25cb \u2717 Comparator \u25cb \u2717 \u2717 \u2705 \u2717 \u2717 \u25cb \u2705 \u25cb \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb DAC \u25cb \u25cb \u25cb \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u2717 \u25cb \u2717 DMA \u2705 \u2705 \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb \u2705 \u2705 \u2705 \u25cb \u2717 \u2717 \u2717 Ethernet \u2717 \u25cb \u25cb \u2717 \u25cb \u2705 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 External Interrupt \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 External Memory \u2717 \u2705 \u2705 \u2717 \u2705 \u25cb \u2717 \u25cb \u2717 \u2717 \u25cb \u2717 \u2717 \u2717 \u2717 GPIO \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 I 2 C \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u2705 Internal Flash \u25cb \u25cb \u25cb \u25cb \u2705 \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb \u25cb \u2717 \u2717 \u2717 Random Generator \u2717 \u2717 \u2705 \u2717 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2705 \u2717 \u2717 \u2717 \u2717 SPI \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u2705 System Clock \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2717 \u2717 Timer \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u25cb \u25cb UART \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb Unique ID \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2717 \u2717 \u2717 USB \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2717 \u2717 We are only a small team of developers and are limited in the amount of devices we can support and test in hardware. Open an issue to ask if your specific device is supported out-of-the-box and what you can do if it is not. Boards \u00b6 We have out-of-box support for many development boards including documentation. AL-AVREB-CAN Arduino NANO Arduino UNO Black Pill F103 Black Pill F401 Black Pill F411 Blue Pill F103 DEVEBOX-STM32F4XX DISCO-F051R8 DISCO-F072RB DISCO-F100RB DISCO-F303VC DISCO-F407VG DISCO-F429ZI DISCO-F469NI DISCO-F746NG DISCO-F769NI DISCO-L152RC DISCO-L476VG FEATHER-M0 MEGA-2560-PRO NUCLEO-F031K6 NUCLEO-F042K6 NUCLEO-F103RB NUCLEO-F303K8 NUCLEO-F303RE NUCLEO-F334R8 NUCLEO-F401RE NUCLEO-F411RE NUCLEO-F429ZI NUCLEO-F439ZI NUCLEO-F446RE NUCLEO-F446ZE NUCLEO-F746ZG NUCLEO-F767ZI NUCLEO-G071RB NUCLEO-G431KB NUCLEO-G431RB NUCLEO-G474RE NUCLEO-L031K6 NUCLEO-L152RE NUCLEO-L432KC NUCLEO-L452RE NUCLEO-L476RG OLIMEXINO-STM32 Raspberry Pi SAMD21-MINI STM32-F4VE STM32F030-DEMO Drivers \u00b6 We also have a number of completely target-independent drivers for external devices connected via I 2 C, SPI, UART, BitBang, etc. Most of these also give you access to the entire device so you can easily configure them for you specific needs. AD7280A AD7928 ADNS9800 ADS7843 AMS5915 APA102 SPI-FLASH BME280 BMP085 BNO055 CAT24AA DRV832X DS1302 DS1631 DS18B20 EA-DOG ENCODER-INPUT-BITBANG ENCODER-OUTPUT-BITBANG FT245 FT6X06 GPIO-SAMPLER HCLAx HD44780 HMC58x HMC6343 HX711 I2C-EEPROM ILI9341 IS31FL3733 ITG3200 L3GD20 LAN8720A LAWICEL LIS302DL LIS3DSH LIS3MDL LM75 LP503X LSM303A LSM6DS33 LTC2984 MAX6966 MAX7219 MCP23X17 MCP2515 MMC5603 NOKIA5110 NRF24 TFT-DISPLAY PAT9125EL PCA8574 PCA9535 PCA9548A PCA9685 SIEMENS-S65 SIEMENS-S75 SK6812 SK9822 SSD1306 STUSB4500 SX1276 TCS3414 TCS3472 TLC594X TMP102 TMP175 TOUCH2046 VL53L0 VL6180 WS2812 Examples \u00b6 We have a huge number of examples which are always up-to-date and compilable as enforced by our CI. AVR: 1-wire/ds18b20 AVR: adc/basic AVR: adc/oversample AVR: app_can2usb AVR: assert AVR: block_device_mirror AVR: can/mcp2515 AVR: can/mcp2515_uart AVR: display/dogm128/benchmark AVR: display/dogm128/caged_ball AVR: display/dogm128/draw AVR: display/dogm128/image AVR: display/dogm128/text AVR: display/dogm128/touch AVR: display/dogm132 AVR: display/dogm163 AVR: display/hd44780 AVR: display/siemens_s65 AVR: flash AVR: gpio/basic AVR: gpio/blinking AVR: gpio/button_group AVR: logger AVR: mega_pro AVR: ports AVR: protothread AVR: pwm/pca9685 AVR: sab/master AVR: sab/slave AVR: timeout AVR: timer AVR: uart/basic AVR: uart/extended AVR: xpcc/receiver AVR: xpcc/sender Arduino NANO: color Arduino NANO: encoder_input Arduino UNO: basic/analog_read_serial Arduino UNO: basic/blink Arduino UNO: basic/digital_read_serial Arduino UNO: basic/read_analog_voltage Black Pill F103: blink Black Pill F401: blink Black Pill F411: blink Black Pill F411: usbfatfs Blue Pill F103: adns_9800 Blue Pill F103: blink Blue Pill F103: can Blue Pill F103: environment Blue Pill F103: graphics Blue Pill F103: logger Blue Pill F103: tlc594x Blue Pill F103: weight_scale_hx711 Generic: blinky Generic: i2c_multiplex Generic: resumable Generic: ros/can_bridge Generic: ros/environment Generic: ros/sub_pub Generic: rtc_ds1302 Generic: usb Linux: assert Linux: block_device/file Linux: block_device/mirror Linux: block_device/ram Linux: build_info Linux: can_debugger Linux: git Linux: logger Linux: printf Linux: serial_interface Linux: static_serial_interface Linux: threads NUCLEO-F031K6: blink NUCLEO-F031K6: sk6812 NUCLEO-F042K6: adc NUCLEO-F042K6: blink NUCLEO-F042K6: lis3mdl NUCLEO-F042K6: lp503x NUCLEO-F042K6: lsm6ds33 NUCLEO-F042K6: spi_dma NUCLEO-F103RB: blink NUCLEO-F103RB: hard_fault NUCLEO-F103RB: itm NUCLEO-F103RB: rtos NUCLEO-F103RB: undefined_irq NUCLEO-F303K8: blink NUCLEO-F303K8: rtos NUCLEO-F303RE: blink NUCLEO-F303RE: itm NUCLEO-F303RE: rtos NUCLEO-F303RE: spi_dma NUCLEO-F334R8: blink NUCLEO-F401RE: blink NUCLEO-F401RE: distance_vl53l0 NUCLEO-F411RE: blink NUCLEO-F411RE: imu_bno055 NUCLEO-F411RE: radio/nrf24-basic-comm NUCLEO-F411RE: radio/nrf24-data NUCLEO-F411RE: radio/nrf24-phy-test NUCLEO-F411RE: radio/nrf24-scanner NUCLEO-F411RE: rtos NUCLEO-F411RE: sx1276_rx NUCLEO-F411RE: sx1276_tx NUCLEO-F411RE: ws2812b NUCLEO-F429ZI: blink NUCLEO-F429ZI: cmsis_dsp/class_marks NUCLEO-F429ZI: cmsis_dsp/convolution NUCLEO-F429ZI: cmsis_dsp/dotproduct NUCLEO-F429ZI: cmsis_dsp/fft_bin NUCLEO-F429ZI: cmsis_dsp/fir NUCLEO-F429ZI: cmsis_dsp/graphic_equalizer NUCLEO-F429ZI: cmsis_dsp/linear_interp NUCLEO-F429ZI: cmsis_dsp/matrix NUCLEO-F429ZI: cmsis_dsp/signal_converge NUCLEO-F429ZI: cmsis_dsp/sin_cos NUCLEO-F429ZI: cmsis_dsp/variance NUCLEO-F429ZI: freertos_plus_tcp NUCLEO-F429ZI: pat9125el NUCLEO-F429ZI: spi_flash NUCLEO-F439ZI: blink NUCLEO-F446RE: blink NUCLEO-F446RE: color NUCLEO-F446RE: flash NUCLEO-F446ZE: blink NUCLEO-F446ZE: usbserial NUCLEO-F746ZG: blink NUCLEO-F767ZI: blink NUCLEO-F767ZI: ethernet NUCLEO-G071RB: adc NUCLEO-G071RB: amnb NUCLEO-G071RB: apa102 NUCLEO-G071RB: blink NUCLEO-G071RB: custom_allocator NUCLEO-G071RB: flash NUCLEO-G071RB: matrix NUCLEO-G071RB: rtos NUCLEO-G431KB: blink NUCLEO-G431RB: blink NUCLEO-G474RE: adc_basic NUCLEO-G474RE: blink NUCLEO-G474RE: can NUCLEO-L031K6: blink NUCLEO-L152RE: blink NUCLEO-L432KC: blink NUCLEO-L432KC: comp NUCLEO-L432KC: gyroscope NUCLEO-L432KC: pwm NUCLEO-L432KC: pwm_advanced NUCLEO-L432KC: spi_dma NUCLEO-L432KC: uart_spi NUCLEO-L452RE: blink NUCLEO-L452RE: graphics_touch NUCLEO-L452RE: lvgl NUCLEO-L476RG: adc NUCLEO-L476RG: blink NUCLEO-L476RG: i2c_test OLIMEXINO-STM32: blink RPI: blinky SAMD: blink SAMD: interrupt SAMD: usbserial STM32-F4VE: flash STM32-F4VE: gui STM32F0-DISCOVERY: blink STM32F0-DISCOVERY: logger STM32F030F4P6-DEMO-BOARD: adc STM32F030F4P6-DEMO-BOARD: blink STM32F072-DISCOVERY: blink STM32F072-DISCOVERY: can STM32F072-DISCOVERY: hard_fault STM32F072-DISCOVERY: rotation STM32F072-DISCOVERY: stusb4500 STM32F072-DISCOVERY: tmp102 STM32F072-DISCOVERY: uart STM32F072-DISCOVERY: unaligned_access STM32F1-DISCOVERY: blink STM32F1-DISCOVERY: logger STM32F3-DISCOVERY: accelerometer STM32F3-DISCOVERY: adc/continous STM32F3-DISCOVERY: adc/interrupt STM32F3-DISCOVERY: adc/simple STM32F3-DISCOVERY: blink STM32F3-DISCOVERY: can STM32F3-DISCOVERY: comp STM32F3-DISCOVERY: ft245 STM32F3-DISCOVERY: gdb STM32F3-DISCOVERY: rotation STM32F3-DISCOVERY: rtt STM32F3-DISCOVERY: timer/basic STM32F3-DISCOVERY: uart/hal STM32F3-DISCOVERY: uart/logger STM32F3-DISCOVERY: usb_dfu STM32F4-DISCOVERY: accelerometer STM32F4-DISCOVERY: adc/interrupt STM32F4-DISCOVERY: adc/oversample STM32F4-DISCOVERY: adc/simple STM32F4-DISCOVERY: app_uart_sniffer STM32F4-DISCOVERY: barometer_bmp085_bmp180 STM32F4-DISCOVERY: blink STM32F4-DISCOVERY: can STM32F4-DISCOVERY: can2 STM32F4-DISCOVERY: colour_tcs3414 STM32F4-DISCOVERY: display/hd44780 STM32F4-DISCOVERY: display/nokia_5110 STM32F4-DISCOVERY: display/ssd1306 STM32F4-DISCOVERY: distance_vl6180 STM32F4-DISCOVERY: encoder_output STM32F4-DISCOVERY: exti STM32F4-DISCOVERY: fpu STM32F4-DISCOVERY: fsmc STM32F4-DISCOVERY: led_matrix_display STM32F4-DISCOVERY: open407v-d/gui STM32F4-DISCOVERY: open407v-d/touchscreen STM32F4-DISCOVERY: pressure_ams5915 STM32F4-DISCOVERY: protothreads STM32F4-DISCOVERY: sab2 STM32F4-DISCOVERY: spi STM32F4-DISCOVERY: temperature_ltc2984 STM32F4-DISCOVERY: timer STM32F4-DISCOVERY: timer_test STM32F4-DISCOVERY: uart STM32F4-DISCOVERY: uart_spi STM32F407VET6-DEVEBOX: blinky STM32F407VET6-DEVEBOX: flash STM32F407VET6-DEVEBOX: logger STM32F429-DISCOVERY: blink STM32F429-DISCOVERY: logger STM32F469-DISCOVERY: assert STM32F469-DISCOVERY: blink STM32F469-DISCOVERY: can STM32F469-DISCOVERY: display STM32F469-DISCOVERY: exceptions_rtti STM32F469-DISCOVERY: game_of_life STM32F469-DISCOVERY: hard_fault STM32F469-DISCOVERY: lvgl STM32F469-DISCOVERY: ports STM32F469-DISCOVERY: threadsafe_statics STM32F469-DISCOVERY: tlsf-allocator STM32F469-DISCOVERY: touchscreen STM32F746G-DISCOVERY: adc_ad7928 STM32F746G-DISCOVERY: blink STM32F746G-DISCOVERY: rtos STM32F746G-DISCOVERY: tmp102 STM32F769I-DISCOVERY: blink STM32L1-DISCOVERY: blink STM32L476-DISCOVERY: blink","title":"Introduction"},{"location":"#modm-a-barebone-embedded-library-generator","text":"modm (pronounced like dial-up \"modem\") is a toolbox for building custom C++20 libraries tailored to your embedded device. modm generates startup code, HALs and their implementations, communication protocols, drivers for external devices, BSPs, etc\u2026 in a modular, customizable process that you can fine-tune to your needs. Install the toolchain and explore our examples . You can discover the modm library in more detail. Easily start your own completely custom project . Our CI checks every contribution for regressions. We care about testing modm . API reference is available here . We do quarterly releases with a curated changelog . This project also has a technical blog to document larger design concepts. You found a bug? Open up an issue, we don't bite . You want to contribute? Read the contribution guidelines and open a pull request . modm is optimized for the harsh requirements of the Eurobot competition , where our robots need to run reliably and completely autonomously for the game's 100 second duration. Our robots contain a lot of different microcontrollers, some without a lot of resources, so modm needs to fulfill a diverse set of objectives, like small code size with small memory consumption, predictable program flow, extreme portability. The library source code is licensed as MPLv2 with any external source code under compatible licenses (BSD, Apache2, MIT). So feel free to fork this project and adapt it to your needs. The only thing we ask of you is to contribute your changes back so everyone can benefit. Please clone modm recursively, you need all the submodules: git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git","title":"modm: a barebone embedded library generator"},{"location":"#features","text":"Efficient and fast object-oriented C++20 API. Support for hundreds of AVR and ARM Cortex-M microcontrollers from Atmel and ST. Build system agnostic: Choose SCons, CMake, Makefile or use your own. Data-driven, target-specific HAL generation using the lbuild engine. No memory allocations in HAL with very low overall RAM consumption. Highly configurable modules with sensible defaults and lots of documentation. Cross-platform peripheral interfaces incl. bit banging: GPIO, External Interrupt and IO expanders. ADC, DAC and Comparators. UART, I 2 C, SPI, CAN and Ethernet. Interfaces and drivers for many external I 2 C and SPI sensors and devices. Debug/logging system with IOStream and printf interface. Lightweight, stackless threads and resumable functions using cooperative multitasking. Functional (partial) libstdc++ implementation for AVRs. Useful filter, interpolation and geometric algorithms. Lightweight unit testing system (suitable for AVRs). Hundreds of tests to ensure correct functionality. Integration of useful third-party software: FreeRTOS and FreeRTOS+TCP . CMSIS and CMSIS-DSP . TinyUSB . FatFS . ROSserial . CrashCatcher .","title":"Features"},{"location":"#microcontrollers","text":"modm can create a HAL for 3107 devices of these vendors: STMicroelectronics STM32: 2438 devices. Microchip SAM: 163 devices. Microchip AVR: 506 devices. Here is a table with all device families and the peripheral drivers they support: \u2705 Implemented as a software driver in modm. \u25cb Available in hardware but missing a software driver in modm. \u2717 Unavailable in hardware or device with that peripheral not supported by modm. Note that this is a summary overview and your specific device may not have all the peripherals in this table. Please discover modm's peripheral drivers for your specific device . STM32 SAM AT Peripheral F0 F1 F2 F3 F4 F7 G0 G4 L0 L1 L4 D21 90 Mega Tiny ADC \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u25cb \u25cb \u2705 \u2705 CAN \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2705 \u2717 \u2717 \u2705 \u2717 \u25cb \u25cb \u2717 Comparator \u25cb \u2717 \u2717 \u2705 \u2717 \u2717 \u25cb \u2705 \u25cb \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb DAC \u25cb \u25cb \u25cb \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u25cb \u2717 \u25cb \u2717 DMA \u2705 \u2705 \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb \u2705 \u2705 \u2705 \u25cb \u2717 \u2717 \u2717 Ethernet \u2717 \u25cb \u25cb \u2717 \u25cb \u2705 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 \u2717 External Interrupt \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 External Memory \u2717 \u2705 \u2705 \u2717 \u2705 \u25cb \u2717 \u25cb \u2717 \u2717 \u25cb \u2717 \u2717 \u2717 \u2717 GPIO \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 I 2 C \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u2705 Internal Flash \u25cb \u25cb \u25cb \u25cb \u2705 \u25cb \u2705 \u25cb \u25cb \u25cb \u25cb \u25cb \u2717 \u2717 \u2717 Random Generator \u2717 \u2717 \u2705 \u2717 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2705 \u2717 \u2717 \u2717 \u2717 SPI \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u2705 \u2705 \u2705 System Clock \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2717 \u2717 Timer \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb \u25cb \u25cb \u25cb UART \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u25cb Unique ID \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2717 \u2717 \u2717 USB \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2705 \u2705 \u2705 \u2705 \u2705 \u2717 \u2717 \u2717 We are only a small team of developers and are limited in the amount of devices we can support and test in hardware. Open an issue to ask if your specific device is supported out-of-the-box and what you can do if it is not.","title":"Microcontrollers"},{"location":"#boards","text":"We have out-of-box support for many development boards including documentation. AL-AVREB-CAN Arduino NANO Arduino UNO Black Pill F103 Black Pill F401 Black Pill F411 Blue Pill F103 DEVEBOX-STM32F4XX DISCO-F051R8 DISCO-F072RB DISCO-F100RB DISCO-F303VC DISCO-F407VG DISCO-F429ZI DISCO-F469NI DISCO-F746NG DISCO-F769NI DISCO-L152RC DISCO-L476VG FEATHER-M0 MEGA-2560-PRO NUCLEO-F031K6 NUCLEO-F042K6 NUCLEO-F103RB NUCLEO-F303K8 NUCLEO-F303RE NUCLEO-F334R8 NUCLEO-F401RE NUCLEO-F411RE NUCLEO-F429ZI NUCLEO-F439ZI NUCLEO-F446RE NUCLEO-F446ZE NUCLEO-F746ZG NUCLEO-F767ZI NUCLEO-G071RB NUCLEO-G431KB NUCLEO-G431RB NUCLEO-G474RE NUCLEO-L031K6 NUCLEO-L152RE NUCLEO-L432KC NUCLEO-L452RE NUCLEO-L476RG OLIMEXINO-STM32 Raspberry Pi SAMD21-MINI STM32-F4VE STM32F030-DEMO","title":"Boards"},{"location":"#drivers","text":"We also have a number of completely target-independent drivers for external devices connected via I 2 C, SPI, UART, BitBang, etc. Most of these also give you access to the entire device so you can easily configure them for you specific needs. AD7280A AD7928 ADNS9800 ADS7843 AMS5915 APA102 SPI-FLASH BME280 BMP085 BNO055 CAT24AA DRV832X DS1302 DS1631 DS18B20 EA-DOG ENCODER-INPUT-BITBANG ENCODER-OUTPUT-BITBANG FT245 FT6X06 GPIO-SAMPLER HCLAx HD44780 HMC58x HMC6343 HX711 I2C-EEPROM ILI9341 IS31FL3733 ITG3200 L3GD20 LAN8720A LAWICEL LIS302DL LIS3DSH LIS3MDL LM75 LP503X LSM303A LSM6DS33 LTC2984 MAX6966 MAX7219 MCP23X17 MCP2515 MMC5603 NOKIA5110 NRF24 TFT-DISPLAY PAT9125EL PCA8574 PCA9535 PCA9548A PCA9685 SIEMENS-S65 SIEMENS-S75 SK6812 SK9822 SSD1306 STUSB4500 SX1276 TCS3414 TCS3472 TLC594X TMP102 TMP175 TOUCH2046 VL53L0 VL6180 WS2812","title":"Drivers"},{"location":"#examples","text":"We have a huge number of examples which are always up-to-date and compilable as enforced by our CI. AVR: 1-wire/ds18b20 AVR: adc/basic AVR: adc/oversample AVR: app_can2usb AVR: assert AVR: block_device_mirror AVR: can/mcp2515 AVR: can/mcp2515_uart AVR: display/dogm128/benchmark AVR: display/dogm128/caged_ball AVR: display/dogm128/draw AVR: display/dogm128/image AVR: display/dogm128/text AVR: display/dogm128/touch AVR: display/dogm132 AVR: display/dogm163 AVR: display/hd44780 AVR: display/siemens_s65 AVR: flash AVR: gpio/basic AVR: gpio/blinking AVR: gpio/button_group AVR: logger AVR: mega_pro AVR: ports AVR: protothread AVR: pwm/pca9685 AVR: sab/master AVR: sab/slave AVR: timeout AVR: timer AVR: uart/basic AVR: uart/extended AVR: xpcc/receiver AVR: xpcc/sender Arduino NANO: color Arduino NANO: encoder_input Arduino UNO: basic/analog_read_serial Arduino UNO: basic/blink Arduino UNO: basic/digital_read_serial Arduino UNO: basic/read_analog_voltage Black Pill F103: blink Black Pill F401: blink Black Pill F411: blink Black Pill F411: usbfatfs Blue Pill F103: adns_9800 Blue Pill F103: blink Blue Pill F103: can Blue Pill F103: environment Blue Pill F103: graphics Blue Pill F103: logger Blue Pill F103: tlc594x Blue Pill F103: weight_scale_hx711 Generic: blinky Generic: i2c_multiplex Generic: resumable Generic: ros/can_bridge Generic: ros/environment Generic: ros/sub_pub Generic: rtc_ds1302 Generic: usb Linux: assert Linux: block_device/file Linux: block_device/mirror Linux: block_device/ram Linux: build_info Linux: can_debugger Linux: git Linux: logger Linux: printf Linux: serial_interface Linux: static_serial_interface Linux: threads NUCLEO-F031K6: blink NUCLEO-F031K6: sk6812 NUCLEO-F042K6: adc NUCLEO-F042K6: blink NUCLEO-F042K6: lis3mdl NUCLEO-F042K6: lp503x NUCLEO-F042K6: lsm6ds33 NUCLEO-F042K6: spi_dma NUCLEO-F103RB: blink NUCLEO-F103RB: hard_fault NUCLEO-F103RB: itm NUCLEO-F103RB: rtos NUCLEO-F103RB: undefined_irq NUCLEO-F303K8: blink NUCLEO-F303K8: rtos NUCLEO-F303RE: blink NUCLEO-F303RE: itm NUCLEO-F303RE: rtos NUCLEO-F303RE: spi_dma NUCLEO-F334R8: blink NUCLEO-F401RE: blink NUCLEO-F401RE: distance_vl53l0 NUCLEO-F411RE: blink NUCLEO-F411RE: imu_bno055 NUCLEO-F411RE: radio/nrf24-basic-comm NUCLEO-F411RE: radio/nrf24-data NUCLEO-F411RE: radio/nrf24-phy-test NUCLEO-F411RE: radio/nrf24-scanner NUCLEO-F411RE: rtos NUCLEO-F411RE: sx1276_rx NUCLEO-F411RE: sx1276_tx NUCLEO-F411RE: ws2812b NUCLEO-F429ZI: blink NUCLEO-F429ZI: cmsis_dsp/class_marks NUCLEO-F429ZI: cmsis_dsp/convolution NUCLEO-F429ZI: cmsis_dsp/dotproduct NUCLEO-F429ZI: cmsis_dsp/fft_bin NUCLEO-F429ZI: cmsis_dsp/fir NUCLEO-F429ZI: cmsis_dsp/graphic_equalizer NUCLEO-F429ZI: cmsis_dsp/linear_interp NUCLEO-F429ZI: cmsis_dsp/matrix NUCLEO-F429ZI: cmsis_dsp/signal_converge NUCLEO-F429ZI: cmsis_dsp/sin_cos NUCLEO-F429ZI: cmsis_dsp/variance NUCLEO-F429ZI: freertos_plus_tcp NUCLEO-F429ZI: pat9125el NUCLEO-F429ZI: spi_flash NUCLEO-F439ZI: blink NUCLEO-F446RE: blink NUCLEO-F446RE: color NUCLEO-F446RE: flash NUCLEO-F446ZE: blink NUCLEO-F446ZE: usbserial NUCLEO-F746ZG: blink NUCLEO-F767ZI: blink NUCLEO-F767ZI: ethernet NUCLEO-G071RB: adc NUCLEO-G071RB: amnb NUCLEO-G071RB: apa102 NUCLEO-G071RB: blink NUCLEO-G071RB: custom_allocator NUCLEO-G071RB: flash NUCLEO-G071RB: matrix NUCLEO-G071RB: rtos NUCLEO-G431KB: blink NUCLEO-G431RB: blink NUCLEO-G474RE: adc_basic NUCLEO-G474RE: blink NUCLEO-G474RE: can NUCLEO-L031K6: blink NUCLEO-L152RE: blink NUCLEO-L432KC: blink NUCLEO-L432KC: comp NUCLEO-L432KC: gyroscope NUCLEO-L432KC: pwm NUCLEO-L432KC: pwm_advanced NUCLEO-L432KC: spi_dma NUCLEO-L432KC: uart_spi NUCLEO-L452RE: blink NUCLEO-L452RE: graphics_touch NUCLEO-L452RE: lvgl NUCLEO-L476RG: adc NUCLEO-L476RG: blink NUCLEO-L476RG: i2c_test OLIMEXINO-STM32: blink RPI: blinky SAMD: blink SAMD: interrupt SAMD: usbserial STM32-F4VE: flash STM32-F4VE: gui STM32F0-DISCOVERY: blink STM32F0-DISCOVERY: logger STM32F030F4P6-DEMO-BOARD: adc STM32F030F4P6-DEMO-BOARD: blink STM32F072-DISCOVERY: blink STM32F072-DISCOVERY: can STM32F072-DISCOVERY: hard_fault STM32F072-DISCOVERY: rotation STM32F072-DISCOVERY: stusb4500 STM32F072-DISCOVERY: tmp102 STM32F072-DISCOVERY: uart STM32F072-DISCOVERY: unaligned_access STM32F1-DISCOVERY: blink STM32F1-DISCOVERY: logger STM32F3-DISCOVERY: accelerometer STM32F3-DISCOVERY: adc/continous STM32F3-DISCOVERY: adc/interrupt STM32F3-DISCOVERY: adc/simple STM32F3-DISCOVERY: blink STM32F3-DISCOVERY: can STM32F3-DISCOVERY: comp STM32F3-DISCOVERY: ft245 STM32F3-DISCOVERY: gdb STM32F3-DISCOVERY: rotation STM32F3-DISCOVERY: rtt STM32F3-DISCOVERY: timer/basic STM32F3-DISCOVERY: uart/hal STM32F3-DISCOVERY: uart/logger STM32F3-DISCOVERY: usb_dfu STM32F4-DISCOVERY: accelerometer STM32F4-DISCOVERY: adc/interrupt STM32F4-DISCOVERY: adc/oversample STM32F4-DISCOVERY: adc/simple STM32F4-DISCOVERY: app_uart_sniffer STM32F4-DISCOVERY: barometer_bmp085_bmp180 STM32F4-DISCOVERY: blink STM32F4-DISCOVERY: can STM32F4-DISCOVERY: can2 STM32F4-DISCOVERY: colour_tcs3414 STM32F4-DISCOVERY: display/hd44780 STM32F4-DISCOVERY: display/nokia_5110 STM32F4-DISCOVERY: display/ssd1306 STM32F4-DISCOVERY: distance_vl6180 STM32F4-DISCOVERY: encoder_output STM32F4-DISCOVERY: exti STM32F4-DISCOVERY: fpu STM32F4-DISCOVERY: fsmc STM32F4-DISCOVERY: led_matrix_display STM32F4-DISCOVERY: open407v-d/gui STM32F4-DISCOVERY: open407v-d/touchscreen STM32F4-DISCOVERY: pressure_ams5915 STM32F4-DISCOVERY: protothreads STM32F4-DISCOVERY: sab2 STM32F4-DISCOVERY: spi STM32F4-DISCOVERY: temperature_ltc2984 STM32F4-DISCOVERY: timer STM32F4-DISCOVERY: timer_test STM32F4-DISCOVERY: uart STM32F4-DISCOVERY: uart_spi STM32F407VET6-DEVEBOX: blinky STM32F407VET6-DEVEBOX: flash STM32F407VET6-DEVEBOX: logger STM32F429-DISCOVERY: blink STM32F429-DISCOVERY: logger STM32F469-DISCOVERY: assert STM32F469-DISCOVERY: blink STM32F469-DISCOVERY: can STM32F469-DISCOVERY: display STM32F469-DISCOVERY: exceptions_rtti STM32F469-DISCOVERY: game_of_life STM32F469-DISCOVERY: hard_fault STM32F469-DISCOVERY: lvgl STM32F469-DISCOVERY: ports STM32F469-DISCOVERY: threadsafe_statics STM32F469-DISCOVERY: tlsf-allocator STM32F469-DISCOVERY: touchscreen STM32F746G-DISCOVERY: adc_ad7928 STM32F746G-DISCOVERY: blink STM32F746G-DISCOVERY: rtos STM32F746G-DISCOVERY: tmp102 STM32F769I-DISCOVERY: blink STM32L1-DISCOVERY: blink STM32L476-DISCOVERY: blink","title":"Examples"},{"location":"how-modm-works/","text":"How modm works \u00b6 modm is an umbrella project for a handful of stand-alone projects and acts as a curated toolbox for creating custom C++ libraries for embedded targets. Three of these projects form the heart of modm: modm-devices contains hardware descriptions like memories, peripherals and pins of many devices. modm provides configurable modules to translate this data into code, tests and documentation. lbuild links these two together using the Jinja2 template engine in Python to create a custom library for your target. As a developer you can use lbuild to explore the modm modules, configure them specifically for your targets and needs and generate a custom library. You can generate more than just code, in this example, lbuild also generates a build system which then compiles and links the application into a executable. @media(prefers-color-scheme:dark){img{filter:invert(100%)}} We've also put a lot of thought into modm-devices, about what data to extract, how to format and store it. We automated the entire process to get the high quality data we use to build our library. You can read all about modm-devices in this blog post . modm is highly modular \u00b6 modm's modules are kept small in scope on purpose and declare their dependencies, so that lbuild can build a minimal library from the initial modules you specified. So if you only want to use our UART drivers for example, lbuild will only include code from that module and its dependencies. This makes it easier to understand what parts of modm you actually use, either by looking at the dependency graph before, or by inspecting the generated code after calling lbuild, and gives you the opportunity to only use the parts of modm you really like. A lbuild module is just a few lines of Python code. Here we can see the code for the modm:platform:uart module from the example above. It declares its name, its dependencies and then which files it wants to generate where to using the data from modm-devices, by just setting the env.substitutions to the device's properties and calling env.template with the input and output file names. def init ( module ): module . name = \":platform:uart\" module . description = \"UART driver\" def prepare ( module , options ): module . depends ( \":architecture:interrupt\" , \":architecture:register\" , \":architecture:atomic\" , \":architecture:uart\" , \":platform:gpio\" ) return True def build ( env ): device = env [ \":target\" ] env . substitutions = device . properties env . outbasepath = \"src/modm/platform/uart\" for instance in device . get_driver ( \"uart:stm32*\" )[ \"instance\" ]: env . template ( \"uart.hpp.in\" , \"uart_ {} .hpp\" . format ( instance )) env . template ( \"uart.cpp.in\" , \"uart_ {} .cpp\" . format ( instance )) The input template then can access all the devices properties, and generate the correct code for this device. Here the template on left is passed to the Jinja2 engine which outputs the code on the right. void {{ name }}::write(uint8_t data) { %% if \"extended\" in driver[\"type\"] {{ peripheral }}->TDR = data; %% else {{ peripheral }}->DR = data; %% endif } void Uart4 :: write ( uint8_t data ) { UART4 -> DR = data ; } This example is simple, but since it's based on Python, anything more complicated is possible . Looking at the data excerpt from a STM32 device the above module will generate a only three classes of this type for this target. However, a similar driver will generate classes for the four USART peripherals. ... <driver name= \"uart\" type= \"stm32\" > <instance value= \"4\" /> <instance value= \"5\" /> <instance value= \"7\" /> </driver> <driver name= \"usart\" type= \"stm32\" > <instance value= \"1\" /> <instance value= \"2\" /> <instance value= \"3\" /> <instance value= \"6\" /> </driver> ... With these techiques we can generate a target specific HAL for hundreds of devices. modm asserts at compile-time \u00b6 modm stands out for its extensive use of generated static C++ (template) classes. Consider this data from the GPIO peripheral, which shows the signal map for the PA0 pin on a STM32 device. ... <driver name= \"gpio\" type= \"stm32\" > <gpio port= \"a\" pin= \"0\" > <signal driver= \"adc\" instance= \"1\" name= \"in0\" /> <signal driver= \"adc\" instance= \"2\" name= \"in0\" /> <signal driver= \"adc\" instance= \"3\" name= \"in0\" /> <signal af= \"1\" driver= \"tim\" instance= \"2\" name= \"ch1\" /> <signal af= \"2\" driver= \"tim\" instance= \"5\" name= \"ch1\" /> <signal af= \"8\" driver= \"uart\" instance= \"4\" name= \"tx\" /> ... We use this data in the modm:platform:gpio module to generate type-safe signal connections, which will then assert that the signal you want to connect actually exists on this pin and even gives you a helpful (!) error message at compile time. class GpioA0 { ... template < Peripheral peripheral > struct Tx { static_assert ( ( peripheral == Peripheral :: Uart4 ), \"GpioA0::Tx only connects to Uart4!\" ); }; template < Peripheral peripheral > struct Ch1 { static_assert ( ( peripheral == Peripheral :: Tim2 ) || ( peripheral == Peripheral :: Tim5 ), \"GpioA0::Ch1 only connects to Tim2 or Tim5!\" ); }; template < Peripheral peripheral > struct In0 { static_assert ( ( peripheral == Peripheral :: Adc1 ) || ( peripheral == Peripheral :: Adc2 ) || ( peripheral == Peripheral :: Adc3 ), \"GpioA0::In0 only connects to Adc1 or Adc2 or Adc3!\" ); }; ... }; Continuing with this technique, we can even check if your signal groups are conflict free of overlaps or invalid configurations and again give you a helpful error message! Uart4 :: connect < GpioA0 :: Tx > (); Adc1 :: connect < GpioA0 :: In0 , GpioA1 :: In1 > (); Tim2 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Tim5 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Maps to GpioA0::setAlternateFunction(8); Maps to GpioAx::setAnalogInput(); Each pin in group called with their respective Alternate Function ID Same API, but for Timer5 different Alternate Function IDs are used Uart4 :: connect < GpioA0 :: Rx > (); error: 'Rx' is not a member of 'GpioA0' Uart4 :: connect < GpioA2 :: Tx > (); error: GpioA2::Tx only connects to Usart2! Usart1 :: connect < GpioA9 :: Tx , GpioB7 :: Rx > (); error: This pin set contains conflicting remap groups! Available groups for Usart1 are: Usart1 | 0 | 1 --------|----|---- A9 | Tx | A10 | Rx | B6 | | Tx B7 | | Rx We use a similar technique to compute baudrates at compile time and make sure the resulting baudrates remains within the specified error tolerances. In addition the executable now only contains prescaler values which are written directly to the hardware without any computation required. This is very helpful for keeping code size in check on very resource constrained targets, like the AVRs. Uart4 :: connect < GpioA0 :: Tx , GpioA1 :: Rx > ( Gpio :: InputType :: PullUp ); // pull-up in RX pin Uart4 :: initialize < Board :: SystemClock , 115'200 _Bd > (); // Within 1% default tolerance Uart4 :: initialize < Board :: SystemClock , 115.2 _kBd , 0 _pct > (); // error: The closest available baudrate exceeds the tolerance of the requested baudrate! modm is fast and usable \u00b6 modm's APIs are kept simple and fast by splitting up functionality into separate, small, static functions, which implement the same behavior on all platforms. And with our code generation capabilities, we can hide the crazy implementation details of the hardware without compromising on performance. For example, on different AVRs, simple things like enabling the internal pull-up resistor, dealing with external interrupts or even just toggling a pin is done quite dissimilarly in hardware, yet we can wrap this in the same API for every target. Since we\u2018re using static inlined functions that often just compile to a handful of instructions we can call our GPIOs at ludicrous speed . // All pin functions follow a common naming scheme using Led = GpioB1 ; Led :: setOutput (); Led :: set (); Led :: reset (); Led :: toggle (); using Button = GpioA0 ; Button :: setInput (); bool state = Button :: read (); // Depending on your targets, additional functions are available Led :: setOutput ( Gpio :: OutputType :: OpenDrain ); Button :: setInput ( Gpio :: InputType :: PullUp ); Button :: setInputTrigger ( Gpio :: InputTrigger :: RisingEdge ); Button :: enableExternalInterrupt (); Button :: acknowledgeExternalInterruptFlag (); You can use these GPIOs as building blocks for more complex drivers and peripherals and still maintain access speed without sacrificing usability: // Create a hardware accelerated port of 4 bit width. using Port4 = GpioPort < GpioC0 , 4 > ; // MSB -> C3, C2, C1, C0 <- LSB using ReadWrite = GpioC4 ; // \"name\" your GPIOs. using Reset = GpioOutputC5 ; using Enable = GpioOutputC6 ; // Build a super fast character display driver using these inlined GPIOs. modm :: Hd44780 < Port4 , ReadWrite , Reset , Enable > display ; display . initialize (); // driver knows to initialize for a 4 bit bus! display << \"Hello World!\" << modm :: endl ; // Yes, ostreams. Deal with it. display . printf ( \"You don't really have to use %s!\" , \"OStreams\" ); All drivers in modm follow the same principle of building up your hardware drivers from other parts of the HAL by passing them as template parameters. This works surprisingly well to reduce both code size and execution time. For example, here is how you assemble and initialize a driver for the MCP23x17 GPIO expander and then use its pins. using Transport = modm :: Mcp23TransportSpi < SpiMaster1 , GpioA0 > ; using GpioExpander = modm :: Mcp23x17 < Transport > ; GpioExpander expander ; // Connect and initialize the peripherals SpiMaster1 :: connect < GpioA0 :: Sck , GpioA1 :: Mosi , GpioA2 :: Miso > (); SpiMaster1 :: initialize < Board :: SystemClock , 1 _MHz > (); expander . initialize (); // Bind the expander pins to a simpler name using Pin0 = GpioExpander :: P0 < expander > ; using Pin1 = GpioExpander :: P1 < expander > ; // Oh, look, same API Pin0 :: setOutput (); Pin0 :: toggle (); Pin1 :: setInput (); bool state = Pin1 :: read (); modm is memory-efficient \u00b6 Our HAL does not allocate memory dynamically \u2013 everything is either statically allocated or must explicitly be allocated by the user. This is a strong requirement for running modm on AVRs, which have little if any memory to spare for dynamic allocations. We took great care to make sure this constraint remains usable, making configuration options first-class citizens in lbuild for you to easily discover and safely change. When we do need to allocate static memory, we choose a sensible default size for its purpose. $ lbuild discover-module-options ... modm:platform:cortex-m:main_stack_size = 3040 [256 ... 65536] Minimum size of the application main stack ... modm:platform:uart:1:buffer.rx = 16 [1 ... 65534] modm:platform:uart:1:buffer.tx = 250 [1 ... 65534] We transparently show you how much static memory your application is using, so you get an idea of how much certain functionality costs you in resources. This is the size of the accelerometer example on the STM32F4 discovery board: $ cd examples/stm32f4_discovery/accelerometer $ scons ... Memory usage\u00b7\u00b7\u00b7 build/stm32f4_discovery/accelerometer/project.elf Program: 8144B (0.8% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3464B (1.7% used) = 424B static (0.2%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197240B (98.3% available) (.heap0 + .heap1 + .heap2 + .heap5) modm does multitasking \u00b6 modm uses stackless cooperative multitasking, for which we have ported protothreads to C++ and extended them with resumable functions. This enables you to split up your application into separate tasks, and use synchronous APIs in all of them, without sacrificing overall responsiveness. This works on even the most resource restricted AVRs, since each task only requires 2 bytes of static RAM! All our IC drivers are implemented using resumable functions, which can be called from within protothreads or explicitly blocking outside of them. Here is an example of reading out the accelerometer : class ReaderThread : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // The driver does several I2C transfer here to initialize and configure the // external sensor. The CPU is free to do other things while this happens though. PT_CALL ( accelerometer . configure ( accelerometer . Scale :: G2 )); while ( true ) // this feels quite similar to regular threads { // this resumable function will defer execution back to other protothreads PT_CALL ( accelerometer . readAcceleration ()); // smooth out the acceleration data a little bit averageX . update ( accelerometer . getData (). getX ()); averageY . update ( accelerometer . getData (). getY ()); // set the boards LEDs depending on the acceleration values LedUp :: set ( averageX . getValue () < -0.2 ); LedDown :: set ( averageX . getValue () > 0.2 ); LedLeft :: set ( averageY . getValue () < -0.2 ); LedRight :: set ( averageY . getValue () > 0.2 ); // defer back to other protothreads until the timer fires PT_WAIT_UNTIL ( timer . execute ()); } PT_END (); } private : // This accelerometer is connected via I2C. modm :: Lis3dsh < modm :: Lis3TransportI2c < I2cMaster > > accelerometer ; modm :: PeriodicTimer timer = modm :: PeriodicTimer ( 5 ); // 5ms periodic timer. modm :: filter :: MovingAverage < float , 25 > averageX ; modm :: filter :: MovingAverage < float , 25 > averageY ; }; ReaderThread reader ; // Protothread is statically allocated! int main () // Execution entry point. { while ( true ) { // the main loop with implicit round robin cooperative scheduling. reader . run (); otherProtothreads . run (); } return 0 ; }","title":"How modm works"},{"location":"how-modm-works/#how-modm-works","text":"modm is an umbrella project for a handful of stand-alone projects and acts as a curated toolbox for creating custom C++ libraries for embedded targets. Three of these projects form the heart of modm: modm-devices contains hardware descriptions like memories, peripherals and pins of many devices. modm provides configurable modules to translate this data into code, tests and documentation. lbuild links these two together using the Jinja2 template engine in Python to create a custom library for your target. As a developer you can use lbuild to explore the modm modules, configure them specifically for your targets and needs and generate a custom library. You can generate more than just code, in this example, lbuild also generates a build system which then compiles and links the application into a executable. @media(prefers-color-scheme:dark){img{filter:invert(100%)}} We've also put a lot of thought into modm-devices, about what data to extract, how to format and store it. We automated the entire process to get the high quality data we use to build our library. You can read all about modm-devices in this blog post .","title":"How modm works"},{"location":"how-modm-works/#modm-is-highly-modular","text":"modm's modules are kept small in scope on purpose and declare their dependencies, so that lbuild can build a minimal library from the initial modules you specified. So if you only want to use our UART drivers for example, lbuild will only include code from that module and its dependencies. This makes it easier to understand what parts of modm you actually use, either by looking at the dependency graph before, or by inspecting the generated code after calling lbuild, and gives you the opportunity to only use the parts of modm you really like. A lbuild module is just a few lines of Python code. Here we can see the code for the modm:platform:uart module from the example above. It declares its name, its dependencies and then which files it wants to generate where to using the data from modm-devices, by just setting the env.substitutions to the device's properties and calling env.template with the input and output file names. def init ( module ): module . name = \":platform:uart\" module . description = \"UART driver\" def prepare ( module , options ): module . depends ( \":architecture:interrupt\" , \":architecture:register\" , \":architecture:atomic\" , \":architecture:uart\" , \":platform:gpio\" ) return True def build ( env ): device = env [ \":target\" ] env . substitutions = device . properties env . outbasepath = \"src/modm/platform/uart\" for instance in device . get_driver ( \"uart:stm32*\" )[ \"instance\" ]: env . template ( \"uart.hpp.in\" , \"uart_ {} .hpp\" . format ( instance )) env . template ( \"uart.cpp.in\" , \"uart_ {} .cpp\" . format ( instance )) The input template then can access all the devices properties, and generate the correct code for this device. Here the template on left is passed to the Jinja2 engine which outputs the code on the right. void {{ name }}::write(uint8_t data) { %% if \"extended\" in driver[\"type\"] {{ peripheral }}->TDR = data; %% else {{ peripheral }}->DR = data; %% endif } void Uart4 :: write ( uint8_t data ) { UART4 -> DR = data ; } This example is simple, but since it's based on Python, anything more complicated is possible . Looking at the data excerpt from a STM32 device the above module will generate a only three classes of this type for this target. However, a similar driver will generate classes for the four USART peripherals. ... <driver name= \"uart\" type= \"stm32\" > <instance value= \"4\" /> <instance value= \"5\" /> <instance value= \"7\" /> </driver> <driver name= \"usart\" type= \"stm32\" > <instance value= \"1\" /> <instance value= \"2\" /> <instance value= \"3\" /> <instance value= \"6\" /> </driver> ... With these techiques we can generate a target specific HAL for hundreds of devices.","title":"modm is highly modular"},{"location":"how-modm-works/#modm-asserts-at-compile-time","text":"modm stands out for its extensive use of generated static C++ (template) classes. Consider this data from the GPIO peripheral, which shows the signal map for the PA0 pin on a STM32 device. ... <driver name= \"gpio\" type= \"stm32\" > <gpio port= \"a\" pin= \"0\" > <signal driver= \"adc\" instance= \"1\" name= \"in0\" /> <signal driver= \"adc\" instance= \"2\" name= \"in0\" /> <signal driver= \"adc\" instance= \"3\" name= \"in0\" /> <signal af= \"1\" driver= \"tim\" instance= \"2\" name= \"ch1\" /> <signal af= \"2\" driver= \"tim\" instance= \"5\" name= \"ch1\" /> <signal af= \"8\" driver= \"uart\" instance= \"4\" name= \"tx\" /> ... We use this data in the modm:platform:gpio module to generate type-safe signal connections, which will then assert that the signal you want to connect actually exists on this pin and even gives you a helpful (!) error message at compile time. class GpioA0 { ... template < Peripheral peripheral > struct Tx { static_assert ( ( peripheral == Peripheral :: Uart4 ), \"GpioA0::Tx only connects to Uart4!\" ); }; template < Peripheral peripheral > struct Ch1 { static_assert ( ( peripheral == Peripheral :: Tim2 ) || ( peripheral == Peripheral :: Tim5 ), \"GpioA0::Ch1 only connects to Tim2 or Tim5!\" ); }; template < Peripheral peripheral > struct In0 { static_assert ( ( peripheral == Peripheral :: Adc1 ) || ( peripheral == Peripheral :: Adc2 ) || ( peripheral == Peripheral :: Adc3 ), \"GpioA0::In0 only connects to Adc1 or Adc2 or Adc3!\" ); }; ... }; Continuing with this technique, we can even check if your signal groups are conflict free of overlaps or invalid configurations and again give you a helpful error message! Uart4 :: connect < GpioA0 :: Tx > (); Adc1 :: connect < GpioA0 :: In0 , GpioA1 :: In1 > (); Tim2 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Tim5 :: connect < GpioA0 :: Ch1 , GpioA1 :: Ch2 , GpioA2 :: Ch3 , GpioA3 :: Ch4 > (); Maps to GpioA0::setAlternateFunction(8); Maps to GpioAx::setAnalogInput(); Each pin in group called with their respective Alternate Function ID Same API, but for Timer5 different Alternate Function IDs are used Uart4 :: connect < GpioA0 :: Rx > (); error: 'Rx' is not a member of 'GpioA0' Uart4 :: connect < GpioA2 :: Tx > (); error: GpioA2::Tx only connects to Usart2! Usart1 :: connect < GpioA9 :: Tx , GpioB7 :: Rx > (); error: This pin set contains conflicting remap groups! Available groups for Usart1 are: Usart1 | 0 | 1 --------|----|---- A9 | Tx | A10 | Rx | B6 | | Tx B7 | | Rx We use a similar technique to compute baudrates at compile time and make sure the resulting baudrates remains within the specified error tolerances. In addition the executable now only contains prescaler values which are written directly to the hardware without any computation required. This is very helpful for keeping code size in check on very resource constrained targets, like the AVRs. Uart4 :: connect < GpioA0 :: Tx , GpioA1 :: Rx > ( Gpio :: InputType :: PullUp ); // pull-up in RX pin Uart4 :: initialize < Board :: SystemClock , 115'200 _Bd > (); // Within 1% default tolerance Uart4 :: initialize < Board :: SystemClock , 115.2 _kBd , 0 _pct > (); // error: The closest available baudrate exceeds the tolerance of the requested baudrate!","title":"modm asserts at compile-time"},{"location":"how-modm-works/#modm-is-fast-and-usable","text":"modm's APIs are kept simple and fast by splitting up functionality into separate, small, static functions, which implement the same behavior on all platforms. And with our code generation capabilities, we can hide the crazy implementation details of the hardware without compromising on performance. For example, on different AVRs, simple things like enabling the internal pull-up resistor, dealing with external interrupts or even just toggling a pin is done quite dissimilarly in hardware, yet we can wrap this in the same API for every target. Since we\u2018re using static inlined functions that often just compile to a handful of instructions we can call our GPIOs at ludicrous speed . // All pin functions follow a common naming scheme using Led = GpioB1 ; Led :: setOutput (); Led :: set (); Led :: reset (); Led :: toggle (); using Button = GpioA0 ; Button :: setInput (); bool state = Button :: read (); // Depending on your targets, additional functions are available Led :: setOutput ( Gpio :: OutputType :: OpenDrain ); Button :: setInput ( Gpio :: InputType :: PullUp ); Button :: setInputTrigger ( Gpio :: InputTrigger :: RisingEdge ); Button :: enableExternalInterrupt (); Button :: acknowledgeExternalInterruptFlag (); You can use these GPIOs as building blocks for more complex drivers and peripherals and still maintain access speed without sacrificing usability: // Create a hardware accelerated port of 4 bit width. using Port4 = GpioPort < GpioC0 , 4 > ; // MSB -> C3, C2, C1, C0 <- LSB using ReadWrite = GpioC4 ; // \"name\" your GPIOs. using Reset = GpioOutputC5 ; using Enable = GpioOutputC6 ; // Build a super fast character display driver using these inlined GPIOs. modm :: Hd44780 < Port4 , ReadWrite , Reset , Enable > display ; display . initialize (); // driver knows to initialize for a 4 bit bus! display << \"Hello World!\" << modm :: endl ; // Yes, ostreams. Deal with it. display . printf ( \"You don't really have to use %s!\" , \"OStreams\" ); All drivers in modm follow the same principle of building up your hardware drivers from other parts of the HAL by passing them as template parameters. This works surprisingly well to reduce both code size and execution time. For example, here is how you assemble and initialize a driver for the MCP23x17 GPIO expander and then use its pins. using Transport = modm :: Mcp23TransportSpi < SpiMaster1 , GpioA0 > ; using GpioExpander = modm :: Mcp23x17 < Transport > ; GpioExpander expander ; // Connect and initialize the peripherals SpiMaster1 :: connect < GpioA0 :: Sck , GpioA1 :: Mosi , GpioA2 :: Miso > (); SpiMaster1 :: initialize < Board :: SystemClock , 1 _MHz > (); expander . initialize (); // Bind the expander pins to a simpler name using Pin0 = GpioExpander :: P0 < expander > ; using Pin1 = GpioExpander :: P1 < expander > ; // Oh, look, same API Pin0 :: setOutput (); Pin0 :: toggle (); Pin1 :: setInput (); bool state = Pin1 :: read ();","title":"modm is fast and usable"},{"location":"how-modm-works/#modm-is-memory-efficient","text":"Our HAL does not allocate memory dynamically \u2013 everything is either statically allocated or must explicitly be allocated by the user. This is a strong requirement for running modm on AVRs, which have little if any memory to spare for dynamic allocations. We took great care to make sure this constraint remains usable, making configuration options first-class citizens in lbuild for you to easily discover and safely change. When we do need to allocate static memory, we choose a sensible default size for its purpose. $ lbuild discover-module-options ... modm:platform:cortex-m:main_stack_size = 3040 [256 ... 65536] Minimum size of the application main stack ... modm:platform:uart:1:buffer.rx = 16 [1 ... 65534] modm:platform:uart:1:buffer.tx = 250 [1 ... 65534] We transparently show you how much static memory your application is using, so you get an idea of how much certain functionality costs you in resources. This is the size of the accelerometer example on the STM32F4 discovery board: $ cd examples/stm32f4_discovery/accelerometer $ scons ... Memory usage\u00b7\u00b7\u00b7 build/stm32f4_discovery/accelerometer/project.elf Program: 8144B (0.8% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3464B (1.7% used) = 424B static (0.2%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197240B (98.3% available) (.heap0 + .heap1 + .heap2 + .heap5)","title":"modm is memory-efficient"},{"location":"how-modm-works/#modm-does-multitasking","text":"modm uses stackless cooperative multitasking, for which we have ported protothreads to C++ and extended them with resumable functions. This enables you to split up your application into separate tasks, and use synchronous APIs in all of them, without sacrificing overall responsiveness. This works on even the most resource restricted AVRs, since each task only requires 2 bytes of static RAM! All our IC drivers are implemented using resumable functions, which can be called from within protothreads or explicitly blocking outside of them. Here is an example of reading out the accelerometer : class ReaderThread : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // The driver does several I2C transfer here to initialize and configure the // external sensor. The CPU is free to do other things while this happens though. PT_CALL ( accelerometer . configure ( accelerometer . Scale :: G2 )); while ( true ) // this feels quite similar to regular threads { // this resumable function will defer execution back to other protothreads PT_CALL ( accelerometer . readAcceleration ()); // smooth out the acceleration data a little bit averageX . update ( accelerometer . getData (). getX ()); averageY . update ( accelerometer . getData (). getY ()); // set the boards LEDs depending on the acceleration values LedUp :: set ( averageX . getValue () < -0.2 ); LedDown :: set ( averageX . getValue () > 0.2 ); LedLeft :: set ( averageY . getValue () < -0.2 ); LedRight :: set ( averageY . getValue () > 0.2 ); // defer back to other protothreads until the timer fires PT_WAIT_UNTIL ( timer . execute ()); } PT_END (); } private : // This accelerometer is connected via I2C. modm :: Lis3dsh < modm :: Lis3TransportI2c < I2cMaster > > accelerometer ; modm :: PeriodicTimer timer = modm :: PeriodicTimer ( 5 ); // 5ms periodic timer. modm :: filter :: MovingAverage < float , 25 > averageX ; modm :: filter :: MovingAverage < float , 25 > averageY ; }; ReaderThread reader ; // Protothread is statically allocated! int main () // Execution entry point. { while ( true ) { // the main loop with implicit round robin cooperative scheduling. reader . run (); otherProtothreads . run (); } return 0 ; }","title":"modm does multitasking"},{"location":"who-we-are/","text":"Who we are \u00b6 The modm project is maintained by Niklas Hauser ( @salkinium ) and Raphael Lehmann ( @rleh ) with significant contributions from Sascha Schade ( @strongly-typed ), Fabian Greif ( @dergraaf ), Kevin L\u00e4ufer ( @ekiwi ), Martin Rosekeit ( @thundernail ), Daniel Krebs ( @daniel-k ), Georgi Grinshpun ( @georgi-g ), Christopher Durand ( @chris-durand ) David Hebbeker ( @dhebbeker ), Thorsten Lajewski ( @TheTh0r ), Mike Wolfram ( @mikewolfram ) and many more contributors . History of modm \u00b6 In the mid-2000s the [Roboterclub Aachen e.V.][rca_ev] has developed a software library called XPCC for communication among components that are distributed on PCs and microcontrollers. This library was initially used only in autonomous robots for the Eurobot competition . In 2009, XPCC became a separate project and over the years grew from a communication library to a general purpose framework (called lowercase xpcc, 'cos #namingthings) suitable for all kinds of embedded applications. Between 2016 and 2018, Niklas and Fabian refactored xpcc into modm by completely rewriting the way the library generates its HAL. This also gave us the tools to fix some larger architectural issues in xpcc's HAL as well as significantly improve customizability of the HAL and its documentation. All xpcc authors agreed to relicense their contributions from BSD to MPLv2 in modm. Eurobot and Team RCA \u00b6 Most of our contributors are or used to be members of the Roboterclub Aachen e.V.. We've been building robots for the Eurobot competition for many years now and all of them have been running xpcc or modm successfully as their only OS on dozens of different AVR and STM32 targets each. So modm is truly battle-tested in real-world conditions and has passed through the scrutiny of many capable engineers over the years. Check out how we're competing in the quarter finals of the Eurobot 2015 competition.","title":"Who we are"},{"location":"who-we-are/#who-we-are","text":"The modm project is maintained by Niklas Hauser ( @salkinium ) and Raphael Lehmann ( @rleh ) with significant contributions from Sascha Schade ( @strongly-typed ), Fabian Greif ( @dergraaf ), Kevin L\u00e4ufer ( @ekiwi ), Martin Rosekeit ( @thundernail ), Daniel Krebs ( @daniel-k ), Georgi Grinshpun ( @georgi-g ), Christopher Durand ( @chris-durand ) David Hebbeker ( @dhebbeker ), Thorsten Lajewski ( @TheTh0r ), Mike Wolfram ( @mikewolfram ) and many more contributors .","title":"Who we are"},{"location":"who-we-are/#history-of-modm","text":"In the mid-2000s the [Roboterclub Aachen e.V.][rca_ev] has developed a software library called XPCC for communication among components that are distributed on PCs and microcontrollers. This library was initially used only in autonomous robots for the Eurobot competition . In 2009, XPCC became a separate project and over the years grew from a communication library to a general purpose framework (called lowercase xpcc, 'cos #namingthings) suitable for all kinds of embedded applications. Between 2016 and 2018, Niklas and Fabian refactored xpcc into modm by completely rewriting the way the library generates its HAL. This also gave us the tools to fix some larger architectural issues in xpcc's HAL as well as significantly improve customizability of the HAL and its documentation. All xpcc authors agreed to relicense their contributions from BSD to MPLv2 in modm.","title":"History of modm"},{"location":"who-we-are/#eurobot-and-team-rca","text":"Most of our contributors are or used to be members of the Roboterclub Aachen e.V.. We've been building robots for the Eurobot competition for many years now and all of them have been running xpcc or modm successfully as their only OS on dozens of different AVR and STM32 targets each. So modm is truly battle-tested in real-world conditions and has passed through the scrutiny of many capable engineers over the years. Check out how we're competing in the quarter finals of the Eurobot 2015 competition.","title":"Eurobot and Team RCA"},{"location":"guide/custom-project/","text":"Starting a new Project \u00b6 The modm library explicitly generates and copies its files from inside the modm repository into your project using the lbuild code generator. It is intended and very strongly recommended to commit all generated files from lbuild build into your repository. This will make any changes very clear when you run lbuild build again with an updated version of modm! We recommend adding modm into your repository as a Git submodule so that you control exactly what version of modm you're using. We recommend you place the modm repository (and all other external code) into a folder called ext/ or similiar: $ git submodule add https://github.com/modm-io/modm.git ext/modm $ tree . \u2514\u2500\u2500 ext \u2514\u2500\u2500 modm \u251c\u2500\u2500 repo.lb ... Next you want to create a folder with a project.xml and a main.cpp file. We recommend you place that in a separate app/ folder so that all your firmwares are in the same place: $ tree . \u251c\u2500\u2500 ext \u2502 \u2514\u2500\u2500 modm \u2502 \u251c\u2500\u2500 repo.lb \u2502 ... \u2514\u2500\u2500 app \u2514\u2500\u2500 project_name \u251c\u2500\u2500 main.cpp \u2514\u2500\u2500 project.xml Place your applications into their own folder! All modm build systems search recursively for application sources inside the current folder. If you place the modm library repository into your application folder you will see build errors related to building sources twice: scons: *** Multiple ways to build the same target were specified for: ... The project.xml must contain the (relative) path to modm's repo.lb file. Note that the project name is inferred from the project folder, but you can easily change it. modm also does not add a build system by default, so you want to choose one at this point . Add the modm:docs module to generate custom API docs: <library> <repositories> <repository><path> ../modm/repo.lb </path></repository> </repositories> <options> <option name= \"modm:build:project.name\" > custom_name </option> </options> <modules> <module> modm:build:scons </module> <module> modm:docs </module> </modules> </library> You should now be able to discover modm from inside your project folder: $ cd app/project_name $ lbuild discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../../ext/modm) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ... ... Note that we've not yet declared the modm:target option, so you cannot discover all of modm yet. You can now choose from two levels of customization: Inherit and extend a board support package from modm. This is particularly useful if your project is based on an existing development board. Define your own modm:target option and required modules. This is necessary for using modm on a custom hardware design. Using a Board Support Package \u00b6 Use lbuild to discover the specific BSP configuration you want to use: $ lbuild discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../../ext/modm) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ... \u251c\u2500\u2500 Config(modm:disco-f469ni) STM32F469IDISCOVERY ... Then inherit from this configuration in your project.xml . This will add the modm:target option and give you a set of modules that the BSP depends on. Note that you can overwrite any options you don't agree with, however, you cannot remove any inherited modules. <library> <repositories> ... </repositories> <extends> modm:disco-f469ni </extends> <options> ... </options> <modules> ... </modules> </library> You can now lbuild discover all of modm. Note that the selected modules are now marked underlined as a subtle hint. Our board support packages provide their configuration in the Board namespace, which you can use to initialize the target and several board subsystems. If a serial connection is available on the board, you can directly use the modm logging functions. A minimal main.cpp can look like this: #include <modm/board.hpp> int main () { Board :: initialize (); Board :: Leds :: setOutput (); while ( true ) { Board :: Leds :: toggle (); modm :: delayMilliseconds ( Board :: Button :: read () ? 250 : 500 ); #ifdef MODM_BOARD_HAS_LOGGER static uint32_t counter ( 0 ); MODM_LOG_INFO << \"Loop counter: \" << ( counter ++ ) << modm :: endl ; #endif } return 0 ; } You can find more details about the BSPs capabilities on docs.modm.io which contains the full API documentation for all BSPs. Alternatively you can generate your own API docs locally: ( cd modm/docs && doxypress doxypress.json ) # open modm/docs/html/index.html Please note that the BSPs contain an opinionated set of pre-defined functionality and settings. This is great for getting started quickly, however, if you want to change some hardcoded things (like which UART to use for logging), it's better to use your own BSP: Generate the BSP closest to your custom hardware, then copy the files from modm/src/modm/board/{name} to your own project and modify them. In your project.xml remove the board config inheritance ( <extends> ) and instead copy the pre-defined options into your own config. Check what modm modules you need to depend on and add them to your own project (check for module.depends(...) in the BSPs module.lb ). You may need to manually add the pre-defined collector values to your project configuration (check for env.collect(...) in the BSPs module.lb ). Custom Configuration \u00b6 For completely custom hardware, you start by definining the modm:target option and then adding the modules with their options as needed. For example, a basic configuration for the STM32F469NIH6 with startup, GPIO and clock modules looks like this: <library> <repositories> <repository><path> ../../ext/modm/repo.lb </path></repository> </repositories> <options> <option name= \"modm:target\" > stm32f469nih6 </option> </options> <modules> <module> modm:platform:clock </module> <module> modm:platform:core </module> <module> modm:platform:gpio </module> <module> modm:architecture:delay </module> <module> modm:build:scons </module> <module> modm:docs </module> </modules> </library> Remember to include the modm:docs module, since you need to generate your own API docs from your specific configuration: ( cd modm/docs && doxypress doxypress.json ) # open modm/docs/html/index.html A minimal main.cpp for this configuration can look like this. Since there is no BSP, you need to #include <modm/platform.hpp> and add the modm::platform namespace manually. #include <modm/platform.hpp> using namespace modm :: platform ; using namespace std :: chrono_literals ; int main () { GpioA0 :: setOutput (); while ( true ) { GpioA0 :: toggle (); modm :: delay ( 0.5 s ); } } We recommend to start your custom projects with a known-good configuration from one of our examples and then work your way into your specialization. Visualize your dependencies You can create a dependency graph with lbuild dependencies | dot -Tsvg -Grankdir=BT -o dependencies.svg to help you understand what code is pulled in when you generate your library. Generate, Compile and Upload \u00b6 Once you have your project.xml set up, you can call lbuild build , which generates the target and configuration specific library from modm. This will create a few files and folders: $ cd app/project_name $ ls main.cpp project.xml $ lbuild build $ ls SConstruct main.cpp modm project.xml project.xml.log For this project we included the modm:build:scons generator, so we can just call scons build , which will compile the entire source code and output the resource consumption: $ scons build -j8 scons: Reading SConscript files ... scons: done reading SConscript files. scons: Building targets ... Compiling C++\u00b7\u00b7 build/main.o ... Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/project.elf Memory usage\u00b7\u00b7\u00b7 build/project.elf Program: 3612B (0.3% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3184B (1.6% used) = 144B static (0.1%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197520B (98.4% available) (.heap0 + .heap1 + .heap2 + .heap5) You can upload this firmware to your target by calling scons program . Additional tools are documented in the SCons module documentation . Enable parallel builds Remember to add the -j8 flag to your scons build call to enable parallel builds, which are significantly faster than sequential builds. To make this permanent you can add export SCONSFLAGS=\"-j8\" or export MAKEFLAGS=\"-j8\" to your .bashrc ! If you have any questions, open an issue or ping @salkinium .","title":"Your Project"},{"location":"guide/custom-project/#starting-a-new-project","text":"The modm library explicitly generates and copies its files from inside the modm repository into your project using the lbuild code generator. It is intended and very strongly recommended to commit all generated files from lbuild build into your repository. This will make any changes very clear when you run lbuild build again with an updated version of modm! We recommend adding modm into your repository as a Git submodule so that you control exactly what version of modm you're using. We recommend you place the modm repository (and all other external code) into a folder called ext/ or similiar: $ git submodule add https://github.com/modm-io/modm.git ext/modm $ tree . \u2514\u2500\u2500 ext \u2514\u2500\u2500 modm \u251c\u2500\u2500 repo.lb ... Next you want to create a folder with a project.xml and a main.cpp file. We recommend you place that in a separate app/ folder so that all your firmwares are in the same place: $ tree . \u251c\u2500\u2500 ext \u2502 \u2514\u2500\u2500 modm \u2502 \u251c\u2500\u2500 repo.lb \u2502 ... \u2514\u2500\u2500 app \u2514\u2500\u2500 project_name \u251c\u2500\u2500 main.cpp \u2514\u2500\u2500 project.xml Place your applications into their own folder! All modm build systems search recursively for application sources inside the current folder. If you place the modm library repository into your application folder you will see build errors related to building sources twice: scons: *** Multiple ways to build the same target were specified for: ... The project.xml must contain the (relative) path to modm's repo.lb file. Note that the project name is inferred from the project folder, but you can easily change it. modm also does not add a build system by default, so you want to choose one at this point . Add the modm:docs module to generate custom API docs: <library> <repositories> <repository><path> ../modm/repo.lb </path></repository> </repositories> <options> <option name= \"modm:build:project.name\" > custom_name </option> </options> <modules> <module> modm:build:scons </module> <module> modm:docs </module> </modules> </library> You should now be able to discover modm from inside your project folder: $ cd app/project_name $ lbuild discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../../ext/modm) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ... ... Note that we've not yet declared the modm:target option, so you cannot discover all of modm yet. You can now choose from two levels of customization: Inherit and extend a board support package from modm. This is particularly useful if your project is based on an existing development board. Define your own modm:target option and required modules. This is necessary for using modm on a custom hardware design.","title":"Starting a new Project"},{"location":"guide/custom-project/#using-a-board-support-package","text":"Use lbuild to discover the specific BSP configuration you want to use: $ lbuild discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../../ext/modm) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ... \u251c\u2500\u2500 Config(modm:disco-f469ni) STM32F469IDISCOVERY ... Then inherit from this configuration in your project.xml . This will add the modm:target option and give you a set of modules that the BSP depends on. Note that you can overwrite any options you don't agree with, however, you cannot remove any inherited modules. <library> <repositories> ... </repositories> <extends> modm:disco-f469ni </extends> <options> ... </options> <modules> ... </modules> </library> You can now lbuild discover all of modm. Note that the selected modules are now marked underlined as a subtle hint. Our board support packages provide their configuration in the Board namespace, which you can use to initialize the target and several board subsystems. If a serial connection is available on the board, you can directly use the modm logging functions. A minimal main.cpp can look like this: #include <modm/board.hpp> int main () { Board :: initialize (); Board :: Leds :: setOutput (); while ( true ) { Board :: Leds :: toggle (); modm :: delayMilliseconds ( Board :: Button :: read () ? 250 : 500 ); #ifdef MODM_BOARD_HAS_LOGGER static uint32_t counter ( 0 ); MODM_LOG_INFO << \"Loop counter: \" << ( counter ++ ) << modm :: endl ; #endif } return 0 ; } You can find more details about the BSPs capabilities on docs.modm.io which contains the full API documentation for all BSPs. Alternatively you can generate your own API docs locally: ( cd modm/docs && doxypress doxypress.json ) # open modm/docs/html/index.html Please note that the BSPs contain an opinionated set of pre-defined functionality and settings. This is great for getting started quickly, however, if you want to change some hardcoded things (like which UART to use for logging), it's better to use your own BSP: Generate the BSP closest to your custom hardware, then copy the files from modm/src/modm/board/{name} to your own project and modify them. In your project.xml remove the board config inheritance ( <extends> ) and instead copy the pre-defined options into your own config. Check what modm modules you need to depend on and add them to your own project (check for module.depends(...) in the BSPs module.lb ). You may need to manually add the pre-defined collector values to your project configuration (check for env.collect(...) in the BSPs module.lb ).","title":"Using a Board Support Package"},{"location":"guide/custom-project/#custom-configuration","text":"For completely custom hardware, you start by definining the modm:target option and then adding the modules with their options as needed. For example, a basic configuration for the STM32F469NIH6 with startup, GPIO and clock modules looks like this: <library> <repositories> <repository><path> ../../ext/modm/repo.lb </path></repository> </repositories> <options> <option name= \"modm:target\" > stm32f469nih6 </option> </options> <modules> <module> modm:platform:clock </module> <module> modm:platform:core </module> <module> modm:platform:gpio </module> <module> modm:architecture:delay </module> <module> modm:build:scons </module> <module> modm:docs </module> </modules> </library> Remember to include the modm:docs module, since you need to generate your own API docs from your specific configuration: ( cd modm/docs && doxypress doxypress.json ) # open modm/docs/html/index.html A minimal main.cpp for this configuration can look like this. Since there is no BSP, you need to #include <modm/platform.hpp> and add the modm::platform namespace manually. #include <modm/platform.hpp> using namespace modm :: platform ; using namespace std :: chrono_literals ; int main () { GpioA0 :: setOutput (); while ( true ) { GpioA0 :: toggle (); modm :: delay ( 0.5 s ); } } We recommend to start your custom projects with a known-good configuration from one of our examples and then work your way into your specialization. Visualize your dependencies You can create a dependency graph with lbuild dependencies | dot -Tsvg -Grankdir=BT -o dependencies.svg to help you understand what code is pulled in when you generate your library.","title":"Custom Configuration"},{"location":"guide/custom-project/#generate-compile-and-upload","text":"Once you have your project.xml set up, you can call lbuild build , which generates the target and configuration specific library from modm. This will create a few files and folders: $ cd app/project_name $ ls main.cpp project.xml $ lbuild build $ ls SConstruct main.cpp modm project.xml project.xml.log For this project we included the modm:build:scons generator, so we can just call scons build , which will compile the entire source code and output the resource consumption: $ scons build -j8 scons: Reading SConscript files ... scons: done reading SConscript files. scons: Building targets ... Compiling C++\u00b7\u00b7 build/main.o ... Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 build/project.elf Memory usage\u00b7\u00b7\u00b7 build/project.elf Program: 3612B (0.3% used) (.fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 3184B (1.6% used) = 144B static (0.1%) + 3040B stack (1.5%) (.bss + .fastdata + .stack) Heap: 197520B (98.4% available) (.heap0 + .heap1 + .heap2 + .heap5) You can upload this firmware to your target by calling scons program . Additional tools are documented in the SCons module documentation . Enable parallel builds Remember to add the -j8 flag to your scons build call to enable parallel builds, which are significantly faster than sequential builds. To make this permanent you can add export SCONSFLAGS=\"-j8\" or export MAKEFLAGS=\"-j8\" to your .bashrc ! If you have any questions, open an issue or ping @salkinium .","title":"Generate, Compile and Upload"},{"location":"guide/discover/","text":"Discover modm \u00b6 modm uses the lbuild code generator to discover available modules and their configuration options. Let's use the lbuild CLI to poke around modm! Make sure you've installed all tools required for building modm and you've cloned the modm repository recursively and change directory into modm: git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git cd modm lbuild operates on repositories which contain modules and options in a tree format. The modm/repo.lb file must be declared to find all modm modules: $ lbuild --repository repo.lb discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ .) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ... \u251c\u2500\u2500 Config(modm:disco-f469ni) STM32F469IDISCOVERY ... This gives you an overview of the repositories and their options and configurations. Here you can see the modm:target option is marked as REQUIRED , since the HAL modules obviously depend on the target device, so we need to discover the option in detail: $ lbuild -r repo.lb discover modm:target >> modm:target [TargetOption] Meta-HAL target device Value: REQUIRED Inputs: [at90can128-16ai, at90can128-16au, at90can128-16mi, at90can128-16mu, ... a really long list ... stm32l4s9aii6, stm32l4s9vit6, stm32l4s9zij6, stm32l4s9zit6, stm32l4s9ziy6] Options are checked lbuild checks all your project options against the possible values in the module and outputs an error if they are incorrect. Try passing a wrong value to see what happens. You can now choose a value for this repository option and discover the available modules for this specific target. We will choose the stm32f469nih6 device: $ lbuild -r repo.lb --option modm:target=stm32f469nih6 discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ .) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = stm32f469nih6 in [stm32f407vgt6, stm32f469nih6, ... \u251c\u2500\u2500 Config(modm:disco-f469ni) STM32F469IDISCOVERY ... \u251c\u2500\u2500 Module(modm:board) Board Support Packages \u2502 \u2570\u2500\u2500 Module(modm:board:disco-f469ni) STM32F469IDISCOVERY ... \u251c\u2500\u2500 Module(modm:build) Build System Generators \u2502 \u251c\u2500\u2500 Option(build.path) = build/parent-folder in [String] \u2502 \u251c\u2500\u2500 Option(project.name) = parent-folder in [String] \u2502 \u2570\u2500\u2500 Module(modm:build:scons) SCons Build Script Generator ... \u251c\u2500\u2500 Module(modm:platform) Platform HAL \u2502 \u251c\u2500\u2500 Module(modm:platform:cortex-m) ARM Cortex-M Core \u2502 \u2502 \u251c\u2500\u2500 Option(float-abi) = hard in [hard, soft, softfp] Floating point ABI \u2502 \u2502 \u251c\u2500\u2500 Option(main_stack_size) = 3*1024 (3072) in [256 .. 3*1024 .. 65536] \u2502 \u2502 \u251c\u2500\u2500 Option(vector_table_location) = rom in [ram, rom] Vector table location ... ... \u2502 \u251c\u2500\u2500 Module(modm:platform:uart) Universal Asynchronous Receiver Transmitter (UART) \u2502 \u2502 \u251c\u2500\u2500 Module(modm:platform:uart:1) Instance 1 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Option(buffer.rx) = 0 in [0 ... 65534] \u2502 \u2502 \u2502 \u2570\u2500\u2500 Option(buffer.tx) = 0 in [0 ... 65534] Since there are no more REQUIRED options, you can now discover all module and option descriptions. Let's have a look at the modm:platform:cortex-m module , which deals with the startup code of Cortex-M devices. Note that you can leave out parts of any name as long as it remains unique: $ lbuild -r repo.lb -D :target=stm32f469nih6 discover ::cortex-m >> modm:platform:cortex-m [Module] # ARM Cortex-M Core This module generates the startup code, vector table, linkerscript as well as initialize the heap, deal with assertions, provide blocking delay functions, atomic and unaligned access and the GNU build ID. >>>> modm:platform:cortex-m:vector_table_location [EnumerationOption] # Vector table location in ROM or RAM The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions: - `void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)` - `uint32_t NVIC_GetVector(IRQn_Type IRQn)` Value: rom Inputs: [ram, rom] Once you've made your choices about which modules and options you want, you can generate a custom modm library using the build command: lbuild -r repo.lb -D :target = stm32f469nih6 -D :::vector_table_location = ram \\ build --module ::cortex-m Which will create a folder modm at the callsite which contains the minimal startup code for the STM32F469NIH6 device. $ tree modm modm \u251c\u2500\u2500 ext \u2502 \u2514\u2500\u2500 cmsis \u2502 \u2514\u2500\u2500 device \u2502 \u251c\u2500\u2500 stm32f469xx.h \u2502 \u2514\u2500\u2500 system_stm32f4xx.h \u2514\u2500\u2500 src \u2514\u2500\u2500 modm \u251c\u2500\u2500 platform \u2502 \u251c\u2500\u2500 core \u2502 \u2502 \u251c\u2500\u2500 reset_handler.sx \u2502 \u2502 \u251c\u2500\u2500 startup.c \u2502 \u2502 \u2514\u2500\u2500 vectors.c \u2502 \u2514\u2500\u2500 device.hpp \u2514\u2500\u2500 platform.hpp However, declaring everything on the command line is a bit annoying, so instead we can create a project.xml with the same information: <library> <repositories> <repository> <path> repo.lb </path> </repository> </repositories> <options> <option name= \"modm:target\" > stm32f469nih6 </option> <option name= \"modm:platform:cortex-m:vector_table_location\" > ram </option> </options> <modules> <module> modm:platform:cortex-m </module> </modules> </library> This file is now automatically used for all calls to lbuild : lbuild discover lbuild build You can read the lbuild reference manual if you want to know the details about config inheritance, collectors and queries. You can discover the whole repository view with the --developer option: lbuild discover --developer","title":"Discover modm"},{"location":"guide/discover/#discover-modm","text":"modm uses the lbuild code generator to discover available modules and their configuration options. Let's use the lbuild CLI to poke around modm! Make sure you've installed all tools required for building modm and you've cloned the modm repository recursively and change directory into modm: git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git cd modm lbuild operates on repositories which contain modules and options in a tree format. The modm/repo.lb file must be declared to find all modm modules: $ lbuild --repository repo.lb discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ .) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = REQUIRED in [stm32f469ngh6, stm32f469nih6, stm32f469vet6, ... \u251c\u2500\u2500 Config(modm:disco-f469ni) STM32F469IDISCOVERY ... This gives you an overview of the repositories and their options and configurations. Here you can see the modm:target option is marked as REQUIRED , since the HAL modules obviously depend on the target device, so we need to discover the option in detail: $ lbuild -r repo.lb discover modm:target >> modm:target [TargetOption] Meta-HAL target device Value: REQUIRED Inputs: [at90can128-16ai, at90can128-16au, at90can128-16mi, at90can128-16mu, ... a really long list ... stm32l4s9aii6, stm32l4s9vit6, stm32l4s9zij6, stm32l4s9zit6, stm32l4s9ziy6] Options are checked lbuild checks all your project options against the possible values in the module and outputs an error if they are incorrect. Try passing a wrong value to see what happens. You can now choose a value for this repository option and discover the available modules for this specific target. We will choose the stm32f469nih6 device: $ lbuild -r repo.lb --option modm:target=stm32f469nih6 discover Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ .) modm: a barebone embedded library generator \u251c\u2500\u2500 Option(target) = stm32f469nih6 in [stm32f407vgt6, stm32f469nih6, ... \u251c\u2500\u2500 Config(modm:disco-f469ni) STM32F469IDISCOVERY ... \u251c\u2500\u2500 Module(modm:board) Board Support Packages \u2502 \u2570\u2500\u2500 Module(modm:board:disco-f469ni) STM32F469IDISCOVERY ... \u251c\u2500\u2500 Module(modm:build) Build System Generators \u2502 \u251c\u2500\u2500 Option(build.path) = build/parent-folder in [String] \u2502 \u251c\u2500\u2500 Option(project.name) = parent-folder in [String] \u2502 \u2570\u2500\u2500 Module(modm:build:scons) SCons Build Script Generator ... \u251c\u2500\u2500 Module(modm:platform) Platform HAL \u2502 \u251c\u2500\u2500 Module(modm:platform:cortex-m) ARM Cortex-M Core \u2502 \u2502 \u251c\u2500\u2500 Option(float-abi) = hard in [hard, soft, softfp] Floating point ABI \u2502 \u2502 \u251c\u2500\u2500 Option(main_stack_size) = 3*1024 (3072) in [256 .. 3*1024 .. 65536] \u2502 \u2502 \u251c\u2500\u2500 Option(vector_table_location) = rom in [ram, rom] Vector table location ... ... \u2502 \u251c\u2500\u2500 Module(modm:platform:uart) Universal Asynchronous Receiver Transmitter (UART) \u2502 \u2502 \u251c\u2500\u2500 Module(modm:platform:uart:1) Instance 1 \u2502 \u2502 \u2502 \u251c\u2500\u2500 Option(buffer.rx) = 0 in [0 ... 65534] \u2502 \u2502 \u2502 \u2570\u2500\u2500 Option(buffer.tx) = 0 in [0 ... 65534] Since there are no more REQUIRED options, you can now discover all module and option descriptions. Let's have a look at the modm:platform:cortex-m module , which deals with the startup code of Cortex-M devices. Note that you can leave out parts of any name as long as it remains unique: $ lbuild -r repo.lb -D :target=stm32f469nih6 discover ::cortex-m >> modm:platform:cortex-m [Module] # ARM Cortex-M Core This module generates the startup code, vector table, linkerscript as well as initialize the heap, deal with assertions, provide blocking delay functions, atomic and unaligned access and the GNU build ID. >>>> modm:platform:cortex-m:vector_table_location [EnumerationOption] # Vector table location in ROM or RAM The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions: - `void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)` - `uint32_t NVIC_GetVector(IRQn_Type IRQn)` Value: rom Inputs: [ram, rom] Once you've made your choices about which modules and options you want, you can generate a custom modm library using the build command: lbuild -r repo.lb -D :target = stm32f469nih6 -D :::vector_table_location = ram \\ build --module ::cortex-m Which will create a folder modm at the callsite which contains the minimal startup code for the STM32F469NIH6 device. $ tree modm modm \u251c\u2500\u2500 ext \u2502 \u2514\u2500\u2500 cmsis \u2502 \u2514\u2500\u2500 device \u2502 \u251c\u2500\u2500 stm32f469xx.h \u2502 \u2514\u2500\u2500 system_stm32f4xx.h \u2514\u2500\u2500 src \u2514\u2500\u2500 modm \u251c\u2500\u2500 platform \u2502 \u251c\u2500\u2500 core \u2502 \u2502 \u251c\u2500\u2500 reset_handler.sx \u2502 \u2502 \u251c\u2500\u2500 startup.c \u2502 \u2502 \u2514\u2500\u2500 vectors.c \u2502 \u2514\u2500\u2500 device.hpp \u2514\u2500\u2500 platform.hpp However, declaring everything on the command line is a bit annoying, so instead we can create a project.xml with the same information: <library> <repositories> <repository> <path> repo.lb </path> </repository> </repositories> <options> <option name= \"modm:target\" > stm32f469nih6 </option> <option name= \"modm:platform:cortex-m:vector_table_location\" > ram </option> </options> <modules> <module> modm:platform:cortex-m </module> </modules> </library> This file is now automatically used for all calls to lbuild : lbuild discover lbuild build You can read the lbuild reference manual if you want to know the details about config inheritance, collectors and queries. You can discover the whole repository view with the --developer option: lbuild discover --developer","title":"Discover modm"},{"location":"guide/examples/","text":"Explore the Examples \u00b6 To get a quick feel about modm's APIs you can look at and experiment with our examples , especially if you have a development board that modm supports out-of-box. Make sure you've installed all tools required for building modm and you've cloned the modm repository recursively : git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git TL;DR \u00b6 Change directory into any of the examples and compile it: # cd into any example you like cd modm/examples/generic/blinky # generate modm library (call only once) lbuild build # compile the example scons -j8 # Connect your development board and upload the firmware scons program To debug with GDB in TUI mode. Make sure to change to the debug profile: # compile and upload debug profile scons program profile = debug # launch OpenOCD and GDB for debugging scons debug profile = debug To generate your target specific Doxypress documentation: ( cd modm/docs && doxypress doxypress.json ) # open modm/docs/html/index.html To remove it all: # Remove build artifacts scons -c # Remove generated files lbuild clean Have a look at the build system documentation and the online documentation . Interesting Examples \u00b6 We have hundreds of examples but here are some of our favorite ones for our supported development boards: Arduino Uno: Blinky , Button & Serial , Analog & Serial . NUCLEO-F031K6: Blinky & Serial . NUCLEO-F103RB: Blinky & Serial , Undefined IRQ Handler , Logging via ITM . NUCLEO-F429ZI: CMSIS DSP . NUCLEO-F446RE: Internal Flash Programming . STM32F072 Discovery: Blinky , CAN , Gyroscope . STM32F3 Discovery: Blinky , CAN , Accelerometer , Gyroscope , TinyUSB DFU , Logging via RTT . STM32F4 Discovery: Blinky , CAN , Accelerometer , Timer & LED Animations . STM32F469 Discovery: Blinky , Drawing on display , Touchscreen inputs , Multi-heap with external 16MB memory , Game of Life in Color with Multitouch , Hard Fault with CrashCatcher STM32F769 Discovery: FPU with double precision Here are some additional examples of displays and sensors we like: SSD1306 OLED display : Draws text and graphics onto I2C display. BMP085/BMP180 barometer : Reads atmospheric pressure and temperature from I2C sensor. BMP180/BME280 barometer : Reads atmospheric pressure and temperature from multiple I2C sensors. VL6180 time-of-flight distance sensor : Reads distance and ambient light from I2C sensor. VL53L0 time-of-flight distance sensor : Much improved version of the VL6180 sensor. ADNS9800 motion sensor : Reads 2D motion from SPI sensor used in gaming mice. TCS3414 color sensor : Reads RGB color from I2C sensor. HD44780 over I2C-GPIO expander : Draws text via native GPIO port or I2C-GPIO expander port onto character display. Copy Carefully \u00b6 When copying from our examples make sure to set the repository path correctly! All example modm/examples/**/project.xml files are missing this path, since we set it in the inherited base modm/examples/lbuild.xml configuration. You must also add the modm:docs module manually if you want it. The modm/examples/lbuild.xml file: <library> <!-- This is the default lbuild configuration file for every example in this folder. It only defaults the common settings, so that this isn't duplicated in every single example. When you write your own application, you must set this path yourself! --> <repositories> <repository><path> ../repo.lb </path></repository> </repositories> <modules> <module> modm:docs </module> </modules> </library>","title":"Explore Examples"},{"location":"guide/examples/#explore-the-examples","text":"To get a quick feel about modm's APIs you can look at and experiment with our examples , especially if you have a development board that modm supports out-of-box. Make sure you've installed all tools required for building modm and you've cloned the modm repository recursively : git clone --recurse-submodules --jobs 8 https://github.com/modm-io/modm.git","title":"Explore the Examples"},{"location":"guide/examples/#tldr","text":"Change directory into any of the examples and compile it: # cd into any example you like cd modm/examples/generic/blinky # generate modm library (call only once) lbuild build # compile the example scons -j8 # Connect your development board and upload the firmware scons program To debug with GDB in TUI mode. Make sure to change to the debug profile: # compile and upload debug profile scons program profile = debug # launch OpenOCD and GDB for debugging scons debug profile = debug To generate your target specific Doxypress documentation: ( cd modm/docs && doxypress doxypress.json ) # open modm/docs/html/index.html To remove it all: # Remove build artifacts scons -c # Remove generated files lbuild clean Have a look at the build system documentation and the online documentation .","title":"TL;DR"},{"location":"guide/examples/#interesting-examples","text":"We have hundreds of examples but here are some of our favorite ones for our supported development boards: Arduino Uno: Blinky , Button & Serial , Analog & Serial . NUCLEO-F031K6: Blinky & Serial . NUCLEO-F103RB: Blinky & Serial , Undefined IRQ Handler , Logging via ITM . NUCLEO-F429ZI: CMSIS DSP . NUCLEO-F446RE: Internal Flash Programming . STM32F072 Discovery: Blinky , CAN , Gyroscope . STM32F3 Discovery: Blinky , CAN , Accelerometer , Gyroscope , TinyUSB DFU , Logging via RTT . STM32F4 Discovery: Blinky , CAN , Accelerometer , Timer & LED Animations . STM32F469 Discovery: Blinky , Drawing on display , Touchscreen inputs , Multi-heap with external 16MB memory , Game of Life in Color with Multitouch , Hard Fault with CrashCatcher STM32F769 Discovery: FPU with double precision Here are some additional examples of displays and sensors we like: SSD1306 OLED display : Draws text and graphics onto I2C display. BMP085/BMP180 barometer : Reads atmospheric pressure and temperature from I2C sensor. BMP180/BME280 barometer : Reads atmospheric pressure and temperature from multiple I2C sensors. VL6180 time-of-flight distance sensor : Reads distance and ambient light from I2C sensor. VL53L0 time-of-flight distance sensor : Much improved version of the VL6180 sensor. ADNS9800 motion sensor : Reads 2D motion from SPI sensor used in gaming mice. TCS3414 color sensor : Reads RGB color from I2C sensor. HD44780 over I2C-GPIO expander : Draws text via native GPIO port or I2C-GPIO expander port onto character display.","title":"Interesting Examples"},{"location":"guide/examples/#copy-carefully","text":"When copying from our examples make sure to set the repository path correctly! All example modm/examples/**/project.xml files are missing this path, since we set it in the inherited base modm/examples/lbuild.xml configuration. You must also add the modm:docs module manually if you want it. The modm/examples/lbuild.xml file: <library> <!-- This is the default lbuild configuration file for every example in this folder. It only defaults the common settings, so that this isn't duplicated in every single example. When you write your own application, you must set this path yourself! --> <repositories> <repository><path> ../repo.lb </path></repository> </repositories> <modules> <module> modm:docs </module> </modules> </library>","title":"Copy Carefully"},{"location":"guide/installation/","text":"Installation \u00b6 This is the required software for generating, compiling and programming projects with modm: Python 3 . Software Construct or CMake . Library Builder . AVR toolchain: avr-gcc and avrdude . ARM toolchain: gcc-arm-toolchain and OpenOCD (at least v0.11!). Optional: Doxypress . Optional: gdbgui for IDE-independent debugging. Note that the modm examples use the SCons build system by default, however, you are not required to use it. See the reference manual for additional build system documentation. Use GCC 10 or newer modm uses C++20, so you need at least GCC 10. Beware of AVRs We strongly discourage using AVRs for new designs, due to a significant lack of commitment from Atmel on keeping their AVR toolchain up-to-date. Check your Locale If you get a UnicodeEncodeError when calling lbuild , you may need to add export LC_ALL=C.UTF-8 to your .bashrc . Consult the internet until python3 -c \"import sys; print(sys.stdout.encoding)\" returns UTF-8 . Please help us keep these instructions up-to-date ! Linux \u00b6 For Ubuntu 20.04LTS, these commands install the minimal build system: sudo apt install python3 python3-pip scons git pip3 install modm We recommend using a graphical frontend for GDB called gdbgui : pip3 install gdbgui Python Packages in PATH The pip3 command installs executables into ~/.local/bin , which must be added to PATH if it is not already the case. Add the following line to the end of your ~/.bashrc file: export PATH = \"~/.local/bin: $PATH \" Ubuntu \u2264 19.10 Ubuntu \u2264 19.10 unfortunately defaults to Python 2, however, our SCons tools require Python 3. For a less intrusive way to run all scons scripts with Python 3 add this to your .bashrc or .zshrc : alias scons = \"/usr/bin/env python3 $( which scons ) \" If you get errors about missing pyelftools , check that you're really running SCons with Python 3! We use Doxypress to generate the API documentation: sudo mkdir /opt/doxypress wget -O- https://download.copperspice.com/doxypress/binary/doxypress-1.4.1-ubuntu20.04-x64.tar.bz2 | sudo tar xj -C /opt/doxypress Add the directory to your PATH variable in ~/.bashrc : export PATH = \"/opt/doxypress: $PATH \" ARM Cortex-M \u00b6 Install the pre-built ARM toolchain : wget -O- https://developer.arm.com/-/media/Files/downloads/gnu-rm/10-2020q4/gcc-arm-none-eabi-10-2020-q4-major-x86_64-linux.tar.bz2 | sudo tar xj -C /opt/ Add it to your PATH variable in ~/.bashrc : export PATH = \"/opt/gcc-arm-none-eabi-10-2020-q4-major/bin: $PATH \" Ubuntus 'gcc-arm-none-eabi' package The Ubuntu package 'gcc-arm-none-eabi' causes issues at the moment and ships only version 9.3. Install the OpenOCD tool: sudo apt install openocd OpenOCD < v0.11 Make sure to get at least OpenOCD release v0.11, since v0.10 is too old for some targets (STM32G0, STM32G4, STM32F7). You can manually install an up-to-date version of OpenOCD by following the instructions here . Microchip AVR \u00b6 Download and extract the pre-built AVR toolchain : wget -O- https://github.com/modm-io/avr-gcc/releases/download/v10.2.0/avr-gcc.tar.bz2 | sudo tar xj -C /opt Add the bin directories to your PATH variable in ~/.bashrc : export PATH = \"/opt/avr-gcc/avr-gcc/bin:/opt/avr-gcc/avr-binutils/bin: $PATH \" Install the AvrDude tool: sudo apt install avrdude Hosted \u00b6 To compile modm for host system targets (x86_64/arm64): sudo apt install gcc build-essential libboost-all-dev macOS \u00b6 Install the minimal build system via Homebrew : brew update brew install python3 scons git doxygen pip3 install modm We recommend using a graphical frontend for GDB called gdbgui : pip3 install gdbgui We use Doxypress to generate the API documentation: brew tap modm-ext/modm brew install doxypress ARM Cortex-M \u00b6 Install the pre-built ARM toolchain : brew tap osx-cross/arm brew install arm-gcc-bin brew install openocd --HEAD To program Microchip SAM devices via the bootloader, install the bossac tool: brew cask install bossa Microchip AVR \u00b6 Install the AVR toolchain from source : brew tap osx-cross/avr brew install avr-gcc@10 brew link --force avr-gcc@10 Hosted \u00b6 To compile modm for x86_64 macOS you need to install these tools too: brew install boost gcc Windows \u00b6 In general, Windows is not a great fit for the command line tools that modm is built on. Consider using the Windows subsystem for Linux (WSL) instead. Alternatively consider using a better terminal emulator than command prompt ( cmd ) or PowerShell, perhaps use the official Windows Terminal . Debugging with arm-none-eabi-gdb We could not get arm-none-eabi-gdb to work on Windows, it seems not to support TUI mode and the web-based GDBGUI does not support Windows either. If you find a solution, please open a PR so we can fix this . These instructions assume a vanilla Windows 10 installation. Install Git via the official installer . Make sure to unselect vim as the default Git editor and instead choose at least the Wordpad editor or better. Install Python3 via the full installer . Make sure to select Add Python to PATH during installation! Test the installation by opening the command prompt ( cmd ): python -c \"print('Hello World')\" Then install the necessary Python packages: pip install modm scons Test that you have access to the lbuild and scons tools inside the command prompt: lbuild --version scons --version We use Doxypress to generate the API documentation. Download and run the Installer . Please use the free and open-source 7-Zip file archiver to extract the files in the next steps. ARM Cortex-M \u00b6 Install the pre-built ARM toolchain via the 32-bit installer and make sure you select Add path to environment variable at the end! Open a new command prompt to test the compiler: arm-none-eabi-gcc --version Install the and then download the latest pre-built OpenOCD tool : unpack the .tar.gz file using the context menu 7-Zip > Extract Here . unpack the .tar file using 7-Zip > Extract to \"openocd-v0.11.0-...\" Then rename and move the extracted folder to C:\\Program Files (x86)\\openocd . Open PowerShell to add the \\bin folder to the Path : [Environment]::SetEnvironmentVariable(\"Path\", $env:Path + \";C:\\Program Files (x86)\\openocd\\bin\", \"User\") Close the PowerShell and open a new command prompt to test openocd: openocd --version Microchip AVR \u00b6 Download the pre-built AVR toolchain and unpack the .zip file using the context menu 7-Zip > Extract to \"avr-gcc-10.1.0-...\" Then rename and move the extracted folder to C:\\Program Files\\avr-gcc . Open PowerShell to add the \\bin folder to the Path : [Environment]::SetEnvironmentVariable(\"Path\", $env:Path + \";C:\\Program Files\\avr-gcc\\bin\", \"User\") Close the PowerShell and open a new command prompt to test avr-gcc and avrdude: avr-gcc --version avrdude --version For non-English speakers For now project and build paths containing non-ASCII characters are not parsed correctly. Please open an issue if this is a problem. Windows paths Windows created several compatibility issues with its \\ path separator. Even though we try hard to not hardcode the path separator, there may still be issues related to this. Please open an issue in that case. Dear Windows users We don't regularly use Windows with modm, so please give us some feedback about the quality of these instructions.","title":"Installation"},{"location":"guide/installation/#installation","text":"This is the required software for generating, compiling and programming projects with modm: Python 3 . Software Construct or CMake . Library Builder . AVR toolchain: avr-gcc and avrdude . ARM toolchain: gcc-arm-toolchain and OpenOCD (at least v0.11!). Optional: Doxypress . Optional: gdbgui for IDE-independent debugging. Note that the modm examples use the SCons build system by default, however, you are not required to use it. See the reference manual for additional build system documentation. Use GCC 10 or newer modm uses C++20, so you need at least GCC 10. Beware of AVRs We strongly discourage using AVRs for new designs, due to a significant lack of commitment from Atmel on keeping their AVR toolchain up-to-date. Check your Locale If you get a UnicodeEncodeError when calling lbuild , you may need to add export LC_ALL=C.UTF-8 to your .bashrc . Consult the internet until python3 -c \"import sys; print(sys.stdout.encoding)\" returns UTF-8 . Please help us keep these instructions up-to-date !","title":"Installation"},{"location":"guide/installation/#linux","text":"For Ubuntu 20.04LTS, these commands install the minimal build system: sudo apt install python3 python3-pip scons git pip3 install modm We recommend using a graphical frontend for GDB called gdbgui : pip3 install gdbgui Python Packages in PATH The pip3 command installs executables into ~/.local/bin , which must be added to PATH if it is not already the case. Add the following line to the end of your ~/.bashrc file: export PATH = \"~/.local/bin: $PATH \" Ubuntu \u2264 19.10 Ubuntu \u2264 19.10 unfortunately defaults to Python 2, however, our SCons tools require Python 3. For a less intrusive way to run all scons scripts with Python 3 add this to your .bashrc or .zshrc : alias scons = \"/usr/bin/env python3 $( which scons ) \" If you get errors about missing pyelftools , check that you're really running SCons with Python 3! We use Doxypress to generate the API documentation: sudo mkdir /opt/doxypress wget -O- https://download.copperspice.com/doxypress/binary/doxypress-1.4.1-ubuntu20.04-x64.tar.bz2 | sudo tar xj -C /opt/doxypress Add the directory to your PATH variable in ~/.bashrc : export PATH = \"/opt/doxypress: $PATH \"","title":"Linux"},{"location":"guide/installation/#arm-cortex-m","text":"Install the pre-built ARM toolchain : wget -O- https://developer.arm.com/-/media/Files/downloads/gnu-rm/10-2020q4/gcc-arm-none-eabi-10-2020-q4-major-x86_64-linux.tar.bz2 | sudo tar xj -C /opt/ Add it to your PATH variable in ~/.bashrc : export PATH = \"/opt/gcc-arm-none-eabi-10-2020-q4-major/bin: $PATH \" Ubuntus 'gcc-arm-none-eabi' package The Ubuntu package 'gcc-arm-none-eabi' causes issues at the moment and ships only version 9.3. Install the OpenOCD tool: sudo apt install openocd OpenOCD < v0.11 Make sure to get at least OpenOCD release v0.11, since v0.10 is too old for some targets (STM32G0, STM32G4, STM32F7). You can manually install an up-to-date version of OpenOCD by following the instructions here .","title":"ARM Cortex-M"},{"location":"guide/installation/#microchip-avr","text":"Download and extract the pre-built AVR toolchain : wget -O- https://github.com/modm-io/avr-gcc/releases/download/v10.2.0/avr-gcc.tar.bz2 | sudo tar xj -C /opt Add the bin directories to your PATH variable in ~/.bashrc : export PATH = \"/opt/avr-gcc/avr-gcc/bin:/opt/avr-gcc/avr-binutils/bin: $PATH \" Install the AvrDude tool: sudo apt install avrdude","title":"Microchip AVR"},{"location":"guide/installation/#hosted","text":"To compile modm for host system targets (x86_64/arm64): sudo apt install gcc build-essential libboost-all-dev","title":"Hosted"},{"location":"guide/installation/#macos","text":"Install the minimal build system via Homebrew : brew update brew install python3 scons git doxygen pip3 install modm We recommend using a graphical frontend for GDB called gdbgui : pip3 install gdbgui We use Doxypress to generate the API documentation: brew tap modm-ext/modm brew install doxypress","title":"macOS"},{"location":"guide/installation/#arm-cortex-m_1","text":"Install the pre-built ARM toolchain : brew tap osx-cross/arm brew install arm-gcc-bin brew install openocd --HEAD To program Microchip SAM devices via the bootloader, install the bossac tool: brew cask install bossa","title":"ARM Cortex-M"},{"location":"guide/installation/#microchip-avr_1","text":"Install the AVR toolchain from source : brew tap osx-cross/avr brew install avr-gcc@10 brew link --force avr-gcc@10","title":"Microchip AVR"},{"location":"guide/installation/#hosted_1","text":"To compile modm for x86_64 macOS you need to install these tools too: brew install boost gcc","title":"Hosted"},{"location":"guide/installation/#windows","text":"In general, Windows is not a great fit for the command line tools that modm is built on. Consider using the Windows subsystem for Linux (WSL) instead. Alternatively consider using a better terminal emulator than command prompt ( cmd ) or PowerShell, perhaps use the official Windows Terminal . Debugging with arm-none-eabi-gdb We could not get arm-none-eabi-gdb to work on Windows, it seems not to support TUI mode and the web-based GDBGUI does not support Windows either. If you find a solution, please open a PR so we can fix this . These instructions assume a vanilla Windows 10 installation. Install Git via the official installer . Make sure to unselect vim as the default Git editor and instead choose at least the Wordpad editor or better. Install Python3 via the full installer . Make sure to select Add Python to PATH during installation! Test the installation by opening the command prompt ( cmd ): python -c \"print('Hello World')\" Then install the necessary Python packages: pip install modm scons Test that you have access to the lbuild and scons tools inside the command prompt: lbuild --version scons --version We use Doxypress to generate the API documentation. Download and run the Installer . Please use the free and open-source 7-Zip file archiver to extract the files in the next steps.","title":"Windows"},{"location":"guide/installation/#arm-cortex-m_2","text":"Install the pre-built ARM toolchain via the 32-bit installer and make sure you select Add path to environment variable at the end! Open a new command prompt to test the compiler: arm-none-eabi-gcc --version Install the and then download the latest pre-built OpenOCD tool : unpack the .tar.gz file using the context menu 7-Zip > Extract Here . unpack the .tar file using 7-Zip > Extract to \"openocd-v0.11.0-...\" Then rename and move the extracted folder to C:\\Program Files (x86)\\openocd . Open PowerShell to add the \\bin folder to the Path : [Environment]::SetEnvironmentVariable(\"Path\", $env:Path + \";C:\\Program Files (x86)\\openocd\\bin\", \"User\") Close the PowerShell and open a new command prompt to test openocd: openocd --version","title":"ARM Cortex-M"},{"location":"guide/installation/#microchip-avr_2","text":"Download the pre-built AVR toolchain and unpack the .zip file using the context menu 7-Zip > Extract to \"avr-gcc-10.1.0-...\" Then rename and move the extracted folder to C:\\Program Files\\avr-gcc . Open PowerShell to add the \\bin folder to the Path : [Environment]::SetEnvironmentVariable(\"Path\", $env:Path + \";C:\\Program Files\\avr-gcc\\bin\", \"User\") Close the PowerShell and open a new command prompt to test avr-gcc and avrdude: avr-gcc --version avrdude --version For non-English speakers For now project and build paths containing non-ASCII characters are not parsed correctly. Please open an issue if this is a problem. Windows paths Windows created several compatibility issues with its \\ path separator. Even though we try hard to not hardcode the path separator, there may still be issues related to this. Please open an issue in that case. Dear Windows users We don't regularly use Windows with modm, so please give us some feedback about the quality of these instructions.","title":"Microchip AVR"},{"location":"reference/build-systems/","text":"Build Systems \u00b6 For modm, build systems are not special and are treated as just another module that generates the build system configuration as part of your custom library. The required data for this is a list of generated files provided by lbuild itself, and lots of metadata like header include paths, compile flags, preprocessor definitions, libraries to be linked, that is collected from each module. This information is then assembled by the modm:build module which generates generic support files and data for providing compilation, uploading and debugging functionality. This alone is not enough to compile your project though, so you have to select one or more modm:build:* submodules, that translates this data for the specific build system. Build systems do not interoperate While you can generate and use multiple build systems at the same time, they do not have the same feature set and do not interoperate. So you cannot compile your program with one build system and expect to upload the firmware to your target with another. Add your build system Most of the difficult work is done by the modm:build module, so adding another build system generator is a manageable feat. Feel free to open up an PR that adds support for your build system and we'll give you lots of tips during the review. Enable parallel builds Remember to add the -j8 flag to your scons/make build call to enable parallel builds, which are significantly faster than sequential builds. To make this a permanent setting you can add export SCONSFLAGS=\"-j8\" or export MAKEFLAGS=\"-j8\" to your .bashrc ! SCons \u00b6 The modm:build:scons build system generator is our preferred and recommended one and features many very useful modm- and embedded-specific tools. However, it is more optimized for terminal use and not for integration into IDEs. See the modm:build:scons documentation . Make \u00b6 The modm:build:make generator creates a stand-alone, but feature-complete, Makefile build system. The embedded-specific tooling is provided by wrapping separate Python3 scripts in .PHONY targets. It is intended as a simple, hackable build system without standardized IDE integration. See the modm:build:make documentation . CMake \u00b6 The modm:build:cmake module generates a CMake build script, which you can import into a lot of IDEs and compile it from there. This module ships with a Makefile that wraps all of the CMake commands, however, its focus is less on tooling. See the modm:build:cmake documentation . Customization \u00b6 All build system modules have many options, which you can set in your project.xml configuration file. However, there are also lbuild collectors, which are the mechanism used by the library modules themselves to communicate the required metadata to the build modules. You can specify additional collector values in your project.xml file to customize your build! For example, if you disagree with our compile flags you can extend them like so: <library> <collectors> <!-- Warn about strict ISO C and C++ usage --> <collect name= \"modm:build:ccflags\" > -Wpedantic </collect> <!-- Don't warn about double promotion, I know what I'm doing (no, you don't) --> <collect name= \"modm:build:ccflags\" > -Wno-double-promotion </collect> </collectors> </library> This can be significantly easier than manually editing the generated build scripts, and is also persistent across library regeneration. Please see the modm:build documentation for the available collectors and their inputs.","title":"Build Systems"},{"location":"reference/build-systems/#build-systems","text":"For modm, build systems are not special and are treated as just another module that generates the build system configuration as part of your custom library. The required data for this is a list of generated files provided by lbuild itself, and lots of metadata like header include paths, compile flags, preprocessor definitions, libraries to be linked, that is collected from each module. This information is then assembled by the modm:build module which generates generic support files and data for providing compilation, uploading and debugging functionality. This alone is not enough to compile your project though, so you have to select one or more modm:build:* submodules, that translates this data for the specific build system. Build systems do not interoperate While you can generate and use multiple build systems at the same time, they do not have the same feature set and do not interoperate. So you cannot compile your program with one build system and expect to upload the firmware to your target with another. Add your build system Most of the difficult work is done by the modm:build module, so adding another build system generator is a manageable feat. Feel free to open up an PR that adds support for your build system and we'll give you lots of tips during the review. Enable parallel builds Remember to add the -j8 flag to your scons/make build call to enable parallel builds, which are significantly faster than sequential builds. To make this a permanent setting you can add export SCONSFLAGS=\"-j8\" or export MAKEFLAGS=\"-j8\" to your .bashrc !","title":"Build Systems"},{"location":"reference/build-systems/#scons","text":"The modm:build:scons build system generator is our preferred and recommended one and features many very useful modm- and embedded-specific tools. However, it is more optimized for terminal use and not for integration into IDEs. See the modm:build:scons documentation .","title":"SCons"},{"location":"reference/build-systems/#make","text":"The modm:build:make generator creates a stand-alone, but feature-complete, Makefile build system. The embedded-specific tooling is provided by wrapping separate Python3 scripts in .PHONY targets. It is intended as a simple, hackable build system without standardized IDE integration. See the modm:build:make documentation .","title":"Make"},{"location":"reference/build-systems/#cmake","text":"The modm:build:cmake module generates a CMake build script, which you can import into a lot of IDEs and compile it from there. This module ships with a Makefile that wraps all of the CMake commands, however, its focus is less on tooling. See the modm:build:cmake documentation .","title":"CMake"},{"location":"reference/build-systems/#customization","text":"All build system modules have many options, which you can set in your project.xml configuration file. However, there are also lbuild collectors, which are the mechanism used by the library modules themselves to communicate the required metadata to the build modules. You can specify additional collector values in your project.xml file to customize your build! For example, if you disagree with our compile flags you can extend them like so: <library> <collectors> <!-- Warn about strict ISO C and C++ usage --> <collect name= \"modm:build:ccflags\" > -Wpedantic </collect> <!-- Don't warn about double promotion, I know what I'm doing (no, you don't) --> <collect name= \"modm:build:ccflags\" > -Wno-double-promotion </collect> </collectors> </library> This can be significantly easier than manually editing the generated build scripts, and is also persistent across library regeneration. Please see the modm:build documentation for the available collectors and their inputs.","title":"Customization"},{"location":"reference/documentation/","text":"Documentation \u00b6 Since modm is so highly configurable with its many options and selectable modules, it can generate wildly different code for different project configurations. However we've taken great care to keep modm discoverable by making documentation a first-class citizen of our code generation engine lbuild . modm's documentation is split into two parts: The module documentation available during library discovery via lbuild discover . The Doxygen API documentation available after generating the library with the modm:docs module via lbuild build . Modules \u00b6 The modm modules and their options are shown by lbuild discover . These descriptions advertise the modules capabilities and gives a high-level overview of how to use it. You can search for keywords in all modules using lbuild search QUERIES [QUERIES ...] : $ lbuild search animation Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../../..) modm: a barebone embedded library generator \u2570\u2500\u2500 Module(modm:ui) User interface \u251c\u2500\u2500 Module(modm:ui:animation) Animators \u2570\u2500\u2500 Module(modm:ui:led) LED Animation and Gamma Correction >> modm:ui [Module] 4 Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures. >> modm:ui:led [Module] 1 # LED Animation and Gamma Correction 6 `modm:ui:animation` module and providing look-up tables for performing 12 wraps an 8-bit `modm::ui::Animation` and a 8-bit value. 38 Depending on how smooth you require your animation to be, you may call the 42 `modm::ui::KeyFrameAnimation` class and it's derivatives, to animate it's 83 use the `modm::ui::table22_16_256` table to map the linear LED animation values To make discovery even easier we have created a superimposed view of all available modules on this homepage . Try searching for your keywords in the search bar above. Note that in this superimposed view, some Modules and Options are only available for certain targets. These are then labels as \" {Module, Option, Collector} only available for {target} \". Additionally the view does not show peripheral instance submodule to reduce visual noise. Doxypress / Doxygen \u00b6 The generated C/C++ API is documented using Doxypress and therefore only available after code generation. To view this documentation, include the modm:docs module in your project.xml configuration and run lbuild build . A modm/docs folder is created containing the doxypress.json for modm as well as all the @defgroup s mirroring the module structure. You must then run Doxypress manually, which can take several minutes, and compiles the target-specific documentation into modm/docs/html : lbuild build -m \"modm:docs\" # With Doxypress ( cd modm/docs && doxypress doxypress.json ) # then open: modm/docs/html/index.html The generated Doxypress/Doxygen documentation contains the original module documentation including the option choices you made . This makes it easier to map the lbuild options to changes in the generated source code. Online API Docs \u00b6 API documentation is available at docs.modm.io for a large and representative number of targets with all modules enabled.","title":"Documentation"},{"location":"reference/documentation/#documentation","text":"Since modm is so highly configurable with its many options and selectable modules, it can generate wildly different code for different project configurations. However we've taken great care to keep modm discoverable by making documentation a first-class citizen of our code generation engine lbuild . modm's documentation is split into two parts: The module documentation available during library discovery via lbuild discover . The Doxygen API documentation available after generating the library with the modm:docs module via lbuild build .","title":"Documentation"},{"location":"reference/documentation/#modules","text":"The modm modules and their options are shown by lbuild discover . These descriptions advertise the modules capabilities and gives a high-level overview of how to use it. You can search for keywords in all modules using lbuild search QUERIES [QUERIES ...] : $ lbuild search animation Parser(lbuild) \u2570\u2500\u2500 Repository(modm @ ../../..) modm: a barebone embedded library generator \u2570\u2500\u2500 Module(modm:ui) User interface \u251c\u2500\u2500 Module(modm:ui:animation) Animators \u2570\u2500\u2500 Module(modm:ui:led) LED Animation and Gamma Correction >> modm:ui [Module] 4 Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures. >> modm:ui:led [Module] 1 # LED Animation and Gamma Correction 6 `modm:ui:animation` module and providing look-up tables for performing 12 wraps an 8-bit `modm::ui::Animation` and a 8-bit value. 38 Depending on how smooth you require your animation to be, you may call the 42 `modm::ui::KeyFrameAnimation` class and it's derivatives, to animate it's 83 use the `modm::ui::table22_16_256` table to map the linear LED animation values To make discovery even easier we have created a superimposed view of all available modules on this homepage . Try searching for your keywords in the search bar above. Note that in this superimposed view, some Modules and Options are only available for certain targets. These are then labels as \" {Module, Option, Collector} only available for {target} \". Additionally the view does not show peripheral instance submodule to reduce visual noise.","title":"Modules"},{"location":"reference/documentation/#doxypress-doxygen","text":"The generated C/C++ API is documented using Doxypress and therefore only available after code generation. To view this documentation, include the modm:docs module in your project.xml configuration and run lbuild build . A modm/docs folder is created containing the doxypress.json for modm as well as all the @defgroup s mirroring the module structure. You must then run Doxypress manually, which can take several minutes, and compiles the target-specific documentation into modm/docs/html : lbuild build -m \"modm:docs\" # With Doxypress ( cd modm/docs && doxypress doxypress.json ) # then open: modm/docs/html/index.html The generated Doxypress/Doxygen documentation contains the original module documentation including the option choices you made . This makes it easier to map the lbuild options to changes in the generated source code.","title":"Doxypress / Doxygen"},{"location":"reference/documentation/#online-api-docs","text":"API documentation is available at docs.modm.io for a large and representative number of targets with all modules enabled.","title":"Online API Docs"},{"location":"reference/module/modm-architecture-1-wire/","text":"1-Wire \u00b6 lbuild module: modm:architecture:1-wire 1-Wire is a device communications bus system designed by Dallas Semiconductor Corp. that provides low-speed data, signaling and power over a single signal. 1-Wire is similar in concept to I\u00b2C, but with lower data rates and longer range. It is typically used to communicate with small inexpensive devices such as digital thermometers and weather instruments. One distinctive feature of the bus is the possibility to use only two wires: data and ground. To accomplish this, 1-wire devices include an 800 pF capacitor to store charge, and power the device during periods where the data line is used for data.","title":":architecture:1-wire"},{"location":"reference/module/modm-architecture-1-wire/#1-wire","text":"lbuild module: modm:architecture:1-wire 1-Wire is a device communications bus system designed by Dallas Semiconductor Corp. that provides low-speed data, signaling and power over a single signal. 1-Wire is similar in concept to I\u00b2C, but with lower data rates and longer range. It is typically used to communicate with small inexpensive devices such as digital thermometers and weather instruments. One distinctive feature of the bus is the possibility to use only two wires: data and ground. To accomplish this, 1-wire devices include an 800 pF capacitor to store charge, and power the device during periods where the data line is used for data.","title":"1-Wire"},{"location":"reference/module/modm-architecture-accessor/","text":"Memory Accessors \u00b6 lbuild module: modm:architecture:accessor","title":":architecture:accessor"},{"location":"reference/module/modm-architecture-accessor/#memory-accessors","text":"lbuild module: modm:architecture:accessor","title":"Memory Accessors"},{"location":"reference/module/modm-architecture-adc/","text":"Analog-to-Digital Converters \u00b6 lbuild module: modm:architecture:adc","title":":architecture:adc"},{"location":"reference/module/modm-architecture-adc/#analog-to-digital-converters","text":"lbuild module: modm:architecture:adc","title":"Analog-to-Digital Converters"},{"location":"reference/module/modm-architecture-assert/","text":"Assertions and Abandonment \u00b6 lbuild module: modm:architecture:assert This module provides a way to define and report assertions, that act as a low-cost replacement for C++ exceptions and as a low-cost customization point for errors raised in asynchronous code. Assertions are called with or without a context: modm_assert(condition, name, descr); modm_assert(condition, name, descr, context); They have the following arguments: bool condition : The assertion fails when this condition evaluated to false. const char *name : A short and unique assertion name. const char *description : A detailed description of the failure. uintptr_t context = -1 : Optional context. The condition is evaluated at most once by a (C-style) cast to bool. The name format is not enforced, however, it is recommended to either use what for top-level failures, like malloc for heap troubles, or scope.what for failures that may not be unique, like can.rx vs. uart.rx for when their respective receive buffers overflow. The description can be as detailed as necessary, since it is only included in the firmware if the with_description option is set to true, which also defines MODM_ASSERTION_INFO_HAS_DESCRIPTION to 1 or 0. You can either find the detailed description in your code via its name, or if you prefer a stand-alone solution and your target has enough memory, include all strings in your binary. The context is of pointer size, and anything passed to it is cast to uintptr_t . Otherwise all bits are set via uintptr_t(-1) . Assertions are implemented as macros and expand to this pseudo-code equivalent: void modm_assert ( bool condition , const char * name , const char * description , uintptr_t context = uintptr_t ( -1 )) { if ( not condition ) { modm :: AssertionInfo info { name , description , context }; modm_assert_report ( info ); // Unreachable code } } Assertions can be used in both C and C++ code. If you like to know the technical details, you can read here about the original assertions in xpcc . Assertion Handlers \u00b6 Assertions may also be recoverable if the call site allows for it. For example if the CAN receive buffer overflows, you may want to simply discard the input. If malloc fails to allocate it just returns NULL and the caller is responsible to deal with that. But maybe you want to enable an additional assertion in debug mode just to double-check. When an assertion fails, the runtime calls any number of user-defined handlers, registered using MODM_ASSERTION_HANDLER(handler) . The handlers must return a modm::Abandonment value, specifing whether they want to continue with the execution with Abandonment::Ignore , or abandon execution with Abandonment::Fail leading to a call to modm_abandon(info) , or delegate the decision with Abandonment::DontCare . For example, this neutral handler logs the failed assertion's name, but delegates all further decisions to others: static modm :: Abandonment log_assertion ( const modm :: AssertionInfo & info ) { MODM_LOG_ERROR . printf ( \"Assertion '%s' raised! \\n \" , info . name ); return Abandonment :: DontCare ; } // Register handler for all builds MODM_ASSERTION_HANDLER ( log_assertion ); // Or register only for debug builds MODM_ASSERTION_HANDLER_DEBUG ( log_assertion ); You may register specialized handlers anywhere in your code, for example for ignoring the mentioned CAN receive buffer overflow in your connectivity code: static modm :: Abandonment ignore_can_rx_handler ( const modm :: AssertionInfo & info ) { if ( info . name == \"can.rx\" s ) { // Only silently ignore this specific assertion! return Abandonment :: Ignore ; } return Abandonment :: DontCare ; } MODM_ASSERTION_HANDLER ( ignore_can_rx_handler ); You may define any number of handlers, which are called in random order by the runtime and their results are accumulated as follows: If at least one handler returns Abandonment::Fail execution abandons. Otherwise if any handler returns Abandonment::Ignore execution resumes. Otherwise if no handlers are registered or all handlers return Abandonment::DontCare , the assertion type determines the outcome. Handler execution order is undefined. The order of handler execution is undefined and must not be relied upon for any functionality! Assertions and handlers are not reentrant! Assertions may fail in an interrupt context, thus calling handlers in that context too. Since handlers may make use of interrupts themselves (for logging via UART) assertions are not atomically scoped by default. You may however use a modm::atomic::Lock inside your assertion handler. Handlers may be called inside high-priority interrupts! This is problematic when relying on interrupts still working inside handlers for example for logging the failure via UART. Be aware of this and make sure you do not inadvertantly block inside handlers. Assertion Types \u00b6 The call site of the assertion decides whether an assertion can be recovered from or not. For example, if the CAN receive buffer has overflowed, but execution continues, then code to discard the message must be in place. In case no handlers are registered or they all delegate the abandoment decision away, the call site must decide what the default behavior is. For this purpose the following assertions are available: void modm_assert() : Always abandons execution when failed. bool modm_assert_continue_fail() : Abandons execution unless overwritten. bool modm_assert_continue_ignore() : Resumes execution unless overwritten. Assertions that can resume execution return the evaluated boolean condition to be used to branch to cleanup code: // Can be done inline in any flow control statement if ( not modm_assert_continue_fail ( condition , ...)) { // cleanup code } // Or saved in a variable and queried multiple times. const bool cleanup = not modm_assert_continue_ignore ( condition , ...); if ( cleanup ) { // cleanup code part 1 } // other code if ( cleanup ) { // cleanup code part 1 } // or if cleanup is require *before* assertion is called const bool is_ok = ( condition ); if ( not is_ok ) { // pre-assert cleanup } modm_assert_continue_fail ( is_ok , ...); if ( not is_ok ) { // post-assert cleanup } Additionally, these assertions are only active in debug mode. Of course they still evaluate and return the condition in release mode, so you can use them just as above: bool modm_assert_continue_fail_debug() bool modm_assert_continue_ignore_debug() When to use what? \u00b6 Here are some guidelines for choosing the best assertion type: Prefer to report errors via return types whenever possible! If no sane recovery is possible, use modm_assert() . If there is a (sensible) fallback for the failure, use modm_assert_continue_{fail|ignore}() : a. Abort by default, if the failure runs contrary to expected behavior. b. Resume by default, if the failure is expected and its behavior is well documented. If the failure is expected and communicated via the normal API, or it only occurs rarely or through a clear misuse of the API, use modm_assert_continue_{fail|ignore}_debug() . Let's illustrate these with a few examples: libc exit() is called. There is no sensible fallback, since there is no operating system to return control back to, so use modm_assert() . An interrupt without a user-defined handler is triggered. The developer most likely enabled the wrong interrupt or provided the wrong handler. A sensible fallback is to disable the interrupt from triggering again and to alert the developer with modm_assert_continue_fail(..., irq_number) . The CAN receive buffer overflows. A sensible fallback is to discard the message, which is documented as the expected behavior. Since this occurs asynchronously inside the CAN RX interrupt, there is no way to return an error code, so call modm_assert_continue_ignore(..., &message) with a pointer to the message to inform the developer. malloc fails to due to heap exhaustion and returns NULL, delegating the fallback implementation to the caller. Since the typical callers of malloc are known for not checking for NULL, using modm_assert_continue_fail_debug() here is warranted, helping the developer find potential issues faster, and then ignoring this assert for debug builds by registering a handler via MODM_ASSERTION_HANDLER_DEBUG() . An I2C transfer failure is detected inside an interrupt. Such failures are expected on busses and typically the transfers are simply retried. You can use modm_assert_continue_ignore_debug() to give the developer a way to log the failure frequency without having to provide a special API. This can help diagnose a problem perhaps with the bus connection faster. Abandoning execution \u00b6 If execution is abandoned modm_abandon(const AssertionInfo &info) is called, which is a weak and empty function by default. The function is meant to be overwritten by the application on embedded targets for example to disable relevant hardware for safety, log the failure via UART and perhaps blink some LEDs wildly to get the user's attention. After returning from that function, the runtime resets the chip on Cortex-M, or loops forever on AVR, or calls abort() on hosted. You may of course, implement your own abandoning behavior instead of returning from modm_abandon() . modm_abandon() may be called inside high-priority interrupts! You can try to lower the active IRQ priority to let UART work, however, in the worst case you're called from within the HardFault or even NMI handlers which have the highest fixed priority. Options \u00b6 with_description \u00b6 Include assertion description Places the full description of a modm_assert() into the firmware image instead of only into the ELF file. This makes printing assertion information a simple standalone feature, fully independent of any additional script for decoding logging output, however, it may increase binary size considerably! Default: debug avr, sam, stm32 Default: release hosted Inputs: [debug, off, release] Dependencies \u00b6 modm:architecture:assert modm_architecture_assert modm: architecture: assert modm_architecture_accessor modm: architecture: accessor modm_architecture_assert->modm_architecture_accessor modm_architecture_register modm: architecture: register modm_architecture_assert->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:assert"},{"location":"reference/module/modm-architecture-assert/#assertions-and-abandonment","text":"lbuild module: modm:architecture:assert This module provides a way to define and report assertions, that act as a low-cost replacement for C++ exceptions and as a low-cost customization point for errors raised in asynchronous code. Assertions are called with or without a context: modm_assert(condition, name, descr); modm_assert(condition, name, descr, context); They have the following arguments: bool condition : The assertion fails when this condition evaluated to false. const char *name : A short and unique assertion name. const char *description : A detailed description of the failure. uintptr_t context = -1 : Optional context. The condition is evaluated at most once by a (C-style) cast to bool. The name format is not enforced, however, it is recommended to either use what for top-level failures, like malloc for heap troubles, or scope.what for failures that may not be unique, like can.rx vs. uart.rx for when their respective receive buffers overflow. The description can be as detailed as necessary, since it is only included in the firmware if the with_description option is set to true, which also defines MODM_ASSERTION_INFO_HAS_DESCRIPTION to 1 or 0. You can either find the detailed description in your code via its name, or if you prefer a stand-alone solution and your target has enough memory, include all strings in your binary. The context is of pointer size, and anything passed to it is cast to uintptr_t . Otherwise all bits are set via uintptr_t(-1) . Assertions are implemented as macros and expand to this pseudo-code equivalent: void modm_assert ( bool condition , const char * name , const char * description , uintptr_t context = uintptr_t ( -1 )) { if ( not condition ) { modm :: AssertionInfo info { name , description , context }; modm_assert_report ( info ); // Unreachable code } } Assertions can be used in both C and C++ code. If you like to know the technical details, you can read here about the original assertions in xpcc .","title":"Assertions and Abandonment"},{"location":"reference/module/modm-architecture-assert/#assertion-handlers","text":"Assertions may also be recoverable if the call site allows for it. For example if the CAN receive buffer overflows, you may want to simply discard the input. If malloc fails to allocate it just returns NULL and the caller is responsible to deal with that. But maybe you want to enable an additional assertion in debug mode just to double-check. When an assertion fails, the runtime calls any number of user-defined handlers, registered using MODM_ASSERTION_HANDLER(handler) . The handlers must return a modm::Abandonment value, specifing whether they want to continue with the execution with Abandonment::Ignore , or abandon execution with Abandonment::Fail leading to a call to modm_abandon(info) , or delegate the decision with Abandonment::DontCare . For example, this neutral handler logs the failed assertion's name, but delegates all further decisions to others: static modm :: Abandonment log_assertion ( const modm :: AssertionInfo & info ) { MODM_LOG_ERROR . printf ( \"Assertion '%s' raised! \\n \" , info . name ); return Abandonment :: DontCare ; } // Register handler for all builds MODM_ASSERTION_HANDLER ( log_assertion ); // Or register only for debug builds MODM_ASSERTION_HANDLER_DEBUG ( log_assertion ); You may register specialized handlers anywhere in your code, for example for ignoring the mentioned CAN receive buffer overflow in your connectivity code: static modm :: Abandonment ignore_can_rx_handler ( const modm :: AssertionInfo & info ) { if ( info . name == \"can.rx\" s ) { // Only silently ignore this specific assertion! return Abandonment :: Ignore ; } return Abandonment :: DontCare ; } MODM_ASSERTION_HANDLER ( ignore_can_rx_handler ); You may define any number of handlers, which are called in random order by the runtime and their results are accumulated as follows: If at least one handler returns Abandonment::Fail execution abandons. Otherwise if any handler returns Abandonment::Ignore execution resumes. Otherwise if no handlers are registered or all handlers return Abandonment::DontCare , the assertion type determines the outcome. Handler execution order is undefined. The order of handler execution is undefined and must not be relied upon for any functionality! Assertions and handlers are not reentrant! Assertions may fail in an interrupt context, thus calling handlers in that context too. Since handlers may make use of interrupts themselves (for logging via UART) assertions are not atomically scoped by default. You may however use a modm::atomic::Lock inside your assertion handler. Handlers may be called inside high-priority interrupts! This is problematic when relying on interrupts still working inside handlers for example for logging the failure via UART. Be aware of this and make sure you do not inadvertantly block inside handlers.","title":"Assertion Handlers"},{"location":"reference/module/modm-architecture-assert/#assertion-types","text":"The call site of the assertion decides whether an assertion can be recovered from or not. For example, if the CAN receive buffer has overflowed, but execution continues, then code to discard the message must be in place. In case no handlers are registered or they all delegate the abandoment decision away, the call site must decide what the default behavior is. For this purpose the following assertions are available: void modm_assert() : Always abandons execution when failed. bool modm_assert_continue_fail() : Abandons execution unless overwritten. bool modm_assert_continue_ignore() : Resumes execution unless overwritten. Assertions that can resume execution return the evaluated boolean condition to be used to branch to cleanup code: // Can be done inline in any flow control statement if ( not modm_assert_continue_fail ( condition , ...)) { // cleanup code } // Or saved in a variable and queried multiple times. const bool cleanup = not modm_assert_continue_ignore ( condition , ...); if ( cleanup ) { // cleanup code part 1 } // other code if ( cleanup ) { // cleanup code part 1 } // or if cleanup is require *before* assertion is called const bool is_ok = ( condition ); if ( not is_ok ) { // pre-assert cleanup } modm_assert_continue_fail ( is_ok , ...); if ( not is_ok ) { // post-assert cleanup } Additionally, these assertions are only active in debug mode. Of course they still evaluate and return the condition in release mode, so you can use them just as above: bool modm_assert_continue_fail_debug() bool modm_assert_continue_ignore_debug()","title":"Assertion Types"},{"location":"reference/module/modm-architecture-assert/#when-to-use-what","text":"Here are some guidelines for choosing the best assertion type: Prefer to report errors via return types whenever possible! If no sane recovery is possible, use modm_assert() . If there is a (sensible) fallback for the failure, use modm_assert_continue_{fail|ignore}() : a. Abort by default, if the failure runs contrary to expected behavior. b. Resume by default, if the failure is expected and its behavior is well documented. If the failure is expected and communicated via the normal API, or it only occurs rarely or through a clear misuse of the API, use modm_assert_continue_{fail|ignore}_debug() . Let's illustrate these with a few examples: libc exit() is called. There is no sensible fallback, since there is no operating system to return control back to, so use modm_assert() . An interrupt without a user-defined handler is triggered. The developer most likely enabled the wrong interrupt or provided the wrong handler. A sensible fallback is to disable the interrupt from triggering again and to alert the developer with modm_assert_continue_fail(..., irq_number) . The CAN receive buffer overflows. A sensible fallback is to discard the message, which is documented as the expected behavior. Since this occurs asynchronously inside the CAN RX interrupt, there is no way to return an error code, so call modm_assert_continue_ignore(..., &message) with a pointer to the message to inform the developer. malloc fails to due to heap exhaustion and returns NULL, delegating the fallback implementation to the caller. Since the typical callers of malloc are known for not checking for NULL, using modm_assert_continue_fail_debug() here is warranted, helping the developer find potential issues faster, and then ignoring this assert for debug builds by registering a handler via MODM_ASSERTION_HANDLER_DEBUG() . An I2C transfer failure is detected inside an interrupt. Such failures are expected on busses and typically the transfers are simply retried. You can use modm_assert_continue_ignore_debug() to give the developer a way to log the failure frequency without having to provide a special API. This can help diagnose a problem perhaps with the bus connection faster.","title":"When to use what?"},{"location":"reference/module/modm-architecture-assert/#abandoning-execution","text":"If execution is abandoned modm_abandon(const AssertionInfo &info) is called, which is a weak and empty function by default. The function is meant to be overwritten by the application on embedded targets for example to disable relevant hardware for safety, log the failure via UART and perhaps blink some LEDs wildly to get the user's attention. After returning from that function, the runtime resets the chip on Cortex-M, or loops forever on AVR, or calls abort() on hosted. You may of course, implement your own abandoning behavior instead of returning from modm_abandon() . modm_abandon() may be called inside high-priority interrupts! You can try to lower the active IRQ priority to let UART work, however, in the worst case you're called from within the HardFault or even NMI handlers which have the highest fixed priority.","title":"Abandoning execution"},{"location":"reference/module/modm-architecture-assert/#options","text":"","title":"Options"},{"location":"reference/module/modm-architecture-assert/#with_description","text":"Include assertion description Places the full description of a modm_assert() into the firmware image instead of only into the ELF file. This makes printing assertion information a simple standalone feature, fully independent of any additional script for decoding logging output, however, it may increase binary size considerably! Default: debug avr, sam, stm32 Default: release hosted Inputs: [debug, off, release]","title":"with_description"},{"location":"reference/module/modm-architecture-assert/#dependencies","text":"modm:architecture:assert modm_architecture_assert modm: architecture: assert modm_architecture_accessor modm: architecture: accessor modm_architecture_assert->modm_architecture_accessor modm_architecture_register modm: architecture: register modm_architecture_assert->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-atomic/","text":"Atomic Operations and Containers \u00b6 lbuild module: modm:architecture:atomic","title":":architecture:atomic"},{"location":"reference/module/modm-architecture-atomic/#atomic-operations-and-containers","text":"lbuild module: modm:architecture:atomic","title":"Atomic Operations and Containers"},{"location":"reference/module/modm-architecture-block-device/","text":"Block Devices \u00b6 lbuild module: modm:architecture:block.device Dependencies \u00b6 modm:architecture:block.device modm_architecture_block_device modm: architecture: block.device modm_processing_resumable modm: processing: resumable modm_architecture_block_device->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:block.device"},{"location":"reference/module/modm-architecture-block-device/#block-devices","text":"lbuild module: modm:architecture:block.device","title":"Block Devices"},{"location":"reference/module/modm-architecture-block-device/#dependencies","text":"modm:architecture:block.device modm_architecture_block_device modm: architecture: block.device modm_processing_resumable modm: processing: resumable modm_architecture_block_device->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-build_id/","text":"GNU Build ID \u00b6 lbuild module: modm:architecture:build_id","title":":architecture:build_id"},{"location":"reference/module/modm-architecture-build_id/#gnu-build-id","text":"lbuild module: modm:architecture:build_id","title":"GNU Build ID"},{"location":"reference/module/modm-architecture-can/","text":"Controller Area Network \u00b6 lbuild module: modm:architecture:can Controller\u2013area network (CAN or CAN-bus) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other within a vehicle without a host computer. CAN is a message based protocol, designed specifically for automotive applications but now also used in other areas such as industrial automation and medical equipment.","title":":architecture:can"},{"location":"reference/module/modm-architecture-can/#controller-area-network","text":"lbuild module: modm:architecture:can Controller\u2013area network (CAN or CAN-bus) is a vehicle bus standard designed to allow microcontrollers and devices to communicate with each other within a vehicle without a host computer. CAN is a message based protocol, designed specifically for automotive applications but now also used in other areas such as industrial automation and medical equipment.","title":"Controller Area Network"},{"location":"reference/module/modm-architecture-clock/","text":"System Clock \u00b6 lbuild module: modm:architecture:clock To provide a system-wide time base this module provides two clocks: modm::Clock : a 32-bit unsigned millisecond clock running for approx. 49 days until wrap around, as an optimized replacement of std::chrono::system_clock . modm::PreciseClock : a 32-bit unsigned microsecond clock running for approx. 71 minutes until wrap around, as an optimized replacement of std::chrono::high_resolution_clock . These clocks are intended to measure time intervals: const auto start = modm :: PreciseClock :: now (); how_long_does_this_function_take (); const auto duration = modm :: PreciseClock :: now () - start ; MODM_LOG_DEBUG << \"Function took \" << duration << modm :: endl ; For additional common timeout and periodic timer use-cases also check out the modm:processing:timer module which uses these clocks. Limitations \u00b6 The clocks intended to be very lightweight to use, however, a few interface tradeoffs had to be made to achieve this goal. The clocks are not steady with their 32-bit counters overflowing after a relatively short time. They must therefore only be used for measuring intervals, not absolute time. The clocks have unsigned durations to make it easy to work with intervals since the addition/subtraction of intervals works just fine on clocks wrapping around, on the important condition that the interval is shorter than the clocks wrap around time. Use a RTC-backed calendar for timekeeping! These clocks are definitely not accurate over long periods of time, since they are based on the internal clock supplies, which may have significant drift and thus are no replacement for a Real-Time Clock! Also check the modm:platform:clock module descriptions for additional limitations on clock resolution and clock drift depending on target. Dependencies \u00b6 modm:architecture:clock modm_architecture_clock modm: architecture: clock modm_stdc++ modm: stdc++ modm_architecture_clock->modm_stdc++ @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:clock"},{"location":"reference/module/modm-architecture-clock/#system-clock","text":"lbuild module: modm:architecture:clock To provide a system-wide time base this module provides two clocks: modm::Clock : a 32-bit unsigned millisecond clock running for approx. 49 days until wrap around, as an optimized replacement of std::chrono::system_clock . modm::PreciseClock : a 32-bit unsigned microsecond clock running for approx. 71 minutes until wrap around, as an optimized replacement of std::chrono::high_resolution_clock . These clocks are intended to measure time intervals: const auto start = modm :: PreciseClock :: now (); how_long_does_this_function_take (); const auto duration = modm :: PreciseClock :: now () - start ; MODM_LOG_DEBUG << \"Function took \" << duration << modm :: endl ; For additional common timeout and periodic timer use-cases also check out the modm:processing:timer module which uses these clocks.","title":"System Clock"},{"location":"reference/module/modm-architecture-clock/#limitations","text":"The clocks intended to be very lightweight to use, however, a few interface tradeoffs had to be made to achieve this goal. The clocks are not steady with their 32-bit counters overflowing after a relatively short time. They must therefore only be used for measuring intervals, not absolute time. The clocks have unsigned durations to make it easy to work with intervals since the addition/subtraction of intervals works just fine on clocks wrapping around, on the important condition that the interval is shorter than the clocks wrap around time. Use a RTC-backed calendar for timekeeping! These clocks are definitely not accurate over long periods of time, since they are based on the internal clock supplies, which may have significant drift and thus are no replacement for a Real-Time Clock! Also check the modm:platform:clock module descriptions for additional limitations on clock resolution and clock drift depending on target.","title":"Limitations"},{"location":"reference/module/modm-architecture-clock/#dependencies","text":"modm:architecture:clock modm_architecture_clock modm: architecture: clock modm_stdc++ modm: stdc++ modm_architecture_clock->modm_stdc++ @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-delay/","text":"Blocking Delays \u00b6 lbuild module: modm:architecture:delay These functions allow you to spin for a short time using only the CPU. In general it is recommended to use the std::chrono duration types to allow the compiler to choose the optimal implementation for you: #include <chrono> constexpr std :: chrono :: nanoseconds DELAY_TIME { 100 }; modm :: delay ( DELAY_TIME ); constexpr std :: chrono :: microseconds DELAY_TIME2 { 200 }; modm :: delay ( DELAY_TIME2 ); // same signature, different implementation In your code you can also use the std::chrono literals: using namespace std :: chrono_literals ; modm :: delay ( 100 ns ); modm :: delay ( 200u s ); modm :: delay ( 300 ms ); In order to not require wild casting around of values, there are also three overloads for (unsigned) integer values. These are particularly useful for when you do not want to or cannot use chrono literals. modm :: delay_ns ( 100 ); modm :: delay_us ( 200 ); modm :: delay_ms ( 300 ); Note that these delay functions work at any CPU clock speed, even if changed dynamically at runtime and are available very early in the startup process at hardware-init time. Limitations \u00b6 The main limitations are accuracy and length of delay. The only guarantee given to you is to delay for at least the specified time. Note that invocation of interrupts during spinning may add delay too. For additional limitations also check the description of the modm:platform:core modules. You should always prefer Software Timers (see modm:processing:timer ) over these blocking delay functions. However, when modm::Clock is not set up yet, or when you need very small delays (for example to bit-bang a protocol), you need to use these delay functions.","title":":architecture:delay"},{"location":"reference/module/modm-architecture-delay/#blocking-delays","text":"lbuild module: modm:architecture:delay These functions allow you to spin for a short time using only the CPU. In general it is recommended to use the std::chrono duration types to allow the compiler to choose the optimal implementation for you: #include <chrono> constexpr std :: chrono :: nanoseconds DELAY_TIME { 100 }; modm :: delay ( DELAY_TIME ); constexpr std :: chrono :: microseconds DELAY_TIME2 { 200 }; modm :: delay ( DELAY_TIME2 ); // same signature, different implementation In your code you can also use the std::chrono literals: using namespace std :: chrono_literals ; modm :: delay ( 100 ns ); modm :: delay ( 200u s ); modm :: delay ( 300 ms ); In order to not require wild casting around of values, there are also three overloads for (unsigned) integer values. These are particularly useful for when you do not want to or cannot use chrono literals. modm :: delay_ns ( 100 ); modm :: delay_us ( 200 ); modm :: delay_ms ( 300 ); Note that these delay functions work at any CPU clock speed, even if changed dynamically at runtime and are available very early in the startup process at hardware-init time.","title":"Blocking Delays"},{"location":"reference/module/modm-architecture-delay/#limitations","text":"The main limitations are accuracy and length of delay. The only guarantee given to you is to delay for at least the specified time. Note that invocation of interrupts during spinning may add delay too. For additional limitations also check the description of the modm:platform:core modules. You should always prefer Software Timers (see modm:processing:timer ) over these blocking delay functions. However, when modm::Clock is not set up yet, or when you need very small delays (for example to bit-bang a protocol), you need to use these delay functions.","title":"Limitations"},{"location":"reference/module/modm-architecture-gpio-expander/","text":"GPIO Expanders \u00b6 lbuild module: modm:architecture:gpio.expander Dependencies \u00b6 modm:architecture:gpio.expander modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio modm: architecture: gpio modm_architecture_gpio_expander->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_architecture_gpio_expander->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_gpio_expander->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_gpio_expander->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:gpio.expander"},{"location":"reference/module/modm-architecture-gpio-expander/#gpio-expanders","text":"lbuild module: modm:architecture:gpio.expander","title":"GPIO Expanders"},{"location":"reference/module/modm-architecture-gpio-expander/#dependencies","text":"modm:architecture:gpio.expander modm_architecture_gpio_expander modm: architecture: gpio.expander modm_architecture_gpio modm: architecture: gpio modm_architecture_gpio_expander->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_architecture_gpio_expander->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_gpio_expander->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_gpio_expander->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-gpio/","text":"General Purpose Input/Output \u00b6 lbuild module: modm:architecture:gpio GPIOs are modeled as individual classes with an interface consisting out of a common set of static methods. Using GPIOs \u00b6 These classes are used to create architecture independent definitions for hardware pins which then can be used as template parameters for miscellaneous device drivers. Example of a platform-independent blinking light: #include <modm/platform.hpp> using Led = GpioOutputB0 ; Led :: setOutput (); Led :: set (); while ( true ) { Led :: toggle (); modm :: delay ( 500 ms ); } You can use the common definitions of modm::Gpio to express your intention for setting a pin. However, you can also use anything that casts to bool . Led :: set ( modm :: Gpio :: High ); // Turns Led on Led :: set ( modm :: Gpio :: Low ); // Turns Led off Led :: set ( true ); Led :: set ( false ); Led :: set ( 1 ); Led :: set ( 0 ); Led :: set (); Led :: reset (); Initialize your GPIOs Call Gpio::setInput() or Gpio::setOutput() before the first use, otherwise the GPIO state may be undefined!","title":":architecture:gpio"},{"location":"reference/module/modm-architecture-gpio/#general-purpose-inputoutput","text":"lbuild module: modm:architecture:gpio GPIOs are modeled as individual classes with an interface consisting out of a common set of static methods.","title":"General Purpose Input/Output"},{"location":"reference/module/modm-architecture-gpio/#using-gpios","text":"These classes are used to create architecture independent definitions for hardware pins which then can be used as template parameters for miscellaneous device drivers. Example of a platform-independent blinking light: #include <modm/platform.hpp> using Led = GpioOutputB0 ; Led :: setOutput (); Led :: set (); while ( true ) { Led :: toggle (); modm :: delay ( 500 ms ); } You can use the common definitions of modm::Gpio to express your intention for setting a pin. However, you can also use anything that casts to bool . Led :: set ( modm :: Gpio :: High ); // Turns Led on Led :: set ( modm :: Gpio :: Low ); // Turns Led off Led :: set ( true ); Led :: set ( false ); Led :: set ( 1 ); Led :: set ( 0 ); Led :: set (); Led :: reset (); Initialize your GPIOs Call Gpio::setInput() or Gpio::setOutput() before the first use, otherwise the GPIO state may be undefined!","title":"Using GPIOs"},{"location":"reference/module/modm-architecture-i2c-device/","text":"I\u00b2C Devices \u00b6 lbuild module: modm:architecture:i2c.device Dependencies \u00b6 modm:architecture:i2c.device modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_device->modm_architecture_i2c modm_processing_resumable modm: processing: resumable modm_architecture_i2c_device->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:i2c.device"},{"location":"reference/module/modm-architecture-i2c-device/#i2c-devices","text":"lbuild module: modm:architecture:i2c.device","title":"I\u00b2C Devices"},{"location":"reference/module/modm-architecture-i2c-device/#dependencies","text":"modm:architecture:i2c.device modm_architecture_i2c_device modm: architecture: i2c.device modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_device->modm_architecture_i2c modm_processing_resumable modm: processing: resumable modm_architecture_i2c_device->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-i2c-multiplexer/","text":"I\u00b2C Multiplexer \u00b6 lbuild module: modm:architecture:i2c.multiplexer Dependencies \u00b6 modm:architecture:i2c.multiplexer modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_multiplexer->modm_architecture_i2c modm_architecture_register modm: architecture: register modm_architecture_i2c_multiplexer->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_i2c_multiplexer->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_i2c_multiplexer->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:i2c.multiplexer"},{"location":"reference/module/modm-architecture-i2c-multiplexer/#i2c-multiplexer","text":"lbuild module: modm:architecture:i2c.multiplexer","title":"I\u00b2C Multiplexer"},{"location":"reference/module/modm-architecture-i2c-multiplexer/#dependencies","text":"modm:architecture:i2c.multiplexer modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_architecture_i2c modm: architecture: i2c modm_architecture_i2c_multiplexer->modm_architecture_i2c modm_architecture_register modm: architecture: register modm_architecture_i2c_multiplexer->modm_architecture_register modm_math_utils modm: math: utils modm_architecture_i2c_multiplexer->modm_math_utils modm_processing_resumable modm: processing: resumable modm_architecture_i2c_multiplexer->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-i2c/","text":"Inter-Integrated Circuit (I\u00b2C) \u00b6 lbuild module: modm:architecture:i2c Dependencies \u00b6 modm:architecture:i2c modm_architecture_i2c modm: architecture: i2c modm_architecture_delay modm: architecture: delay modm_architecture_i2c->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_architecture_i2c->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:i2c"},{"location":"reference/module/modm-architecture-i2c/#inter-integrated-circuit-i2c","text":"lbuild module: modm:architecture:i2c","title":"Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-architecture-i2c/#dependencies","text":"modm:architecture:i2c modm_architecture_i2c modm: architecture: i2c modm_architecture_delay modm: architecture: delay modm_architecture_i2c->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_architecture_i2c->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-interrupt/","text":"Interrupt Service Routines \u00b6 lbuild module: modm:architecture:interrupt","title":":architecture:interrupt"},{"location":"reference/module/modm-architecture-interrupt/#interrupt-service-routines","text":"lbuild module: modm:architecture:interrupt","title":"Interrupt Service Routines"},{"location":"reference/module/modm-architecture-memory/","text":"Memory Traits \u00b6 lbuild module: modm:architecture:memory Memories have different traits, such as DMA-ability or access time. The memory allocator functions ( malloc() , operator new , etc) by default only return DMA-able memories, ordered by fastest access time. To allocate memory with specific traits, use the overloaded operator new : auto * p = new ( modm :: MemoryFastData ) Foo ; auto * q = new ( modm :: MemoryExternal , std :: nothrow ) Foo ; You need to choose a heap implementation! You can include the :platform:heap module or supply your own implementation. Dependencies \u00b6 modm:architecture:memory modm_architecture_memory modm: architecture: memory modm_architecture_register modm: architecture: register modm_architecture_memory->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:memory"},{"location":"reference/module/modm-architecture-memory/#memory-traits","text":"lbuild module: modm:architecture:memory Memories have different traits, such as DMA-ability or access time. The memory allocator functions ( malloc() , operator new , etc) by default only return DMA-able memories, ordered by fastest access time. To allocate memory with specific traits, use the overloaded operator new : auto * p = new ( modm :: MemoryFastData ) Foo ; auto * q = new ( modm :: MemoryExternal , std :: nothrow ) Foo ; You need to choose a heap implementation! You can include the :platform:heap module or supply your own implementation.","title":"Memory Traits"},{"location":"reference/module/modm-architecture-memory/#dependencies","text":"modm:architecture:memory modm_architecture_memory modm: architecture: memory modm_architecture_register modm: architecture: register modm_architecture_memory->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-register/","text":"General Purpose Registers \u00b6 lbuild module: modm:architecture:register Data structures to provide a native register abstraction. These data structures are used to describe the relationship of single bits, bit groups and bit configurations in registers with type-safe access. Registers can be made up of three things: Bits: a single bit (position N), Configurations: a combination of bits where the meaning does not correspond to its numeric value (position [N, M]) Values: a numeric value (position [N, M]) Example of an 8-bit register called Control 7 6 5 4 3 2 1 0 | EN | FS | PRE1 | PRE0 | DEL2 | DEL1 | DEL0 | | Bit 7: Enable Bit 6: Full Scale Configuration [5, 4]: Prescaler 00: Divide by 1 01: Divide by 2 10: Divide by 4 11: Divide by 8 Value [3, 1]: Start-Up Delay in ms Register Bits \u00b6 The bits can be modelled using strongly-typed enums and the Flags template class as follows: enum class Control : uint8_t { EN = Bit7 , ///< bit documentation FS = Bit6 , PRE1 = Bit5 , PRE0 = Bit4 , DEL2 = Bit3 , DEL1 = Bit2 , DEL0 = Bit1 , }; MODM_FLAGS8 ( Control ); // expands to // typedef modm::Flags8< Control > Control_t; // and some enum operator overloading magic You can handle all its register bits as you would expect: Control_t control = Control :: EN ; control = Control :: EN | Control :: FS ; control &= ~ Control :: FS ; control |= Control :: FS ; control ^= Control :: PRE1 ; bool isSet = control & Control :: FS ; control . reset ( Control :: PRE1 | Control :: PRE0 ); control . set ( Control :: DEL0 ); bool noneSet = control . none ( Control :: PRE1 | Control :: PRE0 ); bool allSet = control . all ( Control :: EN | Control :: FS ); You still get raw access if you really need it: uint8_t raw = control . value ; // the underlying type control . value = 0x24 ; The access is type-safe, you cannot use bits from two different registers: enum class Control2 : uint8_t { DIS = Bit4 , HS = Bit3 , }; MODM_FLAGS8 ( Control2 ); auto control = Control :: EN | Control2 :: HS ; // compile error You can even overload functions on argument type now: void write ( Control_t control ); void write ( Control2_t control ); write ( Control :: EN | Control :: FS ); // calls #1 write ( Control2 :: DIS ); // calls #2 Register Configurations \u00b6 Configurations are also described as a strongly-typed enum and then wrapped into the Configuration template class. enum class Prescaler : uint8_t { Div1 = 0 , ///< configuration documentation Div2 = int ( Control :: PRE0 ), Div4 = int ( Control :: PRE1 ), Div8 = int ( Control :: PRE1 ) | int ( Control :: PRE0 ), }; typedef Configuration < Control_t , Prescaler , ( Bit5 | Bit4 ) > Prescaler_t ; The Prescaler enum values are already shifted in this example (hence the (Bit5 | Bit4) mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it: enum class Prescaler : uint8_t { Div1 = 0 , Div2 = 1 , Div4 = 2 , Div8 = 3 , }; typedef Configuration < Control_t , Prescaler , 0b11 , 4 > Prescaler_t ; Why? If you have two or more configurations with the same selections in the same register, you can simply add another one: typedef Configuration < Control_t , Prescaler , 0b11 , 6 > Prescaler2_t ; Configurations can be used inline: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ); Control_t control &= ~ Prescaler_t :: mask (); But do not have to: Prescaler_t :: set ( control , Prescaler :: Div2 ); Prescaler_t :: reset ( control ); Prescaler prescaler = Prescaler_t :: get ( control ); Register Values \u00b6 Values are described using the Value template class which masks and shifts the value as required. In our example the value has a width of 3 bits and needs to be shifted 1 bit: typedef Value < Control_t , 3 , 1 > Delay_t ; This can be used the same way as the Configuration: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ) | Delay_t ( 4 ); Control_t control &= ~ Delay_t :: mask (); Delay_t :: set ( control , 7 ); Delay_t :: reset ( control ); uint8_t delay = Delay_t :: get ( control ); See Typesafe Register Access in C++ for a more detailed background on this implementation. Dependencies \u00b6 modm:architecture:register modm_architecture_register modm: architecture: register modm_math_utils modm: math: utils modm_architecture_register->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:register"},{"location":"reference/module/modm-architecture-register/#general-purpose-registers","text":"lbuild module: modm:architecture:register Data structures to provide a native register abstraction. These data structures are used to describe the relationship of single bits, bit groups and bit configurations in registers with type-safe access. Registers can be made up of three things: Bits: a single bit (position N), Configurations: a combination of bits where the meaning does not correspond to its numeric value (position [N, M]) Values: a numeric value (position [N, M]) Example of an 8-bit register called Control 7 6 5 4 3 2 1 0 | EN | FS | PRE1 | PRE0 | DEL2 | DEL1 | DEL0 | | Bit 7: Enable Bit 6: Full Scale Configuration [5, 4]: Prescaler 00: Divide by 1 01: Divide by 2 10: Divide by 4 11: Divide by 8 Value [3, 1]: Start-Up Delay in ms","title":"General Purpose Registers"},{"location":"reference/module/modm-architecture-register/#register-bits","text":"The bits can be modelled using strongly-typed enums and the Flags template class as follows: enum class Control : uint8_t { EN = Bit7 , ///< bit documentation FS = Bit6 , PRE1 = Bit5 , PRE0 = Bit4 , DEL2 = Bit3 , DEL1 = Bit2 , DEL0 = Bit1 , }; MODM_FLAGS8 ( Control ); // expands to // typedef modm::Flags8< Control > Control_t; // and some enum operator overloading magic You can handle all its register bits as you would expect: Control_t control = Control :: EN ; control = Control :: EN | Control :: FS ; control &= ~ Control :: FS ; control |= Control :: FS ; control ^= Control :: PRE1 ; bool isSet = control & Control :: FS ; control . reset ( Control :: PRE1 | Control :: PRE0 ); control . set ( Control :: DEL0 ); bool noneSet = control . none ( Control :: PRE1 | Control :: PRE0 ); bool allSet = control . all ( Control :: EN | Control :: FS ); You still get raw access if you really need it: uint8_t raw = control . value ; // the underlying type control . value = 0x24 ; The access is type-safe, you cannot use bits from two different registers: enum class Control2 : uint8_t { DIS = Bit4 , HS = Bit3 , }; MODM_FLAGS8 ( Control2 ); auto control = Control :: EN | Control2 :: HS ; // compile error You can even overload functions on argument type now: void write ( Control_t control ); void write ( Control2_t control ); write ( Control :: EN | Control :: FS ); // calls #1 write ( Control2 :: DIS ); // calls #2","title":"Register Bits"},{"location":"reference/module/modm-architecture-register/#register-configurations","text":"Configurations are also described as a strongly-typed enum and then wrapped into the Configuration template class. enum class Prescaler : uint8_t { Div1 = 0 , ///< configuration documentation Div2 = int ( Control :: PRE0 ), Div4 = int ( Control :: PRE1 ), Div8 = int ( Control :: PRE1 ) | int ( Control :: PRE0 ), }; typedef Configuration < Control_t , Prescaler , ( Bit5 | Bit4 ) > Prescaler_t ; The Prescaler enum values are already shifted in this example (hence the (Bit5 | Bit4) mask), however you can also declare the prescaler values non-shifted and let the wrapper shift it: enum class Prescaler : uint8_t { Div1 = 0 , Div2 = 1 , Div4 = 2 , Div8 = 3 , }; typedef Configuration < Control_t , Prescaler , 0b11 , 4 > Prescaler_t ; Why? If you have two or more configurations with the same selections in the same register, you can simply add another one: typedef Configuration < Control_t , Prescaler , 0b11 , 6 > Prescaler2_t ; Configurations can be used inline: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ); Control_t control &= ~ Prescaler_t :: mask (); But do not have to: Prescaler_t :: set ( control , Prescaler :: Div2 ); Prescaler_t :: reset ( control ); Prescaler prescaler = Prescaler_t :: get ( control );","title":"Register Configurations"},{"location":"reference/module/modm-architecture-register/#register-values","text":"Values are described using the Value template class which masks and shifts the value as required. In our example the value has a width of 3 bits and needs to be shifted 1 bit: typedef Value < Control_t , 3 , 1 > Delay_t ; This can be used the same way as the Configuration: Control_t control = Control :: EN | Prescaler_t ( Prescaler :: Div2 ) | Delay_t ( 4 ); Control_t control &= ~ Delay_t :: mask (); Delay_t :: set ( control , 7 ); Delay_t :: reset ( control ); uint8_t delay = Delay_t :: get ( control ); See Typesafe Register Access in C++ for a more detailed background on this implementation.","title":"Register Values"},{"location":"reference/module/modm-architecture-register/#dependencies","text":"modm:architecture:register modm_architecture_register modm: architecture: register modm_math_utils modm: math: utils modm_architecture_register->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-spi-device/","text":"SPI Devices \u00b6 lbuild module: modm:architecture:spi.device Dependencies \u00b6 modm:architecture:spi.device modm_architecture_spi_device modm: architecture: spi.device modm_architecture_spi modm: architecture: spi modm_architecture_spi_device->modm_architecture_spi @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:spi.device"},{"location":"reference/module/modm-architecture-spi-device/#spi-devices","text":"lbuild module: modm:architecture:spi.device","title":"SPI Devices"},{"location":"reference/module/modm-architecture-spi-device/#dependencies","text":"modm:architecture:spi.device modm_architecture_spi_device modm: architecture: spi.device modm_architecture_spi modm: architecture: spi modm_architecture_spi_device->modm_architecture_spi @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-spi/","text":"Serial Peripheral Interface (SPI) \u00b6 lbuild module: modm:architecture:spi Dependencies \u00b6 modm:architecture:spi modm_architecture_spi modm: architecture: spi modm_processing_resumable modm: processing: resumable modm_architecture_spi->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture:spi"},{"location":"reference/module/modm-architecture-spi/#serial-peripheral-interface-spi","text":"lbuild module: modm:architecture:spi","title":"Serial Peripheral Interface (SPI)"},{"location":"reference/module/modm-architecture-spi/#dependencies","text":"modm:architecture:spi modm_architecture_spi modm: architecture: spi modm_processing_resumable modm: processing: resumable modm_architecture_spi->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-architecture-uart/","text":"Universal Asynchronous Receiver/Transmitter (UART) \u00b6 lbuild module: modm:architecture:uart","title":":architecture:uart"},{"location":"reference/module/modm-architecture-uart/#universal-asynchronous-receivertransmitter-uart","text":"lbuild module: modm:architecture:uart","title":"Universal Asynchronous Receiver/Transmitter (UART)"},{"location":"reference/module/modm-architecture-unaligned/","text":"Unaligned Memory Accessor \u00b6 lbuild module: modm:architecture:unaligned","title":":architecture:unaligned"},{"location":"reference/module/modm-architecture-unaligned/#unaligned-memory-accessor","text":"lbuild module: modm:architecture:unaligned","title":"Unaligned Memory Accessor"},{"location":"reference/module/modm-architecture/","text":"Architecture Interfaces \u00b6 lbuild module: modm:architecture All hardware peripherals with common interfaces. Dependencies \u00b6 modm:architecture modm_architecture modm: architecture modm_math_units modm: math: units modm_architecture->modm_math_units @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":architecture"},{"location":"reference/module/modm-architecture/#architecture-interfaces","text":"lbuild module: modm:architecture All hardware peripherals with common interfaces.","title":"Architecture Interfaces"},{"location":"reference/module/modm-architecture/#dependencies","text":"modm:architecture modm_architecture modm: architecture modm_math_units modm: math: units modm_architecture->modm_math_units @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-board-al-avreb-can/","text":"AL-AVREB_CAN Board \u00b6 lbuild module: modm:board:al-avreb-can AVR breakout board with AT90CAN128: https://www.alvidi.de/products/DE/AVR_Entwicklungsboards/avr_modul_avreb_can.php This module is only available for avr90. Dependencies \u00b6 modm:board:al-avreb-can modm_board_al_avreb_can modm: board: al-avreb-can modm_architecture_clock modm: architecture: clock modm_board_al_avreb_can->modm_architecture_clock modm_io modm: io modm_board_al_avreb_can->modm_io modm_platform_clock modm: platform: clock modm_board_al_avreb_can->modm_platform_clock modm_platform_core modm: platform: core modm_board_al_avreb_can->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_al_avreb_can->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_al_avreb_can->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:al-avreb-can"},{"location":"reference/module/modm-board-al-avreb-can/#al-avreb_can-board","text":"lbuild module: modm:board:al-avreb-can AVR breakout board with AT90CAN128: https://www.alvidi.de/products/DE/AVR_Entwicklungsboards/avr_modul_avreb_can.php This module is only available for avr90.","title":"AL-AVREB_CAN Board"},{"location":"reference/module/modm-board-al-avreb-can/#dependencies","text":"modm:board:al-avreb-can modm_board_al_avreb_can modm: board: al-avreb-can modm_architecture_clock modm: architecture: clock modm_board_al_avreb_can->modm_architecture_clock modm_io modm: io modm_board_al_avreb_can->modm_io modm_platform_clock modm: platform: clock modm_board_al_avreb_can->modm_platform_clock modm_platform_core modm: platform: core modm_board_al_avreb_can->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_al_avreb_can->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_al_avreb_can->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-arduino-nano/","text":"Arduino NANO \u00b6 lbuild module: modm:board:arduino-nano This module is only available for avrmega. Dependencies \u00b6 modm:board:arduino-nano modm_board_arduino_nano modm: board: arduino-nano modm_architecture_clock modm: architecture: clock modm_board_arduino_nano->modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_arduino_nano->modm_architecture_interrupt modm_debug modm: debug modm_board_arduino_nano->modm_debug modm_platform_clock modm: platform: clock modm_board_arduino_nano->modm_platform_clock modm_platform_core modm: platform: core modm_board_arduino_nano->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_arduino_nano->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_arduino_nano->modm_platform_uart_0 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:arduino-nano"},{"location":"reference/module/modm-board-arduino-nano/#arduino-nano","text":"lbuild module: modm:board:arduino-nano This module is only available for avrmega.","title":"Arduino NANO"},{"location":"reference/module/modm-board-arduino-nano/#dependencies","text":"modm:board:arduino-nano modm_board_arduino_nano modm: board: arduino-nano modm_architecture_clock modm: architecture: clock modm_board_arduino_nano->modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_arduino_nano->modm_architecture_interrupt modm_debug modm: debug modm_board_arduino_nano->modm_debug modm_platform_clock modm: platform: clock modm_board_arduino_nano->modm_platform_clock modm_platform_core modm: platform: core modm_board_arduino_nano->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_arduino_nano->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_arduino_nano->modm_platform_uart_0 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-arduino-uno/","text":"Arduino UNO \u00b6 lbuild module: modm:board:arduino-uno This module is only available for avrmega. Dependencies \u00b6 modm:board:arduino-uno modm_board_arduino_uno modm: board: arduino-uno modm_architecture_clock modm: architecture: clock modm_board_arduino_uno->modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_arduino_uno->modm_architecture_interrupt modm_debug modm: debug modm_board_arduino_uno->modm_debug modm_platform_clock modm: platform: clock modm_board_arduino_uno->modm_platform_clock modm_platform_core modm: platform: core modm_board_arduino_uno->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_arduino_uno->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_arduino_uno->modm_platform_uart_0 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:arduino-uno"},{"location":"reference/module/modm-board-arduino-uno/#arduino-uno","text":"lbuild module: modm:board:arduino-uno This module is only available for avrmega.","title":"Arduino UNO"},{"location":"reference/module/modm-board-arduino-uno/#dependencies","text":"modm:board:arduino-uno modm_board_arduino_uno modm: board: arduino-uno modm_architecture_clock modm: architecture: clock modm_board_arduino_uno->modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_arduino_uno->modm_architecture_interrupt modm_debug modm: debug modm_board_arduino_uno->modm_debug modm_platform_clock modm: platform: clock modm_board_arduino_uno->modm_platform_clock modm_platform_core modm: platform: core modm_board_arduino_uno->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_arduino_uno->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_arduino_uno->modm_platform_uart_0 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-black-pill-f103/","text":"Black Pill \u00b6 lbuild module: modm:board:black-pill-f103 STM32F103C8T6 \"Black Pill\" Minimum System Development Board Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on well known Internet shops from China. https://stm32-base.org/boards/STM32F103C8T6-Black-Pill.html Programming \u00b6 Since the board doesn't have a programmer on-board, you need to use your own and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] # If you use the clone CKS32F103C8T6 chip you need to overwrite this ID #set CPUTAPID 0x2ba01477 # To select a specific programmer you can specify its serial number #hla_serial \"\\x53\\x3f\\x6f\\x06\\x50\\x77\\x50\\x57\\x12\\x17\\x14\\x3f\" # You can discover the serial via `stlink --hla-serial` or `st-info --hla-serial`. Then include this file in your build options like so: <library> <extends> modm:black-pill </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f103c8t6. Dependencies \u00b6 modm:board:black-pill-f103 modm_board_black_pill_f103 modm: board: black-pill-f103 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f103->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f103->modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f103->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f103->modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_black_pill_f103->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:black-pill-f103"},{"location":"reference/module/modm-board-black-pill-f103/#black-pill","text":"lbuild module: modm:board:black-pill-f103 STM32F103C8T6 \"Black Pill\" Minimum System Development Board Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on well known Internet shops from China. https://stm32-base.org/boards/STM32F103C8T6-Black-Pill.html","title":"Black Pill"},{"location":"reference/module/modm-board-black-pill-f103/#programming","text":"Since the board doesn't have a programmer on-board, you need to use your own and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] # If you use the clone CKS32F103C8T6 chip you need to overwrite this ID #set CPUTAPID 0x2ba01477 # To select a specific programmer you can specify its serial number #hla_serial \"\\x53\\x3f\\x6f\\x06\\x50\\x77\\x50\\x57\\x12\\x17\\x14\\x3f\" # You can discover the serial via `stlink --hla-serial` or `st-info --hla-serial`. Then include this file in your build options like so: <library> <extends> modm:black-pill </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f103c8t6.","title":"Programming"},{"location":"reference/module/modm-board-black-pill-f103/#dependencies","text":"modm:board:black-pill-f103 modm_board_black_pill_f103 modm: board: black-pill-f103 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f103->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f103->modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f103->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f103->modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_black_pill_f103->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-black-pill-f401/","text":"Black Pill F401 \u00b6 lbuild module: modm:board:black-pill-f401 STM32F401CCU \"Mini-F401\" Minimum System Development Board Cheap and bread-board-friendly board for STM32F401 series. Sold for less than 4 USD on well known Internet shops from China. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401. https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0 Programming \u00b6 Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the modm:build:scons tool and can be called as follows: scons program-dfu Alternatively you can go for an external programmer and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] Then include this file in your build options like so: <library> <extends> modm:black-pill-f401 </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f401ccu6. Dependencies \u00b6 modm:board:black-pill-f401 modm_board_black_pill_f401 modm: board: black-pill-f401 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f401->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f401->modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f401->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f401->modm_platform_gpio modm_platform_usb_fs modm: platform: usb: fs modm_board_black_pill_f401->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:black-pill-f401"},{"location":"reference/module/modm-board-black-pill-f401/#black-pill-f401","text":"lbuild module: modm:board:black-pill-f401 STM32F401CCU \"Mini-F401\" Minimum System Development Board Cheap and bread-board-friendly board for STM32F401 series. Sold for less than 4 USD on well known Internet shops from China. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401. https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0","title":"Black Pill F401"},{"location":"reference/module/modm-board-black-pill-f401/#programming","text":"Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the modm:build:scons tool and can be called as follows: scons program-dfu Alternatively you can go for an external programmer and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] Then include this file in your build options like so: <library> <extends> modm:black-pill-f401 </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f401ccu6.","title":"Programming"},{"location":"reference/module/modm-board-black-pill-f401/#dependencies","text":"modm:board:black-pill-f401 modm_board_black_pill_f401 modm: board: black-pill-f401 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f401->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f401->modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f401->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f401->modm_platform_gpio modm_platform_usb_fs modm: platform: usb: fs modm_board_black_pill_f401->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-black-pill-f411/","text":"Black Pill F411 \u00b6 lbuild module: modm:board:black-pill-f411 STM32F411CEU \"Mini-F411\" Minimum System Development Board Cheap and bread-board-friendly board for STM32F411 series. Sold for less than 5 USD on well known Internet shops from China. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401. https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0 Programming \u00b6 Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the modm:build:scons tool and can be called as follows: scons program-dfu Alternatively you can go for an external programmer and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] Then include this file in your build options like so: <library> <extends> modm:black-pill-f411 </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f411ceu6. Dependencies \u00b6 modm:board:black-pill-f411 modm_board_black_pill_f411 modm: board: black-pill-f411 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f411->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f411->modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f411->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f411->modm_platform_gpio modm_platform_usb_fs modm: platform: usb: fs modm_board_black_pill_f411->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:black-pill-f411"},{"location":"reference/module/modm-board-black-pill-f411/#black-pill-f411","text":"lbuild module: modm:board:black-pill-f411 STM32F411CEU \"Mini-F411\" Minimum System Development Board Cheap and bread-board-friendly board for STM32F411 series. Sold for less than 5 USD on well known Internet shops from China. Attention: There are two variants: Mini-F411 and the cheaper Mini-F401. https://stm32-base.org/boards/STM32F401CEU6-WeAct-Black-Pill-V3.0","title":"Black Pill F411"},{"location":"reference/module/modm-board-black-pill-f411/#programming","text":"Since the board has no St-Link programmer on the board, you must use DFU (Device Firmware Update (via USB)) to program the board. A DFU command is integrated into the modm:build:scons tool and can be called as follows: scons program-dfu Alternatively you can go for an external programmer and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] Then include this file in your build options like so: <library> <extends> modm:black-pill-f411 </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f411ceu6.","title":"Programming"},{"location":"reference/module/modm-board-black-pill-f411/#dependencies","text":"modm:board:black-pill-f411 modm_board_black_pill_f411 modm: board: black-pill-f411 modm_architecture_clock modm: architecture: clock modm_board_black_pill_f411->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_black_pill_f411->modm_platform_clock modm_platform_core modm: platform: core modm_board_black_pill_f411->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_black_pill_f411->modm_platform_gpio modm_platform_usb_fs modm: platform: usb: fs modm_board_black_pill_f411->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-blue-pill-f103/","text":"Blue Pill \u00b6 lbuild module: modm:board:blue-pill-f103 STM32F103C8T6 \"Blue Pill\" Minimum System Development Board Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on well known Internet shops from China. https://stm32-base.org/boards/STM32F103C8T6-Blue-Pill.html Programming \u00b6 Since the board doesn't have a programmer on-board, you need to use your own and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] # If you use the clone CKS32F103C8T6 chip you need to overwrite this ID #set CPUTAPID 0x2ba01477 # To select a specific programmer you can specify its serial number #hla_serial \"\\x53\\x3f\\x6f\\x06\\x50\\x77\\x50\\x57\\x12\\x17\\x13\\x3f\" # You can discover the serial via `stlink --hla-serial` or `st-info --hla-serial`. Then include this file in your build options like so: <library> <extends> modm:blue-pill </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f103c8t6. Dependencies \u00b6 modm:board:blue-pill-f103 modm_board_blue_pill_f103 modm: board: blue-pill-f103 modm_architecture_clock modm: architecture: clock modm_board_blue_pill_f103->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_blue_pill_f103->modm_platform_clock modm_platform_core modm: platform: core modm_board_blue_pill_f103->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_blue_pill_f103->modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_blue_pill_f103->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:blue-pill-f103"},{"location":"reference/module/modm-board-blue-pill-f103/#blue-pill","text":"lbuild module: modm:board:blue-pill-f103 STM32F103C8T6 \"Blue Pill\" Minimum System Development Board Cheap and bread-board-friendly board for STM32 F1 series. Sold for less than 2 USD on well known Internet shops from China. https://stm32-base.org/boards/STM32F103C8T6-Blue-Pill.html","title":"Blue Pill"},{"location":"reference/module/modm-board-blue-pill-f103/#programming","text":"Since the board doesn't have a programmer on-board, you need to use your own and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] # If you use the clone CKS32F103C8T6 chip you need to overwrite this ID #set CPUTAPID 0x2ba01477 # To select a specific programmer you can specify its serial number #hla_serial \"\\x53\\x3f\\x6f\\x06\\x50\\x77\\x50\\x57\\x12\\x17\\x13\\x3f\" # You can discover the serial via `stlink --hla-serial` or `st-info --hla-serial`. Then include this file in your build options like so: <library> <extends> modm:blue-pill </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f103c8t6.","title":"Programming"},{"location":"reference/module/modm-board-blue-pill-f103/#dependencies","text":"modm:board:blue-pill-f103 modm_board_blue_pill_f103 modm: board: blue-pill-f103 modm_architecture_clock modm: architecture: clock modm_board_blue_pill_f103->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_blue_pill_f103->modm_platform_clock modm_platform_core modm: platform: core modm_board_blue_pill_f103->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_blue_pill_f103->modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_blue_pill_f103->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-devebox-stm32f4xx/","text":"STM32F4XX mcudev DevEBox \u00b6 lbuild module: modm:board:devebox-stm32f4xx This module is only available for stm32f4. Dependencies \u00b6 modm:board:devebox-stm32f4xx modm_board_devebox_stm32f4xx modm: board: devebox-stm32f4xx modm_architecture_clock modm: architecture: clock modm_board_devebox_stm32f4xx->modm_architecture_clock modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_board_devebox_stm32f4xx->modm_driver_block_device_spi_flash modm_platform_clock modm: platform: clock modm_board_devebox_stm32f4xx->modm_platform_clock modm_platform_core modm: platform: core modm_board_devebox_stm32f4xx->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_devebox_stm32f4xx->modm_platform_gpio modm_platform_spi_1 modm: platform: spi: 1 modm_board_devebox_stm32f4xx->modm_platform_spi_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:devebox-stm32f4xx"},{"location":"reference/module/modm-board-devebox-stm32f4xx/#stm32f4xx-mcudev-devebox","text":"lbuild module: modm:board:devebox-stm32f4xx This module is only available for stm32f4.","title":"STM32F4XX mcudev DevEBox"},{"location":"reference/module/modm-board-devebox-stm32f4xx/#dependencies","text":"modm:board:devebox-stm32f4xx modm_board_devebox_stm32f4xx modm: board: devebox-stm32f4xx modm_architecture_clock modm: architecture: clock modm_board_devebox_stm32f4xx->modm_architecture_clock modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_board_devebox_stm32f4xx->modm_driver_block_device_spi_flash modm_platform_clock modm: platform: clock modm_board_devebox_stm32f4xx->modm_platform_clock modm_platform_core modm: platform: core modm_board_devebox_stm32f4xx->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_devebox_stm32f4xx->modm_platform_gpio modm_platform_spi_1 modm: platform: spi: 1 modm_board_devebox_stm32f4xx->modm_platform_spi_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f051r8/","text":"STM32F0DISCOVERY \u00b6 lbuild module: modm:board:disco-f051r8 Discovery kit for STM32F051 This module is only available for stm32f051r8t6. Dependencies \u00b6 modm:board:disco-f051r8 modm_board_disco_f051r8 modm: board: disco-f051r8 modm_architecture_clock modm: architecture: clock modm_board_disco_f051r8->modm_architecture_clock modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f051r8->modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f051r8->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f051r8->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f051r8->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f051r8"},{"location":"reference/module/modm-board-disco-f051r8/#stm32f0discovery","text":"lbuild module: modm:board:disco-f051r8 Discovery kit for STM32F051 This module is only available for stm32f051r8t6.","title":"STM32F0DISCOVERY"},{"location":"reference/module/modm-board-disco-f051r8/#dependencies","text":"modm:board:disco-f051r8 modm_board_disco_f051r8 modm: board: disco-f051r8 modm_architecture_clock modm: architecture: clock modm_board_disco_f051r8->modm_architecture_clock modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f051r8->modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f051r8->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f051r8->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f051r8->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f072rb/","text":"STM32F072DISCOVERY \u00b6 lbuild module: modm:board:disco-f072rb Discovery kit for STM32F072 This module is only available for stm32f072rbt6. Dependencies \u00b6 modm:board:disco-f072rb modm_board_disco_f072rb modm: board: disco-f072rb modm_architecture_clock modm: architecture: clock modm_board_disco_f072rb->modm_architecture_clock modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f072rb->modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f072rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f072rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f072rb->modm_platform_gpio modm_platform_spi_2 modm: platform: spi: 2 modm_board_disco_f072rb->modm_platform_spi_2 modm_platform_usb modm: platform: usb modm_board_disco_f072rb->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f072rb"},{"location":"reference/module/modm-board-disco-f072rb/#stm32f072discovery","text":"lbuild module: modm:board:disco-f072rb Discovery kit for STM32F072 This module is only available for stm32f072rbt6.","title":"STM32F072DISCOVERY"},{"location":"reference/module/modm-board-disco-f072rb/#dependencies","text":"modm:board:disco-f072rb modm_board_disco_f072rb modm: board: disco-f072rb modm_architecture_clock modm: architecture: clock modm_board_disco_f072rb->modm_architecture_clock modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f072rb->modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f072rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f072rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f072rb->modm_platform_gpio modm_platform_spi_2 modm: platform: spi: 2 modm_board_disco_f072rb->modm_platform_spi_2 modm_platform_usb modm: platform: usb modm_board_disco_f072rb->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f100rb/","text":"STM32VLDISCOVERY \u00b6 lbuild module: modm:board:disco-f100rb Discovery kit for STM32F100 This module is only available for stm32f100rbt6. Dependencies \u00b6 modm:board:disco-f100rb modm_board_disco_f100rb modm: board: disco-f100rb modm_architecture_clock modm: architecture: clock modm_board_disco_f100rb->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_disco_f100rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f100rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f100rb->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f100rb"},{"location":"reference/module/modm-board-disco-f100rb/#stm32vldiscovery","text":"lbuild module: modm:board:disco-f100rb Discovery kit for STM32F100 This module is only available for stm32f100rbt6.","title":"STM32VLDISCOVERY"},{"location":"reference/module/modm-board-disco-f100rb/#dependencies","text":"modm:board:disco-f100rb modm_board_disco_f100rb modm: board: disco-f100rb modm_architecture_clock modm: architecture: clock modm_board_disco_f100rb->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_disco_f100rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f100rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f100rb->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f303vc/","text":"STM32F3DISCOVERY \u00b6 lbuild module: modm:board:disco-f303vc [Discovery kit for STM32F303]( https://www.st.com/en/evaluation-tools/stm32f3discovery.html ] This module is only available for stm32f303vct6. Dependencies \u00b6 modm:board:disco-f303vc modm_board_disco_f303vc modm: board: disco-f303vc modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f303vc->modm_driver_l3gd20 modm_driver_lsm303a modm: driver: lsm303a modm_board_disco_f303vc->modm_driver_lsm303a modm_platform_clock modm: platform: clock modm_board_disco_f303vc->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f303vc->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f303vc->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f303vc->modm_platform_i2c_1 modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f303vc->modm_platform_spi_1 modm_platform_usb modm: platform: usb modm_board_disco_f303vc->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f303vc"},{"location":"reference/module/modm-board-disco-f303vc/#stm32f3discovery","text":"lbuild module: modm:board:disco-f303vc [Discovery kit for STM32F303]( https://www.st.com/en/evaluation-tools/stm32f3discovery.html ] This module is only available for stm32f303vct6.","title":"STM32F3DISCOVERY"},{"location":"reference/module/modm-board-disco-f303vc/#dependencies","text":"modm:board:disco-f303vc modm_board_disco_f303vc modm: board: disco-f303vc modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f303vc->modm_driver_l3gd20 modm_driver_lsm303a modm: driver: lsm303a modm_board_disco_f303vc->modm_driver_lsm303a modm_platform_clock modm: platform: clock modm_board_disco_f303vc->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f303vc->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f303vc->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f303vc->modm_platform_i2c_1 modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f303vc->modm_platform_spi_1 modm_platform_usb modm: platform: usb modm_board_disco_f303vc->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f407vg/","text":"STM32F4DISCOVERY \u00b6 lbuild module: modm:board:disco-f407vg Discovery kit for STM32F407 This module is only available for stm32f407vgt6. Dependencies \u00b6 modm:board:disco-f407vg modm_board_disco_f407vg modm: board: disco-f407vg modm_architecture_clock modm: architecture: clock modm_board_disco_f407vg->modm_architecture_clock modm_driver_lis3dsh modm: driver: lis3dsh modm_board_disco_f407vg->modm_driver_lis3dsh modm_platform_clock modm: platform: clock modm_board_disco_f407vg->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f407vg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f407vg->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f407vg->modm_platform_i2c_1 modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f407vg->modm_platform_spi_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f407vg->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f407vg"},{"location":"reference/module/modm-board-disco-f407vg/#stm32f4discovery","text":"lbuild module: modm:board:disco-f407vg Discovery kit for STM32F407 This module is only available for stm32f407vgt6.","title":"STM32F4DISCOVERY"},{"location":"reference/module/modm-board-disco-f407vg/#dependencies","text":"modm:board:disco-f407vg modm_board_disco_f407vg modm: board: disco-f407vg modm_architecture_clock modm: architecture: clock modm_board_disco_f407vg->modm_architecture_clock modm_driver_lis3dsh modm: driver: lis3dsh modm_board_disco_f407vg->modm_driver_lis3dsh modm_platform_clock modm: platform: clock modm_board_disco_f407vg->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f407vg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f407vg->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f407vg->modm_platform_i2c_1 modm_platform_spi_1 modm: platform: spi: 1 modm_board_disco_f407vg->modm_platform_spi_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f407vg->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f429zi/","text":"STM32F429IDISCOVERY \u00b6 lbuild module: modm:board:disco-f429zi Discovery kit for STM32F429 This module is only available for stm32f429zit6. Dependencies \u00b6 modm:board:disco-f429zi modm_board_disco_f429zi modm: board: disco-f429zi modm_architecture_clock modm: architecture: clock modm_board_disco_f429zi->modm_architecture_clock modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f429zi->modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f429zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f429zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f429zi->modm_platform_gpio modm_platform_spi_5 modm: platform: spi: 5 modm_board_disco_f429zi->modm_platform_spi_5 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f429zi"},{"location":"reference/module/modm-board-disco-f429zi/#stm32f429idiscovery","text":"lbuild module: modm:board:disco-f429zi Discovery kit for STM32F429 This module is only available for stm32f429zit6.","title":"STM32F429IDISCOVERY"},{"location":"reference/module/modm-board-disco-f429zi/#dependencies","text":"modm:board:disco-f429zi modm_board_disco_f429zi modm: board: disco-f429zi modm_architecture_clock modm: architecture: clock modm_board_disco_f429zi->modm_architecture_clock modm_driver_l3gd20 modm: driver: l3gd20 modm_board_disco_f429zi->modm_driver_l3gd20 modm_platform_clock modm: platform: clock modm_board_disco_f429zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f429zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f429zi->modm_platform_gpio modm_platform_spi_5 modm: platform: spi: 5 modm_board_disco_f429zi->modm_platform_spi_5 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f469ni/","text":"STM32F469IDISCOVERY \u00b6 lbuild module: modm:board:disco-f469ni Discovery kit with STM32F469NI MCU. This BSPs Board::initialize() sets the board up with these settings: 180MHz CPU clock frequency in overdrive mode. 90MHz APB2 and 45MHz APB1 clock frequency. MODM_LOGGER initialized at 115.2kBaud outputting on STLink. 16MB SDRAM initialized for heap. Disables the display by default. You can enable and use the on-board display in two ways: Use the modm::GraphicDisplay returned by Board::getDisplay() , which initializes the display on first call and allocates the framebuffer in the external SDRAM. This is the simplest option. Call Board::initializeDisplay() and then provide your own display buffer with Board::setDisplayBuffer(void*) . Caveats No double-buffering is implemented, so you may notice some tearing if you update the display fast enough. Access to the capacitive touchscreen is provided in the Board::ft6 namespace. Call Board::initializeTouchscreen() to setup the peripherals. Product Link This module is only available for stm32f469nih6. Dependencies \u00b6 modm:board:disco-f469ni modm_board_disco_f469ni modm: board: disco-f469ni modm_architecture_clock modm: architecture: clock modm_board_disco_f469ni->modm_architecture_clock modm_architecture_memory modm: architecture: memory modm_board_disco_f469ni->modm_architecture_memory modm_debug modm: debug modm_board_disco_f469ni->modm_debug modm_driver_ft6x06 modm: driver: ft6x06 modm_board_disco_f469ni->modm_driver_ft6x06 modm_math_utils modm: math: utils modm_board_disco_f469ni->modm_math_utils modm_platform_clock modm: platform: clock modm_board_disco_f469ni->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f469ni->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f469ni->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f469ni->modm_platform_i2c_1 modm_platform_rcc modm: platform: rcc modm_board_disco_f469ni->modm_platform_rcc modm_platform_uart_3 modm: platform: uart: 3 modm_board_disco_f469ni->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f469ni->modm_platform_usb_fs modm_ui_display modm: ui: display modm_board_disco_f469ni->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f469ni"},{"location":"reference/module/modm-board-disco-f469ni/#stm32f469idiscovery","text":"lbuild module: modm:board:disco-f469ni Discovery kit with STM32F469NI MCU. This BSPs Board::initialize() sets the board up with these settings: 180MHz CPU clock frequency in overdrive mode. 90MHz APB2 and 45MHz APB1 clock frequency. MODM_LOGGER initialized at 115.2kBaud outputting on STLink. 16MB SDRAM initialized for heap. Disables the display by default. You can enable and use the on-board display in two ways: Use the modm::GraphicDisplay returned by Board::getDisplay() , which initializes the display on first call and allocates the framebuffer in the external SDRAM. This is the simplest option. Call Board::initializeDisplay() and then provide your own display buffer with Board::setDisplayBuffer(void*) . Caveats No double-buffering is implemented, so you may notice some tearing if you update the display fast enough. Access to the capacitive touchscreen is provided in the Board::ft6 namespace. Call Board::initializeTouchscreen() to setup the peripherals. Product Link This module is only available for stm32f469nih6.","title":"STM32F469IDISCOVERY"},{"location":"reference/module/modm-board-disco-f469ni/#dependencies","text":"modm:board:disco-f469ni modm_board_disco_f469ni modm: board: disco-f469ni modm_architecture_clock modm: architecture: clock modm_board_disco_f469ni->modm_architecture_clock modm_architecture_memory modm: architecture: memory modm_board_disco_f469ni->modm_architecture_memory modm_debug modm: debug modm_board_disco_f469ni->modm_debug modm_driver_ft6x06 modm: driver: ft6x06 modm_board_disco_f469ni->modm_driver_ft6x06 modm_math_utils modm: math: utils modm_board_disco_f469ni->modm_math_utils modm_platform_clock modm: platform: clock modm_board_disco_f469ni->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f469ni->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f469ni->modm_platform_gpio modm_platform_i2c_1 modm: platform: i2c: 1 modm_board_disco_f469ni->modm_platform_i2c_1 modm_platform_rcc modm: platform: rcc modm_board_disco_f469ni->modm_platform_rcc modm_platform_uart_3 modm: platform: uart: 3 modm_board_disco_f469ni->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f469ni->modm_platform_usb_fs modm_ui_display modm: ui: display modm_board_disco_f469ni->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f746ng/","text":"STM32F7DISCOVERY \u00b6 lbuild module: modm:board:disco-f746ng Discovery kit for STM32F746 This module is only available for stm32f746ngh6. Dependencies \u00b6 modm:board:disco-f746ng modm_board_disco_f746ng modm: board: disco-f746ng modm_architecture_clock modm: architecture: clock modm_board_disco_f746ng->modm_architecture_clock modm_debug modm: debug modm_board_disco_f746ng->modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f746ng->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f746ng->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f746ng->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_disco_f746ng->modm_platform_uart_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f746ng->modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_board_disco_f746ng->modm_platform_usb_hs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f746ng"},{"location":"reference/module/modm-board-disco-f746ng/#stm32f7discovery","text":"lbuild module: modm:board:disco-f746ng Discovery kit for STM32F746 This module is only available for stm32f746ngh6.","title":"STM32F7DISCOVERY"},{"location":"reference/module/modm-board-disco-f746ng/#dependencies","text":"modm:board:disco-f746ng modm_board_disco_f746ng modm: board: disco-f746ng modm_architecture_clock modm: architecture: clock modm_board_disco_f746ng->modm_architecture_clock modm_debug modm: debug modm_board_disco_f746ng->modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f746ng->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f746ng->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f746ng->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_disco_f746ng->modm_platform_uart_1 modm_platform_usb_fs modm: platform: usb: fs modm_board_disco_f746ng->modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_board_disco_f746ng->modm_platform_usb_hs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-f769ni/","text":"STM32F769IDISCOVERY \u00b6 lbuild module: modm:board:disco-f769ni Discovery kit for STM32F769 line This module is only available for stm32f769nih6. Dependencies \u00b6 modm:board:disco-f769ni modm_board_disco_f769ni modm: board: disco-f769ni modm_architecture_clock modm: architecture: clock modm_board_disco_f769ni->modm_architecture_clock modm_debug modm: debug modm_board_disco_f769ni->modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f769ni->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f769ni->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f769ni->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_disco_f769ni->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-f769ni"},{"location":"reference/module/modm-board-disco-f769ni/#stm32f769idiscovery","text":"lbuild module: modm:board:disco-f769ni Discovery kit for STM32F769 line This module is only available for stm32f769nih6.","title":"STM32F769IDISCOVERY"},{"location":"reference/module/modm-board-disco-f769ni/#dependencies","text":"modm:board:disco-f769ni modm_board_disco_f769ni modm: board: disco-f769ni modm_architecture_clock modm: architecture: clock modm_board_disco_f769ni->modm_architecture_clock modm_debug modm: debug modm_board_disco_f769ni->modm_debug modm_platform_clock modm: platform: clock modm_board_disco_f769ni->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_f769ni->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_f769ni->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_disco_f769ni->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-l152rc/","text":"DISCO-L152RC \u00b6 lbuild module: modm:board:disco-l152rc Discovery kit for STM32L152RC This module is only available for stm32l152rct6. Dependencies \u00b6 modm:board:disco-l152rc modm_board_disco_l152rc modm: board: disco-l152rc modm_architecture_clock modm: architecture: clock modm_board_disco_l152rc->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_disco_l152rc->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_l152rc->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_l152rc->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-l152rc"},{"location":"reference/module/modm-board-disco-l152rc/#disco-l152rc","text":"lbuild module: modm:board:disco-l152rc Discovery kit for STM32L152RC This module is only available for stm32l152rct6.","title":"DISCO-L152RC"},{"location":"reference/module/modm-board-disco-l152rc/#dependencies","text":"modm:board:disco-l152rc modm_board_disco_l152rc modm: board: disco-l152rc modm_architecture_clock modm: architecture: clock modm_board_disco_l152rc->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_disco_l152rc->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_l152rc->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_l152rc->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-disco-l476vg/","text":"STM32L476DISCOVERY \u00b6 lbuild module: modm:board:disco-l476vg Discovery kit for STM32L476 This module is only available for stm32l476vgt6. Dependencies \u00b6 modm:board:disco-l476vg modm_board_disco_l476vg modm: board: disco-l476vg modm_architecture_clock modm: architecture: clock modm_board_disco_l476vg->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_disco_l476vg->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_l476vg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_l476vg->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:disco-l476vg"},{"location":"reference/module/modm-board-disco-l476vg/#stm32l476discovery","text":"lbuild module: modm:board:disco-l476vg Discovery kit for STM32L476 This module is only available for stm32l476vgt6.","title":"STM32L476DISCOVERY"},{"location":"reference/module/modm-board-disco-l476vg/#dependencies","text":"modm:board:disco-l476vg modm_board_disco_l476vg modm: board: disco-l476vg modm_architecture_clock modm: architecture: clock modm_board_disco_l476vg->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_disco_l476vg->modm_platform_clock modm_platform_core modm: platform: core modm_board_disco_l476vg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_disco_l476vg->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-feather-m0/","text":"Adafruit Feather-M0 \u00b6 lbuild module: modm:board:feather-m0 At the Feather M0's heart is an ATSAMD21G18 ARM Cortex M0 processor, clocked at 48 MHz and at 3.3V logic, the same one used in the new Arduino Zero. This chip has a whopping 256K of FLASH (8x more than the Atmega328 or 32u4) and 32K of RAM (16x as much)! This chip comes with built in USB so it has USB-to-Serial program & debug capability built in with no need for an FTDI-like chip. https://www.adafruit.com/product/2772 This module is only available for sam. Dependencies \u00b6 modm:board:feather-m0 modm_board_feather_m0 modm: board: feather-m0 modm_debug modm: debug modm_board_feather_m0->modm_debug modm_platform_clock modm: platform: clock modm_board_feather_m0->modm_platform_clock modm_platform_core modm: platform: core modm_board_feather_m0->modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_feather_m0->modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_feather_m0->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_feather_m0->modm_platform_uart_0 modm_platform_usb modm: platform: usb modm_board_feather_m0->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:feather-m0"},{"location":"reference/module/modm-board-feather-m0/#adafruit-feather-m0","text":"lbuild module: modm:board:feather-m0 At the Feather M0's heart is an ATSAMD21G18 ARM Cortex M0 processor, clocked at 48 MHz and at 3.3V logic, the same one used in the new Arduino Zero. This chip has a whopping 256K of FLASH (8x more than the Atmega328 or 32u4) and 32K of RAM (16x as much)! This chip comes with built in USB so it has USB-to-Serial program & debug capability built in with no need for an FTDI-like chip. https://www.adafruit.com/product/2772 This module is only available for sam.","title":"Adafruit Feather-M0"},{"location":"reference/module/modm-board-feather-m0/#dependencies","text":"modm:board:feather-m0 modm_board_feather_m0 modm: board: feather-m0 modm_debug modm: debug modm_board_feather_m0->modm_debug modm_platform_clock modm: platform: clock modm_board_feather_m0->modm_platform_clock modm_platform_core modm: platform: core modm_board_feather_m0->modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_feather_m0->modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_feather_m0->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_feather_m0->modm_platform_uart_0 modm_platform_usb modm: platform: usb modm_board_feather_m0->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-mega-2560-pro/","text":"Mega 2560 PRO (Embed) CH340G \u00b6 lbuild module: modm:board:mega-2560-pro A compact breakout board similiar to the Arduino Mega 2560 board. You can order this for little money from well known Chinese online stores. See: https://robotdyn.com/mega-2560-pro-embed-ch340g-atmega2560-16au.html This module is only available for avrmega. Dependencies \u00b6 modm:board:mega-2560-pro modm_board_mega_2560_pro modm: board: mega-2560-pro modm_architecture_clock modm: architecture: clock modm_board_mega_2560_pro->modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_mega_2560_pro->modm_architecture_interrupt modm_debug modm: debug modm_board_mega_2560_pro->modm_debug modm_platform_clock modm: platform: clock modm_board_mega_2560_pro->modm_platform_clock modm_platform_core modm: platform: core modm_board_mega_2560_pro->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_mega_2560_pro->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_mega_2560_pro->modm_platform_uart_0 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:mega-2560-pro"},{"location":"reference/module/modm-board-mega-2560-pro/#mega-2560-pro-embed-ch340g","text":"lbuild module: modm:board:mega-2560-pro A compact breakout board similiar to the Arduino Mega 2560 board. You can order this for little money from well known Chinese online stores. See: https://robotdyn.com/mega-2560-pro-embed-ch340g-atmega2560-16au.html This module is only available for avrmega.","title":"Mega 2560 PRO (Embed) CH340G"},{"location":"reference/module/modm-board-mega-2560-pro/#dependencies","text":"modm:board:mega-2560-pro modm_board_mega_2560_pro modm: board: mega-2560-pro modm_architecture_clock modm: architecture: clock modm_board_mega_2560_pro->modm_architecture_clock modm_architecture_interrupt modm: architecture: interrupt modm_board_mega_2560_pro->modm_architecture_interrupt modm_debug modm: debug modm_board_mega_2560_pro->modm_debug modm_platform_clock modm: platform: clock modm_board_mega_2560_pro->modm_platform_clock modm_platform_core modm: platform: core modm_board_mega_2560_pro->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_mega_2560_pro->modm_platform_gpio modm_platform_uart_0 modm: platform: uart: 0 modm_board_mega_2560_pro->modm_platform_uart_0 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f031k6/","text":"NUCLEO-F031K6 \u00b6 lbuild module: modm:board:nucleo-f031k6 Nucleo kit for STM32F031K6 This module is only available for stm32f031k6t6. Dependencies \u00b6 modm:board:nucleo-f031k6 modm_board_nucleo_f031k6 modm: board: nucleo-f031k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f031k6->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f031k6->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f031k6->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f031k6->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f031k6->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_nucleo_f031k6->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f031k6"},{"location":"reference/module/modm-board-nucleo-f031k6/#nucleo-f031k6","text":"lbuild module: modm:board:nucleo-f031k6 Nucleo kit for STM32F031K6 This module is only available for stm32f031k6t6.","title":"NUCLEO-F031K6"},{"location":"reference/module/modm-board-nucleo-f031k6/#dependencies","text":"modm:board:nucleo-f031k6 modm_board_nucleo_f031k6 modm: board: nucleo-f031k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f031k6->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f031k6->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f031k6->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f031k6->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f031k6->modm_platform_gpio modm_platform_uart_1 modm: platform: uart: 1 modm_board_nucleo_f031k6->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f042k6/","text":"NUCLEO-F042K6 \u00b6 lbuild module: modm:board:nucleo-f042k6 Nucleo kit for STM32F042K6 This module is only available for stm32f042k6t6. Dependencies \u00b6 modm:board:nucleo-f042k6 modm_board_nucleo_f042k6 modm: board: nucleo-f042k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f042k6->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f042k6->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f042k6->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f042k6->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f042k6->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f042k6->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f042k6"},{"location":"reference/module/modm-board-nucleo-f042k6/#nucleo-f042k6","text":"lbuild module: modm:board:nucleo-f042k6 Nucleo kit for STM32F042K6 This module is only available for stm32f042k6t6.","title":"NUCLEO-F042K6"},{"location":"reference/module/modm-board-nucleo-f042k6/#dependencies","text":"modm:board:nucleo-f042k6 modm_board_nucleo_f042k6 modm: board: nucleo-f042k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f042k6->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f042k6->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f042k6->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f042k6->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f042k6->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f042k6->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f103rb/","text":"NUCLEO-F103RB \u00b6 lbuild module: modm:board:nucleo-f103rb Nucleo kit for STM32F103RB This module is only available for stm32f103rbt6. Dependencies \u00b6 modm:board:nucleo-f103rb modm_board_nucleo_f103rb modm: board: nucleo-f103rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_f103rb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f103rb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f103rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f103rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f103rb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f103rb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f103rb"},{"location":"reference/module/modm-board-nucleo-f103rb/#nucleo-f103rb","text":"lbuild module: modm:board:nucleo-f103rb Nucleo kit for STM32F103RB This module is only available for stm32f103rbt6.","title":"NUCLEO-F103RB"},{"location":"reference/module/modm-board-nucleo-f103rb/#dependencies","text":"modm:board:nucleo-f103rb modm_board_nucleo_f103rb modm: board: nucleo-f103rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_f103rb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f103rb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f103rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f103rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f103rb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f103rb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f303k8/","text":"NUCLEO-F303K8 \u00b6 lbuild module: modm:board:nucleo-f303k8 Nucleo kit for STM32F303K8 This module is only available for stm32f303k8t6. Dependencies \u00b6 modm:board:nucleo-f303k8 modm_board_nucleo_f303k8 modm: board: nucleo-f303k8 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f303k8->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f303k8->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f303k8->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f303k8->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f303k8->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f303k8->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f303k8"},{"location":"reference/module/modm-board-nucleo-f303k8/#nucleo-f303k8","text":"lbuild module: modm:board:nucleo-f303k8 Nucleo kit for STM32F303K8 This module is only available for stm32f303k8t6.","title":"NUCLEO-F303K8"},{"location":"reference/module/modm-board-nucleo-f303k8/#dependencies","text":"modm:board:nucleo-f303k8 modm_board_nucleo_f303k8 modm: board: nucleo-f303k8 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f303k8->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f303k8->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f303k8->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f303k8->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f303k8->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f303k8->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f303re/","text":"NUCLEO-F303RE \u00b6 lbuild module: modm:board:nucleo-f303re Nucleo kit for STM32F303RE This module is only available for stm32f303ret6. Dependencies \u00b6 modm:board:nucleo-f303re modm_board_nucleo_f303re modm: board: nucleo-f303re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f303re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f303re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f303re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f303re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f303re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f303re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f303re"},{"location":"reference/module/modm-board-nucleo-f303re/#nucleo-f303re","text":"lbuild module: modm:board:nucleo-f303re Nucleo kit for STM32F303RE This module is only available for stm32f303ret6.","title":"NUCLEO-F303RE"},{"location":"reference/module/modm-board-nucleo-f303re/#dependencies","text":"modm:board:nucleo-f303re modm_board_nucleo_f303re modm: board: nucleo-f303re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f303re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f303re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f303re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f303re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f303re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f303re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f334r8/","text":"NUCLEO-F334R8 \u00b6 lbuild module: modm:board:nucleo-f334r8 Nucleo kit for STM32F334R8 This module is only available for stm32f334r8t6. Dependencies \u00b6 modm:board:nucleo-f334r8 modm_board_nucleo_f334r8 modm: board: nucleo-f334r8 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f334r8->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f334r8->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f334r8->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f334r8->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f334r8->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f334r8->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f334r8"},{"location":"reference/module/modm-board-nucleo-f334r8/#nucleo-f334r8","text":"lbuild module: modm:board:nucleo-f334r8 Nucleo kit for STM32F334R8 This module is only available for stm32f334r8t6.","title":"NUCLEO-F334R8"},{"location":"reference/module/modm-board-nucleo-f334r8/#dependencies","text":"modm:board:nucleo-f334r8 modm_board_nucleo_f334r8 modm: board: nucleo-f334r8 modm_architecture_clock modm: architecture: clock modm_board_nucleo_f334r8->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f334r8->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f334r8->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f334r8->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f334r8->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f334r8->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f401re/","text":"NUCLEO-F401RE \u00b6 lbuild module: modm:board:nucleo-f401re Nucleo kit for STM32F401RE This module is only available for stm32f401ret6. Dependencies \u00b6 modm:board:nucleo-f401re modm_board_nucleo_f401re modm: board: nucleo-f401re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f401re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f401re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f401re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f401re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f401re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f401re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f401re"},{"location":"reference/module/modm-board-nucleo-f401re/#nucleo-f401re","text":"lbuild module: modm:board:nucleo-f401re Nucleo kit for STM32F401RE This module is only available for stm32f401ret6.","title":"NUCLEO-F401RE"},{"location":"reference/module/modm-board-nucleo-f401re/#dependencies","text":"modm:board:nucleo-f401re modm_board_nucleo_f401re modm: board: nucleo-f401re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f401re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f401re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f401re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f401re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f401re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f401re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f411re/","text":"NUCLEO-F411RE \u00b6 lbuild module: modm:board:nucleo-f411re Nucleo kit for STM32F411RE This module is only available for stm32f411ret6. Dependencies \u00b6 modm:board:nucleo-f411re modm_board_nucleo_f411re modm: board: nucleo-f411re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f411re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f411re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f411re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f411re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f411re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f411re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f411re"},{"location":"reference/module/modm-board-nucleo-f411re/#nucleo-f411re","text":"lbuild module: modm:board:nucleo-f411re Nucleo kit for STM32F411RE This module is only available for stm32f411ret6.","title":"NUCLEO-F411RE"},{"location":"reference/module/modm-board-nucleo-f411re/#dependencies","text":"modm:board:nucleo-f411re modm_board_nucleo_f411re modm: board: nucleo-f411re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f411re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f411re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f411re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f411re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f411re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f411re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f429zi/","text":"NUCLEO-F429ZI \u00b6 lbuild module: modm:board:nucleo-f429zi Nucleo kit for STM32F429ZI This module is only available for stm32f429zit6. Dependencies \u00b6 modm:board:nucleo-f429zi modm_board_nucleo_f429zi modm: board: nucleo-f429zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f429zi->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f429zi->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f429zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f429zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f429zi->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f429zi->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f429zi->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f429zi"},{"location":"reference/module/modm-board-nucleo-f429zi/#nucleo-f429zi","text":"lbuild module: modm:board:nucleo-f429zi Nucleo kit for STM32F429ZI This module is only available for stm32f429zit6.","title":"NUCLEO-F429ZI"},{"location":"reference/module/modm-board-nucleo-f429zi/#dependencies","text":"modm:board:nucleo-f429zi modm_board_nucleo_f429zi modm: board: nucleo-f429zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f429zi->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f429zi->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f429zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f429zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f429zi->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f429zi->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f429zi->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f439zi/","text":"NUCLEO-F439ZI \u00b6 lbuild module: modm:board:nucleo-f439zi Nucleo kit for STM32F439ZI This module is only available for stm32f439zit6. Dependencies \u00b6 modm:board:nucleo-f439zi modm_board_nucleo_f439zi modm: board: nucleo-f439zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f439zi->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f439zi->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f439zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f439zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f439zi->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f439zi->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f439zi->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f439zi"},{"location":"reference/module/modm-board-nucleo-f439zi/#nucleo-f439zi","text":"lbuild module: modm:board:nucleo-f439zi Nucleo kit for STM32F439ZI This module is only available for stm32f439zit6.","title":"NUCLEO-F439ZI"},{"location":"reference/module/modm-board-nucleo-f439zi/#dependencies","text":"modm:board:nucleo-f439zi modm_board_nucleo_f439zi modm: board: nucleo-f439zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f439zi->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f439zi->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f439zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f439zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f439zi->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f439zi->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f439zi->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f446re/","text":"NUCLEO-F446RE \u00b6 lbuild module: modm:board:nucleo-f446re Nucleo kit for STM32F446RE This module is only available for stm32f446ret6. Dependencies \u00b6 modm:board:nucleo-f446re modm_board_nucleo_f446re modm: board: nucleo-f446re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f446re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f446re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f446re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f446re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f446re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f446re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f446re"},{"location":"reference/module/modm-board-nucleo-f446re/#nucleo-f446re","text":"lbuild module: modm:board:nucleo-f446re Nucleo kit for STM32F446RE This module is only available for stm32f446ret6.","title":"NUCLEO-F446RE"},{"location":"reference/module/modm-board-nucleo-f446re/#dependencies","text":"modm:board:nucleo-f446re modm_board_nucleo_f446re modm: board: nucleo-f446re modm_architecture_clock modm: architecture: clock modm_board_nucleo_f446re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f446re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f446re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f446re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f446re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_f446re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f446ze/","text":"NUCLEO-F446ZE \u00b6 lbuild module: modm:board:nucleo-f446ze Nucleo kit for STM32F446ZE This module is only available for stm32f446zet6. Dependencies \u00b6 modm:board:nucleo-f446ze modm_board_nucleo_f446ze modm: board: nucleo-f446ze modm_architecture_clock modm: architecture: clock modm_board_nucleo_f446ze->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f446ze->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f446ze->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f446ze->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f446ze->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f446ze->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f446ze->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f446ze"},{"location":"reference/module/modm-board-nucleo-f446ze/#nucleo-f446ze","text":"lbuild module: modm:board:nucleo-f446ze Nucleo kit for STM32F446ZE This module is only available for stm32f446zet6.","title":"NUCLEO-F446ZE"},{"location":"reference/module/modm-board-nucleo-f446ze/#dependencies","text":"modm:board:nucleo-f446ze modm_board_nucleo_f446ze modm: board: nucleo-f446ze modm_architecture_clock modm: architecture: clock modm_board_nucleo_f446ze->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f446ze->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f446ze->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f446ze->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f446ze->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f446ze->modm_platform_uart_3 modm_platform_usb_fs modm: platform: usb: fs modm_board_nucleo_f446ze->modm_platform_usb_fs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f746zg/","text":"NUCLEO-F746ZG \u00b6 lbuild module: modm:board:nucleo-f746zg Nucleo kit for STM32F746ZG This module is only available for stm32f746zgt6. Dependencies \u00b6 modm:board:nucleo-f746zg modm_board_nucleo_f746zg modm: board: nucleo-f746zg modm_architecture_clock modm: architecture: clock modm_board_nucleo_f746zg->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f746zg->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f746zg->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f746zg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f746zg->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f746zg->modm_platform_uart_3 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f746zg"},{"location":"reference/module/modm-board-nucleo-f746zg/#nucleo-f746zg","text":"lbuild module: modm:board:nucleo-f746zg Nucleo kit for STM32F746ZG This module is only available for stm32f746zgt6.","title":"NUCLEO-F746ZG"},{"location":"reference/module/modm-board-nucleo-f746zg/#dependencies","text":"modm:board:nucleo-f746zg modm_board_nucleo_f746zg modm: board: nucleo-f746zg modm_architecture_clock modm: architecture: clock modm_board_nucleo_f746zg->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f746zg->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f746zg->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f746zg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f746zg->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f746zg->modm_platform_uart_3 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-f767zi/","text":"NUCLEO-F767ZI \u00b6 lbuild module: modm:board:nucleo-f767zi Nucleo kit for STM32F767ZI This module is only available for stm32f767zit6. Dependencies \u00b6 modm:board:nucleo-f767zi modm_board_nucleo_f767zi modm: board: nucleo-f767zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f767zi->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f767zi->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f767zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f767zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f767zi->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f767zi->modm_platform_uart_3 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-f767zi"},{"location":"reference/module/modm-board-nucleo-f767zi/#nucleo-f767zi","text":"lbuild module: modm:board:nucleo-f767zi Nucleo kit for STM32F767ZI This module is only available for stm32f767zit6.","title":"NUCLEO-F767ZI"},{"location":"reference/module/modm-board-nucleo-f767zi/#dependencies","text":"modm:board:nucleo-f767zi modm_board_nucleo_f767zi modm: board: nucleo-f767zi modm_architecture_clock modm: architecture: clock modm_board_nucleo_f767zi->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_f767zi->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_f767zi->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_f767zi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_f767zi->modm_platform_gpio modm_platform_uart_3 modm: platform: uart: 3 modm_board_nucleo_f767zi->modm_platform_uart_3 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-g071rb/","text":"NUCLEO-G071RB \u00b6 lbuild module: modm:board:nucleo-g071rb Nucleo kit for STM32G071RB This module is only available for stm32g071rbt6. Dependencies \u00b6 modm:board:nucleo-g071rb modm_board_nucleo_g071rb modm: board: nucleo-g071rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g071rb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g071rb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g071rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g071rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g071rb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g071rb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-g071rb"},{"location":"reference/module/modm-board-nucleo-g071rb/#nucleo-g071rb","text":"lbuild module: modm:board:nucleo-g071rb Nucleo kit for STM32G071RB This module is only available for stm32g071rbt6.","title":"NUCLEO-G071RB"},{"location":"reference/module/modm-board-nucleo-g071rb/#dependencies","text":"modm:board:nucleo-g071rb modm_board_nucleo_g071rb modm: board: nucleo-g071rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g071rb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g071rb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g071rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g071rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g071rb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g071rb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-g431kb/","text":"NUCLEO-G431KB \u00b6 lbuild module: modm:board:nucleo-g431kb Nucleo kit for STM32G431KB This module is only available for stm32g431kbt6. Dependencies \u00b6 modm:board:nucleo-g431kb modm_board_nucleo_g431kb modm: board: nucleo-g431kb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g431kb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g431kb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g431kb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g431kb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g431kb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g431kb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-g431kb"},{"location":"reference/module/modm-board-nucleo-g431kb/#nucleo-g431kb","text":"lbuild module: modm:board:nucleo-g431kb Nucleo kit for STM32G431KB This module is only available for stm32g431kbt6.","title":"NUCLEO-G431KB"},{"location":"reference/module/modm-board-nucleo-g431kb/#dependencies","text":"modm:board:nucleo-g431kb modm_board_nucleo_g431kb modm: board: nucleo-g431kb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g431kb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g431kb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g431kb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g431kb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g431kb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g431kb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-g431rb/","text":"NUCLEO-G431RB \u00b6 lbuild module: modm:board:nucleo-g431rb Nucleo kit for STM32G474RE This module is only available for stm32g431rbt6. Dependencies \u00b6 modm:board:nucleo-g431rb modm_board_nucleo_g431rb modm: board: nucleo-g431rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g431rb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g431rb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g431rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g431rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g431rb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g431rb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-g431rb"},{"location":"reference/module/modm-board-nucleo-g431rb/#nucleo-g431rb","text":"lbuild module: modm:board:nucleo-g431rb Nucleo kit for STM32G474RE This module is only available for stm32g431rbt6.","title":"NUCLEO-G431RB"},{"location":"reference/module/modm-board-nucleo-g431rb/#dependencies","text":"modm:board:nucleo-g431rb modm_board_nucleo_g431rb modm: board: nucleo-g431rb modm_architecture_clock modm: architecture: clock modm_board_nucleo_g431rb->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g431rb->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g431rb->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g431rb->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g431rb->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g431rb->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-g474re/","text":"NUCLEO-G474RE \u00b6 lbuild module: modm:board:nucleo-g474re Nucleo kit for STM32G474RE This module is only available for stm32g474ret6. Dependencies \u00b6 modm:board:nucleo-g474re modm_board_nucleo_g474re modm: board: nucleo-g474re modm_architecture_clock modm: architecture: clock modm_board_nucleo_g474re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g474re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g474re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g474re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g474re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g474re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-g474re"},{"location":"reference/module/modm-board-nucleo-g474re/#nucleo-g474re","text":"lbuild module: modm:board:nucleo-g474re Nucleo kit for STM32G474RE This module is only available for stm32g474ret6.","title":"NUCLEO-G474RE"},{"location":"reference/module/modm-board-nucleo-g474re/#dependencies","text":"modm:board:nucleo-g474re modm_board_nucleo_g474re modm: board: nucleo-g474re modm_architecture_clock modm: architecture: clock modm_board_nucleo_g474re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_g474re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_g474re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_g474re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_g474re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_g474re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-l031k6/","text":"NUCLEO-L031K6 \u00b6 lbuild module: modm:board:nucleo-l031k6 Nucleo kit for STM32L031K6 This module is only available for stm32l031k6t6. Dependencies \u00b6 modm:board:nucleo-l031k6 modm_board_nucleo_l031k6 modm: board: nucleo-l031k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_l031k6->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l031k6->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l031k6->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l031k6->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l031k6->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l031k6->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-l031k6"},{"location":"reference/module/modm-board-nucleo-l031k6/#nucleo-l031k6","text":"lbuild module: modm:board:nucleo-l031k6 Nucleo kit for STM32L031K6 This module is only available for stm32l031k6t6.","title":"NUCLEO-L031K6"},{"location":"reference/module/modm-board-nucleo-l031k6/#dependencies","text":"modm:board:nucleo-l031k6 modm_board_nucleo_l031k6 modm: board: nucleo-l031k6 modm_architecture_clock modm: architecture: clock modm_board_nucleo_l031k6->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l031k6->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l031k6->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l031k6->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l031k6->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l031k6->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-l152re/","text":"NUCLEO-L152RE \u00b6 lbuild module: modm:board:nucleo-l152re Nucleo kit for STM32L152RE This module is only available for stm32l152ret6. Dependencies \u00b6 modm:board:nucleo-l152re modm_board_nucleo_l152re modm: board: nucleo-l152re modm_architecture_clock modm: architecture: clock modm_board_nucleo_l152re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l152re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l152re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l152re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l152re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l152re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-l152re"},{"location":"reference/module/modm-board-nucleo-l152re/#nucleo-l152re","text":"lbuild module: modm:board:nucleo-l152re Nucleo kit for STM32L152RE This module is only available for stm32l152ret6.","title":"NUCLEO-L152RE"},{"location":"reference/module/modm-board-nucleo-l152re/#dependencies","text":"modm:board:nucleo-l152re modm_board_nucleo_l152re modm: board: nucleo-l152re modm_architecture_clock modm: architecture: clock modm_board_nucleo_l152re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l152re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l152re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l152re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l152re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l152re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-l432kc/","text":"NUCLEO-L432KC \u00b6 lbuild module: modm:board:nucleo-l432kc Nucleo kit for STM32L432KC This module is only available for stm32l432kcu6. Dependencies \u00b6 modm:board:nucleo-l432kc modm_board_nucleo_l432kc modm: board: nucleo-l432kc modm_architecture_clock modm: architecture: clock modm_board_nucleo_l432kc->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l432kc->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l432kc->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l432kc->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l432kc->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l432kc->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-l432kc"},{"location":"reference/module/modm-board-nucleo-l432kc/#nucleo-l432kc","text":"lbuild module: modm:board:nucleo-l432kc Nucleo kit for STM32L432KC This module is only available for stm32l432kcu6.","title":"NUCLEO-L432KC"},{"location":"reference/module/modm-board-nucleo-l432kc/#dependencies","text":"modm:board:nucleo-l432kc modm_board_nucleo_l432kc modm: board: nucleo-l432kc modm_architecture_clock modm: architecture: clock modm_board_nucleo_l432kc->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l432kc->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l432kc->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l432kc->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l432kc->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l432kc->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-l452re/","text":"NUCLEO-L452RE \u00b6 lbuild module: modm:board:nucleo-l452re Nucleo kit for STM32L452RE This module is only available for stm32l4. Dependencies \u00b6 modm:board:nucleo-l452re modm_board_nucleo_l452re modm: board: nucleo-l452re modm_architecture_clock modm: architecture: clock modm_board_nucleo_l452re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l452re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l452re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l452re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l452re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l452re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-l452re"},{"location":"reference/module/modm-board-nucleo-l452re/#nucleo-l452re","text":"lbuild module: modm:board:nucleo-l452re Nucleo kit for STM32L452RE This module is only available for stm32l4.","title":"NUCLEO-L452RE"},{"location":"reference/module/modm-board-nucleo-l452re/#dependencies","text":"modm:board:nucleo-l452re modm_board_nucleo_l452re modm: board: nucleo-l452re modm_architecture_clock modm: architecture: clock modm_board_nucleo_l452re->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l452re->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l452re->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l452re->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l452re->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l452re->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-nucleo-l476rg/","text":"NUCLEO-L476RG \u00b6 lbuild module: modm:board:nucleo-l476rg Nucleo kit for STM32L476RG This module is only available for stm32l476rgt6. Dependencies \u00b6 modm:board:nucleo-l476rg modm_board_nucleo_l476rg modm: board: nucleo-l476rg modm_architecture_clock modm: architecture: clock modm_board_nucleo_l476rg->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l476rg->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l476rg->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l476rg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l476rg->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l476rg->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:nucleo-l476rg"},{"location":"reference/module/modm-board-nucleo-l476rg/#nucleo-l476rg","text":"lbuild module: modm:board:nucleo-l476rg Nucleo kit for STM32L476RG This module is only available for stm32l476rgt6.","title":"NUCLEO-L476RG"},{"location":"reference/module/modm-board-nucleo-l476rg/#dependencies","text":"modm:board:nucleo-l476rg modm_board_nucleo_l476rg modm: board: nucleo-l476rg modm_architecture_clock modm: architecture: clock modm_board_nucleo_l476rg->modm_architecture_clock modm_debug modm: debug modm_board_nucleo_l476rg->modm_debug modm_platform_clock modm: platform: clock modm_board_nucleo_l476rg->modm_platform_clock modm_platform_core modm: platform: core modm_board_nucleo_l476rg->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_nucleo_l476rg->modm_platform_gpio modm_platform_uart_2 modm: platform: uart: 2 modm_board_nucleo_l476rg->modm_platform_uart_2 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-olimexino-stm32/","text":"Olimexino STM32 \u00b6 lbuild module: modm:board:olimexino-stm32 Modified Maple board with STM32F103RBT6: https://www.olimex.com/Products/Duino/STM32/OLIMEXINO-STM32/open-source-hardware This module is only available for stm32f103rbt6. Dependencies \u00b6 modm:board:olimexino-stm32 modm_board_olimexino_stm32 modm: board: olimexino-stm32 modm_architecture_clock modm: architecture: clock modm_board_olimexino_stm32->modm_architecture_clock modm_debug modm: debug modm_board_olimexino_stm32->modm_debug modm_platform_clock modm: platform: clock modm_board_olimexino_stm32->modm_platform_clock modm_platform_core modm: platform: core modm_board_olimexino_stm32->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_olimexino_stm32->modm_platform_gpio modm_platform_spi_2 modm: platform: spi: 2 modm_board_olimexino_stm32->modm_platform_spi_2 modm_platform_uart_1 modm: platform: uart: 1 modm_board_olimexino_stm32->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:olimexino-stm32"},{"location":"reference/module/modm-board-olimexino-stm32/#olimexino-stm32","text":"lbuild module: modm:board:olimexino-stm32 Modified Maple board with STM32F103RBT6: https://www.olimex.com/Products/Duino/STM32/OLIMEXINO-STM32/open-source-hardware This module is only available for stm32f103rbt6.","title":"Olimexino STM32"},{"location":"reference/module/modm-board-olimexino-stm32/#dependencies","text":"modm:board:olimexino-stm32 modm_board_olimexino_stm32 modm: board: olimexino-stm32 modm_architecture_clock modm: architecture: clock modm_board_olimexino_stm32->modm_architecture_clock modm_debug modm: debug modm_board_olimexino_stm32->modm_debug modm_platform_clock modm: platform: clock modm_board_olimexino_stm32->modm_platform_clock modm_platform_core modm: platform: core modm_board_olimexino_stm32->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_olimexino_stm32->modm_platform_gpio modm_platform_spi_2 modm: platform: spi: 2 modm_board_olimexino_stm32->modm_platform_spi_2 modm_platform_uart_1 modm: platform: uart: 1 modm_board_olimexino_stm32->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-raspberrypi/","text":"Raspberry Pi \u00b6 lbuild module: modm:board:raspberrypi This module is only available for hosted-rpi. Dependencies \u00b6 modm:board:raspberrypi modm_board_raspberrypi modm: board: raspberrypi modm_debug modm: debug modm_board_raspberrypi->modm_debug modm_platform_core modm: platform: core modm_board_raspberrypi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_raspberrypi->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:raspberrypi"},{"location":"reference/module/modm-board-raspberrypi/#raspberry-pi","text":"lbuild module: modm:board:raspberrypi This module is only available for hosted-rpi.","title":"Raspberry Pi"},{"location":"reference/module/modm-board-raspberrypi/#dependencies","text":"modm:board:raspberrypi modm_board_raspberrypi modm: board: raspberrypi modm_debug modm: debug modm_board_raspberrypi->modm_debug modm_platform_core modm: platform: core modm_board_raspberrypi->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_raspberrypi->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-samd21-mini/","text":"RobotDyn SAMD21 M0 MINI \u00b6 lbuild module: modm:board:samd21-mini The SAMD21 MINI board is a small breakout board for the ATSAMD21G18 ARM Cortex-M0 processor, clocked at 48 MHz and at 3.3V logic. See: https://robotdyn.com/samd21-m0-mini.html It can be bought for little cost from well known Chinese online stores. This module is only available for sam. Dependencies \u00b6 modm:board:samd21-mini modm_board_samd21_mini modm: board: samd21-mini modm_platform_clock modm: platform: clock modm_board_samd21_mini->modm_platform_clock modm_platform_core modm: platform: core modm_board_samd21_mini->modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_samd21_mini->modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_samd21_mini->modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_samd21_mini->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:samd21-mini"},{"location":"reference/module/modm-board-samd21-mini/#robotdyn-samd21-m0-mini","text":"lbuild module: modm:board:samd21-mini The SAMD21 MINI board is a small breakout board for the ATSAMD21G18 ARM Cortex-M0 processor, clocked at 48 MHz and at 3.3V logic. See: https://robotdyn.com/samd21-m0-mini.html It can be bought for little cost from well known Chinese online stores. This module is only available for sam.","title":"RobotDyn SAMD21 M0 MINI"},{"location":"reference/module/modm-board-samd21-mini/#dependencies","text":"modm:board:samd21-mini modm_board_samd21_mini modm: board: samd21-mini modm_platform_clock modm: platform: clock modm_board_samd21_mini->modm_platform_clock modm_platform_core modm: platform: core modm_board_samd21_mini->modm_platform_core modm_platform_gclk modm: platform: gclk modm_board_samd21_mini->modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_board_samd21_mini->modm_platform_gpio modm_platform_usb modm: platform: usb modm_board_samd21_mini->modm_platform_usb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-stm32_f4ve/","text":"STM32_F4VE \u00b6 lbuild module: modm:board:stm32_f4ve https://stm32-base.org/boards/STM32F407VET6-STM32-F4VE-V2.0.html This module is only available for stm32f407vet6. Dependencies \u00b6 modm:board:stm32_f4ve modm_board_stm32_f4ve modm: board: stm32_f4ve modm_architecture_clock modm: architecture: clock modm_board_stm32_f4ve->modm_architecture_clock modm_debug modm: debug modm_board_stm32_f4ve->modm_debug modm_driver_ads7843 modm: driver: ads7843 modm_board_stm32_f4ve->modm_driver_ads7843 modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_board_stm32_f4ve->modm_driver_block_device_spi_flash modm_platform_clock modm: platform: clock modm_board_stm32_f4ve->modm_platform_clock modm_platform_core modm: platform: core modm_board_stm32_f4ve->modm_platform_core modm_platform_fsmc modm: platform: fsmc modm_board_stm32_f4ve->modm_platform_fsmc modm_platform_gpio modm: platform: gpio modm_board_stm32_f4ve->modm_platform_gpio modm_platform_spi_1 modm: platform: spi: 1 modm_board_stm32_f4ve->modm_platform_spi_1 modm_platform_spi_2 modm: platform: spi: 2 modm_board_stm32_f4ve->modm_platform_spi_2 modm_platform_uart_1 modm: platform: uart: 1 modm_board_stm32_f4ve->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:stm32_f4ve"},{"location":"reference/module/modm-board-stm32_f4ve/#stm32_f4ve","text":"lbuild module: modm:board:stm32_f4ve https://stm32-base.org/boards/STM32F407VET6-STM32-F4VE-V2.0.html This module is only available for stm32f407vet6.","title":"STM32_F4VE"},{"location":"reference/module/modm-board-stm32_f4ve/#dependencies","text":"modm:board:stm32_f4ve modm_board_stm32_f4ve modm: board: stm32_f4ve modm_architecture_clock modm: architecture: clock modm_board_stm32_f4ve->modm_architecture_clock modm_debug modm: debug modm_board_stm32_f4ve->modm_debug modm_driver_ads7843 modm: driver: ads7843 modm_board_stm32_f4ve->modm_driver_ads7843 modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_board_stm32_f4ve->modm_driver_block_device_spi_flash modm_platform_clock modm: platform: clock modm_board_stm32_f4ve->modm_platform_clock modm_platform_core modm: platform: core modm_board_stm32_f4ve->modm_platform_core modm_platform_fsmc modm: platform: fsmc modm_board_stm32_f4ve->modm_platform_fsmc modm_platform_gpio modm: platform: gpio modm_board_stm32_f4ve->modm_platform_gpio modm_platform_spi_1 modm: platform: spi: 1 modm_board_stm32_f4ve->modm_platform_spi_1 modm_platform_spi_2 modm: platform: spi: 2 modm_board_stm32_f4ve->modm_platform_spi_2 modm_platform_uart_1 modm: platform: uart: 1 modm_board_stm32_f4ve->modm_platform_uart_1 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board-stm32f030_demo/","text":"STM32F030 Demo Board \u00b6 lbuild module: modm:board:stm32f030_demo STM32F030F4P6 Minimum System Development Board. Cheap and bread-board-friendly board for STM32 F0 series. Sold for less than 1.5 USD on well known Internet shops from China. https://stm32-base.org/boards/STM32F030F4P6-STM32F030-DEMO-BOARD-V1.1 Programming \u00b6 Since the board doesn't have a programmer on-board, you need to use your own and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] # To select a specific programmer you can specify its serial number #hla_serial \"\\x53\\x3f\\x6f\\x06\\x51\\x77\\x50\\x57\\x12\\x17\\x13\\x3f\" # You can discover the serial via `stlink --hla-serial` or `st-info --hla-serial`. Then include this file in your build options like so: <library> <extends> modm:stm32f030_demo </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f030f4p6. Dependencies \u00b6 modm:board:stm32f030_demo modm_board_stm32f030_demo modm: board: stm32f030_demo modm_architecture_clock modm: architecture: clock modm_board_stm32f030_demo->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_stm32f030_demo->modm_platform_clock modm_platform_core modm: platform: core modm_board_stm32f030_demo->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_stm32f030_demo->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":board:stm32f030_demo"},{"location":"reference/module/modm-board-stm32f030_demo/#stm32f030-demo-board","text":"lbuild module: modm:board:stm32f030_demo STM32F030F4P6 Minimum System Development Board. Cheap and bread-board-friendly board for STM32 F0 series. Sold for less than 1.5 USD on well known Internet shops from China. https://stm32-base.org/boards/STM32F030F4P6-STM32F030-DEMO-BOARD-V1.1","title":"STM32F030 Demo Board"},{"location":"reference/module/modm-board-stm32f030_demo/#programming","text":"Since the board doesn't have a programmer on-board, you need to use your own and specify which one you're using in a custom openocd.cfg file: # Replace this with your custom programmer source [find interface/stlink-v2.cfg] # To select a specific programmer you can specify its serial number #hla_serial \"\\x53\\x3f\\x6f\\x06\\x51\\x77\\x50\\x57\\x12\\x17\\x13\\x3f\" # You can discover the serial via `stlink --hla-serial` or `st-info --hla-serial`. Then include this file in your build options like so: <library> <extends> modm:stm32f030_demo </extends> <options> <option name= \"modm:build:openocd.cfg\" > openocd.cfg </option> </options> </library> This module is only available for stm32f030f4p6.","title":"Programming"},{"location":"reference/module/modm-board-stm32f030_demo/#dependencies","text":"modm:board:stm32f030_demo modm_board_stm32f030_demo modm: board: stm32f030_demo modm_architecture_clock modm: architecture: clock modm_board_stm32f030_demo->modm_architecture_clock modm_platform_clock modm: platform: clock modm_board_stm32f030_demo->modm_platform_clock modm_platform_core modm: platform: core modm_board_stm32f030_demo->modm_platform_core modm_platform_gpio modm: platform: gpio modm_board_stm32f030_demo->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-board/","text":"Board Support Packages \u00b6 lbuild module: modm:board modm provides pre-configured BSPs for several commercial off-the-shelf development boards. There are two main components to the BPSs: An inheritable configuration board.xml containing the HAL target, options and the board module. This pre-defined configuration is aliased as a repo configuration so that your project.xml simply <extends>modm:{board-name}</extends> . A module modm:board:{board-name} that pulls in required dependencies, configures the modm library and provides the code to initialize the board. You can then #include <modm/board.hpp> in your project. The BSPs all use a common interface within a top-level namespace Board : Board::initialize() : Initializes the targets clock system, logger, LEDs and Buttons. Board::initialize{subsystem}() : Initializes optional board subsystems. Board::SystemClock : Provides the clock configuration for use in Peripheral::initialize<Board::SystemClock, ...>() . Board::Led{name} : Board-specific LEDs are initialized as outputs and off. Board::Leds : A modm::platform::SoftwareGpioPort containing all board LEDs. Board::Button : Board-specific input buttons are initialized as input with pull-up/down as required. Board::{pin-name} : All board-specific pins are aliased to their respective modm::platform::Gpio{port}{pin} . If the board supports a dedicated serial logging output the BSP redirects the modm:debug module debug stream MODM_LOG_INFO etc. Please note that YOU must explicitly call the Board functions to initialize your hardware, just including the board module is not enough. Here is an example using the modm:disco-f469ni BSP: #include <modm/board.hpp> int main () { // ALWAYS initialize the board first! Board :: initialize (); // Then initialize the subsystems you want to use Board :: initializeDisplay (); // Set LEDs via the GPIO port Board :: Leds :: write ( 0b1011 ); // Use the Arduino pin names Board :: D0 :: setOutput ( modm :: Gpio :: High ); Board :: D1 :: setInput (); // Use the boards serial logging MODM_LOG_INFO << \"REBOOT!\" << modm :: endl ; while ( true ) { // Link the LED to the button Board :: LedBlue :: set ( Board :: Button : read ()); } return 0 ; } Only select one BSP module Even though some targets have multiple BSPs modules available (for example: Blue Pill and Black Pill), you can only use one module, since all define the same functions resulting in naming conflicts. Customization \u00b6 The BSPs contain an opinionated set of pre-defined functionality and settings. This is great for just quickly prototyping something, however, when you want to use custom hardware, or even just change a few settings, it's better to use your own BSP: Generate the BSP closest to your custom hardware, then copy the files from modm/src/modm/board/{name} to your own project and modify them. In your project.xml remove the board config inheritance ( <extends> ) and instead copy the pre-defined options into your own config. Check what modm modules you need to depend on and add them to your own project (check for module.depends(...) in the BSPs module.lb ). You may need to manually add the pre-defined collector values to your project configuration (check for env.collect(...) in the BSPs module.lb ). Create the SystemClock struct \u00b6 The easiest way using ST's CubeMX tool. 1. CubeMX Clock Graph \u00b6 First we create a project in CubeMX with the desired microcontroller using the largest (pin-count, flash) variant. CubeMX displays something like this in the \"Clock configuration\" tab: Then configure all clocks, muxes, multipliers and dividers to the highest allowed clock speeds (*). (*) exceptions: E.g. USB usually requires exactly 48 MHz. This settings are reflected in the constants static constexpr uint32_t Frequency , Apb1 and Apb2 as well as in const Rcc::PllFactors pllFactors{...} and the following lines. The PllFactors struct should be fairly self-explanatory. 2. Peripheral Mapping \u00b6 As we can see in the graphic above, there are different clock ranges. Each peripheral is connected to a clock domain. Some peripherals have an upstream clock mux, this is currently ignored in modm and the default setting for the clock mux is assumed. The figure shows the block diagram of the controller, which can be found at the beginning of the data sheet (not in the reference manual): For each peripheral we create a static constexpr uint32_t member in the struct SystemClock and assign the value of the clock domain to which the peripheral is connected. Dependencies \u00b6 modm:board modm_board modm: board modm_architecture_assert modm: architecture: assert modm_board->modm_architecture_assert modm_architecture_delay modm: architecture: delay modm_board->modm_architecture_delay @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":board"},{"location":"reference/module/modm-board/#board-support-packages","text":"lbuild module: modm:board modm provides pre-configured BSPs for several commercial off-the-shelf development boards. There are two main components to the BPSs: An inheritable configuration board.xml containing the HAL target, options and the board module. This pre-defined configuration is aliased as a repo configuration so that your project.xml simply <extends>modm:{board-name}</extends> . A module modm:board:{board-name} that pulls in required dependencies, configures the modm library and provides the code to initialize the board. You can then #include <modm/board.hpp> in your project. The BSPs all use a common interface within a top-level namespace Board : Board::initialize() : Initializes the targets clock system, logger, LEDs and Buttons. Board::initialize{subsystem}() : Initializes optional board subsystems. Board::SystemClock : Provides the clock configuration for use in Peripheral::initialize<Board::SystemClock, ...>() . Board::Led{name} : Board-specific LEDs are initialized as outputs and off. Board::Leds : A modm::platform::SoftwareGpioPort containing all board LEDs. Board::Button : Board-specific input buttons are initialized as input with pull-up/down as required. Board::{pin-name} : All board-specific pins are aliased to their respective modm::platform::Gpio{port}{pin} . If the board supports a dedicated serial logging output the BSP redirects the modm:debug module debug stream MODM_LOG_INFO etc. Please note that YOU must explicitly call the Board functions to initialize your hardware, just including the board module is not enough. Here is an example using the modm:disco-f469ni BSP: #include <modm/board.hpp> int main () { // ALWAYS initialize the board first! Board :: initialize (); // Then initialize the subsystems you want to use Board :: initializeDisplay (); // Set LEDs via the GPIO port Board :: Leds :: write ( 0b1011 ); // Use the Arduino pin names Board :: D0 :: setOutput ( modm :: Gpio :: High ); Board :: D1 :: setInput (); // Use the boards serial logging MODM_LOG_INFO << \"REBOOT!\" << modm :: endl ; while ( true ) { // Link the LED to the button Board :: LedBlue :: set ( Board :: Button : read ()); } return 0 ; } Only select one BSP module Even though some targets have multiple BSPs modules available (for example: Blue Pill and Black Pill), you can only use one module, since all define the same functions resulting in naming conflicts.","title":"Board Support Packages"},{"location":"reference/module/modm-board/#customization","text":"The BSPs contain an opinionated set of pre-defined functionality and settings. This is great for just quickly prototyping something, however, when you want to use custom hardware, or even just change a few settings, it's better to use your own BSP: Generate the BSP closest to your custom hardware, then copy the files from modm/src/modm/board/{name} to your own project and modify them. In your project.xml remove the board config inheritance ( <extends> ) and instead copy the pre-defined options into your own config. Check what modm modules you need to depend on and add them to your own project (check for module.depends(...) in the BSPs module.lb ). You may need to manually add the pre-defined collector values to your project configuration (check for env.collect(...) in the BSPs module.lb ).","title":"Customization"},{"location":"reference/module/modm-board/#create-the-systemclock-struct","text":"The easiest way using ST's CubeMX tool.","title":"Create the SystemClock struct"},{"location":"reference/module/modm-board/#1-cubemx-clock-graph","text":"First we create a project in CubeMX with the desired microcontroller using the largest (pin-count, flash) variant. CubeMX displays something like this in the \"Clock configuration\" tab: Then configure all clocks, muxes, multipliers and dividers to the highest allowed clock speeds (*). (*) exceptions: E.g. USB usually requires exactly 48 MHz. This settings are reflected in the constants static constexpr uint32_t Frequency , Apb1 and Apb2 as well as in const Rcc::PllFactors pllFactors{...} and the following lines. The PllFactors struct should be fairly self-explanatory.","title":"1. CubeMX Clock Graph"},{"location":"reference/module/modm-board/#2-peripheral-mapping","text":"As we can see in the graphic above, there are different clock ranges. Each peripheral is connected to a clock domain. Some peripherals have an upstream clock mux, this is currently ignored in modm and the default setting for the clock mux is assumed. The figure shows the block diagram of the controller, which can be found at the beginning of the data sheet (not in the reference manual): For each peripheral we create a static constexpr uint32_t member in the struct SystemClock and assign the value of the clock domain to which the peripheral is connected.","title":"2. Peripheral Mapping"},{"location":"reference/module/modm-board/#dependencies","text":"modm:board modm_board modm: board modm_architecture_assert modm: architecture: assert modm_board->modm_architecture_assert modm_architecture_delay modm: architecture: delay modm_board->modm_architecture_delay @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-build-cmake/","text":"CMake Build Script Generator \u00b6 lbuild module: modm:build:cmake CMake is a widely used build tool supported by almost every IDE. This module generates three files: a modm/repo.cmake file: configures all required CMake tools with the right settings (also using information from the modm:build module) to compile the modm library. a top-level CMakeLists.txt : configures CMake to build modm and your application. a top-level Makefile : provides a convenience wrapper for calling CMake from the command line. This module is intended to be used for integration with IDEs that natively only support CMake. It therefore only provides the bare minimum of features to compile and upload your application to your target. For additional build tools features see the modm:build:scons module. Make Methods \u00b6 The Makefile wrapper provides these convenience methods. make cmake \u00b6 Generates the CMake build folders and initializes the build system. $ make cmake ... -- Configuring done -- Generating done -- Build files have been written to: build/{project.name}/cmake-build-release ... -- Build files have been written to: build/{project.name}/cmake-build-debug You must call this once before you can build! If you forget to call this first, the build will fail with this error message: $ make build Error: build/cmake-build-release is not a directory make: *** [build-release] Error 1 make clean \u00b6 Removes the CMake build artifacts. make cleanall \u00b6 Removes the entire build folder. You must then first call make cmake before being able to build again. make build \u00b6 make build profile={debug|release} Compiles your application into an executable using the release or debug profile. $ make build profile=release Scanning dependencies of target blink_cmake [ 3%] Building C object CMakeFiles/blink_cmake.dir/modm/ext/cmsis/device/peripherals.c.o [ 7%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/architecture/driver/atomic/flag.cpp.o [ 19%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/board/board.cpp.o ... [ 96%] Building CXX object CMakeFiles/blink_cmake.dir/main.cpp.o [100%] Linking CXX executable blink_cmake.elf text data bss dec hex filename 1596 52 20468 22116 5664 blink_cmake.elf [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss make size \u00b6 make size profile={debug|release} Displays the static Flash and RAM consumption of your target. Example for the Blue Pill target: $ make size Program: 1.4 KiB (2.2% used) (.build_id + .fastcode + .fastdata + .hardware_init + .rodata + .table.copy.intern + .table.heap + .table.zero.intern + .text + .vector_rom) Data: 3.0 KiB (15.1% used) = 20 B static (0.1%) + 3072 B stack (15.0%) (.bss + .fastdata + .stack) Heap: 17.0 KiB (84.9% available) (.heap1) make program \u00b6 make program profile={debug|release} [port={serial-port}] Writes the executable onto your target via AvrDude or OpenOCD. $ make program [100%] Built target blink_cmake [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.171034 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x20036410 Info : flash size = 64kbytes ... wrote 2048 bytes from file build/cmake-build-release/blink_cmake.elf in 0.187893s (10.644 KiB/s) ** Programming Finished ** ** Verify Started ** verified 1652 bytes in 0.104584s (15.426 KiB/s) ** Verified OK ** shutdown command invoked make program-bmp \u00b6 make program-bmp profile={debug|release} [port={serial-port}] Writes the executable onto your target via Black Magic Probe. (* only ARM Cortex-M targets ) make debug \u00b6 make debug profile={debug|release} ui={tui|web} Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based gdbgui UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets ) To use gdbgui you must have it installed via pip install gdbgui . Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the some or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to make debug profile=release , and if that doesn't help, compile and make program profile=debug and try make debug profile=debug again. make debug-coredump \u00b6 make debug-coredump profile={debug|release} ui={tui|web} Launches GDB for post-mortem debugging with the using the data in the coredump.txt argument. (* only ARM Cortex-M targets ) See the :platform:fault module for details how to receive the coredump data. make log-itm \u00b6 make log-itm fcpu={HCLK in Hz} Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. See the modm:platform:itm module for details how to use the ITM as a logging output. Options \u00b6 include_cmakelists \u00b6 Generate a CMakeLists.txt This overwrites any top-level CMakeLists.txt file! Default: True Inputs: [True, False] include_makefile \u00b6 Generate a wrapper Makefile This overwrites any top-level Makefile file! Default: True Inputs: [True, False] Collectors \u00b6 flag_format \u00b6 Formatting compile flags for CMake Inputs: [Callable]","title":":build:cmake"},{"location":"reference/module/modm-build-cmake/#cmake-build-script-generator","text":"lbuild module: modm:build:cmake CMake is a widely used build tool supported by almost every IDE. This module generates three files: a modm/repo.cmake file: configures all required CMake tools with the right settings (also using information from the modm:build module) to compile the modm library. a top-level CMakeLists.txt : configures CMake to build modm and your application. a top-level Makefile : provides a convenience wrapper for calling CMake from the command line. This module is intended to be used for integration with IDEs that natively only support CMake. It therefore only provides the bare minimum of features to compile and upload your application to your target. For additional build tools features see the modm:build:scons module.","title":"CMake Build Script Generator"},{"location":"reference/module/modm-build-cmake/#make-methods","text":"The Makefile wrapper provides these convenience methods.","title":"Make Methods"},{"location":"reference/module/modm-build-cmake/#make-cmake","text":"Generates the CMake build folders and initializes the build system. $ make cmake ... -- Configuring done -- Generating done -- Build files have been written to: build/{project.name}/cmake-build-release ... -- Build files have been written to: build/{project.name}/cmake-build-debug You must call this once before you can build! If you forget to call this first, the build will fail with this error message: $ make build Error: build/cmake-build-release is not a directory make: *** [build-release] Error 1","title":"make cmake"},{"location":"reference/module/modm-build-cmake/#make-clean","text":"Removes the CMake build artifacts.","title":"make clean"},{"location":"reference/module/modm-build-cmake/#make-cleanall","text":"Removes the entire build folder. You must then first call make cmake before being able to build again.","title":"make cleanall"},{"location":"reference/module/modm-build-cmake/#make-build","text":"make build profile={debug|release} Compiles your application into an executable using the release or debug profile. $ make build profile=release Scanning dependencies of target blink_cmake [ 3%] Building C object CMakeFiles/blink_cmake.dir/modm/ext/cmsis/device/peripherals.c.o [ 7%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/architecture/driver/atomic/flag.cpp.o [ 19%] Building CXX object CMakeFiles/blink_cmake.dir/modm/src/modm/board/board.cpp.o ... [ 96%] Building CXX object CMakeFiles/blink_cmake.dir/main.cpp.o [100%] Linking CXX executable blink_cmake.elf text data bss dec hex filename 1596 52 20468 22116 5664 blink_cmake.elf [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss","title":"make build"},{"location":"reference/module/modm-build-cmake/#make-size","text":"make size profile={debug|release} Displays the static Flash and RAM consumption of your target. Example for the Blue Pill target: $ make size Program: 1.4 KiB (2.2% used) (.build_id + .fastcode + .fastdata + .hardware_init + .rodata + .table.copy.intern + .table.heap + .table.zero.intern + .text + .vector_rom) Data: 3.0 KiB (15.1% used) = 20 B static (0.1%) + 3072 B stack (15.0%) (.bss + .fastdata + .stack) Heap: 17.0 KiB (84.9% available) (.heap1)","title":"make size"},{"location":"reference/module/modm-build-cmake/#make-program","text":"make program profile={debug|release} [port={serial-port}] Writes the executable onto your target via AvrDude or OpenOCD. $ make program [100%] Built target blink_cmake [100%] Built target blink_cmake.bin [100%] Built target blink_cmake.hex [100%] Built target blink_cmake.lss Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.171034 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x20036410 Info : flash size = 64kbytes ... wrote 2048 bytes from file build/cmake-build-release/blink_cmake.elf in 0.187893s (10.644 KiB/s) ** Programming Finished ** ** Verify Started ** verified 1652 bytes in 0.104584s (15.426 KiB/s) ** Verified OK ** shutdown command invoked","title":"make program"},{"location":"reference/module/modm-build-cmake/#make-program-bmp","text":"make program-bmp profile={debug|release} [port={serial-port}] Writes the executable onto your target via Black Magic Probe. (* only ARM Cortex-M targets )","title":"make program-bmp"},{"location":"reference/module/modm-build-cmake/#make-debug","text":"make debug profile={debug|release} ui={tui|web} Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based gdbgui UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets ) To use gdbgui you must have it installed via pip install gdbgui . Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the some or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to make debug profile=release , and if that doesn't help, compile and make program profile=debug and try make debug profile=debug again.","title":"make debug"},{"location":"reference/module/modm-build-cmake/#make-debug-coredump","text":"make debug-coredump profile={debug|release} ui={tui|web} Launches GDB for post-mortem debugging with the using the data in the coredump.txt argument. (* only ARM Cortex-M targets ) See the :platform:fault module for details how to receive the coredump data.","title":"make debug-coredump"},{"location":"reference/module/modm-build-cmake/#make-log-itm","text":"make log-itm fcpu={HCLK in Hz} Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. See the modm:platform:itm module for details how to use the ITM as a logging output.","title":"make log-itm"},{"location":"reference/module/modm-build-cmake/#options","text":"","title":"Options"},{"location":"reference/module/modm-build-cmake/#include_cmakelists","text":"Generate a CMakeLists.txt This overwrites any top-level CMakeLists.txt file! Default: True Inputs: [True, False]","title":"include_cmakelists"},{"location":"reference/module/modm-build-cmake/#include_makefile","text":"Generate a wrapper Makefile This overwrites any top-level Makefile file! Default: True Inputs: [True, False]","title":"include_makefile"},{"location":"reference/module/modm-build-cmake/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-build-cmake/#flag_format","text":"Formatting compile flags for CMake Inputs: [Callable]","title":"flag_format"},{"location":"reference/module/modm-build-compilation_db/","text":"CompilationDB Generator \u00b6 lbuild module: modm:build:compilation_db This module generates a Python script that generates a CompilationDB file, which allows you to import your project into a code editor like CLion or Qt Creator with working code completion and enhanced refactoring. CompilationDB is not a build system replacement CompilationDB support is currently only implemented as an import mechanism in all IDEs, it cannot be used to compile AND LINK your application correctly. Use a proper build system for that purpose. Since the CompilationDB requires absolute paths making it difficult to share with other users, this module instead generates a script that you can call whenever you need to generate a new compile_commands.json file. The script takes are argument the application folder or files that it should include. The search is recursive and looks only for source files while ignoring any generated files: # When calling this from where project.xml is located # adding all sources contained in the current folder python3 modm/tools/builder_compilation_db.py . To generate the CompilationDB for debug mode, use the --debug option: # You can also add individual files python3 modm/tools/builder_compilation_db.py --debug main.cpp SCons integration \u00b6 When including this module together with the modm:build:scons module, a new command is added to SCons, which wraps the above command line invocation. # This command safely wraps the generation script scons compilation_db profile = release scons compilation_db profile = debug Collectors \u00b6 flag_format \u00b6 Formatting compile flags for CompilationDB Inputs: [Callable]","title":":build:compilation_db"},{"location":"reference/module/modm-build-compilation_db/#compilationdb-generator","text":"lbuild module: modm:build:compilation_db This module generates a Python script that generates a CompilationDB file, which allows you to import your project into a code editor like CLion or Qt Creator with working code completion and enhanced refactoring. CompilationDB is not a build system replacement CompilationDB support is currently only implemented as an import mechanism in all IDEs, it cannot be used to compile AND LINK your application correctly. Use a proper build system for that purpose. Since the CompilationDB requires absolute paths making it difficult to share with other users, this module instead generates a script that you can call whenever you need to generate a new compile_commands.json file. The script takes are argument the application folder or files that it should include. The search is recursive and looks only for source files while ignoring any generated files: # When calling this from where project.xml is located # adding all sources contained in the current folder python3 modm/tools/builder_compilation_db.py . To generate the CompilationDB for debug mode, use the --debug option: # You can also add individual files python3 modm/tools/builder_compilation_db.py --debug main.cpp","title":"CompilationDB Generator"},{"location":"reference/module/modm-build-compilation_db/#scons-integration","text":"When including this module together with the modm:build:scons module, a new command is added to SCons, which wraps the above command line invocation. # This command safely wraps the generation script scons compilation_db profile = release scons compilation_db profile = debug","title":"SCons integration"},{"location":"reference/module/modm-build-compilation_db/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-build-compilation_db/#flag_format","text":"Formatting compile flags for CompilationDB Inputs: [Callable]","title":"flag_format"},{"location":"reference/module/modm-build-make/","text":"Makefile Build Script Generator \u00b6 lbuild module: modm:build:make Make is a simple dependency tracking build system. It's very lightweight and available pretty much everywhere. This module generates a set of self contained Makefiles for building modm applications: a modm/config.mk file: configures the toolchain, device-specific information and sets up generic and special build rules based on the modm:build options. a modm/repo.mk file: contains all build rules to build the modm library. a top-level Makefile file: globs the application sources and provides all the Makefile targets for the device-specific embedded tools. We do not intend to serve every possible use-case with this module. If you need something special, write your own Makefile, maybe starting by modifying ours. Remember to set modm:build:make:include_makefile to False , so that your custom Makefile does not get overwritten by lbuild build . No Windows Support Due to issues with the Windows path separator \\ the generated Makefile may not work correctly on Windows. We recommend using SCons on Windows instead. Makefile Targets \u00b6 This module generates these .PHONY targets . make \u00b6 Defaults to make build size . You can add these arguments to any of the Make commands: -j8 : Process 8 jobs in parallel. You can also export MAKEFLAGS=\"-j8\" in your .bashrc to have a permanent setting. -n : gives a verbose, simulated output, so you can check what options the compiler is called with. profile=release : Compile project with the release profile options (default). profile=debug : Compile project with the debug profile options. For a description of the release and debug profiles, see the modm:build module documentation. Debug Profile When working with the debug profile, make sure to add profile=debug to all commands, especially make program profile=debug and make debug profile=debug ! make build \u00b6 make build profile={debug|release} Compiles your application into an executable. Example for an embedded target: $ make build Compiling C++\u00b7\u00b7 {debug|release}/main.o Compiling C\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/ext/gcc/cabi.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf make clean \u00b6 make clean profile={debug|release} Cleans the build artifacts. $ make clean Removing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release} make run \u00b6 Compiles and executes your program on your computer. (* only Hosted targets ) make size \u00b6 make size profile={debug|release} Displays the static Flash and RAM consumption of your target. Example for a STM32 target with 16MB external heap: $ make size Memory usage\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf Program: 12.8 KiB (0.6% used) (.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.extern + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%) (.bss + .data + .fastdata + .stack) Heap: 16.4 MiB (.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern) make program \u00b6 make program profile={debug|release} [port={serial-port}] Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. (* only AVR and ARM Cortex-M targets ) Example for a STM32 target: $ make program Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.259396 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes Info : Dual Bank 2048 kiB STM32F42x/43x/469/479 found ... wrote 16384 bytes from file {debug|release}/blink.elf in 0.589736s (27.131 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.296308s (43.056 KiB/s) ** Verified OK ** shutdown command invoked make program-fuses \u00b6 make program-fuses profile={debug|release} Writes all fuses onto your target connected to avrdude. See the modm:platform:core module for how to define the fuse values. (* only AVR targets ) make program-dfu \u00b6 make program-dfu profile={debug|release} [delay={seconds}] Writes the executable onto your target via Device Firmware Update (DFU) over USB. A DFU bootloader is available on many STM32 microcontrollers and can be accessed by pressing the BOOT0-Button during startup. Some DFU devices require additional delay to re-enumerate, which you can specify with the delay parameter (default is 5 seconds). (* only ARM Cortex-M targets ) $ make program-dfu Binary File\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.bin dfu_stm32_programmer: program /build/{debug|release}/blink.bin dfu-util 0.9 Opening DFU capable USB device... ID 0483:df11 Run-time device DFU version 011a Claiming USB DFU Interface... Determining device status: state = dfuIDLE, status = 0 dfuIDLE, continuing DFU mode device DFU version 011a Device returned transfer size 2048 DfuSe interface name: \"Internal Flash \" Memory segment at 0x08000000 4 x 16384 = 65536 (rew) Memory segment at 0x08010000 1 x 65536 = 65536 (rew) Memory segment at 0x08020000 1 x 131072 = 131072 (rew) Downloading to address = 0x08000000, size = 2060 Download [ ] 0% 0 bytes Poll timeout 100 ms Poll timeout 0 ms Download from image offset 00000000 to memory 08000000-080007ff, size 2048 Poll timeout 104 ms Poll timeout 0 ms Download from image offset 00000800 to memory 08000800-0800080b, size 12 Poll timeout 104 ms Poll timeout 0 ms File downloaded successfully Poll timeout 104 ms Poll timeout 0 ms Transitioning to dfuMANIFEST state make program-bmp \u00b6 make program-bmp profile={debug|release} [port={serial-port}] Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. (* only ARM Cortex-M targets ) Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes. $ ls -l /dev/tty.usb* crw-rw-rw- 1 root wheel 21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF crw-rw-rw- 1 root wheel 21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1 You can let the tool guess the port or explicitly specify it: $ make program-bmp port=/dev/tty.usbmodemDEADBEEF Remote debugging using /dev/tty.usbmodemDEADBEEF Target voltage: unknown Available Targets: No. Att Driver 1 STM32F1 medium density Attaching to Remote target warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0800038e in ?? () Loading section .vector_rom, size 0xec lma 0x8000000 [...] Loading section .table.section_heap, size 0xc lma 0x80013f8 Start address 0x8000e6c, load size 5120 Transfer rate: 10 KB/sec, 365 bytes/write. Detaching from program: , Remote target [Inferior 1 (Remote target) detached] make: done building targets. make debug \u00b6 make debug profile={debug|release} ui={tui|web} Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based GDBGUI UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets ) This is just a convenience wrapper for the debug functionality defined in the modm:build module. To use GDBGUI you must have it installed via pip install gdbgui . Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the same or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to make debug profile=release , and if that doesn't help, compile and make program profile=debug and try make debug profile=debug again. make debug-bmp \u00b6 make debug-bmp profile={debug|release} ui={tui|web} port={serial-port} Launches GDB to debug via Black Magic Probe. (* only ARM Cortex-M targets ) make debug-coredump \u00b6 make debug-coredump profile={debug|release} ui={tui|web} \\ coredump={path/to/coredump.txt} Launches GDB for post-mortem debugging with the latest firmware using the data from the coredump={filepath} argument. (* only ARM Cortex-M targets ) See the modm:platform:fault module for details how to receive the coredump data. make reset \u00b6 make reset Resets the executable via OpenOCD. (* only ARM Cortex-M targets ) make reset-bmp \u00b6 make reset-bmp [port={serial}] Resets the executable via Black Magic Probe. (* only ARM Cortex-M targets ) make log-itm \u00b6 make log-itm fcpu={HCLK in Hz} Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. (* only ARM Cortex-M targets ) $ make log-itm fcpu=64000000 Open On-Chip Debugger 0.10.0 Licensed under GNU GPL v2 Info : The selected transport took over low-level target control. loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:itm module for details how to use the ITM as a logging output. make log-rtt \u00b6 make log-rtt [channel={int}] Configures OpenOCD in RTT mode to output the chosen channel (default 0) via a simple telnet client. Disconnect with Ctrl+D. (* only ARM Cortex-M targets ) $ make log-rtt Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:rtt module for details how to use RTT for data transfer. make library \u00b6 make library profile={debug|release} Generates only the static library libmodm.a without linking it to the application. $ make library Compiling C++\u00b7\u00b7 {debug|release}/modm/ext/gcc/assert.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a make symbols \u00b6 make symbols profile={debug|release} Dumps the symbol table for your executable. $ make symbols 536871656 00000001 b (anonymous namespace)::nextOperation 536871657 00000001 b (anonymous namespace)::checkNextOperation 536871658 00000001 b (anonymous namespace)::error 536871444 00000001 b read_touch()::initialized ... 134228236 00000668 T I2C1_EV_IRQHandler 134224924 00001136 T otm8009a_init(unsigned char) 134221192 00001378 t _GLOBAL__sub_I_p 536871782 00002054 b (anonymous namespace)::txBuffer make listing \u00b6 make listing profile={debug|release} Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions: $ make listing Listing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.lss $ less {debug|release}/blink.lss ... Disassembly of section .text: ... 08000d74 <main>: main(): ./main.cpp:315 int main() { 8000d74: b508 push {r3, lr} Board::initialize(); 8000d76: f7ff fcc9 bl 800070c <_ZN5Board10initializeEv> Board::initializeDisplay(); 8000d7a: f000 fd91 bl 80018a0 <_ZN5Board17initializeDisplayEv> Board::initializeTouchscreen(); 8000d7e: f7ff fc55 bl 800062c <_ZN5Board21initializeTouchscreenEv> blink(); 8000d82: f7ff feff bl 8000b84 <_Z12blinkv> ... make bin \u00b6 make bin profile={debug|release} Creates a binary file of your executable. $ make bin Binary File\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.bin make hex \u00b6 make hex profile={debug|release} Creates a Intel-hex file of your executable. $ make bin Hex File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.hex Information Tool \u00b6 This tool generates a set of header files containing information about the repository state. Setting the modm:build:info.git option will generate a <info_git.h> header file and add these two defines to the command line CPP options: MODM_GIT_INFO MODM_GIT_STATUS : defined only with option Git+Status . Increased build time Since the git repository status can change at any time, it needs to be checked on every build. This adds less than a second to every build. Setting the modm:build:info.build option will generate a <info_build.h> header file and add this define to the command line CPP options: MODM_BUILD_INFO Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need! Bitmap Tool \u00b6 If the modm:build:image.source is defined as a path, it'll be searched for .pbm files to convert into C++ data files using the bitmap tool. See the GraphicsDisplay::drawImage() method in the modm:ui:display module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as #include <image.hpp> . Options \u00b6 include_makefile \u00b6 Generate a Makefile This overwrites any top-level Makefile ! Default: True Inputs: [True, False] Collectors \u00b6 flag_format \u00b6 Formatting compile flags for Make Inputs: [Callable]","title":":build:make"},{"location":"reference/module/modm-build-make/#makefile-build-script-generator","text":"lbuild module: modm:build:make Make is a simple dependency tracking build system. It's very lightweight and available pretty much everywhere. This module generates a set of self contained Makefiles for building modm applications: a modm/config.mk file: configures the toolchain, device-specific information and sets up generic and special build rules based on the modm:build options. a modm/repo.mk file: contains all build rules to build the modm library. a top-level Makefile file: globs the application sources and provides all the Makefile targets for the device-specific embedded tools. We do not intend to serve every possible use-case with this module. If you need something special, write your own Makefile, maybe starting by modifying ours. Remember to set modm:build:make:include_makefile to False , so that your custom Makefile does not get overwritten by lbuild build . No Windows Support Due to issues with the Windows path separator \\ the generated Makefile may not work correctly on Windows. We recommend using SCons on Windows instead.","title":"Makefile Build Script Generator"},{"location":"reference/module/modm-build-make/#makefile-targets","text":"This module generates these .PHONY targets .","title":"Makefile Targets"},{"location":"reference/module/modm-build-make/#make","text":"Defaults to make build size . You can add these arguments to any of the Make commands: -j8 : Process 8 jobs in parallel. You can also export MAKEFLAGS=\"-j8\" in your .bashrc to have a permanent setting. -n : gives a verbose, simulated output, so you can check what options the compiler is called with. profile=release : Compile project with the release profile options (default). profile=debug : Compile project with the debug profile options. For a description of the release and debug profiles, see the modm:build module documentation. Debug Profile When working with the debug profile, make sure to add profile=debug to all commands, especially make program profile=debug and make debug profile=debug !","title":"make"},{"location":"reference/module/modm-build-make/#make-build","text":"make build profile={debug|release} Compiles your application into an executable. Example for an embedded target: $ make build Compiling C++\u00b7\u00b7 {debug|release}/main.o Compiling C\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/ext/gcc/cabi.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf","title":"make build"},{"location":"reference/module/modm-build-make/#make-clean","text":"make clean profile={debug|release} Cleans the build artifacts. $ make clean Removing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}","title":"make clean"},{"location":"reference/module/modm-build-make/#make-run","text":"Compiles and executes your program on your computer. (* only Hosted targets )","title":"make run"},{"location":"reference/module/modm-build-make/#make-size","text":"make size profile={debug|release} Displays the static Flash and RAM consumption of your target. Example for a STM32 target with 16MB external heap: $ make size Memory usage\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf Program: 12.8 KiB (0.6% used) (.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.extern + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%) (.bss + .data + .fastdata + .stack) Heap: 16.4 MiB (.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern)","title":"make size"},{"location":"reference/module/modm-build-make/#make-program","text":"make program profile={debug|release} [port={serial-port}] Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. (* only AVR and ARM Cortex-M targets ) Example for a STM32 target: $ make program Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.259396 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes Info : Dual Bank 2048 kiB STM32F42x/43x/469/479 found ... wrote 16384 bytes from file {debug|release}/blink.elf in 0.589736s (27.131 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.296308s (43.056 KiB/s) ** Verified OK ** shutdown command invoked","title":"make program"},{"location":"reference/module/modm-build-make/#make-program-fuses","text":"make program-fuses profile={debug|release} Writes all fuses onto your target connected to avrdude. See the modm:platform:core module for how to define the fuse values. (* only AVR targets )","title":"make program-fuses"},{"location":"reference/module/modm-build-make/#make-program-dfu","text":"make program-dfu profile={debug|release} [delay={seconds}] Writes the executable onto your target via Device Firmware Update (DFU) over USB. A DFU bootloader is available on many STM32 microcontrollers and can be accessed by pressing the BOOT0-Button during startup. Some DFU devices require additional delay to re-enumerate, which you can specify with the delay parameter (default is 5 seconds). (* only ARM Cortex-M targets ) $ make program-dfu Binary File\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.bin dfu_stm32_programmer: program /build/{debug|release}/blink.bin dfu-util 0.9 Opening DFU capable USB device... ID 0483:df11 Run-time device DFU version 011a Claiming USB DFU Interface... Determining device status: state = dfuIDLE, status = 0 dfuIDLE, continuing DFU mode device DFU version 011a Device returned transfer size 2048 DfuSe interface name: \"Internal Flash \" Memory segment at 0x08000000 4 x 16384 = 65536 (rew) Memory segment at 0x08010000 1 x 65536 = 65536 (rew) Memory segment at 0x08020000 1 x 131072 = 131072 (rew) Downloading to address = 0x08000000, size = 2060 Download [ ] 0% 0 bytes Poll timeout 100 ms Poll timeout 0 ms Download from image offset 00000000 to memory 08000000-080007ff, size 2048 Poll timeout 104 ms Poll timeout 0 ms Download from image offset 00000800 to memory 08000800-0800080b, size 12 Poll timeout 104 ms Poll timeout 0 ms File downloaded successfully Poll timeout 104 ms Poll timeout 0 ms Transitioning to dfuMANIFEST state","title":"make program-dfu"},{"location":"reference/module/modm-build-make/#make-program-bmp","text":"make program-bmp profile={debug|release} [port={serial-port}] Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. (* only ARM Cortex-M targets ) Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes. $ ls -l /dev/tty.usb* crw-rw-rw- 1 root wheel 21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF crw-rw-rw- 1 root wheel 21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1 You can let the tool guess the port or explicitly specify it: $ make program-bmp port=/dev/tty.usbmodemDEADBEEF Remote debugging using /dev/tty.usbmodemDEADBEEF Target voltage: unknown Available Targets: No. Att Driver 1 STM32F1 medium density Attaching to Remote target warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0800038e in ?? () Loading section .vector_rom, size 0xec lma 0x8000000 [...] Loading section .table.section_heap, size 0xc lma 0x80013f8 Start address 0x8000e6c, load size 5120 Transfer rate: 10 KB/sec, 365 bytes/write. Detaching from program: , Remote target [Inferior 1 (Remote target) detached] make: done building targets.","title":"make program-bmp"},{"location":"reference/module/modm-build-make/#make-debug","text":"make debug profile={debug|release} ui={tui|web} Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based GDBGUI UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets ) This is just a convenience wrapper for the debug functionality defined in the modm:build module. To use GDBGUI you must have it installed via pip install gdbgui . Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the same or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to make debug profile=release , and if that doesn't help, compile and make program profile=debug and try make debug profile=debug again.","title":"make debug"},{"location":"reference/module/modm-build-make/#make-debug-bmp","text":"make debug-bmp profile={debug|release} ui={tui|web} port={serial-port} Launches GDB to debug via Black Magic Probe. (* only ARM Cortex-M targets )","title":"make debug-bmp"},{"location":"reference/module/modm-build-make/#make-debug-coredump","text":"make debug-coredump profile={debug|release} ui={tui|web} \\ coredump={path/to/coredump.txt} Launches GDB for post-mortem debugging with the latest firmware using the data from the coredump={filepath} argument. (* only ARM Cortex-M targets ) See the modm:platform:fault module for details how to receive the coredump data.","title":"make debug-coredump"},{"location":"reference/module/modm-build-make/#make-reset","text":"make reset Resets the executable via OpenOCD. (* only ARM Cortex-M targets )","title":"make reset"},{"location":"reference/module/modm-build-make/#make-reset-bmp","text":"make reset-bmp [port={serial}] Resets the executable via Black Magic Probe. (* only ARM Cortex-M targets )","title":"make reset-bmp"},{"location":"reference/module/modm-build-make/#make-log-itm","text":"make log-itm fcpu={HCLK in Hz} Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. (* only ARM Cortex-M targets ) $ make log-itm fcpu=64000000 Open On-Chip Debugger 0.10.0 Licensed under GNU GPL v2 Info : The selected transport took over low-level target control. loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:itm module for details how to use the ITM as a logging output.","title":"make log-itm"},{"location":"reference/module/modm-build-make/#make-log-rtt","text":"make log-rtt [channel={int}] Configures OpenOCD in RTT mode to output the chosen channel (default 0) via a simple telnet client. Disconnect with Ctrl+D. (* only ARM Cortex-M targets ) $ make log-rtt Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:rtt module for details how to use RTT for data transfer.","title":"make log-rtt"},{"location":"reference/module/modm-build-make/#make-library","text":"make library profile={debug|release} Generates only the static library libmodm.a without linking it to the application. $ make library Compiling C++\u00b7\u00b7 {debug|release}/modm/ext/gcc/assert.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a","title":"make library"},{"location":"reference/module/modm-build-make/#make-symbols","text":"make symbols profile={debug|release} Dumps the symbol table for your executable. $ make symbols 536871656 00000001 b (anonymous namespace)::nextOperation 536871657 00000001 b (anonymous namespace)::checkNextOperation 536871658 00000001 b (anonymous namespace)::error 536871444 00000001 b read_touch()::initialized ... 134228236 00000668 T I2C1_EV_IRQHandler 134224924 00001136 T otm8009a_init(unsigned char) 134221192 00001378 t _GLOBAL__sub_I_p 536871782 00002054 b (anonymous namespace)::txBuffer","title":"make symbols"},{"location":"reference/module/modm-build-make/#make-listing","text":"make listing profile={debug|release} Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions: $ make listing Listing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.lss $ less {debug|release}/blink.lss ... Disassembly of section .text: ... 08000d74 <main>: main(): ./main.cpp:315 int main() { 8000d74: b508 push {r3, lr} Board::initialize(); 8000d76: f7ff fcc9 bl 800070c <_ZN5Board10initializeEv> Board::initializeDisplay(); 8000d7a: f000 fd91 bl 80018a0 <_ZN5Board17initializeDisplayEv> Board::initializeTouchscreen(); 8000d7e: f7ff fc55 bl 800062c <_ZN5Board21initializeTouchscreenEv> blink(); 8000d82: f7ff feff bl 8000b84 <_Z12blinkv> ...","title":"make listing"},{"location":"reference/module/modm-build-make/#make-bin","text":"make bin profile={debug|release} Creates a binary file of your executable. $ make bin Binary File\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.bin","title":"make bin"},{"location":"reference/module/modm-build-make/#make-hex","text":"make hex profile={debug|release} Creates a Intel-hex file of your executable. $ make bin Hex File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.hex","title":"make hex"},{"location":"reference/module/modm-build-make/#information-tool","text":"This tool generates a set of header files containing information about the repository state. Setting the modm:build:info.git option will generate a <info_git.h> header file and add these two defines to the command line CPP options: MODM_GIT_INFO MODM_GIT_STATUS : defined only with option Git+Status . Increased build time Since the git repository status can change at any time, it needs to be checked on every build. This adds less than a second to every build. Setting the modm:build:info.build option will generate a <info_build.h> header file and add this define to the command line CPP options: MODM_BUILD_INFO Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need!","title":"Information Tool"},{"location":"reference/module/modm-build-make/#bitmap-tool","text":"If the modm:build:image.source is defined as a path, it'll be searched for .pbm files to convert into C++ data files using the bitmap tool. See the GraphicsDisplay::drawImage() method in the modm:ui:display module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as #include <image.hpp> .","title":"Bitmap Tool"},{"location":"reference/module/modm-build-make/#options","text":"","title":"Options"},{"location":"reference/module/modm-build-make/#include_makefile","text":"Generate a Makefile This overwrites any top-level Makefile ! Default: True Inputs: [True, False]","title":"include_makefile"},{"location":"reference/module/modm-build-make/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-build-make/#flag_format","text":"Formatting compile flags for Make Inputs: [Callable]","title":"flag_format"},{"location":"reference/module/modm-build-scons/","text":"SCons Build Script Generator \u00b6 lbuild module: modm:build:scons SCons is a software construction build system written in Python. For a better embedded experience, we've extended it with modm-specific build tools. This module generates two files: a modm/SConscript file: configures all required SCons tools with the right settings (also using information from the modm:build module) to compile the modm library. a top-level SConstruct file: configures additional, optional tools and sets up all the relevant SCons functions for your target. The SConscript file is self contained and does not depend on anything outside of the modm/ directory. This allows it to be combined with SConscript of other projects without clashing. In fact, if you look at your generated SConstruct file, you'll notice that it doesn't contain a lot of logic or specific data, it is only meant for calling the right SCons tool with the right arguments. We do not intend to serve every possible use-case with this module. If you need something special, write your own SConstruct file, maybe starting by modifying ours. Remember to set modm:build:scons:include_sconstruct to False , so that your custom SConstruct does not get overwritten by lbuild build . See the instructions inside our generated default SConstruct . SCons Methods \u00b6 This module generates these SCons methods depending on the target. scons \u00b6 Defaults to scons build size . You can add these arguments to any of the SCons commands: verbose=1 : gives a more verbose output, so you can, for example, check what options the compiler is called with. profile=release : Compile project with the release profile options (default). profile=debug : Compile project with the debug profile options. For a description of the release and debug profiles, see the modm:build module documentation. Debug Profile When working with the debug profile, make sure to add profile=debug to all commands, especially scons program profile=debug and scons debug profile=debug ! Some SCons commands take a firmware={GNU Build ID or path/to/firmware.elf} argument that specifies which firmware to use for the command. It is useful in combination with the scons artifact command to preserve a specific firmware version for later. scons build \u00b6 scons build profile={debug|release} Compiles your application into an executable. Example for a STM32 target: $ scons build Compiling C++\u00b7\u00b7 {debug|release}/main.o Compiling C\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/ext/gcc/cabi.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf scons -c \u00b6 scons -c profile={debug|release} Cleans the build artifacts. $ scons -c Removed {debug|release}/main.o Removed {debug|release}/modm/ext/tlsf/tlsf.o ... Removed {debug|release}/modm/src/modm/ui/display/virtual_graphic_display.o Removed {debug|release}/modm/src/modm/utils/dummy.o Removed {debug|release}/modm/libmodm.a Removed {debug|release}/blink.elf Removed {debug|release}/blink.lss scons size \u00b6 scons size profile={debug|release} [firmware={hash or file}] Displays the static Flash and RAM consumption of your target. Example for a STM32 target with 16MB external heap: $ scons size Memory usage\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf Program: 12.8 KiB (0.6% used) (.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.extern + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%) (.bss + .data + .fastdata + .stack) Heap: 16.4 MiB (.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern) scons program \u00b6 scons program profile={debug|release} [port={serial-port}] [firmware={hash or file}] Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. (* only AVR and ARM Cortex-M targets ) Example for a STM32 target: $ scons program \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /build/{debug|release}/blink.elf \u2570\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> stm32f469nih Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.259396 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes Info : Dual Bank 2048 kiB STM32F42x/43x/469/479 found ... wrote 16384 bytes from file {debug|release}/blink.elf in 0.589736s (27.131 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.296308s (43.056 KiB/s) ** Verified OK ** shutdown command invoked scons program-fuses \u00b6 scons program-fuses profile={debug|release} [firmware={hash or file}] Writes all fuses onto your target connected to avrdude. See the modm:platform:core module for how to define the fuse values. (* only AVR targets ) scons program-dfu \u00b6 scons program-dfu profile={debug|release} [firmware={hash or file}] [delay={seconds}] Writes the executable onto your target via Device Firmware Update (DFU) over USB. A DFU bootloader is available on many STM32 microcontrollers and can be accessed by pressing the BOOT0-Button during startup. Some DFU devices require additional delay to re-enumerate, which you can specify with the delay parameter (default is 5 seconds). (* only ARM Cortex-M targets ) $ scons program-dfu Binary File\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.bin \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /build/{debug|release}/blink.bin \u2570\u2500\u2500\u2500\u2500\u2500DFU\u2500\u2500\u2500\u2500\u2500> stm32f469nih dfu_stm32_programmer: program /build/{debug|release}/blink.bin dfu-util 0.9 Opening DFU capable USB device... ID 0483:df11 Run-time device DFU version 011a Claiming USB DFU Interface... Determining device status: state = dfuIDLE, status = 0 dfuIDLE, continuing DFU mode device DFU version 011a Device returned transfer size 2048 DfuSe interface name: \"Internal Flash \" Memory segment at 0x08000000 4 x 16384 = 65536 (rew) Memory segment at 0x08010000 1 x 65536 = 65536 (rew) Memory segment at 0x08020000 1 x 131072 = 131072 (rew) Downloading to address = 0x08000000, size = 2060 Download [ ] 0% 0 bytes Poll timeout 100 ms Poll timeout 0 ms Download from image offset 00000000 to memory 08000000-080007ff, size 2048 Poll timeout 104 ms Poll timeout 0 ms Download from image offset 00000800 to memory 08000800-0800080b, size 12 Poll timeout 104 ms Poll timeout 0 ms File downloaded successfully Poll timeout 104 ms Poll timeout 0 ms Transitioning to dfuMANIFEST state scons: done building targets. scons program-bmp \u00b6 scons program-bmp profile={debug|release} [port={serial-port}] [firmware={hash or file}] Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. (* only ARM Cortex-M targets ) Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes. $ ls -l /dev/tty.usb* crw-rw-rw- 1 root wheel 21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF crw-rw-rw- 1 root wheel 21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1 You can let the tool guess the port or explicitly specify it: $ scons program-bmp port=/dev/tty.usbmodemDEADBEEF \u256d\u2500Black\u2500Magic\u2500\u2500 /build/{debug|release}/blink.elf \u2570\u2500\u2500\u2500\u2500Probe\u2500\u2500\u2500\u2500> stm32f103rbt6 Remote debugging using /dev/tty.usbmodemDEADBEEF Target voltage: unknown Available Targets: No. Att Driver 1 STM32F1 medium density Attaching to Remote target warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0800038e in ?? () Loading section .vector_rom, size 0xec lma 0x8000000 [...] Loading section .table.section_heap, size 0xc lma 0x80013f8 Start address 0x8000e6c, load size 5120 Transfer rate: 10 KB/sec, 365 bytes/write. Detaching from program: , Remote target [Inferior 1 (Remote target) detached] scons: done building targets. scons program-remote \u00b6 scons program-remote profile={debug|release} [host={ip or hostname}] [firmware={hash or file}] Writes the executable onto your target connected to a remote OpenOCD process running on your own computer (host= localhost ) or somewhere else. scons run \u00b6 Compiles and executes your program on your computer. (* only Hosted targets ) scons debug \u00b6 scons debug profile={debug|release} ui={tui|web} [firmware={hash or file}] Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based GDBGUI UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets ) This is just a convenience wrapper for the debug functionality defined in the modm:build module. To use GDBGUI you must have it installed via pip install gdbgui . Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the same or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to scons debug profile=release , and if that doesn't help, compile and scons program profile=debug and try scons debug profile=debug again. scons debug-bmp \u00b6 scons debug-bmp profile={debug|release} ui={tui|web} port={serial-port} [firmware={hash or file}] Launches GDB to debug via Black Magic Probe. (* only ARM Cortex-M targets ) scons debug-coredump \u00b6 scons debug-coredump profile={debug|release} ui={tui|web} \\ coredump={path/to/coredump.txt} \\ [firmware={GNU Build ID or path/to/firmware.elf}] Launches GDB for post-mortem debugging with the firmware identified by the (optional) firmware={hash or filepath} argument using the data from the coredump={filepath} argument. (* only ARM Cortex-M targets ) See the modm:platform:fault module for details how to receive the coredump data. scons program-remote \u00b6 scons debug-remote profile={debug|release} ui={tui|web} [host={ip or hostname}] [firmware={hash or file}] Debugs the executable via a remote OpenOCD process running on your own computer (localhost is default) or somewhere else. (* only ARM Cortex-M targets ) scons reset \u00b6 scons reset Resets the executable via OpenOCD. (* only ARM Cortex-M targets ) scons reset-bmp \u00b6 scons reset-bmp [port={serial}] Resets the executable via Black Magic Probe. (* only ARM Cortex-M targets ) scons reset-remote \u00b6 scons reset-remote [host={ip or hostname}] Resets the executable via a remote OpenOCD process running on your own computer (localhost is default) or somewhere else. (* only ARM Cortex-M targets ) scons log-itm \u00b6 scons log-itm fcpu={HCLK in Hz} Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. (* only ARM Cortex-M targets ) $ scons log-itm fcpu=64000000 \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Single Wire Viewer \u2570\u2500\u2500\u2500\u2500\u2500SWO\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt6 Open On-Chip Debugger 0.10.0 Licensed under GNU GPL v2 Info : The selected transport took over low-level target control. loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:itm module for details how to use the ITM as a logging output. scons log-rtt \u00b6 scons log-rtt [channel={int}] Configures OpenOCD in RTT mode to output the chosen channel (default 0) via a simple telnet client. Disconnect with Ctrl+D. (* only ARM Cortex-M targets ) $ scons log-rtt \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Real Time Transfer \u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt6 Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:rtt module for details how to use RTT for data transfer. scons library \u00b6 scons library profile={debug|release} Generates only the static library libmodm.a without linking it to the application. $ scons library Compiling C++\u00b7\u00b7 {debug|release}/modm/ext/gcc/assert.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a scons symbols \u00b6 scons symbols profile={debug|release} [firmware={hash or file}] Dumps the symbol table for your executable. $ scons symbols [firmware={hash or file}] Show symbols for '{debug|release}/blink.elf': 536871656 00000001 b (anonymous namespace)::nextOperation 536871657 00000001 b (anonymous namespace)::checkNextOperation 536871658 00000001 b (anonymous namespace)::error 536871444 00000001 b read_touch()::initialized ... 134228236 00000668 T I2C1_EV_IRQHandler 134224924 00001136 T otm8009a_init(unsigned char) 134221192 00001378 t _GLOBAL__sub_I_p 536871782 00002054 b (anonymous namespace)::txBuffer scons listing \u00b6 scons listing profile={debug|release} [firmware={hash or file}] Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions: $ scons listing Listing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.lss $ less {debug|release}/blink.lss ... Disassembly of section .text: ... 08000d74 <main>: main(): ./main.cpp:315 int main() { 8000d74: b508 push {r3, lr} Board::initialize(); 8000d76: f7ff fcc9 bl 800070c <_ZN5Board10initializeEv> Board::initializeDisplay(); 8000d7a: f000 fd91 bl 80018a0 <_ZN5Board17initializeDisplayEv> Board::initializeTouchscreen(); 8000d7e: f7ff fc55 bl 800062c <_ZN5Board21initializeTouchscreenEv> blink(); 8000d82: f7ff feff bl 8000b84 <_Z12blinkv> ... scons bin \u00b6 scons bin profile={debug|release} [firmware={hash or file}] Creates a binary file of your executable. $ scons bin Binary File\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.bin scons hex \u00b6 scons hex profile={debug|release} [firmware={hash or file}] Creates a Intel-hex file of your executable. $ scons hex Hex File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.hex scons artifact \u00b6 scons artifact profile={debug|release} Caches the ELF and binary file of the newest compiled executable identified by the hash of the binary file in artifacts/{hash}.elf . You can change this path with the modm:build:scons:path.artifact option. $ scons artifact \u256d\u2500\u2500\u2500Artifact\u2500\u2500\u2500 /build/release/blink.elf \u2570\u2500\u2500\u2500\u2500Cache\u2500\u2500\u2500\u2500> artifacts/0214523ab713bc7bdfb37d902e65dae8305f4754.elf scons qtcreator \u00b6 Generates several files so that the project can be imported into Qt Creator via the .creator file importer. Note, that no compiliation or debugging features are supported, this is only meant for using the IDE as an editor. Consider this an unstable feature XPCC Generator Tool \u00b6 The modm:communication:xpcc:generator module contains the Python tools to translate the XPCC XML declarations into various language implementations. This module contains a SCons wrapper tool, that understands the XML dependencies and automatically updates the generated files when it becomes necessary. The wrapper tool is automatically used when the generator module is detected, and its options are evaluated for the wrapper as follows: env . XpccCommunication ( xmlfile = options [ \"::xpcc:generator:source\" ], container = options [ \"::xpcc:generator:container\" ], path = options [ \"::xpcc:generator:path\" ], namespace = options [ \"::xpcc:generator:namespace\" ] ) The generated files are available as a top-level #include <identifiers.hpp> . Information Tool \u00b6 Our info SCons tool generates a set of header files containing information about the repository state. A call to env.InfoGit(with_status={True, False}) will generate a <info_git.h> header file and add these two defines to the command line CPP options: MODM_GIT_INFO MODM_GIT_STATUS : defined only if called with with_state=True . You can enable this by setting the modm:build:info.git option. Increased build time Since the git repository status can change at any time, it needs to be checked on every build. This adds less than a second to every build. A call to env.InfoBuild() will generate a <info_build.h> header file and add this define to the command line CPP options: MODM_BUILD_INFO You can enable this by setting the modm:build:info.build option. Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need! Bitmap Tool \u00b6 If the modm:build:image.source is defined as a path, it'll be searched for .pbm files to convert into C++ data files using the bitmap tool: source , header = env . Bitmap ( bpm_file ) See the GraphicsDisplay::drawImage() method in the modm:ui:display module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as #include <image.hpp> . Options \u00b6 cache_dir \u00b6 Path to SConstruct CacheDir If value is $cache , the cache is placed into the top-level build/ folder. You can disable CacheDir by setting an empty string. Default: [] Inputs: [Path] include_sconstruct \u00b6 Generate a SConstruct file This overwrites any top-level SConstruct file! Default: True Inputs: [True, False] path.artifact \u00b6 Path to Artifact Store The artifact folder contains ELF files named by their GNU build id hash. This allows identification of firmware on the device via serial output and is useful for archiving or post-mortem debugging. Default: artifacts Inputs: [Path] Collectors \u00b6 flag_format \u00b6 Formatting compile flags for SCons Inputs: [Callable] path.tools \u00b6 SCons tool paths to be added to the Environment Inputs: [Path] tools \u00b6 SCons tools to be added to the Environment Inputs: [String]","title":":build:scons"},{"location":"reference/module/modm-build-scons/#scons-build-script-generator","text":"lbuild module: modm:build:scons SCons is a software construction build system written in Python. For a better embedded experience, we've extended it with modm-specific build tools. This module generates two files: a modm/SConscript file: configures all required SCons tools with the right settings (also using information from the modm:build module) to compile the modm library. a top-level SConstruct file: configures additional, optional tools and sets up all the relevant SCons functions for your target. The SConscript file is self contained and does not depend on anything outside of the modm/ directory. This allows it to be combined with SConscript of other projects without clashing. In fact, if you look at your generated SConstruct file, you'll notice that it doesn't contain a lot of logic or specific data, it is only meant for calling the right SCons tool with the right arguments. We do not intend to serve every possible use-case with this module. If you need something special, write your own SConstruct file, maybe starting by modifying ours. Remember to set modm:build:scons:include_sconstruct to False , so that your custom SConstruct does not get overwritten by lbuild build . See the instructions inside our generated default SConstruct .","title":"SCons Build Script Generator"},{"location":"reference/module/modm-build-scons/#scons-methods","text":"This module generates these SCons methods depending on the target.","title":"SCons Methods"},{"location":"reference/module/modm-build-scons/#scons","text":"Defaults to scons build size . You can add these arguments to any of the SCons commands: verbose=1 : gives a more verbose output, so you can, for example, check what options the compiler is called with. profile=release : Compile project with the release profile options (default). profile=debug : Compile project with the debug profile options. For a description of the release and debug profiles, see the modm:build module documentation. Debug Profile When working with the debug profile, make sure to add profile=debug to all commands, especially scons program profile=debug and scons debug profile=debug ! Some SCons commands take a firmware={GNU Build ID or path/to/firmware.elf} argument that specifies which firmware to use for the command. It is useful in combination with the scons artifact command to preserve a specific firmware version for later.","title":"scons"},{"location":"reference/module/modm-build-scons/#scons-build","text":"scons build profile={debug|release} Compiles your application into an executable. Example for a STM32 target: $ scons build Compiling C++\u00b7\u00b7 {debug|release}/main.o Compiling C\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/ext/gcc/cabi.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Linking\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf","title":"scons build"},{"location":"reference/module/modm-build-scons/#scons-c","text":"scons -c profile={debug|release} Cleans the build artifacts. $ scons -c Removed {debug|release}/main.o Removed {debug|release}/modm/ext/tlsf/tlsf.o ... Removed {debug|release}/modm/src/modm/ui/display/virtual_graphic_display.o Removed {debug|release}/modm/src/modm/utils/dummy.o Removed {debug|release}/modm/libmodm.a Removed {debug|release}/blink.elf Removed {debug|release}/blink.lss","title":"scons -c"},{"location":"reference/module/modm-build-scons/#scons-size","text":"scons size profile={debug|release} [firmware={hash or file}] Displays the static Flash and RAM consumption of your target. Example for a STM32 target with 16MB external heap: $ scons size Memory usage\u00b7\u00b7\u00b7 /build/{debug|release}/blink.elf Program: 12.8 KiB (0.6% used) (.data + .fastcode + .fastdata + .hardware_init + .reset + .rodata + .table.copy.extern + .table.copy.intern + .table.section_heap + .table.zero.intern + .text) Data: 5.8 KiB (1.5% used) = 2936 B static (0.7%) + 3040 B stack (0.8%) (.bss + .data + .fastdata + .stack) Heap: 16.4 MiB (.heap0 + .heap1 + .heap2 + .heap3 + .heap5 + .heap_extern)","title":"scons size"},{"location":"reference/module/modm-build-scons/#scons-program","text":"scons program profile={debug|release} [port={serial-port}] [firmware={hash or file}] Writes the executable onto your target via Avrdude or OpenOCD. This is a convenience wrapper around the programming options and methods defined in the modm:build module. (* only AVR and ARM Cortex-M targets ) Example for a STM32 target: $ scons program \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /build/{debug|release}/blink.elf \u2570\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> stm32f469nih Open On-Chip Debugger 0.10.0 ... Info : using stlink api v2 Info : Target voltage: 3.259396 Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints ... ** Programming Started ** auto erase enabled Info : device id = 0x10006434 Info : flash size = 2048kbytes Info : Dual Bank 2048 kiB STM32F42x/43x/469/479 found ... wrote 16384 bytes from file {debug|release}/blink.elf in 0.589736s (27.131 KiB/s) ** Programming Finished ** ** Verify Started ** verified 13064 bytes in 0.296308s (43.056 KiB/s) ** Verified OK ** shutdown command invoked","title":"scons program"},{"location":"reference/module/modm-build-scons/#scons-program-fuses","text":"scons program-fuses profile={debug|release} [firmware={hash or file}] Writes all fuses onto your target connected to avrdude. See the modm:platform:core module for how to define the fuse values. (* only AVR targets )","title":"scons program-fuses"},{"location":"reference/module/modm-build-scons/#scons-program-dfu","text":"scons program-dfu profile={debug|release} [firmware={hash or file}] [delay={seconds}] Writes the executable onto your target via Device Firmware Update (DFU) over USB. A DFU bootloader is available on many STM32 microcontrollers and can be accessed by pressing the BOOT0-Button during startup. Some DFU devices require additional delay to re-enumerate, which you can specify with the delay parameter (default is 5 seconds). (* only ARM Cortex-M targets ) $ scons program-dfu Binary File\u00b7\u00b7\u00b7\u00b7 /build/{debug|release}/blink.bin \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /build/{debug|release}/blink.bin \u2570\u2500\u2500\u2500\u2500\u2500DFU\u2500\u2500\u2500\u2500\u2500> stm32f469nih dfu_stm32_programmer: program /build/{debug|release}/blink.bin dfu-util 0.9 Opening DFU capable USB device... ID 0483:df11 Run-time device DFU version 011a Claiming USB DFU Interface... Determining device status: state = dfuIDLE, status = 0 dfuIDLE, continuing DFU mode device DFU version 011a Device returned transfer size 2048 DfuSe interface name: \"Internal Flash \" Memory segment at 0x08000000 4 x 16384 = 65536 (rew) Memory segment at 0x08010000 1 x 65536 = 65536 (rew) Memory segment at 0x08020000 1 x 131072 = 131072 (rew) Downloading to address = 0x08000000, size = 2060 Download [ ] 0% 0 bytes Poll timeout 100 ms Poll timeout 0 ms Download from image offset 00000000 to memory 08000000-080007ff, size 2048 Poll timeout 104 ms Poll timeout 0 ms Download from image offset 00000800 to memory 08000800-0800080b, size 12 Poll timeout 104 ms Poll timeout 0 ms File downloaded successfully Poll timeout 104 ms Poll timeout 0 ms Transitioning to dfuMANIFEST state scons: done building targets.","title":"scons program-dfu"},{"location":"reference/module/modm-build-scons/#scons-program-bmp","text":"scons program-bmp profile={debug|release} [port={serial-port}] [firmware={hash or file}] Black Magic Probe is convenient tool to convert cheap USB ST-LINK V2 clones to a fully functional GDB compatible debug adaptor for ARM Cortex microcontrollers. GDB can directly communicate with the debug adaptor making debugging easy and accessible. (* only ARM Cortex-M targets ) Black Magic Probe creates two serial devices, the first being the GDB interface and the second a plain serial adaptor for debugging purposes. $ ls -l /dev/tty.usb* crw-rw-rw- 1 root wheel 21, 104 Feb 19 09:46 /dev/tty.usbmodemDEADBEEF crw-rw-rw- 1 root wheel 21, 106 Feb 19 09:46 /dev/tty.usbmodemDEADBEF1 You can let the tool guess the port or explicitly specify it: $ scons program-bmp port=/dev/tty.usbmodemDEADBEEF \u256d\u2500Black\u2500Magic\u2500\u2500 /build/{debug|release}/blink.elf \u2570\u2500\u2500\u2500\u2500Probe\u2500\u2500\u2500\u2500> stm32f103rbt6 Remote debugging using /dev/tty.usbmodemDEADBEEF Target voltage: unknown Available Targets: No. Att Driver 1 STM32F1 medium density Attaching to Remote target warning: No executable has been specified and target does not support determining executable automatically. Try using the \"file\" command. 0x0800038e in ?? () Loading section .vector_rom, size 0xec lma 0x8000000 [...] Loading section .table.section_heap, size 0xc lma 0x80013f8 Start address 0x8000e6c, load size 5120 Transfer rate: 10 KB/sec, 365 bytes/write. Detaching from program: , Remote target [Inferior 1 (Remote target) detached] scons: done building targets.","title":"scons program-bmp"},{"location":"reference/module/modm-build-scons/#scons-program-remote","text":"scons program-remote profile={debug|release} [host={ip or hostname}] [firmware={hash or file}] Writes the executable onto your target connected to a remote OpenOCD process running on your own computer (host= localhost ) or somewhere else.","title":"scons program-remote"},{"location":"reference/module/modm-build-scons/#scons-run","text":"Compiles and executes your program on your computer. (* only Hosted targets )","title":"scons run"},{"location":"reference/module/modm-build-scons/#scons-debug","text":"scons debug profile={debug|release} ui={tui|web} [firmware={hash or file}] Launches OpenOCD in the background, then launches GDB in foreground with the correct executable with text-based or web-based GDBGUI UI. When GDB exits, it stops the OpenOCD process. (* only ARM Cortex-M targets ) This is just a convenience wrapper for the debug functionality defined in the modm:build module. To use GDBGUI you must have it installed via pip install gdbgui . Choose the correct profile When debugging, make sure to select the correct compilation profile. The firmware and the executable given to GDB have to be the same or you'll see GDB translate the program counter to the wrong code locations. When you suspect a bug in your firmware, consider that it was most likely compiled with the release profile, since that's the default. First try to scons debug profile=release , and if that doesn't help, compile and scons program profile=debug and try scons debug profile=debug again.","title":"scons debug"},{"location":"reference/module/modm-build-scons/#scons-debug-bmp","text":"scons debug-bmp profile={debug|release} ui={tui|web} port={serial-port} [firmware={hash or file}] Launches GDB to debug via Black Magic Probe. (* only ARM Cortex-M targets )","title":"scons debug-bmp"},{"location":"reference/module/modm-build-scons/#scons-debug-coredump","text":"scons debug-coredump profile={debug|release} ui={tui|web} \\ coredump={path/to/coredump.txt} \\ [firmware={GNU Build ID or path/to/firmware.elf}] Launches GDB for post-mortem debugging with the firmware identified by the (optional) firmware={hash or filepath} argument using the data from the coredump={filepath} argument. (* only ARM Cortex-M targets ) See the modm:platform:fault module for details how to receive the coredump data.","title":"scons debug-coredump"},{"location":"reference/module/modm-build-scons/#scons-program-remote_1","text":"scons debug-remote profile={debug|release} ui={tui|web} [host={ip or hostname}] [firmware={hash or file}] Debugs the executable via a remote OpenOCD process running on your own computer (localhost is default) or somewhere else. (* only ARM Cortex-M targets )","title":"scons program-remote"},{"location":"reference/module/modm-build-scons/#scons-reset","text":"scons reset Resets the executable via OpenOCD. (* only ARM Cortex-M targets )","title":"scons reset"},{"location":"reference/module/modm-build-scons/#scons-reset-bmp","text":"scons reset-bmp [port={serial}] Resets the executable via Black Magic Probe. (* only ARM Cortex-M targets )","title":"scons reset-bmp"},{"location":"reference/module/modm-build-scons/#scons-reset-remote","text":"scons reset-remote [host={ip or hostname}] Resets the executable via a remote OpenOCD process running on your own computer (localhost is default) or somewhere else. (* only ARM Cortex-M targets )","title":"scons reset-remote"},{"location":"reference/module/modm-build-scons/#scons-log-itm","text":"scons log-itm fcpu={HCLK in Hz} Configures OpenOCD in tracing mode to output ITM channel 0 on SWO pin and displays the serial output stream. (* only ARM Cortex-M targets ) $ scons log-itm fcpu=64000000 \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Single Wire Viewer \u2570\u2500\u2500\u2500\u2500\u2500SWO\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt6 Open On-Chip Debugger 0.10.0 Licensed under GNU GPL v2 Info : The selected transport took over low-level target control. loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:itm module for details how to use the ITM as a logging output.","title":"scons log-itm"},{"location":"reference/module/modm-build-scons/#scons-log-rtt","text":"scons log-rtt [channel={int}] Configures OpenOCD in RTT mode to output the chosen channel (default 0) via a simple telnet client. Disconnect with Ctrl+D. (* only ARM Cortex-M targets ) $ scons log-rtt \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Real Time Transfer \u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt6 Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 loop: 57 loop: 58 loop: 59 loop: 60 loop: 61 See the modm:platform:rtt module for details how to use RTT for data transfer.","title":"scons log-rtt"},{"location":"reference/module/modm-build-scons/#scons-library","text":"scons library profile={debug|release} Generates only the static library libmodm.a without linking it to the application. $ scons library Compiling C++\u00b7\u00b7 {debug|release}/modm/ext/gcc/assert.o ... Compiling C++\u00b7\u00b7 {debug|release}/modm/src/modm/utils/dummy.o Archiving\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a Indexing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/modm/libmodm.a","title":"scons library"},{"location":"reference/module/modm-build-scons/#scons-symbols","text":"scons symbols profile={debug|release} [firmware={hash or file}] Dumps the symbol table for your executable. $ scons symbols [firmware={hash or file}] Show symbols for '{debug|release}/blink.elf': 536871656 00000001 b (anonymous namespace)::nextOperation 536871657 00000001 b (anonymous namespace)::checkNextOperation 536871658 00000001 b (anonymous namespace)::error 536871444 00000001 b read_touch()::initialized ... 134228236 00000668 T I2C1_EV_IRQHandler 134224924 00001136 T otm8009a_init(unsigned char) 134221192 00001378 t _GLOBAL__sub_I_p 536871782 00002054 b (anonymous namespace)::txBuffer","title":"scons symbols"},{"location":"reference/module/modm-build-scons/#scons-listing","text":"scons listing profile={debug|release} [firmware={hash or file}] Decompiles your executable into an annotated assembly listing. This is very useful for checking and learning how the compiler translates C++ into assembly instructions: $ scons listing Listing\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.lss $ less {debug|release}/blink.lss ... Disassembly of section .text: ... 08000d74 <main>: main(): ./main.cpp:315 int main() { 8000d74: b508 push {r3, lr} Board::initialize(); 8000d76: f7ff fcc9 bl 800070c <_ZN5Board10initializeEv> Board::initializeDisplay(); 8000d7a: f000 fd91 bl 80018a0 <_ZN5Board17initializeDisplayEv> Board::initializeTouchscreen(); 8000d7e: f7ff fc55 bl 800062c <_ZN5Board21initializeTouchscreenEv> blink(); 8000d82: f7ff feff bl 8000b84 <_Z12blinkv> ...","title":"scons listing"},{"location":"reference/module/modm-build-scons/#scons-bin","text":"scons bin profile={debug|release} [firmware={hash or file}] Creates a binary file of your executable. $ scons bin Binary File\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.bin","title":"scons bin"},{"location":"reference/module/modm-build-scons/#scons-hex","text":"scons hex profile={debug|release} [firmware={hash or file}] Creates a Intel-hex file of your executable. $ scons hex Hex File\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 {debug|release}/blink.hex","title":"scons hex"},{"location":"reference/module/modm-build-scons/#scons-artifact","text":"scons artifact profile={debug|release} Caches the ELF and binary file of the newest compiled executable identified by the hash of the binary file in artifacts/{hash}.elf . You can change this path with the modm:build:scons:path.artifact option. $ scons artifact \u256d\u2500\u2500\u2500Artifact\u2500\u2500\u2500 /build/release/blink.elf \u2570\u2500\u2500\u2500\u2500Cache\u2500\u2500\u2500\u2500> artifacts/0214523ab713bc7bdfb37d902e65dae8305f4754.elf","title":"scons artifact"},{"location":"reference/module/modm-build-scons/#scons-qtcreator","text":"Generates several files so that the project can be imported into Qt Creator via the .creator file importer. Note, that no compiliation or debugging features are supported, this is only meant for using the IDE as an editor. Consider this an unstable feature","title":"scons qtcreator"},{"location":"reference/module/modm-build-scons/#xpcc-generator-tool","text":"The modm:communication:xpcc:generator module contains the Python tools to translate the XPCC XML declarations into various language implementations. This module contains a SCons wrapper tool, that understands the XML dependencies and automatically updates the generated files when it becomes necessary. The wrapper tool is automatically used when the generator module is detected, and its options are evaluated for the wrapper as follows: env . XpccCommunication ( xmlfile = options [ \"::xpcc:generator:source\" ], container = options [ \"::xpcc:generator:container\" ], path = options [ \"::xpcc:generator:path\" ], namespace = options [ \"::xpcc:generator:namespace\" ] ) The generated files are available as a top-level #include <identifiers.hpp> .","title":"XPCC Generator Tool"},{"location":"reference/module/modm-build-scons/#information-tool","text":"Our info SCons tool generates a set of header files containing information about the repository state. A call to env.InfoGit(with_status={True, False}) will generate a <info_git.h> header file and add these two defines to the command line CPP options: MODM_GIT_INFO MODM_GIT_STATUS : defined only if called with with_state=True . You can enable this by setting the modm:build:info.git option. Increased build time Since the git repository status can change at any time, it needs to be checked on every build. This adds less than a second to every build. A call to env.InfoBuild() will generate a <info_build.h> header file and add this define to the command line CPP options: MODM_BUILD_INFO You can enable this by setting the modm:build:info.build option. Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need!","title":"Information Tool"},{"location":"reference/module/modm-build-scons/#bitmap-tool","text":"If the modm:build:image.source is defined as a path, it'll be searched for .pbm files to convert into C++ data files using the bitmap tool: source , header = env . Bitmap ( bpm_file ) See the GraphicsDisplay::drawImage() method in the modm:ui:display module for how to use these generated files. The directory is added to the include search paths, so the generated files can be accessed as #include <image.hpp> .","title":"Bitmap Tool"},{"location":"reference/module/modm-build-scons/#options","text":"","title":"Options"},{"location":"reference/module/modm-build-scons/#cache_dir","text":"Path to SConstruct CacheDir If value is $cache , the cache is placed into the top-level build/ folder. You can disable CacheDir by setting an empty string. Default: [] Inputs: [Path]","title":"cache_dir"},{"location":"reference/module/modm-build-scons/#include_sconstruct","text":"Generate a SConstruct file This overwrites any top-level SConstruct file! Default: True Inputs: [True, False]","title":"include_sconstruct"},{"location":"reference/module/modm-build-scons/#pathartifact","text":"Path to Artifact Store The artifact folder contains ELF files named by their GNU build id hash. This allows identification of firmware on the device via serial output and is useful for archiving or post-mortem debugging. Default: artifacts Inputs: [Path]","title":"path.artifact"},{"location":"reference/module/modm-build-scons/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-build-scons/#flag_format","text":"Formatting compile flags for SCons Inputs: [Callable]","title":"flag_format"},{"location":"reference/module/modm-build-scons/#pathtools","text":"SCons tool paths to be added to the Environment Inputs: [Path]","title":"path.tools"},{"location":"reference/module/modm-build-scons/#tools","text":"SCons tools to be added to the Environment Inputs: [String]","title":"tools"},{"location":"reference/module/modm-build/","text":"Build System Generators \u00b6 lbuild module: modm:build This parent module defines a common set of functionality that is independent of the specific build system generator implementation. This includes straight-forward options like project name and build path but also more complicated configuration for programming your target via AvrDude or OpenOCD and debugging via GDB. Note that this module does not compile your project, you will need to choose the modm:build:scons or modm:build:cmake submodule for that, or provide your own build system. Compiler Options \u00b6 We maintain a common set of compiler options for all build system generator, so that they all have feature parity. We currently only support compiling modm with GCC for AVR, ARM Cortex-M and x86/posix with the options mentioned in the offical GCC options documentation . You can find all compiler options inside the generated build script for your project, the options presented here are only the most important ones. Shared for C and C++ \u00b6 -W{all, extra} : a basic set of warnings. -Werror={format, maybe-uninitialized, overflow, sign-compare} : these warnings are treated as errors. -f{data, function}-sections : puts data and functions into their own linker section. -funsigned-{char, bitfields} : modm tries to use stdint.h types everywhere, but just in case. -fwrapv : integer overflows wrap around according to 2s complement. For release builds : -Os : optimize for smaller size. For debug builds : -Og : optimize for debugging experience. Only C \u00b6 -std=gnu11 : use C11 with GNU extensions (for asm volatile ). Only C++ \u00b6 -std=c++20 : use C++20 For exception and RTTI flags, see modm:stdc++ module. Linker \u00b6 --gc-section : garbage collecting sections throws out a lot of unused data/code. -L{linkdir} -Tlinkerscript.ld : modm uses a custom linkerscript. For target specific flags, see the modm:platform:core and related modules. Configuration \u00b6 This module generates a common set of configuration files that are used by the common tooling. Please note that these files are the foundation of more extensive tooling available as Python scripts which are then again wrapped by your chosen build system for convenience. OpenOCD \u00b6 For accessing your ARM Cortex-M based device, we use OpenOCD by default and generate a modm/openocd.cfg file with the target specific configuration: Search directories passed via the path.openocd collector. User configuration files passed via the openocd.source collector. Your custom modm:build:openocd.cfg is added here too. You need to start openocd with this configuration file: openocd -f modm/openocd.cfg Be careful attaching to a running target The OpenOCD implementation halts the target at least while the device's debug peripheral is initialized. Only connect to systems that cannot create any damage while being halted! For example halting motor controllers may damage motors!! AvrDude \u00b6 Unfortunately AvrDude does not support a project-specific configuration file like OpenOCD does (only a undocumented user config in ~/.avrduderc ), so there is no convenient one-line command to issue. You have to use the wrapper support of the specific build system or simply call AvrDude yourself via its command line. GDB \u00b6 Two commands are provided for convenience via the modm/gdbinit configuration: restart resets the device and halts. rerun resets the device and continues execution. GDB continues running the target after attaching, but does not load an ELF file! Please pass the ELF file as a command line argument. You can start your GDB session like so: arm-none-eabi-gdb -x modm/gdbinit path/to/project.elf Generic Python Tools \u00b6 We have written a number of pure Python tools to provide common functionality that get wrapped by the build system. Here is a selection of tools that have a command line interface, so you can call them even without build system support in case you have a special setup. Note that there are even more tools that can be called in Python only, so have a look in your generated modm/modm_tools folder. AvrDude \u00b6 This tool simply wraps the avrdude command to provide two features: guessing the serial port when a baudrate was set. inspecting the ELF file to decide whether EEPROM needs to be programmed. python3 modm/modm_tools/avrdude.py -p m328p -c arduino -P auto -b 57600 \\\\ path/to/project.elf Fuses stored in the ELF file can be programmed by passing --fuse arguments: python3 modm/modm_tools/avrdude.py -p m328p -c stk500v2 path/to/project.elf \\\\ --fuse hfuse --fuse lfuse --fuse efuse (* only AVR targets ) OpenOCD \u00b6 Simply wraps OpenOCD and issues the right command to program the target. python3 modm/modm_tools/openocd.py -f modm/openocd.cfg path/to/project.elf You can also reset the target: python3 modm/modm_tools/openocd.py -f modm/openocd.cfg --reset (* only ARM Cortex-M targets ) Black Magic Probe \u00b6 This tool wraps GDB to program an ELF file onto a target connected to a BMP. You can explictly pass the serial port, or let the tool guess it. python3 modm/modm_tools/bmp.py path/to/project.elf # or choose the port explicitly python3 modm/modm_tools/bmp.py path/to/project.elf -p /dev/tty.usbserial-123 You can also reset the target: python3 modm/modm_tools/bmp.py --reset (* only ARM Cortex-M targets ) GDB \u00b6 For debugging your program on ARM Cortex-M device, this Python tool wraps arm-none-eabi-gdb and connects it to a number of programmers running in the background or remotely. The tool can be called from the command line. Here is a typical use-case using the openocd backend with the common configuration files: python3 modm/modm_tools/gdb.py path/to/project.elf --ui = tui \\ -x modm/gdbinit -x modm/openocd_gdbinit \\ openocd -f modm/openocd.cfg Or you can call the Python API directly: import sys sys . path . append ( \"modm\" ) from modm_tools import gdb from modm_tools.openocd import OpenOcdBackend backend = OpenOcdBackend ( config = \"modm/openocd.cfg\" ) gdb . call ( source = \"path/to/project.elf\" , backend = backend , config = [ \"modm/gdbinit\" , \"modm/openocd_gdbinit\" ], ui = \"tui\" ) This configuration starts the OpenOCD process in the background for you, however, if you want to connect to an already running process, you can use the remote backend with the --host={ip or hostname} via the command line: # Extended-Remote running remotely python3 modm/modm_tools/gdb.py path/to/project.elf -x modm/gdbinit --ui = tui \\ remote --host 123 .45.67.89 Note that you can use different programmer backends to GDB: # Black Magic Probe python3 modm/modm_tools/gdb.py path/to/project.elf -x modm/gdbinit --ui = tui \\ bmp --port /dev/tty.usbserial-123 # CrashDebug for Post-Mortem debugging python3 modm/modm_tools/gdb.py path/to/project.elf -x modm/gdbinit --ui = tui \\ crashdebug --binary-path modm/ext/crashcatcher/bins --dump coredump.txt (* only ARM Cortex-M targets ) Currently two UIs are implemented for debugging: --ui=tui : Text-based UI in your shell. --ui=web : Web-based UI in your browser, based on gdbgui . Text UI \u00b6 This UI is builtin to GDB and is therefore always available. \u250c\u2014\u2014main.cpp\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2510 >\u2502194 DRAW(x+1, y+3); \u2502 \u2502195 DRAW(x+2, y+3); \u2502 \u2502196 #else \u2502 \u2502197 DRAW(x , y ); \u2502 \u2502198 #endif \u2502 \u2502199 #undef DRAW \u2502 \u2502200 } \u2502 \u2502201 \u2502 \u2502202 static inline void drawScreen(framebuffer_t before, frame\u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 >\u25020x80017a0 <game_of_life()+1692> strh.w r3, [r4, r12, lsl #1] \u2502 \u25020x80017a4 <game_of_life()+1696> add r0, lr \u2502 \u25020x80017a6 <game_of_life()+1698> ldr r2, [r2, #0] \u2502 \u25020x80017a8 <game_of_life()+1700> strh.w r3, [r2, r0, lsl #1] \u2502 \u25020x80017ac <game_of_life()+1704> ldr r3, [sp, #12] \u2502 \u25020x80017ae <game_of_life()+1706> ldr r2, [sp, #0] \u2502 \u25020x80017b0 <game_of_life()+1708> add r2, r3 \u2502 \u25020x80017b2 <game_of_life()+1710> ldrb r3, [r7, r1] \u2502 \u25020x80017b4 <game_of_life()+1712> strb r3, [r2, r1] \u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 extended-r Remote target In: game_of_life L194 PC: 0x80017a0 Program received signal SIGINT, Interrupt. 0x080017a0 in drawPixel (color=<optimized out>, y=42, x=578) at main.c (gdb) Web UI \u00b6 This UI simply uses the gdbgui project and works very well as an advanced IDE-independent debugging solution. Size Report \u00b6 Inspects the ELF file and generates a size report of the static usage of the device's memories. You must pass the available memory segments as a Python dictionary: python3 modm/modm_tools/size.py path/to/project.elf \\\\ \"[{'name': 'flash', 'access': 'rx', 'start': 134217728, 'size': 65536}, \\\\ {'name': 'sram1', 'access': 'rwx', 'start': 536870912, 'size': 20480}]\" Program: 1 .4 KiB ( 2 .2% used ) ( .build_id + .fastcode + .fastdata + .hardware_init + .rodata + .table.copy.intern + .table.heap + .table.zero.intern + .text + .vector_rom ) Data: 3 .0 KiB ( 15 .1% used ) = 20 B static ( 0 .1% ) + 3072 B stack ( 15 .0% ) ( .bss + .fastdata + .stack ) Heap: 17 .0 KiB ( 84 .9% available ) ( .heap1 ) (* only ARM Cortex-M targets ) Information Tool \u00b6 This tool generates a set of source files containing information about the repository state. You can use the --check-rebuild flag to only write the output file when the information changed. This prevents unnecessary rebuilding and relinking. Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need! Git Information \u00b6 python3 modm/modm_tools/info.py -o git_info.c -t git [ --check-rebuild ] python3 modm/modm_tools/info.py -o git_info.c -t git_status [ --check-rebuild ] The git_info(directory) function returns a dictionary with these values: MODM_GIT_SHA : commit hash: %H . MODM_GIT_SHA_ABBR : short commit hash: %h . MODM_GIT_SUBJECT : commit subject as text: %s . MODM_GIT_AUTHOR : author name: %an . MODM_GIT_AUTHOR_EMAIL : author email: %ae . MODM_GIT_AUTHOR_DATE : authoring date: %ad . MODM_GIT_AUTHOR_DATE_TIMESTAMP : authoring date as Unix timestamp: %at . MODM_GIT_COMMITTER : committer name: %cn . MODM_GIT_COMMITTER_EMAIL : committer email: %ce . MODM_GIT_COMMITTER_DATE : committer date: %cd . MODM_GIT_COMMITTER_DATE_TIMESTAMP : committer das as Unix timestamp: %ct . MODM_GIT_CONFIG_USER_NAME : local user name: user.name . MODM_GIT_CONFIG_USER_EMAIL : local user email: user.email . The git_info(directory, with_status=True) function returns these additional values: MODM_GIT_MODIFIED : number of modified files: M . MODM_GIT_ADDED : number of added files: A . MODM_GIT_DELETED : number of deleted files: D . MODM_GIT_RENAMED : number of renamed files: R . MODM_GIT_COPIED : number of copied files: C . MODM_GIT_UNTRACKED : number of untracked files: ? . This example project is showing an unclean repository state with uncommitted changes. This can give you a few hints as to where a firmware came from and help you pinpoint the source of a bug or feature. Local Git User: Name: Name Surname Email: name.surname@example.com Last Commit: SHA: 1b5a9a642857182161a615039c92907e59881614 Abbreviated SHA: 1b5a9a642 Subject: wip Author: Name: Name Surname Email: name.surname@example.com Date: Tue Jul 17 22:23:20 2018 +0200 Timestamp: 1531859000 Committer: Name: Name Surname Email: name.surname@example.com Date: Tue Jul 17 22:23:20 2018 +0200 Timestamp: 1531859000 File Status: Modified: 10 Added: 0 Deleted: 0 Renamed: 0 Copied: 0 Untracked: 6 Build Information \u00b6 python3 modm/modm_tools/info.py -o build_info.c -t build --compiler = gcc [ --check-rebuild ] Generates a files with these values defined as const char * strings: MODM_BUILD_PROJECT_NAME : as defined in the modm:build:project.name option. MODM_BUILD_MACHINE : machine information. MODM_BUILD_USER : user information. MODM_BUILD_OS : OS version string (best effort, may not be useful!). MODM_BUILD_COMPILER : compiler information. Example output on macOS: Project: build_info Machine: name.local User: user OS: macOS 10.14.6 (x86_64) Compiler: g++-10 10.2.0 Unittest \u00b6 This tools scans a directory for files ending in _test.hpp , extracts their test cases and generates a source file containing the test runner. python3 modm/modm_tools/unit_test.py path/containing/tests \\\\ path/to/generated_runner.cpp Note that the files containing unittests must contain one class that inherits from the unittest::TestSuite class, and test case names must begin with test : class TestClass : public unittest :: TestSuite { public : void testCase1 (); } Logging \u00b6 Usually logging is done simply via a serial port and only a USB-Serial adapter is necessary to read the device output. However, some forms of logging require host support or additional processing steps. ITM \u00b6 Logging via the SWO trace pin is supported via OpenOCD and the modm:platform:itm module: python3 modm/modm_tools/log.py itm openocd -f modm/openocd.cfg --fcpu 64000000 RTT \u00b6 Logging via the RTT protocol is supported via OpenOCD and the modm:platform:rtt module: python3 modm/modm_tools/log.py rtt openocd -f modm/openocd.cfg --channel 0 (* only ARM Cortex-M targets ) GNU Build-ID \u00b6 To extract the build ID from an ELF file: python3 modm/modm_tools/build_id.py path/to/project.elf fa8918e6971ed783b25bff0ad11a0541be47a933 To copy the ELF file to a artifact cache: python3 modm/modm_tools/build_id.py path/to/project.elf --cache path/to/folder # copies to `path/to/folder/fa8918e6971ed783b25bff0ad11a0541be47a933.elf` (* only ARM Cortex-M targets ) Bitmap \u00b6 This tool can convert P1 .pbm files into C++ source code. python3 modm/modm_tools/bitmap.py image.pbm --outpath . # creates `image.hpp` and `image.cpp` in the CWD Options \u00b6 avrdude.baudrate \u00b6 AvrDude programmer baudrate This option is only available for avr. Default: 0 Inputs: [0 ... +Inf] avrdude.options \u00b6 AvrDude programmer options This option is only available for avr. Default: \"\" Inputs: [String] avrdude.port \u00b6 AvrDude programmer port This option is only available for avr. Default: \"\" Inputs: [String] avrdude.programmer \u00b6 AvrDude programmer This option is only available for avr. Default: \"\" Inputs: [String] build.path \u00b6 Build Path The build path is defaulted to build/{modm:build:project.name} . If you have a lot of embedded projects, you may want to change the build path to a common directory so that you don't have build/ folders everywhere. Remember to add your build path to your .gitignore . You should use a relative path instead of an absolute one, so that this option still works for other developers. Default: build/modm Inputs: [Path] image.source \u00b6 Path to directory containing .pbm files Default: [] Inputs: [Path] info.build \u00b6 Generate build state information Default: False Inputs: [True, False] info.git \u00b6 Generate git repository state information Info : generates information about the last commit. Info+Status : like Info plus git file status. Default: Disabled Inputs: [Disabled, Info, Info+Status] openocd.cfg \u00b6 Path to a custom OpenOCD configuration file If you have a custom configuration file for your target, it will get included by the generated modm/openocd.cfg . This is useful for not having to duplicate your config if you have several projects using the same target (like small bring-up and test projects). Do not execute commands by default When providing your own config file, wrap your specific commands into functions and do not execute them by default. A stray init or similar in your script will mess with modm's ability to program and debug a device correctly. This option is only available for sam, stm32. Default: [] Inputs: [Path] project.name \u00b6 Project Name The project name defaults to the folder name you're calling lbuild from. It's used by your build system to name the executable and it may also be passed to your application via a string constant or CPP define. Default: modm Inputs: [String] unittest.source \u00b6 Path to directory containing unittests When this path is declared, the generated build script will compile only the unittests, not your application source code! You must use separate project configurations for compiling your unittest and application! Default: [] Inputs: [Path] Collectors \u00b6 archflags \u00b6 Compiler flags related to the target architecture Flags must start with '-'! See Machine-Dependent Options Inputs: [String] archflags.debug \u00b6 Compiler flags related to the target architecture (debug profile) Flags must start with '-'! See Machine-Dependent Options Inputs: [String] archflags.release \u00b6 Compiler flags related to the target architecture (release profile) Flags must start with '-'! See Machine-Dependent Options Inputs: [String] asflags \u00b6 Assembler flags Flags must start with '-'! See Assembler Options Inputs: [String] asflags.debug \u00b6 Assembler flags (debug profile) Flags must start with '-'! See Assembler Options Inputs: [String] asflags.release \u00b6 Assembler flags (release profile) Flags must start with '-'! See Assembler Options Inputs: [String] bossac.options \u00b6 Additional BOSSAc options This collector is only available for sam. Inputs: [String] ccflags \u00b6 Compiler flags for both C and C++ sources Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program Inputs: [String] ccflags.debug \u00b6 Compiler flags for both C and C++ sources (debug profile) Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program Inputs: [String] ccflags.release \u00b6 Compiler flags for both C and C++ sources (release profile) Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program Inputs: [String] cflags \u00b6 Compiler flags only for C sources Flags must start with '-'! See Options Controlling C Dialect Inputs: [String] cflags.debug \u00b6 Compiler flags only for C sources (debug profile) Flags must start with '-'! See Options Controlling C Dialect Inputs: [String] cflags.release \u00b6 Compiler flags only for C sources (release profile) Flags must start with '-'! See Options Controlling C Dialect Inputs: [String] cppdefines \u00b6 Preprocessor definitions Accepted values are NAME or NAME=DEFINITION . See -D name=definition in Preprocessor Options Inputs: [String] cppdefines.debug \u00b6 Preprocessor definitions (debug profile) Accepted values are NAME or NAME=DEFINITION . See -D name=definition in Preprocessor Options Inputs: [String] cppdefines.release \u00b6 Preprocessor definitions (release profile) Accepted values are NAME or NAME=DEFINITION . See -D name=definition in Preprocessor Options Inputs: [String] cxxflags \u00b6 Compiler flags only for C++ sources Flags must start with '-'! See Options Controlling C++ Dialect Inputs: [String] cxxflags.debug \u00b6 Compiler flags only for C++ sources (debug profile) Flags must start with '-'! See Options Controlling C++ Dialect Inputs: [String] cxxflags.release \u00b6 Compiler flags only for C++ sources (release profile) Flags must start with '-'! See Options Controlling C++ Dialect Inputs: [String] default.avrdude.baudrate \u00b6 Default AvrDude baudrate This collector is only available for avr. Inputs: [0 ... +Inf] default.avrdude.options \u00b6 Default AvrDude options This collector is only available for avr. Inputs: [String] default.avrdude.port \u00b6 Default AvrDude port This collector is only available for avr. Inputs: [String] default.avrdude.programmer \u00b6 Default AvrDude programmer This collector is only available for avr. Inputs: [String] gitignore \u00b6 Generated files that need to be ignored by Git Inputs: [Path] library \u00b6 Libraries to link against Inputs: [String] linkflags \u00b6 Linker flags Flags must start with '-'! See Options for Linking Inputs: [String] linkflags.debug \u00b6 Linker flags (debug profile) Flags must start with '-'! See Options for Linking Inputs: [String] linkflags.release \u00b6 Linker flags (release profile) Flags must start with '-'! See Options for Linking Inputs: [String] openocd.source \u00b6 Additional OpenOCD source files. This collector is only available for sam, stm32. Inputs: [Path] path.include \u00b6 Search path for header files Inputs: [Path] path.library \u00b6 Search path for static libraries Inputs: [Path] path.openocd \u00b6 Search path for OpenOCD configuration files This collector is only available for sam, stm32. Inputs: [Path] pkg-config \u00b6 Packages to configure against Inputs: [String] Queries \u00b6 avrdude_options \u00b6 Merges the default AvrDude options with the user options (* post-build only ): avrdude_programmer avrdude_port avrdude_baudrate avrdude_options :returns: options dictionary collect_flags \u00b6 Scans the collections for module compile flags. Converts them into SCons-compatible names and places them into a dictionary of the form: flags[filename][name][profile] = list(values) (* post-build only ). :param env: the post_build step env :param scope_filter: the collection scope filter :returns: compile flags dictionary device \u00b6 Extracts common properties from a modm:target device: platform family partname core mcu (AVR only) :returns: a dictionary of common properties. memories \u00b6 Extracts the memory map of the device. A memory region is a dictionary containing: name of region start address of region size of region access of region :returns: a list of memory regions. source_files \u00b6 Builds a list of files that need to be compiled per repository (* post-build only ). :returns: a dictionary of sorted lists of filenames, keyed by repository.","title":":build"},{"location":"reference/module/modm-build/#build-system-generators","text":"lbuild module: modm:build This parent module defines a common set of functionality that is independent of the specific build system generator implementation. This includes straight-forward options like project name and build path but also more complicated configuration for programming your target via AvrDude or OpenOCD and debugging via GDB. Note that this module does not compile your project, you will need to choose the modm:build:scons or modm:build:cmake submodule for that, or provide your own build system.","title":"Build System Generators"},{"location":"reference/module/modm-build/#compiler-options","text":"We maintain a common set of compiler options for all build system generator, so that they all have feature parity. We currently only support compiling modm with GCC for AVR, ARM Cortex-M and x86/posix with the options mentioned in the offical GCC options documentation . You can find all compiler options inside the generated build script for your project, the options presented here are only the most important ones.","title":"Compiler Options"},{"location":"reference/module/modm-build/#shared-for-c-and-c","text":"-W{all, extra} : a basic set of warnings. -Werror={format, maybe-uninitialized, overflow, sign-compare} : these warnings are treated as errors. -f{data, function}-sections : puts data and functions into their own linker section. -funsigned-{char, bitfields} : modm tries to use stdint.h types everywhere, but just in case. -fwrapv : integer overflows wrap around according to 2s complement. For release builds : -Os : optimize for smaller size. For debug builds : -Og : optimize for debugging experience.","title":"Shared for C and C++"},{"location":"reference/module/modm-build/#only-c","text":"-std=gnu11 : use C11 with GNU extensions (for asm volatile ).","title":"Only C"},{"location":"reference/module/modm-build/#only-c_1","text":"-std=c++20 : use C++20 For exception and RTTI flags, see modm:stdc++ module.","title":"Only C++"},{"location":"reference/module/modm-build/#linker","text":"--gc-section : garbage collecting sections throws out a lot of unused data/code. -L{linkdir} -Tlinkerscript.ld : modm uses a custom linkerscript. For target specific flags, see the modm:platform:core and related modules.","title":"Linker"},{"location":"reference/module/modm-build/#configuration","text":"This module generates a common set of configuration files that are used by the common tooling. Please note that these files are the foundation of more extensive tooling available as Python scripts which are then again wrapped by your chosen build system for convenience.","title":"Configuration"},{"location":"reference/module/modm-build/#openocd","text":"For accessing your ARM Cortex-M based device, we use OpenOCD by default and generate a modm/openocd.cfg file with the target specific configuration: Search directories passed via the path.openocd collector. User configuration files passed via the openocd.source collector. Your custom modm:build:openocd.cfg is added here too. You need to start openocd with this configuration file: openocd -f modm/openocd.cfg Be careful attaching to a running target The OpenOCD implementation halts the target at least while the device's debug peripheral is initialized. Only connect to systems that cannot create any damage while being halted! For example halting motor controllers may damage motors!!","title":"OpenOCD"},{"location":"reference/module/modm-build/#avrdude","text":"Unfortunately AvrDude does not support a project-specific configuration file like OpenOCD does (only a undocumented user config in ~/.avrduderc ), so there is no convenient one-line command to issue. You have to use the wrapper support of the specific build system or simply call AvrDude yourself via its command line.","title":"AvrDude"},{"location":"reference/module/modm-build/#gdb","text":"Two commands are provided for convenience via the modm/gdbinit configuration: restart resets the device and halts. rerun resets the device and continues execution. GDB continues running the target after attaching, but does not load an ELF file! Please pass the ELF file as a command line argument. You can start your GDB session like so: arm-none-eabi-gdb -x modm/gdbinit path/to/project.elf","title":"GDB"},{"location":"reference/module/modm-build/#generic-python-tools","text":"We have written a number of pure Python tools to provide common functionality that get wrapped by the build system. Here is a selection of tools that have a command line interface, so you can call them even without build system support in case you have a special setup. Note that there are even more tools that can be called in Python only, so have a look in your generated modm/modm_tools folder.","title":"Generic Python Tools"},{"location":"reference/module/modm-build/#avrdude_1","text":"This tool simply wraps the avrdude command to provide two features: guessing the serial port when a baudrate was set. inspecting the ELF file to decide whether EEPROM needs to be programmed. python3 modm/modm_tools/avrdude.py -p m328p -c arduino -P auto -b 57600 \\\\ path/to/project.elf Fuses stored in the ELF file can be programmed by passing --fuse arguments: python3 modm/modm_tools/avrdude.py -p m328p -c stk500v2 path/to/project.elf \\\\ --fuse hfuse --fuse lfuse --fuse efuse (* only AVR targets )","title":"AvrDude"},{"location":"reference/module/modm-build/#openocd_1","text":"Simply wraps OpenOCD and issues the right command to program the target. python3 modm/modm_tools/openocd.py -f modm/openocd.cfg path/to/project.elf You can also reset the target: python3 modm/modm_tools/openocd.py -f modm/openocd.cfg --reset (* only ARM Cortex-M targets )","title":"OpenOCD"},{"location":"reference/module/modm-build/#black-magic-probe","text":"This tool wraps GDB to program an ELF file onto a target connected to a BMP. You can explictly pass the serial port, or let the tool guess it. python3 modm/modm_tools/bmp.py path/to/project.elf # or choose the port explicitly python3 modm/modm_tools/bmp.py path/to/project.elf -p /dev/tty.usbserial-123 You can also reset the target: python3 modm/modm_tools/bmp.py --reset (* only ARM Cortex-M targets )","title":"Black Magic Probe"},{"location":"reference/module/modm-build/#gdb_1","text":"For debugging your program on ARM Cortex-M device, this Python tool wraps arm-none-eabi-gdb and connects it to a number of programmers running in the background or remotely. The tool can be called from the command line. Here is a typical use-case using the openocd backend with the common configuration files: python3 modm/modm_tools/gdb.py path/to/project.elf --ui = tui \\ -x modm/gdbinit -x modm/openocd_gdbinit \\ openocd -f modm/openocd.cfg Or you can call the Python API directly: import sys sys . path . append ( \"modm\" ) from modm_tools import gdb from modm_tools.openocd import OpenOcdBackend backend = OpenOcdBackend ( config = \"modm/openocd.cfg\" ) gdb . call ( source = \"path/to/project.elf\" , backend = backend , config = [ \"modm/gdbinit\" , \"modm/openocd_gdbinit\" ], ui = \"tui\" ) This configuration starts the OpenOCD process in the background for you, however, if you want to connect to an already running process, you can use the remote backend with the --host={ip or hostname} via the command line: # Extended-Remote running remotely python3 modm/modm_tools/gdb.py path/to/project.elf -x modm/gdbinit --ui = tui \\ remote --host 123 .45.67.89 Note that you can use different programmer backends to GDB: # Black Magic Probe python3 modm/modm_tools/gdb.py path/to/project.elf -x modm/gdbinit --ui = tui \\ bmp --port /dev/tty.usbserial-123 # CrashDebug for Post-Mortem debugging python3 modm/modm_tools/gdb.py path/to/project.elf -x modm/gdbinit --ui = tui \\ crashdebug --binary-path modm/ext/crashcatcher/bins --dump coredump.txt (* only ARM Cortex-M targets ) Currently two UIs are implemented for debugging: --ui=tui : Text-based UI in your shell. --ui=web : Web-based UI in your browser, based on gdbgui .","title":"GDB"},{"location":"reference/module/modm-build/#text-ui","text":"This UI is builtin to GDB and is therefore always available. \u250c\u2014\u2014main.cpp\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2510 >\u2502194 DRAW(x+1, y+3); \u2502 \u2502195 DRAW(x+2, y+3); \u2502 \u2502196 #else \u2502 \u2502197 DRAW(x , y ); \u2502 \u2502198 #endif \u2502 \u2502199 #undef DRAW \u2502 \u2502200 } \u2502 \u2502201 \u2502 \u2502202 static inline void drawScreen(framebuffer_t before, frame\u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 >\u25020x80017a0 <game_of_life()+1692> strh.w r3, [r4, r12, lsl #1] \u2502 \u25020x80017a4 <game_of_life()+1696> add r0, lr \u2502 \u25020x80017a6 <game_of_life()+1698> ldr r2, [r2, #0] \u2502 \u25020x80017a8 <game_of_life()+1700> strh.w r3, [r2, r0, lsl #1] \u2502 \u25020x80017ac <game_of_life()+1704> ldr r3, [sp, #12] \u2502 \u25020x80017ae <game_of_life()+1706> ldr r2, [sp, #0] \u2502 \u25020x80017b0 <game_of_life()+1708> add r2, r3 \u2502 \u25020x80017b2 <game_of_life()+1710> ldrb r3, [r7, r1] \u2502 \u25020x80017b4 <game_of_life()+1712> strb r3, [r2, r1] \u2502 \u2514\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2518 extended-r Remote target In: game_of_life L194 PC: 0x80017a0 Program received signal SIGINT, Interrupt. 0x080017a0 in drawPixel (color=<optimized out>, y=42, x=578) at main.c (gdb)","title":"Text UI"},{"location":"reference/module/modm-build/#web-ui","text":"This UI simply uses the gdbgui project and works very well as an advanced IDE-independent debugging solution.","title":"Web UI"},{"location":"reference/module/modm-build/#size-report","text":"Inspects the ELF file and generates a size report of the static usage of the device's memories. You must pass the available memory segments as a Python dictionary: python3 modm/modm_tools/size.py path/to/project.elf \\\\ \"[{'name': 'flash', 'access': 'rx', 'start': 134217728, 'size': 65536}, \\\\ {'name': 'sram1', 'access': 'rwx', 'start': 536870912, 'size': 20480}]\" Program: 1 .4 KiB ( 2 .2% used ) ( .build_id + .fastcode + .fastdata + .hardware_init + .rodata + .table.copy.intern + .table.heap + .table.zero.intern + .text + .vector_rom ) Data: 3 .0 KiB ( 15 .1% used ) = 20 B static ( 0 .1% ) + 3072 B stack ( 15 .0% ) ( .bss + .fastdata + .stack ) Heap: 17 .0 KiB ( 84 .9% available ) ( .heap1 ) (* only ARM Cortex-M targets )","title":"Size Report"},{"location":"reference/module/modm-build/#information-tool","text":"This tool generates a set of source files containing information about the repository state. You can use the --check-rebuild flag to only write the output file when the information changed. This prevents unnecessary rebuilding and relinking. Respect developers privacy This information is placed into the firmware in cleartext , so it will be trivial to extract from a memory dump. Consider this information public as soon as it is uploaded to your target. Make sure you only use the information you absolutely need!","title":"Information Tool"},{"location":"reference/module/modm-build/#git-information","text":"python3 modm/modm_tools/info.py -o git_info.c -t git [ --check-rebuild ] python3 modm/modm_tools/info.py -o git_info.c -t git_status [ --check-rebuild ] The git_info(directory) function returns a dictionary with these values: MODM_GIT_SHA : commit hash: %H . MODM_GIT_SHA_ABBR : short commit hash: %h . MODM_GIT_SUBJECT : commit subject as text: %s . MODM_GIT_AUTHOR : author name: %an . MODM_GIT_AUTHOR_EMAIL : author email: %ae . MODM_GIT_AUTHOR_DATE : authoring date: %ad . MODM_GIT_AUTHOR_DATE_TIMESTAMP : authoring date as Unix timestamp: %at . MODM_GIT_COMMITTER : committer name: %cn . MODM_GIT_COMMITTER_EMAIL : committer email: %ce . MODM_GIT_COMMITTER_DATE : committer date: %cd . MODM_GIT_COMMITTER_DATE_TIMESTAMP : committer das as Unix timestamp: %ct . MODM_GIT_CONFIG_USER_NAME : local user name: user.name . MODM_GIT_CONFIG_USER_EMAIL : local user email: user.email . The git_info(directory, with_status=True) function returns these additional values: MODM_GIT_MODIFIED : number of modified files: M . MODM_GIT_ADDED : number of added files: A . MODM_GIT_DELETED : number of deleted files: D . MODM_GIT_RENAMED : number of renamed files: R . MODM_GIT_COPIED : number of copied files: C . MODM_GIT_UNTRACKED : number of untracked files: ? . This example project is showing an unclean repository state with uncommitted changes. This can give you a few hints as to where a firmware came from and help you pinpoint the source of a bug or feature. Local Git User: Name: Name Surname Email: name.surname@example.com Last Commit: SHA: 1b5a9a642857182161a615039c92907e59881614 Abbreviated SHA: 1b5a9a642 Subject: wip Author: Name: Name Surname Email: name.surname@example.com Date: Tue Jul 17 22:23:20 2018 +0200 Timestamp: 1531859000 Committer: Name: Name Surname Email: name.surname@example.com Date: Tue Jul 17 22:23:20 2018 +0200 Timestamp: 1531859000 File Status: Modified: 10 Added: 0 Deleted: 0 Renamed: 0 Copied: 0 Untracked: 6","title":"Git Information"},{"location":"reference/module/modm-build/#build-information","text":"python3 modm/modm_tools/info.py -o build_info.c -t build --compiler = gcc [ --check-rebuild ] Generates a files with these values defined as const char * strings: MODM_BUILD_PROJECT_NAME : as defined in the modm:build:project.name option. MODM_BUILD_MACHINE : machine information. MODM_BUILD_USER : user information. MODM_BUILD_OS : OS version string (best effort, may not be useful!). MODM_BUILD_COMPILER : compiler information. Example output on macOS: Project: build_info Machine: name.local User: user OS: macOS 10.14.6 (x86_64) Compiler: g++-10 10.2.0","title":"Build Information"},{"location":"reference/module/modm-build/#unittest","text":"This tools scans a directory for files ending in _test.hpp , extracts their test cases and generates a source file containing the test runner. python3 modm/modm_tools/unit_test.py path/containing/tests \\\\ path/to/generated_runner.cpp Note that the files containing unittests must contain one class that inherits from the unittest::TestSuite class, and test case names must begin with test : class TestClass : public unittest :: TestSuite { public : void testCase1 (); }","title":"Unittest"},{"location":"reference/module/modm-build/#logging","text":"Usually logging is done simply via a serial port and only a USB-Serial adapter is necessary to read the device output. However, some forms of logging require host support or additional processing steps.","title":"Logging"},{"location":"reference/module/modm-build/#itm","text":"Logging via the SWO trace pin is supported via OpenOCD and the modm:platform:itm module: python3 modm/modm_tools/log.py itm openocd -f modm/openocd.cfg --fcpu 64000000","title":"ITM"},{"location":"reference/module/modm-build/#rtt","text":"Logging via the RTT protocol is supported via OpenOCD and the modm:platform:rtt module: python3 modm/modm_tools/log.py rtt openocd -f modm/openocd.cfg --channel 0 (* only ARM Cortex-M targets )","title":"RTT"},{"location":"reference/module/modm-build/#gnu-build-id","text":"To extract the build ID from an ELF file: python3 modm/modm_tools/build_id.py path/to/project.elf fa8918e6971ed783b25bff0ad11a0541be47a933 To copy the ELF file to a artifact cache: python3 modm/modm_tools/build_id.py path/to/project.elf --cache path/to/folder # copies to `path/to/folder/fa8918e6971ed783b25bff0ad11a0541be47a933.elf` (* only ARM Cortex-M targets )","title":"GNU Build-ID"},{"location":"reference/module/modm-build/#bitmap","text":"This tool can convert P1 .pbm files into C++ source code. python3 modm/modm_tools/bitmap.py image.pbm --outpath . # creates `image.hpp` and `image.cpp` in the CWD","title":"Bitmap"},{"location":"reference/module/modm-build/#options","text":"","title":"Options"},{"location":"reference/module/modm-build/#avrdudebaudrate","text":"AvrDude programmer baudrate This option is only available for avr. Default: 0 Inputs: [0 ... +Inf]","title":"avrdude.baudrate"},{"location":"reference/module/modm-build/#avrdudeoptions","text":"AvrDude programmer options This option is only available for avr. Default: \"\" Inputs: [String]","title":"avrdude.options"},{"location":"reference/module/modm-build/#avrdudeport","text":"AvrDude programmer port This option is only available for avr. Default: \"\" Inputs: [String]","title":"avrdude.port"},{"location":"reference/module/modm-build/#avrdudeprogrammer","text":"AvrDude programmer This option is only available for avr. Default: \"\" Inputs: [String]","title":"avrdude.programmer"},{"location":"reference/module/modm-build/#buildpath","text":"Build Path The build path is defaulted to build/{modm:build:project.name} . If you have a lot of embedded projects, you may want to change the build path to a common directory so that you don't have build/ folders everywhere. Remember to add your build path to your .gitignore . You should use a relative path instead of an absolute one, so that this option still works for other developers. Default: build/modm Inputs: [Path]","title":"build.path"},{"location":"reference/module/modm-build/#imagesource","text":"Path to directory containing .pbm files Default: [] Inputs: [Path]","title":"image.source"},{"location":"reference/module/modm-build/#infobuild","text":"Generate build state information Default: False Inputs: [True, False]","title":"info.build"},{"location":"reference/module/modm-build/#infogit","text":"Generate git repository state information Info : generates information about the last commit. Info+Status : like Info plus git file status. Default: Disabled Inputs: [Disabled, Info, Info+Status]","title":"info.git"},{"location":"reference/module/modm-build/#openocdcfg","text":"Path to a custom OpenOCD configuration file If you have a custom configuration file for your target, it will get included by the generated modm/openocd.cfg . This is useful for not having to duplicate your config if you have several projects using the same target (like small bring-up and test projects). Do not execute commands by default When providing your own config file, wrap your specific commands into functions and do not execute them by default. A stray init or similar in your script will mess with modm's ability to program and debug a device correctly. This option is only available for sam, stm32. Default: [] Inputs: [Path]","title":"openocd.cfg"},{"location":"reference/module/modm-build/#projectname","text":"Project Name The project name defaults to the folder name you're calling lbuild from. It's used by your build system to name the executable and it may also be passed to your application via a string constant or CPP define. Default: modm Inputs: [String]","title":"project.name"},{"location":"reference/module/modm-build/#unittestsource","text":"Path to directory containing unittests When this path is declared, the generated build script will compile only the unittests, not your application source code! You must use separate project configurations for compiling your unittest and application! Default: [] Inputs: [Path]","title":"unittest.source"},{"location":"reference/module/modm-build/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-build/#archflags","text":"Compiler flags related to the target architecture Flags must start with '-'! See Machine-Dependent Options Inputs: [String]","title":"archflags"},{"location":"reference/module/modm-build/#archflagsdebug","text":"Compiler flags related to the target architecture (debug profile) Flags must start with '-'! See Machine-Dependent Options Inputs: [String]","title":"archflags.debug"},{"location":"reference/module/modm-build/#archflagsrelease","text":"Compiler flags related to the target architecture (release profile) Flags must start with '-'! See Machine-Dependent Options Inputs: [String]","title":"archflags.release"},{"location":"reference/module/modm-build/#asflags","text":"Assembler flags Flags must start with '-'! See Assembler Options Inputs: [String]","title":"asflags"},{"location":"reference/module/modm-build/#asflagsdebug","text":"Assembler flags (debug profile) Flags must start with '-'! See Assembler Options Inputs: [String]","title":"asflags.debug"},{"location":"reference/module/modm-build/#asflagsrelease","text":"Assembler flags (release profile) Flags must start with '-'! See Assembler Options Inputs: [String]","title":"asflags.release"},{"location":"reference/module/modm-build/#bossacoptions","text":"Additional BOSSAc options This collector is only available for sam. Inputs: [String]","title":"bossac.options"},{"location":"reference/module/modm-build/#ccflags","text":"Compiler flags for both C and C++ sources Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program Inputs: [String]","title":"ccflags"},{"location":"reference/module/modm-build/#ccflagsdebug","text":"Compiler flags for both C and C++ sources (debug profile) Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program Inputs: [String]","title":"ccflags.debug"},{"location":"reference/module/modm-build/#ccflagsrelease","text":"Compiler flags for both C and C++ sources (release profile) Flags must start with '-'! See Options that Control Optimization See Options to Request or Suppress Warnings See Options for Debugging Your Program Inputs: [String]","title":"ccflags.release"},{"location":"reference/module/modm-build/#cflags","text":"Compiler flags only for C sources Flags must start with '-'! See Options Controlling C Dialect Inputs: [String]","title":"cflags"},{"location":"reference/module/modm-build/#cflagsdebug","text":"Compiler flags only for C sources (debug profile) Flags must start with '-'! See Options Controlling C Dialect Inputs: [String]","title":"cflags.debug"},{"location":"reference/module/modm-build/#cflagsrelease","text":"Compiler flags only for C sources (release profile) Flags must start with '-'! See Options Controlling C Dialect Inputs: [String]","title":"cflags.release"},{"location":"reference/module/modm-build/#cppdefines","text":"Preprocessor definitions Accepted values are NAME or NAME=DEFINITION . See -D name=definition in Preprocessor Options Inputs: [String]","title":"cppdefines"},{"location":"reference/module/modm-build/#cppdefinesdebug","text":"Preprocessor definitions (debug profile) Accepted values are NAME or NAME=DEFINITION . See -D name=definition in Preprocessor Options Inputs: [String]","title":"cppdefines.debug"},{"location":"reference/module/modm-build/#cppdefinesrelease","text":"Preprocessor definitions (release profile) Accepted values are NAME or NAME=DEFINITION . See -D name=definition in Preprocessor Options Inputs: [String]","title":"cppdefines.release"},{"location":"reference/module/modm-build/#cxxflags","text":"Compiler flags only for C++ sources Flags must start with '-'! See Options Controlling C++ Dialect Inputs: [String]","title":"cxxflags"},{"location":"reference/module/modm-build/#cxxflagsdebug","text":"Compiler flags only for C++ sources (debug profile) Flags must start with '-'! See Options Controlling C++ Dialect Inputs: [String]","title":"cxxflags.debug"},{"location":"reference/module/modm-build/#cxxflagsrelease","text":"Compiler flags only for C++ sources (release profile) Flags must start with '-'! See Options Controlling C++ Dialect Inputs: [String]","title":"cxxflags.release"},{"location":"reference/module/modm-build/#defaultavrdudebaudrate","text":"Default AvrDude baudrate This collector is only available for avr. Inputs: [0 ... +Inf]","title":"default.avrdude.baudrate"},{"location":"reference/module/modm-build/#defaultavrdudeoptions","text":"Default AvrDude options This collector is only available for avr. Inputs: [String]","title":"default.avrdude.options"},{"location":"reference/module/modm-build/#defaultavrdudeport","text":"Default AvrDude port This collector is only available for avr. Inputs: [String]","title":"default.avrdude.port"},{"location":"reference/module/modm-build/#defaultavrdudeprogrammer","text":"Default AvrDude programmer This collector is only available for avr. Inputs: [String]","title":"default.avrdude.programmer"},{"location":"reference/module/modm-build/#gitignore","text":"Generated files that need to be ignored by Git Inputs: [Path]","title":"gitignore"},{"location":"reference/module/modm-build/#library","text":"Libraries to link against Inputs: [String]","title":"library"},{"location":"reference/module/modm-build/#linkflags","text":"Linker flags Flags must start with '-'! See Options for Linking Inputs: [String]","title":"linkflags"},{"location":"reference/module/modm-build/#linkflagsdebug","text":"Linker flags (debug profile) Flags must start with '-'! See Options for Linking Inputs: [String]","title":"linkflags.debug"},{"location":"reference/module/modm-build/#linkflagsrelease","text":"Linker flags (release profile) Flags must start with '-'! See Options for Linking Inputs: [String]","title":"linkflags.release"},{"location":"reference/module/modm-build/#openocdsource","text":"Additional OpenOCD source files. This collector is only available for sam, stm32. Inputs: [Path]","title":"openocd.source"},{"location":"reference/module/modm-build/#pathinclude","text":"Search path for header files Inputs: [Path]","title":"path.include"},{"location":"reference/module/modm-build/#pathlibrary","text":"Search path for static libraries Inputs: [Path]","title":"path.library"},{"location":"reference/module/modm-build/#pathopenocd","text":"Search path for OpenOCD configuration files This collector is only available for sam, stm32. Inputs: [Path]","title":"path.openocd"},{"location":"reference/module/modm-build/#pkg-config","text":"Packages to configure against Inputs: [String]","title":"pkg-config"},{"location":"reference/module/modm-build/#queries","text":"","title":"Queries"},{"location":"reference/module/modm-build/#avrdude_options","text":"Merges the default AvrDude options with the user options (* post-build only ): avrdude_programmer avrdude_port avrdude_baudrate avrdude_options :returns: options dictionary","title":"avrdude_options"},{"location":"reference/module/modm-build/#collect_flags","text":"Scans the collections for module compile flags. Converts them into SCons-compatible names and places them into a dictionary of the form: flags[filename][name][profile] = list(values) (* post-build only ). :param env: the post_build step env :param scope_filter: the collection scope filter :returns: compile flags dictionary","title":"collect_flags"},{"location":"reference/module/modm-build/#device","text":"Extracts common properties from a modm:target device: platform family partname core mcu (AVR only) :returns: a dictionary of common properties.","title":"device"},{"location":"reference/module/modm-build/#memories","text":"Extracts the memory map of the device. A memory region is a dictionary containing: name of region start address of region size of region access of region :returns: a list of memory regions.","title":"memories"},{"location":"reference/module/modm-build/#source_files","text":"Builds a list of files that need to be compiled per repository (* post-build only ). :returns: a dictionary of sorted lists of filenames, keyed by repository.","title":"source_files"},{"location":"reference/module/modm-cmsis-core/","text":"ARM CMSIS-CORE \u00b6 lbuild module: modm:cmsis:core This module provides these files for accessing the ARM Cortex-M CPU and peripherals: cmsis_gcc.h : Contains the GCC-specific API. core_cm{core}.h : Contains the core-specific API. Please see the API documentation for their content and how to use them. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:core"},{"location":"reference/module/modm-cmsis-core/#arm-cmsis-core","text":"lbuild module: modm:cmsis:core This module provides these files for accessing the ARM Cortex-M CPU and peripherals: cmsis_gcc.h : Contains the GCC-specific API. core_cm{core}.h : Contains the core-specific API. Please see the API documentation for their content and how to use them. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"ARM CMSIS-CORE"},{"location":"reference/module/modm-cmsis-device-sam/","text":"modm:cmsis:device \u00b6 lbuild module: modm:cmsis:device This module is only available for sam. Dependencies \u00b6 modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis_core modm: cmsis: core modm_cmsis_device->modm_cmsis_core @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:device (sam)"},{"location":"reference/module/modm-cmsis-device-sam/#modmcmsisdevice","text":"lbuild module: modm:cmsis:device This module is only available for sam.","title":"modm:cmsis:device"},{"location":"reference/module/modm-cmsis-device-sam/#dependencies","text":"modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis_core modm: cmsis: core modm_cmsis_device->modm_cmsis_core @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-device-stm32/","text":"STM32 CMSIS Headers \u00b6 lbuild module: modm:cmsis:device This module wraps the CMSIS headers for STM32 devices and provides the header file and CPP definitions for accessing the modm:target peripherals. Specifically, it copies the target header file which provides the CMSIS implementation of the target's language interface for its memory-mapped peripherals. Discrepancies between documentation and headers These CMSIS headers should reflect what's written in the documentation, however, in our experience there may be small differences in naming, behavior and availability between it and this implementation. The generated header file modm/platform/device.hpp contains the necessary target define STM32{FAMILY}{NAME}xx or similar and includes the modm:target -specific header. Include only modm/platform/device.hpp ! This file is only included by interface implementations inside the modm/platform folder! If you need to implement your own drivers, include only this file. CMSIS Compliance \u00b6 modm implements the target specific CMSIS functionality itself, without using the CMSIS interface. This is necessary to provide similar functionality on non-Cortex-M based targets. uint32_t SystemCoreClock contains an up-to-date value of CPU frequency. void SystemCoreClockUpdate() does nothing, it's a weak empty function. void SystemInit() is undefined : modm defines its own startup architecture, see the modm:platform:core module for details. Debugging Peripherals \u00b6 When debugging with GDB, it can sometimes be difficult to access peripherals, due to the CMSIS implementation with CPP defines and GCC optimization flags. Depending on these circumstances, GDB may only \"see\" a peripheral in a certain context, which can make the debugging experience quite frustrating. To aid this, we generate a linkerscript fragment and source file, which place the peripherals memory as real objects in the peripheral memory space. You can then access these peripherals inside GDB at any time, regardless of context and build profile setting: (gdb) p/x *GPIOB $1 = { MODER = 0xaa0280, OTYPER = 0x300, OSPEEDR = 0x2a00c0, PUPDR = 0x400100, IDR = 0xfd0, ODR = 0x100, BSRR = 0x0, LCKR = 0x0, AFR = {0x0, 0x7744} } This does not have any effect on your firmware! It is purely a debug helper feature and none of these definitions make it into the executable. Beware read/write side-effects When debugging be aware of the side-effects that your read or write to a peripheral memory location can have. It's fairly obvious that a write may have consequences, but also reads can modify peripheral state, for example, a hardware FIFO buffer may pop the queue if your read the top of it. This module is only available for stm32. Queries \u00b6 headers \u00b6 Gives information about the STM32 header files. For example the STM32F469: family_define: STM32F4 define: STM32F469xx core_header: core_cm4.h system_header: system_stm32f4xx.h family_header: stm32f4xx.h device_header: stm32f469xx.h :returns: a dictionary with the above keys rcc-map \u00b6 Finds all CMSIS bit fields related to enabling and resetting peripherals in the RCC of the format RCC_(REGISTER)_(PERIPHERAL)_(TYPE) where: REGISTER: a variation of (BUS)(ID?)(ENR|RSTR) , e.g. AHB1ENR PERIPHERAL: typical peripheral name, e.g. GPIOA TYPE: either EN or RST . :returns: a 2D-dictionary: map[PERIPHERAL][TYPE] = REGISTER Dependencies \u00b6 modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis_core modm: cmsis: core modm_cmsis_device->modm_cmsis_core @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:device (stm32)"},{"location":"reference/module/modm-cmsis-device-stm32/#stm32-cmsis-headers","text":"lbuild module: modm:cmsis:device This module wraps the CMSIS headers for STM32 devices and provides the header file and CPP definitions for accessing the modm:target peripherals. Specifically, it copies the target header file which provides the CMSIS implementation of the target's language interface for its memory-mapped peripherals. Discrepancies between documentation and headers These CMSIS headers should reflect what's written in the documentation, however, in our experience there may be small differences in naming, behavior and availability between it and this implementation. The generated header file modm/platform/device.hpp contains the necessary target define STM32{FAMILY}{NAME}xx or similar and includes the modm:target -specific header. Include only modm/platform/device.hpp ! This file is only included by interface implementations inside the modm/platform folder! If you need to implement your own drivers, include only this file.","title":"STM32 CMSIS Headers"},{"location":"reference/module/modm-cmsis-device-stm32/#cmsis-compliance","text":"modm implements the target specific CMSIS functionality itself, without using the CMSIS interface. This is necessary to provide similar functionality on non-Cortex-M based targets. uint32_t SystemCoreClock contains an up-to-date value of CPU frequency. void SystemCoreClockUpdate() does nothing, it's a weak empty function. void SystemInit() is undefined : modm defines its own startup architecture, see the modm:platform:core module for details.","title":"CMSIS Compliance"},{"location":"reference/module/modm-cmsis-device-stm32/#debugging-peripherals","text":"When debugging with GDB, it can sometimes be difficult to access peripherals, due to the CMSIS implementation with CPP defines and GCC optimization flags. Depending on these circumstances, GDB may only \"see\" a peripheral in a certain context, which can make the debugging experience quite frustrating. To aid this, we generate a linkerscript fragment and source file, which place the peripherals memory as real objects in the peripheral memory space. You can then access these peripherals inside GDB at any time, regardless of context and build profile setting: (gdb) p/x *GPIOB $1 = { MODER = 0xaa0280, OTYPER = 0x300, OSPEEDR = 0x2a00c0, PUPDR = 0x400100, IDR = 0xfd0, ODR = 0x100, BSRR = 0x0, LCKR = 0x0, AFR = {0x0, 0x7744} } This does not have any effect on your firmware! It is purely a debug helper feature and none of these definitions make it into the executable. Beware read/write side-effects When debugging be aware of the side-effects that your read or write to a peripheral memory location can have. It's fairly obvious that a write may have consequences, but also reads can modify peripheral state, for example, a hardware FIFO buffer may pop the queue if your read the top of it. This module is only available for stm32.","title":"Debugging Peripherals"},{"location":"reference/module/modm-cmsis-device-stm32/#queries","text":"","title":"Queries"},{"location":"reference/module/modm-cmsis-device-stm32/#headers","text":"Gives information about the STM32 header files. For example the STM32F469: family_define: STM32F4 define: STM32F469xx core_header: core_cm4.h system_header: system_stm32f4xx.h family_header: stm32f4xx.h device_header: stm32f469xx.h :returns: a dictionary with the above keys","title":"headers"},{"location":"reference/module/modm-cmsis-device-stm32/#rcc-map","text":"Finds all CMSIS bit fields related to enabling and resetting peripherals in the RCC of the format RCC_(REGISTER)_(PERIPHERAL)_(TYPE) where: REGISTER: a variation of (BUS)(ID?)(ENR|RSTR) , e.g. AHB1ENR PERIPHERAL: typical peripheral name, e.g. GPIOA TYPE: either EN or RST . :returns: a 2D-dictionary: map[PERIPHERAL][TYPE] = REGISTER","title":"rcc-map"},{"location":"reference/module/modm-cmsis-device-stm32/#dependencies","text":"modm:cmsis:device modm_cmsis_device modm: cmsis: device modm_cmsis_core modm: cmsis: core modm_cmsis_device->modm_cmsis_core @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-basic_math/","text":"DSP Basic Math \u00b6 lbuild module: modm:cmsis:dsp:basic_math Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:basic_math"},{"location":"reference/module/modm-cmsis-dsp-basic_math/#dsp-basic-math","text":"lbuild module: modm:cmsis:dsp:basic_math Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"DSP Basic Math"},{"location":"reference/module/modm-cmsis-dsp-bayes/","text":"DSP Bayes \u00b6 lbuild module: modm:cmsis:dsp:bayes Dependencies \u00b6 modm:cmsis:dsp:bayes modm_cmsis_dsp_bayes modm: cmsis: dsp: bayes modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_bayes->modm_cmsis_dsp_statistics @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:bayes"},{"location":"reference/module/modm-cmsis-dsp-bayes/#dsp-bayes","text":"lbuild module: modm:cmsis:dsp:bayes","title":"DSP Bayes"},{"location":"reference/module/modm-cmsis-dsp-bayes/#dependencies","text":"modm:cmsis:dsp:bayes modm_cmsis_dsp_bayes modm: cmsis: dsp: bayes modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_bayes->modm_cmsis_dsp_statistics @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-complex_math/","text":"DSP Complex Math \u00b6 lbuild module: modm:cmsis:dsp:complex_math Dependencies \u00b6 modm:cmsis:dsp:complex_math modm_cmsis_dsp_complex_math modm: cmsis: dsp: complex_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_complex_math->modm_cmsis_dsp_fast_math @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:complex_math"},{"location":"reference/module/modm-cmsis-dsp-complex_math/#dsp-complex-math","text":"lbuild module: modm:cmsis:dsp:complex_math","title":"DSP Complex Math"},{"location":"reference/module/modm-cmsis-dsp-complex_math/#dependencies","text":"modm:cmsis:dsp:complex_math modm_cmsis_dsp_complex_math modm: cmsis: dsp: complex_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_complex_math->modm_cmsis_dsp_fast_math @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-controller/","text":"DSP Controller \u00b6 lbuild module: modm:cmsis:dsp:controller Dependencies \u00b6 modm:cmsis:dsp:controller modm_cmsis_dsp_controller modm: cmsis: dsp: controller modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_controller->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:controller"},{"location":"reference/module/modm-cmsis-dsp-controller/#dsp-controller","text":"lbuild module: modm:cmsis:dsp:controller","title":"DSP Controller"},{"location":"reference/module/modm-cmsis-dsp-controller/#dependencies","text":"modm:cmsis:dsp:controller modm_cmsis_dsp_controller modm: cmsis: dsp: controller modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_controller->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-distance/","text":"DSP Distance \u00b6 lbuild module: modm:cmsis:dsp:distance Dependencies \u00b6 modm:cmsis:dsp:distance modm_cmsis_dsp_distance modm: cmsis: dsp: distance modm_cmsis_dsp_basic_math modm: cmsis: dsp: basic_math modm_cmsis_dsp_distance->modm_cmsis_dsp_basic_math modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_distance->modm_cmsis_dsp_statistics @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:distance"},{"location":"reference/module/modm-cmsis-dsp-distance/#dsp-distance","text":"lbuild module: modm:cmsis:dsp:distance","title":"DSP Distance"},{"location":"reference/module/modm-cmsis-dsp-distance/#dependencies","text":"modm:cmsis:dsp:distance modm_cmsis_dsp_distance modm: cmsis: dsp: distance modm_cmsis_dsp_basic_math modm: cmsis: dsp: basic_math modm_cmsis_dsp_distance->modm_cmsis_dsp_basic_math modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_distance->modm_cmsis_dsp_statistics @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-fast_math/","text":"DSP Fast Math \u00b6 lbuild module: modm:cmsis:dsp:fast_math Dependencies \u00b6 modm:cmsis:dsp:fast_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_fast_math->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:fast_math"},{"location":"reference/module/modm-cmsis-dsp-fast_math/#dsp-fast-math","text":"lbuild module: modm:cmsis:dsp:fast_math","title":"DSP Fast Math"},{"location":"reference/module/modm-cmsis-dsp-fast_math/#dependencies","text":"modm:cmsis:dsp:fast_math modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_fast_math->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-filtering/","text":"DSP Filtering \u00b6 lbuild module: modm:cmsis:dsp:filtering Dependencies \u00b6 modm:cmsis:dsp:filtering modm_cmsis_dsp_filtering modm: cmsis: dsp: filtering modm_cmsis_dsp_support modm: cmsis: dsp: support modm_cmsis_dsp_filtering->modm_cmsis_dsp_support modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_filtering->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:filtering"},{"location":"reference/module/modm-cmsis-dsp-filtering/#dsp-filtering","text":"lbuild module: modm:cmsis:dsp:filtering","title":"DSP Filtering"},{"location":"reference/module/modm-cmsis-dsp-filtering/#dependencies","text":"modm:cmsis:dsp:filtering modm_cmsis_dsp_filtering modm: cmsis: dsp: filtering modm_cmsis_dsp_support modm: cmsis: dsp: support modm_cmsis_dsp_filtering->modm_cmsis_dsp_support modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_filtering->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-matrix/","text":"DSP Matrix \u00b6 lbuild module: modm:cmsis:dsp:matrix Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:matrix"},{"location":"reference/module/modm-cmsis-dsp-matrix/#dsp-matrix","text":"lbuild module: modm:cmsis:dsp:matrix Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"DSP Matrix"},{"location":"reference/module/modm-cmsis-dsp-statistics/","text":"DSP Statistics \u00b6 lbuild module: modm:cmsis:dsp:statistics Dependencies \u00b6 modm:cmsis:dsp:statistics modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_statistics->modm_cmsis_dsp_fast_math @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:statistics"},{"location":"reference/module/modm-cmsis-dsp-statistics/#dsp-statistics","text":"lbuild module: modm:cmsis:dsp:statistics","title":"DSP Statistics"},{"location":"reference/module/modm-cmsis-dsp-statistics/#dependencies","text":"modm:cmsis:dsp:statistics modm_cmsis_dsp_statistics modm: cmsis: dsp: statistics modm_cmsis_dsp_fast_math modm: cmsis: dsp: fast_math modm_cmsis_dsp_statistics->modm_cmsis_dsp_fast_math @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp-support/","text":"DSP Support \u00b6 lbuild module: modm:cmsis:dsp:support Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:support"},{"location":"reference/module/modm-cmsis-dsp-support/#dsp-support","text":"lbuild module: modm:cmsis:dsp:support Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"DSP Support"},{"location":"reference/module/modm-cmsis-dsp-svm/","text":"DSP Svm \u00b6 lbuild module: modm:cmsis:dsp:svm Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:svm"},{"location":"reference/module/modm-cmsis-dsp-svm/#dsp-svm","text":"lbuild module: modm:cmsis:dsp:svm Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"DSP Svm"},{"location":"reference/module/modm-cmsis-dsp-tables/","text":"DSP Tables \u00b6 lbuild module: modm:cmsis:dsp:tables Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:tables"},{"location":"reference/module/modm-cmsis-dsp-tables/#dsp-tables","text":"lbuild module: modm:cmsis:dsp:tables Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"DSP Tables"},{"location":"reference/module/modm-cmsis-dsp-transform/","text":"DSP Transform \u00b6 lbuild module: modm:cmsis:dsp:transform Dependencies \u00b6 modm:cmsis:dsp:transform modm_cmsis_dsp_transform modm: cmsis: dsp: transform modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_transform->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp:transform"},{"location":"reference/module/modm-cmsis-dsp-transform/#dsp-transform","text":"lbuild module: modm:cmsis:dsp:transform","title":"DSP Transform"},{"location":"reference/module/modm-cmsis-dsp-transform/#dependencies","text":"modm:cmsis:dsp:transform modm_cmsis_dsp_transform modm: cmsis: dsp: transform modm_cmsis_dsp_tables modm: cmsis: dsp: tables modm_cmsis_dsp_transform->modm_cmsis_dsp_tables @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-cmsis-dsp/","text":"ARM CMSIS-DSP \u00b6 lbuild module: modm:cmsis:dsp This module provides the CMSIS-DSP library. Please see the API documentation for details. Options \u00b6 check_matrix_sizes \u00b6 Check input/output matrix size Check the input and output sizes of matrices and return ARM_MATH_SIZE_MISMATCH on failure. Default: False Inputs: [True, False] loop_unroll \u00b6 Loop Unroll Enables manual loop unrolling in DSP functions. Default: True Inputs: [True, False] round_float_inputs \u00b6 Round float inputs Rounds float inputs properly during all conversions. Default: True Inputs: [True, False] unaligned_data \u00b6 Allow unaligned data storage If the core supports it, this options enables storing data in unaligned memory. This may reduce data size, but cost some speed. This option is only available for stm32{f1,f2,f3,f4,f7,g4,l1,l4}. Default: False Inputs: [True, False] Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis:dsp"},{"location":"reference/module/modm-cmsis-dsp/#arm-cmsis-dsp","text":"lbuild module: modm:cmsis:dsp This module provides the CMSIS-DSP library. Please see the API documentation for details.","title":"ARM CMSIS-DSP"},{"location":"reference/module/modm-cmsis-dsp/#options","text":"","title":"Options"},{"location":"reference/module/modm-cmsis-dsp/#check_matrix_sizes","text":"Check input/output matrix size Check the input and output sizes of matrices and return ARM_MATH_SIZE_MISMATCH on failure. Default: False Inputs: [True, False]","title":"check_matrix_sizes"},{"location":"reference/module/modm-cmsis-dsp/#loop_unroll","text":"Loop Unroll Enables manual loop unrolling in DSP functions. Default: True Inputs: [True, False]","title":"loop_unroll"},{"location":"reference/module/modm-cmsis-dsp/#round_float_inputs","text":"Round float inputs Rounds float inputs properly during all conversions. Default: True Inputs: [True, False]","title":"round_float_inputs"},{"location":"reference/module/modm-cmsis-dsp/#unaligned_data","text":"Allow unaligned data storage If the core supports it, this options enables storing data in unaligned memory. This may reduce data size, but cost some speed. This option is only available for stm32{f1,f2,f3,f4,f7,g4,l1,l4}. Default: False Inputs: [True, False] Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"unaligned_data"},{"location":"reference/module/modm-cmsis/","text":"ARM CMSIS Support \u00b6 lbuild module: modm:cmsis The Cortex Microcontroller Software Interface Standard is a software standard by ARM that defines a number of foundational interfaces for Cortex-M microcontrollers. We use only use these parts of CMSIS: The modm:cmsis:core module provides access to the ARM Cortex-M peripherals via CMSIS-CORE. The modm:cmsis:device module provides access to the peripherals of the modm:target devices via the vendor's CMSIS implementation. The modm:cmsis:dsp module provides a basic digital signal processing library via CMSIS-DSP. This module is only available for sam, stm32. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":cmsis"},{"location":"reference/module/modm-cmsis/#arm-cmsis-support","text":"lbuild module: modm:cmsis The Cortex Microcontroller Software Interface Standard is a software standard by ARM that defines a number of foundational interfaces for Cortex-M microcontrollers. We use only use these parts of CMSIS: The modm:cmsis:core module provides access to the ARM Cortex-M peripherals via CMSIS-CORE. The modm:cmsis:device module provides access to the peripherals of the modm:target devices via the vendor's CMSIS implementation. The modm:cmsis:dsp module provides a basic digital signal processing library via CMSIS-DSP. This module is only available for sam, stm32. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"ARM CMSIS Support"},{"location":"reference/module/modm-communication-amnb/","text":"Asynchronous Multi-Node Bus (AMNB) \u00b6 lbuild module: modm:communication:amnb The AMNB (**A**synchronous **M**ulti-**N**ode **B**us) is a multi-master bus system, using p-persistent CSMA/CD to send messages. One bus can be populated with up to 256 (logical) nodes. The nodes can be queried for data and they will respond like an SAB Slave, and can query data from other nodes like an SAB Master, or they can just broadcast a message. Each node can listen to all the responses and broadcasts and store that information for its purpose. Action callbacks to query requests can be defined as well as universal callbacks to any transmitted messaged (Listener callbacks). As an optional advanced feature, error handling callbacks can also be defined, which fire if messages have not been able to be sent, or requests timed out or misbehaved in other manners, or other nodes query unavailable information. Protocol Structure \u00b6 Message without data: SYNC : Synchronization sequence. CRC8 : checksum for the header ADDR : Node address. TYPE : Message type . COMMAND : Command code. 1 2 3 4 5 6 +------+------+------+---------+------+ | SYNC | CRC8 | ADDR | COMMAND | TYPE | +------+------+------+---------+------+ Message with <=28B data: CRC8 : checksum for the header and data. TYPE/LENGTH : Message type and length. 1 2 3 4 5 6 7 ... +------+------+------+---------+-------------+--------------------+ | SYNC | CRC8 | ADDR | COMMAND | TYPE/LENGTH | ... <=28B DATA ... | +------+------+------+---------+-------------+--------------------+ Message with <8kB data: CRC16 : checksum for the data. DATA : Up to 8kB payload (nodes may support much less though!) 1 2 3 4 5 6 7 8 9 10 11 ... +------+------+------+---------+------+--------+-------+-------------------+ | SYNC | CRC8 | ADDR | COMMAND | TYPE | LENGTH | CRC16 | ... <8kB DATA ... | +------+------+------+---------+------+--------+-------+-------------------+ Message Types \u00b6 Type Meaning 000 Data broadcast by a node 010 Data request by a node 100 Negative response from the node (NACK) 101 Positive response from the node (ACK) When transmitting, the second bit determines, whether or not to expect an answer from the addressed node. To just send information without any need for acknowledgment, use a broadcast. When a node is responding, the second bit has the following meaning: true : Message is an positive response and may contain a payload false : Message signals an error condition and carries only one byte of payload. This byte is an error code. Electrical characteristics \u00b6 Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. These are identical to the SAB CAN electrical characteristics. You have to use the CAN transceivers, otherwise it cannot be determined, if the bus is busy or available for transmission. Options \u00b6 with_heap \u00b6 Allow large messages to allocate on the heap. Default: True Inputs: [True, False] Dependencies \u00b6 modm:communication:amnb modm_communication_amnb modm: communication: amnb modm_container modm: container modm_communication_amnb->modm_container modm_math_utils modm: math: utils modm_communication_amnb->modm_math_utils modm_processing_resumable modm: processing: resumable modm_communication_amnb->modm_processing_resumable modm_processing_timer modm: processing: timer modm_communication_amnb->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":communication:amnb"},{"location":"reference/module/modm-communication-amnb/#asynchronous-multi-node-bus-amnb","text":"lbuild module: modm:communication:amnb The AMNB (**A**synchronous **M**ulti-**N**ode **B**us) is a multi-master bus system, using p-persistent CSMA/CD to send messages. One bus can be populated with up to 256 (logical) nodes. The nodes can be queried for data and they will respond like an SAB Slave, and can query data from other nodes like an SAB Master, or they can just broadcast a message. Each node can listen to all the responses and broadcasts and store that information for its purpose. Action callbacks to query requests can be defined as well as universal callbacks to any transmitted messaged (Listener callbacks). As an optional advanced feature, error handling callbacks can also be defined, which fire if messages have not been able to be sent, or requests timed out or misbehaved in other manners, or other nodes query unavailable information.","title":"Asynchronous Multi-Node Bus (AMNB)"},{"location":"reference/module/modm-communication-amnb/#protocol-structure","text":"Message without data: SYNC : Synchronization sequence. CRC8 : checksum for the header ADDR : Node address. TYPE : Message type . COMMAND : Command code. 1 2 3 4 5 6 +------+------+------+---------+------+ | SYNC | CRC8 | ADDR | COMMAND | TYPE | +------+------+------+---------+------+ Message with <=28B data: CRC8 : checksum for the header and data. TYPE/LENGTH : Message type and length. 1 2 3 4 5 6 7 ... +------+------+------+---------+-------------+--------------------+ | SYNC | CRC8 | ADDR | COMMAND | TYPE/LENGTH | ... <=28B DATA ... | +------+------+------+---------+-------------+--------------------+ Message with <8kB data: CRC16 : checksum for the data. DATA : Up to 8kB payload (nodes may support much less though!) 1 2 3 4 5 6 7 8 9 10 11 ... +------+------+------+---------+------+--------+-------+-------------------+ | SYNC | CRC8 | ADDR | COMMAND | TYPE | LENGTH | CRC16 | ... <8kB DATA ... | +------+------+------+---------+------+--------+-------+-------------------+","title":"Protocol Structure"},{"location":"reference/module/modm-communication-amnb/#message-types","text":"Type Meaning 000 Data broadcast by a node 010 Data request by a node 100 Negative response from the node (NACK) 101 Positive response from the node (ACK) When transmitting, the second bit determines, whether or not to expect an answer from the addressed node. To just send information without any need for acknowledgment, use a broadcast. When a node is responding, the second bit has the following meaning: true : Message is an positive response and may contain a payload false : Message signals an error condition and carries only one byte of payload. This byte is an error code.","title":"Message Types"},{"location":"reference/module/modm-communication-amnb/#electrical-characteristics","text":"Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. These are identical to the SAB CAN electrical characteristics. You have to use the CAN transceivers, otherwise it cannot be determined, if the bus is busy or available for transmission.","title":"Electrical characteristics"},{"location":"reference/module/modm-communication-amnb/#options","text":"","title":"Options"},{"location":"reference/module/modm-communication-amnb/#with_heap","text":"Allow large messages to allocate on the heap. Default: True Inputs: [True, False]","title":"with_heap"},{"location":"reference/module/modm-communication-amnb/#dependencies","text":"modm:communication:amnb modm_communication_amnb modm: communication: amnb modm_container modm: container modm_communication_amnb->modm_container modm_math_utils modm: math: utils modm_communication_amnb->modm_math_utils modm_processing_resumable modm: processing: resumable modm_communication_amnb->modm_processing_resumable modm_processing_timer modm: processing: timer modm_communication_amnb->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-communication-ros/","text":"Drivers for rosserial \u00b6 lbuild module: modm:communication:ros Dependencies \u00b6 modm:communication:ros modm_communication_ros modm: communication: ros modm_architecture_clock modm: architecture: clock modm_communication_ros->modm_architecture_clock modm_architecture_uart modm: architecture: uart modm_communication_ros->modm_architecture_uart modm_processing_timer modm: processing: timer modm_communication_ros->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":communication:ros"},{"location":"reference/module/modm-communication-ros/#drivers-for-rosserial","text":"lbuild module: modm:communication:ros","title":"Drivers for rosserial"},{"location":"reference/module/modm-communication-ros/#dependencies","text":"modm:communication:ros modm_communication_ros modm: communication: ros modm_architecture_clock modm: architecture: clock modm_communication_ros->modm_architecture_clock modm_architecture_uart modm: architecture: uart modm_communication_ros->modm_architecture_uart modm_processing_timer modm: processing: timer modm_communication_ros->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-communication-sab/","text":"Sensor Actuator Bus (SAB) \u00b6 lbuild module: modm:communication:sab The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave. Protocol \u00b6 Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire) Structure \u00b6 +------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton) Header \u00b6 7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code. Electrical characteristics \u00b6 Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them). Dependencies \u00b6 modm:communication:sab modm_communication_sab modm: communication: sab modm_architecture_accessor modm: architecture: accessor modm_communication_sab->modm_architecture_accessor modm_debug modm: debug modm_communication_sab->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":communication:sab"},{"location":"reference/module/modm-communication-sab/#sensor-actuator-bus-sab","text":"lbuild module: modm:communication:sab The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave.","title":"Sensor Actuator Bus (SAB)"},{"location":"reference/module/modm-communication-sab/#protocol","text":"Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire)","title":"Protocol"},{"location":"reference/module/modm-communication-sab/#structure","text":"+------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton)","title":"Structure"},{"location":"reference/module/modm-communication-sab/#header","text":"7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code.","title":"Header"},{"location":"reference/module/modm-communication-sab/#electrical-characteristics","text":"Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them).","title":"Electrical characteristics"},{"location":"reference/module/modm-communication-sab/#dependencies","text":"modm:communication:sab modm_communication_sab modm: communication: sab modm_architecture_accessor modm: architecture: accessor modm_communication_sab->modm_architecture_accessor modm_debug modm: debug modm_communication_sab->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-communication-sab2/","text":"Sensor Actuator Bus Version 2 (SAB2) \u00b6 lbuild module: modm:communication:sab2 The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave. Protocol \u00b6 Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire) Structure \u00b6 +------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton) Header \u00b6 7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code. Electrical characteristics \u00b6 Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them). Dependencies \u00b6 modm:communication:sab2 modm_communication_sab2 modm: communication: sab2 modm_architecture_accessor modm: architecture: accessor modm_communication_sab2->modm_architecture_accessor modm_communication_sab modm: communication: sab modm_communication_sab2->modm_communication_sab modm_debug modm: debug modm_communication_sab2->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab2->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":communication:sab2"},{"location":"reference/module/modm-communication-sab2/#sensor-actuator-bus-version-2-sab2","text":"lbuild module: modm:communication:sab2 The SAB (**S**ensor **A**ctuator **B**us) is a simple master-slave bus system. It is primarily used to query simple sensors and control actuators inside our robots. One master can communicate with up to 32 slaves. The slaves are only allowed to transmit after a direct request by the master. They may signal an event by an extra IO line, but this depends on the slave.","title":"Sensor Actuator Bus Version 2 (SAB2)"},{"location":"reference/module/modm-communication-sab2/#protocol","text":"Features: - Baudrate is 115200 Baud. - Maximum payload length is 32 byte. - CRC8 (1-Wire)","title":"Protocol"},{"location":"reference/module/modm-communication-sab2/#structure","text":"+------+--------+--------+---------+--------------+-----+ | SYNC | LENGTH | HEADER | COMMAND | ... DATA ... | CRC | +------+--------+--------+---------+--------------+-----+ SYNC - Synchronization byte (always 0x54) LENGTH - Length of the payload (without header, command and CRC byte) HEADER - Address of the slave and two flag bits COMMAND - Command code DATA - Up to 32 byte of payload CRC - CRC-8 checksum (iButton)","title":"Structure"},{"location":"reference/module/modm-communication-sab2/#header","text":"7 6 5 4 3 2 1 0 +---+---+---+---+---+---+---+---+ | Flags | ADDRESS | +---+---+---+---+---+---+---+---+ Flags | Meaning --------+--------- 0 0 | request by the master 0 1 | reserved 1 0 | negative response from the slave (NACK) 1 1 | positive response from the slave (ACK) The second bit is always false when the master is transmitting. In the other direction, when the slaves are responding, the second bit has to following meaning: true - Message is an positive response and may contain a payload false - Message signals an error condition and carries only one byte of payload. This byte is an error code.","title":"Header"},{"location":"reference/module/modm-communication-sab2/#electrical-characteristics","text":"Between different boards CAN transceivers are used. Compared to RS485 the CAN transceivers have the advantage to work without a separate direction input. You can just connected the transceiver directly to the UART of your microcontroller. Within a single PCB, standard digital levels are used (either 0-3,3V or 0-5V) in a multi-drop configuration. Meaning it does not allow multiple drivers but multiple receivers. The idle state of a UART transmission line is high, so standard TTL-AND gates have to be used for bundling transmission lines from multiple slaves. Both approaches can be combined to reduce the number of needed CAN transceivers on a single board. Between two boards you should always use transceivers and therefore differential signaling to improve noise immunity. The signal lines to indicate events by the slave are strict optional, you may or may not use them (if the slave provides them).","title":"Electrical characteristics"},{"location":"reference/module/modm-communication-sab2/#dependencies","text":"modm:communication:sab2 modm_communication_sab2 modm: communication: sab2 modm_architecture_accessor modm: architecture: accessor modm_communication_sab2->modm_architecture_accessor modm_communication_sab modm: communication: sab modm_communication_sab2->modm_communication_sab modm_debug modm: debug modm_communication_sab2->modm_debug modm_processing_timer modm: processing: timer modm_communication_sab2->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-communication-xpcc-generator/","text":"XPCC Generator \u00b6 lbuild module: modm:communication:xpcc:generator Options \u00b6 container \u00b6 Name of the XPCC container to generate for Default: \"\" Inputs: [String] namespace \u00b6 Namespace of the generated XPCC communications Default: robot Inputs: [String] path \u00b6 Path to the XPCC generated folder Default: generated/xpcc Inputs: [Path] source \u00b6 Path to the XPCC source file Default: [] Inputs: [Path]","title":":communication:xpcc:generator"},{"location":"reference/module/modm-communication-xpcc-generator/#xpcc-generator","text":"lbuild module: modm:communication:xpcc:generator","title":"XPCC Generator"},{"location":"reference/module/modm-communication-xpcc-generator/#options","text":"","title":"Options"},{"location":"reference/module/modm-communication-xpcc-generator/#container","text":"Name of the XPCC container to generate for Default: \"\" Inputs: [String]","title":"container"},{"location":"reference/module/modm-communication-xpcc-generator/#namespace","text":"Namespace of the generated XPCC communications Default: robot Inputs: [String]","title":"namespace"},{"location":"reference/module/modm-communication-xpcc-generator/#path","text":"Path to the XPCC generated folder Default: generated/xpcc Inputs: [Path]","title":"path"},{"location":"reference/module/modm-communication-xpcc-generator/#source","text":"Path to the XPCC source file Default: [] Inputs: [Path]","title":"source"},{"location":"reference/module/modm-communication-xpcc/","text":"Cross Platform Component Communication (XPCC) \u00b6 lbuild module: modm:communication:xpcc Options \u00b6 timeout.acknowledge \u00b6 Timeout in ms of an reception acknowledgement Default: 100 Inputs: [10 .. 100 .. 10000] timeout.response \u00b6 Timeout in ms of an request response Default: 200 Inputs: [10 .. 200 .. 10000] Dependencies \u00b6 modm:communication:xpcc modm_communication_xpcc modm: communication: xpcc modm_architecture_can modm: architecture: can modm_communication_xpcc->modm_architecture_can modm_container modm: container modm_communication_xpcc->modm_container modm_debug modm: debug modm_communication_xpcc->modm_debug modm_io modm: io modm_communication_xpcc->modm_io modm_math_utils modm: math: utils modm_communication_xpcc->modm_math_utils modm_processing_resumable modm: processing: resumable modm_communication_xpcc->modm_processing_resumable modm_processing_timer modm: processing: timer modm_communication_xpcc->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":communication:xpcc"},{"location":"reference/module/modm-communication-xpcc/#cross-platform-component-communication-xpcc","text":"lbuild module: modm:communication:xpcc","title":"Cross Platform Component Communication (XPCC)"},{"location":"reference/module/modm-communication-xpcc/#options","text":"","title":"Options"},{"location":"reference/module/modm-communication-xpcc/#timeoutacknowledge","text":"Timeout in ms of an reception acknowledgement Default: 100 Inputs: [10 .. 100 .. 10000]","title":"timeout.acknowledge"},{"location":"reference/module/modm-communication-xpcc/#timeoutresponse","text":"Timeout in ms of an request response Default: 200 Inputs: [10 .. 200 .. 10000]","title":"timeout.response"},{"location":"reference/module/modm-communication-xpcc/#dependencies","text":"modm:communication:xpcc modm_communication_xpcc modm: communication: xpcc modm_architecture_can modm: architecture: can modm_communication_xpcc->modm_architecture_can modm_container modm: container modm_communication_xpcc->modm_container modm_debug modm: debug modm_communication_xpcc->modm_debug modm_io modm: io modm_communication_xpcc->modm_io modm_math_utils modm: math: utils modm_communication_xpcc->modm_math_utils modm_processing_resumable modm: processing: resumable modm_communication_xpcc->modm_processing_resumable modm_processing_timer modm: processing: timer modm_communication_xpcc->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-communication/","text":"Communication Protocols \u00b6 lbuild module: modm:communication","title":":communication"},{"location":"reference/module/modm-communication/#communication-protocols","text":"lbuild module: modm:communication","title":"Communication Protocols"},{"location":"reference/module/modm-container/","text":"Containers \u00b6 lbuild module: modm:container A container is a holder object that stores a collection other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements. Many containers have several member functions in common, and share functionalities. The decision of which type of container to use for a specific need does not generally depend only on the functionality offered by the container, but also on the efficiency of some of its members (complexity). This is especially true for sequence containers, which offer different trade-offs in complexity between inserting/removing elements and accessing them. modm::Stack and modm::Queue are implemented as container adapters. Container adapters are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as modm::BoundedDeque or modm::LinkedList ) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container class independently of the underlying container class used. Sequence containers: modm::DynamicArray modm::LinkedList modm::DoublyLinkedList modm::BoundedDeque Container adapters: modm::Queue modm::Stack modm::BoundedStack modm::BoundedQueue Other: modm::SmartPointer modm::Pair Two special containers hiding in the modm:architecture:atomic module: modm::atomic::Queue modm::atomic::Container The first is a simple, interrupt-safe queue (but only for the AVRs). Whenever you need to exchange data between a interrupt routine and the normal program consider using this queue. The atomic container wraps objects and provides atomic access to them. This comes in handy when simple objects are accessed by an interrupt and the main program. The container provides secure access without much work in this case. Generic Interface \u00b6 All implementation share a common set of function. Not every container implement every one of it, only a subset which is sufficient for the container. append prepend (insert) removeFront removeBack (remove) getFront getBack push (only Stack and Queue) pop (only Stack and Queue) get (only Stack and Queue) at operator[] clear isEmpty isFull getSize getMaxSize getCapacity Dependencies \u00b6 modm:container modm_container modm: container modm_architecture modm: architecture modm_container->modm_architecture modm_io modm: io modm_container->modm_io modm_utils modm: utils modm_container->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":container"},{"location":"reference/module/modm-container/#containers","text":"lbuild module: modm:container A container is a holder object that stores a collection other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements. Many containers have several member functions in common, and share functionalities. The decision of which type of container to use for a specific need does not generally depend only on the functionality offered by the container, but also on the efficiency of some of its members (complexity). This is especially true for sequence containers, which offer different trade-offs in complexity between inserting/removing elements and accessing them. modm::Stack and modm::Queue are implemented as container adapters. Container adapters are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as modm::BoundedDeque or modm::LinkedList ) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container class independently of the underlying container class used. Sequence containers: modm::DynamicArray modm::LinkedList modm::DoublyLinkedList modm::BoundedDeque Container adapters: modm::Queue modm::Stack modm::BoundedStack modm::BoundedQueue Other: modm::SmartPointer modm::Pair Two special containers hiding in the modm:architecture:atomic module: modm::atomic::Queue modm::atomic::Container The first is a simple, interrupt-safe queue (but only for the AVRs). Whenever you need to exchange data between a interrupt routine and the normal program consider using this queue. The atomic container wraps objects and provides atomic access to them. This comes in handy when simple objects are accessed by an interrupt and the main program. The container provides secure access without much work in this case.","title":"Containers"},{"location":"reference/module/modm-container/#generic-interface","text":"All implementation share a common set of function. Not every container implement every one of it, only a subset which is sufficient for the container. append prepend (insert) removeFront removeBack (remove) getFront getBack push (only Stack and Queue) pop (only Stack and Queue) get (only Stack and Queue) at operator[] clear isEmpty isFull getSize getMaxSize getCapacity","title":"Generic Interface"},{"location":"reference/module/modm-container/#dependencies","text":"modm:container modm_container modm: container modm_architecture modm: architecture modm_container->modm_architecture modm_io modm: io modm_container->modm_io modm_utils modm: utils modm_container->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-crashcatcher/","text":"CrashCatcher \u00b6 lbuild module: modm:crashcatcher CrashCatcher hooks into the ARM Cortex-M HardFault handler and generates a coredump that can be used with CrashDebug for post-mortem debugging. https://github.com/adamgreen/CrashCatcher https://github.com/adamgreen/CrashDebug This module is only available for sam, stm32. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":crashcatcher"},{"location":"reference/module/modm-crashcatcher/#crashcatcher","text":"lbuild module: modm:crashcatcher CrashCatcher hooks into the ARM Cortex-M HardFault handler and generates a coredump that can be used with CrashDebug for post-mortem debugging. https://github.com/adamgreen/CrashCatcher https://github.com/adamgreen/CrashDebug This module is only available for sam, stm32. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"CrashCatcher"},{"location":"reference/module/modm-debug/","text":"Logging \u00b6 lbuild module: modm:debug The modm::log::Logger uses a modm::IOStream to read messages and write them to a given output device. Write a log message with streams: MODM_LOG_DEBUG << \"i=\" << i << \", y=\" << y << modm :: flush ; The name of the stream represents the log level of the message. Available are: MODM_LOG_DEBUG MODM_LOG_INFO MODM_LOG_WARNING MODM_LOG_ERROR A log message can also be generated separately: int a [ 3 ] = { 1 , 2 , 3 }; MODM_LOG_DEBUG << \"a = \" ; for ( int i = 0 ; i < sizeof ( a ); ++ i ) { MODM_LOG_DEBUG << a [ i ] << \", \" ; } MODM_LOG_DEBUG << modm :: flush ; Flow of a call \u00b6 This is to give an estimation how many resources a call of the logger use. All considerations are for a PC program. The given call is: MODM_LOG_DEBUG << 123456 ; The macro resolves to: if ( MODM_LOG_LEVEL <= modm :: log :: DEBUG ) modm :: log :: debug modm::log::debug is an instance of modm::Logger : Call of modm::Logger::operator << (T) (with T = int32_t ) which is inline IOStream::operator << (T) (with T = int32_t ) is inline IOStream::writeInteger(int32_t) IOStream::writeInteger(int32_t) will create the formatted string virtual call of IODevice::write(const char*) redirect to std::cout In sum there are two nested method calls with one of them being virtual. Dependencies \u00b6 modm:debug modm_debug modm: debug modm_architecture modm: architecture modm_debug->modm_architecture modm_driver_terminal modm: driver: terminal modm_debug->modm_driver_terminal modm_io modm: io modm_debug->modm_io modm_utils modm: utils modm_debug->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":debug"},{"location":"reference/module/modm-debug/#logging","text":"lbuild module: modm:debug The modm::log::Logger uses a modm::IOStream to read messages and write them to a given output device. Write a log message with streams: MODM_LOG_DEBUG << \"i=\" << i << \", y=\" << y << modm :: flush ; The name of the stream represents the log level of the message. Available are: MODM_LOG_DEBUG MODM_LOG_INFO MODM_LOG_WARNING MODM_LOG_ERROR A log message can also be generated separately: int a [ 3 ] = { 1 , 2 , 3 }; MODM_LOG_DEBUG << \"a = \" ; for ( int i = 0 ; i < sizeof ( a ); ++ i ) { MODM_LOG_DEBUG << a [ i ] << \", \" ; } MODM_LOG_DEBUG << modm :: flush ;","title":"Logging"},{"location":"reference/module/modm-debug/#flow-of-a-call","text":"This is to give an estimation how many resources a call of the logger use. All considerations are for a PC program. The given call is: MODM_LOG_DEBUG << 123456 ; The macro resolves to: if ( MODM_LOG_LEVEL <= modm :: log :: DEBUG ) modm :: log :: debug modm::log::debug is an instance of modm::Logger : Call of modm::Logger::operator << (T) (with T = int32_t ) which is inline IOStream::operator << (T) (with T = int32_t ) is inline IOStream::writeInteger(int32_t) IOStream::writeInteger(int32_t) will create the formatted string virtual call of IODevice::write(const char*) redirect to std::cout In sum there are two nested method calls with one of them being virtual.","title":"Flow of a call"},{"location":"reference/module/modm-debug/#dependencies","text":"modm:debug modm_debug modm: debug modm_architecture modm: architecture modm_debug->modm_architecture modm_driver_terminal modm: driver: terminal modm_debug->modm_driver_terminal modm_io modm: io modm_debug->modm_io modm_utils modm: utils modm_debug->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-docs/","text":"Documentation Generator \u00b6 lbuild module: modm:docs This module creates the documentation groups and hierarchy according to the modm module structure into modm/docs . The documentation can be generated using Doxygen or Doxypress. Doxygen \u00b6 To generate the C++ documentation call Doxygen manually: (cd modm/docs && doxygen doxyfile.cfg) Then open modm/docs/html/index.html in your web browser of choice. Doxypress \u00b6 Install Doxypress. To generate the C++ documentation call Doxypress: (cd modm/docs && doxypress doxypress.json) Then open modm/docs/html/index.html in your web browser of choice. Options \u00b6 enable_qch \u00b6 Generate the Doxygen docs as Qt Help format (qch) Default: False Inputs: [True, False]","title":":docs"},{"location":"reference/module/modm-docs/#documentation-generator","text":"lbuild module: modm:docs This module creates the documentation groups and hierarchy according to the modm module structure into modm/docs . The documentation can be generated using Doxygen or Doxypress.","title":"Documentation Generator"},{"location":"reference/module/modm-docs/#doxygen","text":"To generate the C++ documentation call Doxygen manually: (cd modm/docs && doxygen doxyfile.cfg) Then open modm/docs/html/index.html in your web browser of choice.","title":"Doxygen"},{"location":"reference/module/modm-docs/#doxypress","text":"Install Doxypress. To generate the C++ documentation call Doxypress: (cd modm/docs && doxypress doxypress.json) Then open modm/docs/html/index.html in your web browser of choice.","title":"Doxypress"},{"location":"reference/module/modm-docs/#options","text":"","title":"Options"},{"location":"reference/module/modm-docs/#enable_qch","text":"Generate the Doxygen docs as Qt Help format (qch) Default: False Inputs: [True, False]","title":"enable_qch"},{"location":"reference/module/modm-driver-ad7280a/","text":"AD7280A Lithium Ion Battery Monitoring System \u00b6 lbuild module: modm:driver:ad7280a The AD7280A is monitor for lithium ion battery packs with up to six cells. It contains six 12-ADCs with 1\u00b5s conversion per channel and a cell balancing interface. Up to 7 devices can be added through a Daisy-Chain interface (chain of 8 devices). cell voltage accuracy of \u00b11.6 mV. Supply voltage 8-30V six auxiliary ADC input channels Recommended SPI Clk frequency is 1 MHz. With a 1 MHz Clk, it takes approximately 1.54 ms to read back the voltage conversions on 48 channels. When addressing devices in the chain directly the frequency needs to be lower than 1 MHz because delays introduced in each stage of the chain. Dependencies \u00b6 modm:driver:ad7280a modm_driver_ad7280a modm: driver: ad7280a modm_architecture_delay modm: architecture: delay modm_driver_ad7280a->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7280a->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_ad7280a->modm_architecture_spi modm_io modm: io modm_driver_ad7280a->modm_io modm_math_utils modm: math: utils modm_driver_ad7280a->modm_math_utils modm_utils modm: utils modm_driver_ad7280a->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ad7280a"},{"location":"reference/module/modm-driver-ad7280a/#ad7280a-lithium-ion-battery-monitoring-system","text":"lbuild module: modm:driver:ad7280a The AD7280A is monitor for lithium ion battery packs with up to six cells. It contains six 12-ADCs with 1\u00b5s conversion per channel and a cell balancing interface. Up to 7 devices can be added through a Daisy-Chain interface (chain of 8 devices). cell voltage accuracy of \u00b11.6 mV. Supply voltage 8-30V six auxiliary ADC input channels Recommended SPI Clk frequency is 1 MHz. With a 1 MHz Clk, it takes approximately 1.54 ms to read back the voltage conversions on 48 channels. When addressing devices in the chain directly the frequency needs to be lower than 1 MHz because delays introduced in each stage of the chain.","title":"AD7280A Lithium Ion Battery Monitoring System"},{"location":"reference/module/modm-driver-ad7280a/#dependencies","text":"modm:driver:ad7280a modm_driver_ad7280a modm: driver: ad7280a modm_architecture_delay modm: architecture: delay modm_driver_ad7280a->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7280a->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_ad7280a->modm_architecture_spi modm_io modm: io modm_driver_ad7280a->modm_io modm_math_utils modm: math: utils modm_driver_ad7280a->modm_math_utils modm_utils modm: utils modm_driver_ad7280a->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ad7928/","text":"AD79x8 ADC \u00b6 lbuild module: modm:driver:ad7928 The AD7928/AD7918/AD7908 are, respectively, 12/10/8 bit analog-digital converters. The conversion time is determined by the Spi clock frequency. A maximum Spi clock of 20 Mhz is supported. Dependencies \u00b6 modm:driver:ad7928 modm_driver_ad7928 modm: driver: ad7928 modm_architecture_accessor modm: architecture: accessor modm_driver_ad7928->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ad7928->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7928->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ad7928->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ad7928->modm_architecture_spi_device modm_io modm: io modm_driver_ad7928->modm_io modm_processing_resumable modm: processing: resumable modm_driver_ad7928->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ad7928"},{"location":"reference/module/modm-driver-ad7928/#ad79x8-adc","text":"lbuild module: modm:driver:ad7928 The AD7928/AD7918/AD7908 are, respectively, 12/10/8 bit analog-digital converters. The conversion time is determined by the Spi clock frequency. A maximum Spi clock of 20 Mhz is supported.","title":"AD79x8 ADC"},{"location":"reference/module/modm-driver-ad7928/#dependencies","text":"modm:driver:ad7928 modm_driver_ad7928 modm: driver: ad7928 modm_architecture_accessor modm: architecture: accessor modm_driver_ad7928->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ad7928->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ad7928->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ad7928->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ad7928->modm_architecture_spi_device modm_io modm: io modm_driver_ad7928->modm_io modm_processing_resumable modm: processing: resumable modm_driver_ad7928->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-adc_sampler/","text":"Oversampling of ADC inputs \u00b6 lbuild module: modm:driver:adc_sampler This template class stores 8, 16 or 32bit ADC values in a buffer and provides an easy interface for managing that data. The code will read the ADC channels you specify in an array. This means you can remap the ADC channels in the order that they should appear in the buffer. The array must obviously have as many elements as channels! For example, if channels 0,2,7 are connected, but the sensors are in the wrong order, just remap them with the array {7,0,2}. To make use of oversampling and averaging, set Oversamples > 0 . This will loop Oversamples times through the ADC channels, adding the average of each result to the buffer. This class will choose the smallest data width for you. It decides this by adding the ADC resolution and the oversample size and choosing the next smallest size (not larger than 32bit though!). Warning The averaging algorithm only works for unsigned ADC data! Dependencies \u00b6 modm:driver:adc_sampler modm_driver_adc_sampler modm: driver: adc_sampler modm_architecture_adc modm: architecture: adc modm_driver_adc_sampler->modm_architecture_adc modm_math_utils modm: math: utils modm_driver_adc_sampler->modm_math_utils modm_utils modm: utils modm_driver_adc_sampler->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:adc_sampler"},{"location":"reference/module/modm-driver-adc_sampler/#oversampling-of-adc-inputs","text":"lbuild module: modm:driver:adc_sampler This template class stores 8, 16 or 32bit ADC values in a buffer and provides an easy interface for managing that data. The code will read the ADC channels you specify in an array. This means you can remap the ADC channels in the order that they should appear in the buffer. The array must obviously have as many elements as channels! For example, if channels 0,2,7 are connected, but the sensors are in the wrong order, just remap them with the array {7,0,2}. To make use of oversampling and averaging, set Oversamples > 0 . This will loop Oversamples times through the ADC channels, adding the average of each result to the buffer. This class will choose the smallest data width for you. It decides this by adding the ADC resolution and the oversample size and choosing the next smallest size (not larger than 32bit though!). Warning The averaging algorithm only works for unsigned ADC data!","title":"Oversampling of ADC inputs"},{"location":"reference/module/modm-driver-adc_sampler/#dependencies","text":"modm:driver:adc_sampler modm_driver_adc_sampler modm: driver: adc_sampler modm_architecture_adc modm: architecture: adc modm_driver_adc_sampler->modm_architecture_adc modm_math_utils modm: math: utils modm_driver_adc_sampler->modm_math_utils modm_utils modm: utils modm_driver_adc_sampler->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-adns9800/","text":"ADNS-9800 Laser Motion Sensor \u00b6 lbuild module: modm:driver:adns9800 Based on work of Alexander Entinger, MSc / LXRobotics Based on https://github.com/mrjohnk/ADNS-9800 Options \u00b6 firmware \u00b6 Select the firmware version to initialize the device with. Default: a6 Inputs: [a4, a4b, a5, a6] Dependencies \u00b6 modm:driver:adns9800 modm_driver_adns9800 modm: driver: adns9800 modm_architecture_delay modm: architecture: delay modm_driver_adns9800->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_adns9800->modm_architecture_spi modm_debug modm: debug modm_driver_adns9800->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:adns9800"},{"location":"reference/module/modm-driver-adns9800/#adns-9800-laser-motion-sensor","text":"lbuild module: modm:driver:adns9800 Based on work of Alexander Entinger, MSc / LXRobotics Based on https://github.com/mrjohnk/ADNS-9800","title":"ADNS-9800 Laser Motion Sensor"},{"location":"reference/module/modm-driver-adns9800/#options","text":"","title":"Options"},{"location":"reference/module/modm-driver-adns9800/#firmware","text":"Select the firmware version to initialize the device with. Default: a6 Inputs: [a4, a4b, a5, a6]","title":"firmware"},{"location":"reference/module/modm-driver-adns9800/#dependencies","text":"modm:driver:adns9800 modm_driver_adns9800 modm: driver: adns9800 modm_architecture_delay modm: architecture: delay modm_driver_adns9800->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_adns9800->modm_architecture_spi modm_debug modm: debug modm_driver_adns9800->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ads7843/","text":"ADS7843 Resistive Touch Controller \u00b6 lbuild module: modm:driver:ads7843 The ADS7843 by Texas Instruments is the de-facto standard for cheap resistive touch screens. There are many compatible devices from other manufacturers available, such as the UH7843 by Zilltek. TSC2046, XPT2046 and other *2046 chips seem to be not fully compatible with the ADS7843 and have their own driver \"modm:driver:touch2046\". Dependencies \u00b6 modm:driver:ads7843 modm_driver_ads7843 modm: driver: ads7843 modm_architecture_delay modm: architecture: delay modm_driver_ads7843->modm_architecture_delay modm_ui_display modm: ui: display modm_driver_ads7843->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ads7843"},{"location":"reference/module/modm-driver-ads7843/#ads7843-resistive-touch-controller","text":"lbuild module: modm:driver:ads7843 The ADS7843 by Texas Instruments is the de-facto standard for cheap resistive touch screens. There are many compatible devices from other manufacturers available, such as the UH7843 by Zilltek. TSC2046, XPT2046 and other *2046 chips seem to be not fully compatible with the ADS7843 and have their own driver \"modm:driver:touch2046\".","title":"ADS7843 Resistive Touch Controller"},{"location":"reference/module/modm-driver-ads7843/#dependencies","text":"modm:driver:ads7843 modm_driver_ads7843 modm: driver: ads7843 modm_architecture_delay modm: architecture: delay modm_driver_ads7843->modm_architecture_delay modm_ui_display modm: ui: display modm_driver_ads7843->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ams5915/","text":"AMS 5915 Pressure Sensor \u00b6 lbuild module: modm:driver:ams5915 Driver for the AMS 5915 differential and absolute pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 500 \u03bcs within the output registers of the internal ASIC. Datasheet Dependencies \u00b6 modm:driver:ams5915 modm_driver_ams5915 modm: driver: ams5915 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ams5915->modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_ams5915->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ams5915"},{"location":"reference/module/modm-driver-ams5915/#ams-5915-pressure-sensor","text":"lbuild module: modm:driver:ams5915 Driver for the AMS 5915 differential and absolute pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 500 \u03bcs within the output registers of the internal ASIC. Datasheet","title":"AMS 5915 Pressure Sensor"},{"location":"reference/module/modm-driver-ams5915/#dependencies","text":"modm:driver:ams5915 modm_driver_ams5915 modm: driver: ams5915 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ams5915->modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_ams5915->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-apa102/","text":"APA102 RGB LED Driver \u00b6 lbuild module: modm:driver:apa102 Drives any number of chained APA102 RGB LEDs using SPI signals SCK and MOSI up to a few dozen MHz. Due to the synchronous clock, there are no special restrictions on protocol timing, making this driver safe to use with interrupts enabled and/or with an RTOS. The internal data buffer size is 4B for start of frame, 4B for every LED and 1B for every 16 LEDs as end of frame. References: \"APA102 aka Superled\" . \"Understanding the APA102 Superled\" . Dependencies \u00b6 modm:driver:apa102 modm_driver_apa102 modm: driver: apa102 modm_architecture_spi modm: architecture: spi modm_driver_apa102->modm_architecture_spi modm_processing_resumable modm: processing: resumable modm_driver_apa102->modm_processing_resumable modm_ui_color modm: ui: color modm_driver_apa102->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:apa102"},{"location":"reference/module/modm-driver-apa102/#apa102-rgb-led-driver","text":"lbuild module: modm:driver:apa102 Drives any number of chained APA102 RGB LEDs using SPI signals SCK and MOSI up to a few dozen MHz. Due to the synchronous clock, there are no special restrictions on protocol timing, making this driver safe to use with interrupts enabled and/or with an RTOS. The internal data buffer size is 4B for start of frame, 4B for every LED and 1B for every 16 LEDs as end of frame. References: \"APA102 aka Superled\" . \"Understanding the APA102 Superled\" .","title":"APA102 RGB LED Driver"},{"location":"reference/module/modm-driver-apa102/#dependencies","text":"modm:driver:apa102 modm_driver_apa102 modm: driver: apa102 modm_architecture_spi modm: architecture: spi modm_driver_apa102->modm_architecture_spi modm_processing_resumable modm: processing: resumable modm_driver_apa102->modm_processing_resumable modm_ui_color modm: ui: color modm_driver_apa102->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-block-allocator/","text":"Block Allocator \u00b6 lbuild module: modm:driver:block.allocator Dependencies \u00b6 modm:driver:block.allocator modm_driver_block_allocator modm: driver: block.allocator modm_architecture modm: architecture modm_driver_block_allocator->modm_architecture modm_math_utils modm: math: utils modm_driver_block_allocator->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:block.allocator"},{"location":"reference/module/modm-driver-block-allocator/#block-allocator","text":"lbuild module: modm:driver:block.allocator","title":"Block Allocator"},{"location":"reference/module/modm-driver-block-allocator/#dependencies","text":"modm:driver:block.allocator modm_driver_block_allocator modm: driver: block.allocator modm_architecture modm: architecture modm_driver_block_allocator->modm_architecture modm_math_utils modm: math: utils modm_driver_block_allocator->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device-file/","text":"File Block Device \u00b6 lbuild module: modm:driver:block.device:file This module is only available for hosted. Dependencies \u00b6 modm:driver:block.device:file modm_driver_block_device_file modm: driver: block.device: file modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_file->modm_architecture_block_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":driver:block.device:file"},{"location":"reference/module/modm-driver-block-device-file/#file-block-device","text":"lbuild module: modm:driver:block.device:file This module is only available for hosted.","title":"File Block Device"},{"location":"reference/module/modm-driver-block-device-file/#dependencies","text":"modm:driver:block.device:file modm_driver_block_device_file modm: driver: block.device: file modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_file->modm_architecture_block_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device-heap/","text":"Heap Block Device \u00b6 lbuild module: modm:driver:block.device:heap Dependencies \u00b6 modm:driver:block.device:heap modm_driver_block_device_heap modm: driver: block.device: heap modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_heap->modm_architecture_block_device modm_utils modm: utils modm_driver_block_device_heap->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:block.device:heap"},{"location":"reference/module/modm-driver-block-device-heap/#heap-block-device","text":"lbuild module: modm:driver:block.device:heap","title":"Heap Block Device"},{"location":"reference/module/modm-driver-block-device-heap/#dependencies","text":"modm:driver:block.device:heap modm_driver_block_device_heap modm: driver: block.device: heap modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_heap->modm_architecture_block_device modm_utils modm: utils modm_driver_block_device_heap->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device-mirror/","text":"Mirroring Block Device \u00b6 lbuild module: modm:driver:block.device:mirror Dependencies \u00b6 modm:driver:block.device:mirror modm_driver_block_device_mirror modm: driver: block.device: mirror modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_mirror->modm_architecture_block_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:block.device:mirror"},{"location":"reference/module/modm-driver-block-device-mirror/#mirroring-block-device","text":"lbuild module: modm:driver:block.device:mirror","title":"Mirroring Block Device"},{"location":"reference/module/modm-driver-block-device-mirror/#dependencies","text":"modm:driver:block.device:mirror modm_driver_block_device_mirror modm: driver: block.device: mirror modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_mirror->modm_architecture_block_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device-spi-flash/","text":"SPI Flash Block Device \u00b6 lbuild module: modm:driver:block.device:spi.flash Microchip SST26VF064B 64MBit flash chip in SOIJ-8, WDFN-8 or SOIC-16. Dependencies \u00b6 modm:driver:block.device:spi.flash modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_spi_flash->modm_architecture_block_device modm_architecture_register modm: architecture: register modm_driver_block_device_spi_flash->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_block_device_spi_flash->modm_architecture_spi_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:block.device:spi.flash"},{"location":"reference/module/modm-driver-block-device-spi-flash/#spi-flash-block-device","text":"lbuild module: modm:driver:block.device:spi.flash Microchip SST26VF064B 64MBit flash chip in SOIJ-8, WDFN-8 or SOIC-16.","title":"SPI Flash Block Device"},{"location":"reference/module/modm-driver-block-device-spi-flash/#dependencies","text":"modm:driver:block.device:spi.flash modm_driver_block_device_spi_flash modm: driver: block.device: spi.flash modm_architecture_block_device modm: architecture: block.device modm_driver_block_device_spi_flash->modm_architecture_block_device modm_architecture_register modm: architecture: register modm_driver_block_device_spi_flash->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_block_device_spi_flash->modm_architecture_spi_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-block-device/","text":"Block Devices \u00b6 lbuild module: modm:driver:block.device","title":":driver:block.device"},{"location":"reference/module/modm-driver-block-device/#block-devices","text":"lbuild module: modm:driver:block.device","title":"Block Devices"},{"location":"reference/module/modm-driver-bme280/","text":"BME280 Pressure Sensor \u00b6 lbuild module: modm:driver:bme280 The BME280 is a high precision digital temperature, pressure and humidity sensor with I2C interface. It is known that many BME280-modules suffer from self-heating (I2C pull-ups?). So the reported temperature is about 1 to 3 degree higher than with other sensors. Forced ventilation can drop the temperature by 2 to 3 degrees. Dependencies \u00b6 modm:driver:bme280 modm_driver_bme280 modm: driver: bme280 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bme280->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bme280->modm_architecture_register modm_debug modm: debug modm_driver_bme280->modm_debug modm_math_utils modm: math: utils modm_driver_bme280->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bme280->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bme280->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:bme280"},{"location":"reference/module/modm-driver-bme280/#bme280-pressure-sensor","text":"lbuild module: modm:driver:bme280 The BME280 is a high precision digital temperature, pressure and humidity sensor with I2C interface. It is known that many BME280-modules suffer from self-heating (I2C pull-ups?). So the reported temperature is about 1 to 3 degree higher than with other sensors. Forced ventilation can drop the temperature by 2 to 3 degrees.","title":"BME280 Pressure Sensor"},{"location":"reference/module/modm-driver-bme280/#dependencies","text":"modm:driver:bme280 modm_driver_bme280 modm: driver: bme280 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bme280->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bme280->modm_architecture_register modm_debug modm: debug modm_driver_bme280->modm_debug modm_math_utils modm: math: utils modm_driver_bme280->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bme280->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bme280->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-bmp085/","text":"BMP085 Pressure Sensor \u00b6 lbuild module: modm:driver:bmp085 The BMP085 is a high precision digital pressure sensor with I2C interface. Unfortunately this sensor is so sensitive, it will give you wrong results when there is traffic on the I2C during either temperature or pressure conversion. So during that time make sure no other sensors on the bus are read out. For further information, consult the product homepage . Also compatible to and tested with BMP180. Dependencies \u00b6 modm:driver:bmp085 modm_driver_bmp085 modm: driver: bmp085 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bmp085->modm_architecture_i2c_device modm_debug modm: debug modm_driver_bmp085->modm_debug modm_math_utils modm: math: utils modm_driver_bmp085->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bmp085->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bmp085->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:bmp085"},{"location":"reference/module/modm-driver-bmp085/#bmp085-pressure-sensor","text":"lbuild module: modm:driver:bmp085 The BMP085 is a high precision digital pressure sensor with I2C interface. Unfortunately this sensor is so sensitive, it will give you wrong results when there is traffic on the I2C during either temperature or pressure conversion. So during that time make sure no other sensors on the bus are read out. For further information, consult the product homepage . Also compatible to and tested with BMP180.","title":"BMP085 Pressure Sensor"},{"location":"reference/module/modm-driver-bmp085/#dependencies","text":"modm:driver:bmp085 modm_driver_bmp085 modm: driver: bmp085 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bmp085->modm_architecture_i2c_device modm_debug modm: debug modm_driver_bmp085->modm_debug modm_math_utils modm: math: utils modm_driver_bmp085->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_bmp085->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_bmp085->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-bno055/","text":"BNO055 9-DOF Inertial Measurement Unit \u00b6 lbuild module: modm:driver:bno055 The BNO055 is a System in Package (SiP), integrating a triaxial 14-bit accelerometer, a triaxial 16-bit gyroscope with a range of \u00b12000 degrees per second, a triaxial geomagnetic sensor and a 32-bit ARM Cortex-M0+ microcontroller running Bosch Sensortec sensor fusion software, in a single package. Dependencies \u00b6 modm:driver:bno055 modm_driver_bno055 modm: driver: bno055 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bno055->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bno055->modm_architecture_register modm_math_geometry modm: math: geometry modm_driver_bno055->modm_math_geometry modm_math_utils modm: math: utils modm_driver_bno055->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_bno055->modm_processing_resumable modm_processing_timer modm: processing: timer modm_driver_bno055->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:bno055"},{"location":"reference/module/modm-driver-bno055/#bno055-9-dof-inertial-measurement-unit","text":"lbuild module: modm:driver:bno055 The BNO055 is a System in Package (SiP), integrating a triaxial 14-bit accelerometer, a triaxial 16-bit gyroscope with a range of \u00b12000 degrees per second, a triaxial geomagnetic sensor and a 32-bit ARM Cortex-M0+ microcontroller running Bosch Sensortec sensor fusion software, in a single package.","title":"BNO055 9-DOF Inertial Measurement Unit"},{"location":"reference/module/modm-driver-bno055/#dependencies","text":"modm:driver:bno055 modm_driver_bno055 modm: driver: bno055 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_bno055->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_bno055->modm_architecture_register modm_math_geometry modm: math: geometry modm_driver_bno055->modm_math_geometry modm_math_utils modm: math: utils modm_driver_bno055->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_bno055->modm_processing_resumable modm_processing_timer modm: processing: timer modm_driver_bno055->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-cat24aa/","text":"CAT24AAxx I2C Eeprom \u00b6 lbuild module: modm:driver:cat24aa Compatible with the OnSemi CAT24AA I2C eeprom (1 kBit to 16 kBit). It uses a 8-bit address pointer, the top 3 bits of the address pointer are added to the the slave address, which is fixed to 0x50. Dependencies \u00b6 modm:driver:cat24aa modm_driver_cat24aa modm: driver: cat24aa modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_cat24aa->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:cat24aa"},{"location":"reference/module/modm-driver-cat24aa/#cat24aaxx-i2c-eeprom","text":"lbuild module: modm:driver:cat24aa Compatible with the OnSemi CAT24AA I2C eeprom (1 kBit to 16 kBit). It uses a 8-bit address pointer, the top 3 bits of the address pointer are added to the the slave address, which is fixed to 0x50.","title":"CAT24AAxx I2C Eeprom"},{"location":"reference/module/modm-driver-cat24aa/#dependencies","text":"modm:driver:cat24aa modm_driver_cat24aa modm: driver: cat24aa modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_cat24aa->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-drv832x_spi/","text":"DRV832xS: Three-Phase Smart Gate Driver \u00b6 lbuild module: modm:driver:drv832x_spi This driver only covers the gate driver configuration accessible via SPI interface. DRV832x Datasheet . Dependencies \u00b6 modm:driver:drv832x_spi modm_driver_drv832x_spi modm: driver: drv832x_spi modm_architecture_gpio modm: architecture: gpio modm_driver_drv832x_spi->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_drv832x_spi->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_drv832x_spi->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_drv832x_spi->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:drv832x_spi"},{"location":"reference/module/modm-driver-drv832x_spi/#drv832xs-three-phase-smart-gate-driver","text":"lbuild module: modm:driver:drv832x_spi This driver only covers the gate driver configuration accessible via SPI interface. DRV832x Datasheet .","title":"DRV832xS: Three-Phase Smart Gate Driver"},{"location":"reference/module/modm-driver-drv832x_spi/#dependencies","text":"modm:driver:drv832x_spi modm_driver_drv832x_spi modm: driver: drv832x_spi modm_architecture_gpio modm: architecture: gpio modm_driver_drv832x_spi->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_drv832x_spi->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_drv832x_spi->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_drv832x_spi->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ds1302/","text":"DS1302 Real-Time Clock \u00b6 lbuild module: modm:driver:ds1302 Dependencies \u00b6 modm:driver:ds1302 modm_driver_ds1302 modm: driver: ds1302 modm_architecture_delay modm: architecture: delay modm_driver_ds1302->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ds1302->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ds1302"},{"location":"reference/module/modm-driver-ds1302/#ds1302-real-time-clock","text":"lbuild module: modm:driver:ds1302","title":"DS1302 Real-Time Clock"},{"location":"reference/module/modm-driver-ds1302/#dependencies","text":"modm:driver:ds1302 modm_driver_ds1302 modm: driver: ds1302 modm_architecture_delay modm: architecture: delay modm_driver_ds1302->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_ds1302->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ds1631/","text":"DS1x31 Temperature Sensor \u00b6 lbuild module: modm:driver:ds1631 Dependencies \u00b6 modm:driver:ds1631 modm_driver_ds1631 modm: driver: ds1631 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ds1631->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ds1631->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_ds1631->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_ds1631->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ds1631"},{"location":"reference/module/modm-driver-ds1631/#ds1x31-temperature-sensor","text":"lbuild module: modm:driver:ds1631","title":"DS1x31 Temperature Sensor"},{"location":"reference/module/modm-driver-ds1631/#dependencies","text":"modm:driver:ds1631 modm_driver_ds1631 modm: driver: ds1631 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ds1631->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_ds1631->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_ds1631->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_ds1631->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ds18b20/","text":"1-Wire Thermometer \u00b6 lbuild module: modm:driver:ds18b20 Programmable resolution 1-wire digital thermometer. The DS18B20 digital thermometer provides 9-bit to 12-bit Celsius temperature measurements and has an alarm function with non-volatile user-programmable upper and lower trigger points. The DS18B20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor. It has an operating temperature range of -55\u00b0C to +125\u00b0C and is accurate to \u00b10.5\u00b0C over the range of -10\u00b0C to +85\u00b0C. In addition, the DS18B20 can derive power directly from the data line (\"parasite power\"), eliminating the need for an external power supply. Features: - Power Supply Range is 3.0V to 5.5V - Each device has a unique 64-Bit Serial Code Stored in an On-Board ROM - Thermometer Resolution is User Selectable from 9 to 12 Bits - Converts Temperature to 12-Bit Digital Word in 750ms (Max) Dependencies \u00b6 modm:driver:ds18b20 modm_driver_ds18b20 modm: driver: ds18b20 modm_architecture_1_wire modm: architecture: 1-wire modm_driver_ds18b20->modm_architecture_1_wire @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ds18b20"},{"location":"reference/module/modm-driver-ds18b20/#1-wire-thermometer","text":"lbuild module: modm:driver:ds18b20 Programmable resolution 1-wire digital thermometer. The DS18B20 digital thermometer provides 9-bit to 12-bit Celsius temperature measurements and has an alarm function with non-volatile user-programmable upper and lower trigger points. The DS18B20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor. It has an operating temperature range of -55\u00b0C to +125\u00b0C and is accurate to \u00b10.5\u00b0C over the range of -10\u00b0C to +85\u00b0C. In addition, the DS18B20 can derive power directly from the data line (\"parasite power\"), eliminating the need for an external power supply. Features: - Power Supply Range is 3.0V to 5.5V - Each device has a unique 64-Bit Serial Code Stored in an On-Board ROM - Thermometer Resolution is User Selectable from 9 to 12 Bits - Converts Temperature to 12-Bit Digital Word in 750ms (Max)","title":"1-Wire Thermometer"},{"location":"reference/module/modm-driver-ds18b20/#dependencies","text":"modm:driver:ds18b20 modm_driver_ds18b20 modm: driver: ds18b20 modm_architecture_1_wire modm: architecture: 1-wire modm_driver_ds18b20->modm_architecture_1_wire @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ea_dog/","text":"EA-DOG Displays \u00b6 lbuild module: modm:driver:ea_dog Options \u00b6 ST7036_voltage \u00b6 Select the supply voltage of the ST7036. Default: 3.3V Inputs: [3.3V, 5V] Dependencies \u00b6 modm:driver:ea_dog modm_driver_ea_dog modm: driver: ea_dog modm_architecture_accessor modm: architecture: accessor modm_driver_ea_dog->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ea_dog->modm_architecture_delay modm_ui_display modm: ui: display modm_driver_ea_dog->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ea_dog"},{"location":"reference/module/modm-driver-ea_dog/#ea-dog-displays","text":"lbuild module: modm:driver:ea_dog","title":"EA-DOG Displays"},{"location":"reference/module/modm-driver-ea_dog/#options","text":"","title":"Options"},{"location":"reference/module/modm-driver-ea_dog/#st7036_voltage","text":"Select the supply voltage of the ST7036. Default: 3.3V Inputs: [3.3V, 5V]","title":"ST7036_voltage"},{"location":"reference/module/modm-driver-ea_dog/#dependencies","text":"modm:driver:ea_dog modm_driver_ea_dog modm: driver: ea_dog modm_architecture_accessor modm: architecture: accessor modm_driver_ea_dog->modm_architecture_accessor modm_architecture_delay modm: architecture: delay modm_driver_ea_dog->modm_architecture_delay modm_ui_display modm: ui: display modm_driver_ea_dog->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-encoder_input-bitbang/","text":"Quadrature Encoder Input \u00b6 lbuild module: modm:driver:encoder_input.bitbang This driver decodes a AB (incremental) encoder signal. Ported from code created by Peter Dannegger: https://www.mikrocontroller.net/articles/Drehgeber . Dependencies \u00b6 modm:driver:encoder_input.bitbang modm_driver_encoder_input_bitbang modm: driver: encoder_input.bitbang modm_architecture_atomic modm: architecture: atomic modm_driver_encoder_input_bitbang->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:encoder_input.bitbang"},{"location":"reference/module/modm-driver-encoder_input-bitbang/#quadrature-encoder-input","text":"lbuild module: modm:driver:encoder_input.bitbang This driver decodes a AB (incremental) encoder signal. Ported from code created by Peter Dannegger: https://www.mikrocontroller.net/articles/Drehgeber .","title":"Quadrature Encoder Input"},{"location":"reference/module/modm-driver-encoder_input-bitbang/#dependencies","text":"modm:driver:encoder_input.bitbang modm_driver_encoder_input_bitbang modm: driver: encoder_input.bitbang modm_architecture_atomic modm: architecture: atomic modm_driver_encoder_input_bitbang->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-encoder_output-bitbang/","text":"Quadrature Encoder Output \u00b6 lbuild module: modm:driver:encoder_output.bitbang This driver generates a AB (incremental) encoder signal to emulate a hardware encoder with a microcontroller. Dependencies \u00b6 modm:driver:encoder_output.bitbang modm_driver_encoder_output_bitbang modm: driver: encoder_output.bitbang modm_architecture_gpio modm: architecture: gpio modm_driver_encoder_output_bitbang->modm_architecture_gpio modm_processing_timer modm: processing: timer modm_driver_encoder_output_bitbang->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:encoder_output.bitbang"},{"location":"reference/module/modm-driver-encoder_output-bitbang/#quadrature-encoder-output","text":"lbuild module: modm:driver:encoder_output.bitbang This driver generates a AB (incremental) encoder signal to emulate a hardware encoder with a microcontroller.","title":"Quadrature Encoder Output"},{"location":"reference/module/modm-driver-encoder_output-bitbang/#dependencies","text":"modm:driver:encoder_output.bitbang modm_driver_encoder_output_bitbang modm: driver: encoder_output.bitbang modm_architecture_gpio modm: architecture: gpio modm_driver_encoder_output_bitbang->modm_architecture_gpio modm_processing_timer modm: processing: timer modm_driver_encoder_output_bitbang->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-fat/","text":"FAT File System \u00b6 lbuild module: modm:driver:fat This module is only available for hosted, sam, stm32. Dependencies \u00b6 modm:driver:fat modm_driver_fat modm: driver: fat modm_fatfs modm: fatfs modm_driver_fat->modm_fatfs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":driver:fat"},{"location":"reference/module/modm-driver-fat/#fat-file-system","text":"lbuild module: modm:driver:fat This module is only available for hosted, sam, stm32.","title":"FAT File System"},{"location":"reference/module/modm-driver-fat/#dependencies","text":"modm:driver:fat modm_driver_fat modm: driver: fat modm_fatfs modm: fatfs modm_driver_fat->modm_fatfs @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-driver-ft245/","text":"FT245 USB FIFO \u00b6 lbuild module: modm:driver:ft245 The FT245R USB FIFO from Future Technology Devices International is a single chip USB to parallel FIFO bidirectional data transfer interface. Wr and Rd must be GpioOutputs and set to output mode before. Rxf and Txe must be GpioInputs. Port is switched between input and output mode. Example \u00b6 #include <modm/architecture.hpp> #include <modm/driver/usb/ft245.hpp> using namespace modm :: platform ; using myPort = GpioPort < GpioD0 , 8 > ; using Rxf = GpioInputC11 ; using Txe = GpioInputC10 ; using Rd = GpioOutputA15 ; using Wr = GpioOutputA9 ; using myFt = modm :: Ft245 < myPort , Rd , Wr , Rxf , Txe > ; int main () { Rd :: setOutput ( modm :: Gpio :: High ); Wr :: setOutput ( modm :: Gpio :: Low ); while ( true ) { uint8_t c ; if ( myFt :: read ( c )) { myFt :: write ( c + 1 ); } } } Dependencies \u00b6 modm:driver:ft245 modm_driver_ft245 modm: driver: ft245 modm_architecture_gpio modm: architecture: gpio modm_driver_ft245->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ft245"},{"location":"reference/module/modm-driver-ft245/#ft245-usb-fifo","text":"lbuild module: modm:driver:ft245 The FT245R USB FIFO from Future Technology Devices International is a single chip USB to parallel FIFO bidirectional data transfer interface. Wr and Rd must be GpioOutputs and set to output mode before. Rxf and Txe must be GpioInputs. Port is switched between input and output mode.","title":"FT245 USB FIFO"},{"location":"reference/module/modm-driver-ft245/#example","text":"#include <modm/architecture.hpp> #include <modm/driver/usb/ft245.hpp> using namespace modm :: platform ; using myPort = GpioPort < GpioD0 , 8 > ; using Rxf = GpioInputC11 ; using Txe = GpioInputC10 ; using Rd = GpioOutputA15 ; using Wr = GpioOutputA9 ; using myFt = modm :: Ft245 < myPort , Rd , Wr , Rxf , Txe > ; int main () { Rd :: setOutput ( modm :: Gpio :: High ); Wr :: setOutput ( modm :: Gpio :: Low ); while ( true ) { uint8_t c ; if ( myFt :: read ( c )) { myFt :: write ( c + 1 ); } } }","title":"Example"},{"location":"reference/module/modm-driver-ft245/#dependencies","text":"modm:driver:ft245 modm_driver_ft245 modm: driver: ft245 modm_architecture_gpio modm: architecture: gpio modm_driver_ft245->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ft6x06/","text":"FT6x06 Capacitive Touch Controller \u00b6 lbuild module: modm:driver:ft6x06 Dependencies \u00b6 modm:driver:ft6x06 modm_driver_ft6x06 modm: driver: ft6x06 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ft6x06->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ft6x06"},{"location":"reference/module/modm-driver-ft6x06/#ft6x06-capacitive-touch-controller","text":"lbuild module: modm:driver:ft6x06","title":"FT6x06 Capacitive Touch Controller"},{"location":"reference/module/modm-driver-ft6x06/#dependencies","text":"modm:driver:ft6x06 modm_driver_ft6x06 modm: driver: ft6x06 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ft6x06->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-gpio_sampler/","text":"modm:driver:gpio_sampler \u00b6 lbuild module: modm:driver:gpio_sampler This module is only available for stm32{f1,f2,f3,f4,g4,l1,l4}. Dependencies \u00b6 modm:driver:gpio_sampler modm_driver_gpio_sampler modm: driver: gpio_sampler modm_architecture_interrupt modm: architecture: interrupt modm_driver_gpio_sampler->modm_architecture_interrupt modm_platform_core modm: platform: core modm_driver_gpio_sampler->modm_platform_core modm_platform_gpio modm: platform: gpio modm_driver_gpio_sampler->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":driver:gpio_sampler"},{"location":"reference/module/modm-driver-gpio_sampler/#modmdrivergpio_sampler","text":"lbuild module: modm:driver:gpio_sampler This module is only available for stm32{f1,f2,f3,f4,g4,l1,l4}.","title":"modm:driver:gpio_sampler"},{"location":"reference/module/modm-driver-gpio_sampler/#dependencies","text":"modm:driver:gpio_sampler modm_driver_gpio_sampler modm: driver: gpio_sampler modm_architecture_interrupt modm: architecture: interrupt modm_driver_gpio_sampler->modm_architecture_interrupt modm_platform_core modm: platform: core modm_driver_gpio_sampler->modm_platform_core modm_platform_gpio modm: platform: gpio modm_driver_gpio_sampler->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-driver-hclax/","text":"HCLA Pressure Sensor \u00b6 lbuild module: modm:driver:hclax Driver for the HCLA differential pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 250 \u03bcs within the output registers of the internal ASIC. Dependencies \u00b6 modm:driver:hclax modm_driver_hclax modm: driver: hclax modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hclax->modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_hclax->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:hclax"},{"location":"reference/module/modm-driver-hclax/#hcla-pressure-sensor","text":"lbuild module: modm:driver:hclax Driver for the HCLA differential pressure sensors. The device runs a cyclic program, which will store a corrected pressure value with 12 bit resolution about every 250 \u03bcs within the output registers of the internal ASIC.","title":"HCLA Pressure Sensor"},{"location":"reference/module/modm-driver-hclax/#dependencies","text":"modm:driver:hclax modm_driver_hclax modm: driver: hclax modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hclax->modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_hclax->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-hd44780/","text":"HD44780 Displays \u00b6 lbuild module: modm:driver:hd44780 Dependencies \u00b6 modm:driver:hd44780 modm_driver_hd44780 modm: driver: hd44780 modm_architecture_delay modm: architecture: delay modm_driver_hd44780->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_hd44780->modm_architecture_gpio modm_ui_display modm: ui: display modm_driver_hd44780->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:hd44780"},{"location":"reference/module/modm-driver-hd44780/#hd44780-displays","text":"lbuild module: modm:driver:hd44780","title":"HD44780 Displays"},{"location":"reference/module/modm-driver-hd44780/#dependencies","text":"modm:driver:hd44780 modm_driver_hd44780 modm: driver: hd44780 modm_architecture_delay modm: architecture: delay modm_driver_hd44780->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_hd44780->modm_architecture_gpio modm_ui_display modm: ui: display modm_driver_hd44780->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-hmc58x/","text":"HMC58x3 3-Axis Digital Magnetometer \u00b6 lbuild module: modm:driver:hmc58x The HMC58x3 is a surface-mount, multi-chip module designed for low-field magnetic sensing with a digital interface for applications such as low-cost compassing and magnetometry. The HMC58x3 includes high-resolution magneto-resistive sensors plus an ASIC containing amplification, automatic degaussing strap drivers, offset cancellation, and a 12-bit ADC that enables 1-2 degrees compass heading accuracy. Dependencies \u00b6 modm:driver:hmc58x modm_driver_hmc58x modm: driver: hmc58x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc58x->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc58x->modm_architecture_register modm_math_utils modm: math: utils modm_driver_hmc58x->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:hmc58x"},{"location":"reference/module/modm-driver-hmc58x/#hmc58x3-3-axis-digital-magnetometer","text":"lbuild module: modm:driver:hmc58x The HMC58x3 is a surface-mount, multi-chip module designed for low-field magnetic sensing with a digital interface for applications such as low-cost compassing and magnetometry. The HMC58x3 includes high-resolution magneto-resistive sensors plus an ASIC containing amplification, automatic degaussing strap drivers, offset cancellation, and a 12-bit ADC that enables 1-2 degrees compass heading accuracy.","title":"HMC58x3 3-Axis Digital Magnetometer"},{"location":"reference/module/modm-driver-hmc58x/#dependencies","text":"modm:driver:hmc58x modm_driver_hmc58x modm: driver: hmc58x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc58x->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc58x->modm_architecture_register modm_math_utils modm: math: utils modm_driver_hmc58x->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-hmc6343/","text":"HMC6343 3-Axis Compass \u00b6 lbuild module: modm:driver:hmc6343 The Honeywell HMC6343 is a fully integrated compass module that includes firmware for heading computation and calibration for magnetic distortions. The module combines 3-axis magneto-resistive sensors and 3-axis MEMS accelerometers, analog and digital support circuits, microprocessor and algorithms required for heading computation. Dependencies \u00b6 modm:driver:hmc6343 modm_driver_hmc6343 modm: driver: hmc6343 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc6343->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc6343->modm_architecture_register modm_math_utils modm: math: utils modm_driver_hmc6343->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_hmc6343->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:hmc6343"},{"location":"reference/module/modm-driver-hmc6343/#hmc6343-3-axis-compass","text":"lbuild module: modm:driver:hmc6343 The Honeywell HMC6343 is a fully integrated compass module that includes firmware for heading computation and calibration for magnetic distortions. The module combines 3-axis magneto-resistive sensors and 3-axis MEMS accelerometers, analog and digital support circuits, microprocessor and algorithms required for heading computation.","title":"HMC6343 3-Axis Compass"},{"location":"reference/module/modm-driver-hmc6343/#dependencies","text":"modm:driver:hmc6343 modm_driver_hmc6343 modm: driver: hmc6343 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_hmc6343->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_hmc6343->modm_architecture_register modm_math_utils modm: math: utils modm_driver_hmc6343->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_hmc6343->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-hx711/","text":"HX711 Load Cell Amplifier and ADC \u00b6 lbuild module: modm:driver:hx711 The HX711 is an integrated load cell amplifier designed for weight scales and industrial control applications to interface directly with a bridge sensor. The interface is bit-bang and timing based, so only GPIO is needed. In a complete system the SCK pin's timing while reading must be met. Dependencies \u00b6 modm:driver:hx711 modm_driver_hx711 modm: driver: hx711 modm_architecture_delay modm: architecture: delay modm_driver_hx711->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_hx711->modm_architecture_gpio modm_processing_resumable modm: processing: resumable modm_driver_hx711->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:hx711"},{"location":"reference/module/modm-driver-hx711/#hx711-load-cell-amplifier-and-adc","text":"lbuild module: modm:driver:hx711 The HX711 is an integrated load cell amplifier designed for weight scales and industrial control applications to interface directly with a bridge sensor. The interface is bit-bang and timing based, so only GPIO is needed. In a complete system the SCK pin's timing while reading must be met.","title":"HX711 Load Cell Amplifier and ADC"},{"location":"reference/module/modm-driver-hx711/#dependencies","text":"modm:driver:hx711 modm_driver_hx711 modm: driver: hx711 modm_architecture_delay modm: architecture: delay modm_driver_hx711->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_hx711->modm_architecture_gpio modm_processing_resumable modm: processing: resumable modm_driver_hx711->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-i2c-eeprom/","text":"I2C Eeprom \u00b6 lbuild module: modm:driver:i2c.eeprom Compatible with the 24C256 (ST) and 24FC1025 (Microchip) family and other I2C eeprom with an 16-bit address pointer. Base address for most 24xxyyyy eeproms is 0x50. Dependencies \u00b6 modm:driver:i2c.eeprom modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_i2c_eeprom->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:i2c.eeprom"},{"location":"reference/module/modm-driver-i2c-eeprom/#i2c-eeprom","text":"lbuild module: modm:driver:i2c.eeprom Compatible with the 24C256 (ST) and 24FC1025 (Microchip) family and other I2C eeprom with an 16-bit address pointer. Base address for most 24xxyyyy eeproms is 0x50.","title":"I2C Eeprom"},{"location":"reference/module/modm-driver-i2c-eeprom/#dependencies","text":"modm:driver:i2c.eeprom modm_driver_i2c_eeprom modm: driver: i2c.eeprom modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_i2c_eeprom->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ili9341/","text":"ILI9341 Display with parallel and SPI bus transports \u00b6 lbuild module: modm:driver:ili9341 Dependencies \u00b6 modm:driver:ili9341 modm_driver_ili9341 modm: driver: ili9341 modm_architecture_delay modm: architecture: delay modm_driver_ili9341->modm_architecture_delay modm_architecture_spi_device modm: architecture: spi.device modm_driver_ili9341->modm_architecture_spi_device modm_ui_display modm: ui: display modm_driver_ili9341->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ili9341"},{"location":"reference/module/modm-driver-ili9341/#ili9341-display-with-parallel-and-spi-bus-transports","text":"lbuild module: modm:driver:ili9341","title":"ILI9341 Display with parallel and SPI bus transports"},{"location":"reference/module/modm-driver-ili9341/#dependencies","text":"modm:driver:ili9341 modm_driver_ili9341 modm: driver: ili9341 modm_architecture_delay modm: architecture: delay modm_driver_ili9341->modm_architecture_delay modm_architecture_spi_device modm: architecture: spi.device modm_driver_ili9341->modm_architecture_spi_device modm_ui_display modm: ui: display modm_driver_ili9341->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-is31fl3733/","text":"IS31FL3733 Matrix Driver \u00b6 lbuild module: modm:driver:is31fl3733 Dependencies \u00b6 modm:driver:is31fl3733 modm_driver_is31fl3733 modm: driver: is31fl3733 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_is31fl3733->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_is31fl3733->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:is31fl3733"},{"location":"reference/module/modm-driver-is31fl3733/#is31fl3733-matrix-driver","text":"lbuild module: modm:driver:is31fl3733","title":"IS31FL3733 Matrix Driver"},{"location":"reference/module/modm-driver-is31fl3733/#dependencies","text":"modm:driver:is31fl3733 modm_driver_is31fl3733 modm: driver: is31fl3733 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_is31fl3733->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_is31fl3733->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-itg3200/","text":"ITG3200 Digital Gyroscope \u00b6 lbuild module: modm:driver:itg3200 For further information on the special sensing functions, consult the product homepage . Dependencies \u00b6 modm:driver:itg3200 modm_driver_itg3200 modm: driver: itg3200 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_itg3200->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_itg3200->modm_architecture_register modm_math_utils modm: math: utils modm_driver_itg3200->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:itg3200"},{"location":"reference/module/modm-driver-itg3200/#itg3200-digital-gyroscope","text":"lbuild module: modm:driver:itg3200 For further information on the special sensing functions, consult the product homepage .","title":"ITG3200 Digital Gyroscope"},{"location":"reference/module/modm-driver-itg3200/#dependencies","text":"modm:driver:itg3200 modm_driver_itg3200 modm: driver: itg3200 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_itg3200->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_itg3200->modm_architecture_register modm_math_utils modm: math: utils modm_driver_itg3200->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-l3gd20/","text":"L3GD20 3-Axis Gyroscope \u00b6 lbuild module: modm:driver:l3gd20 The L3GD20 is a low-power three-axis angular rate sensor. The L3GD20 has a full scale of \u00b1250/\u00b1500/\u00b12000 dps and is capable of measuring rates with a user-selectable bandwidth. Dependencies \u00b6 modm:driver:l3gd20 modm_driver_l3gd20 modm: driver: l3gd20 modm_architecture_register modm: architecture: register modm_driver_l3gd20->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_l3gd20->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_l3gd20->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_l3gd20->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:l3gd20"},{"location":"reference/module/modm-driver-l3gd20/#l3gd20-3-axis-gyroscope","text":"lbuild module: modm:driver:l3gd20 The L3GD20 is a low-power three-axis angular rate sensor. The L3GD20 has a full scale of \u00b1250/\u00b1500/\u00b12000 dps and is capable of measuring rates with a user-selectable bandwidth.","title":"L3GD20 3-Axis Gyroscope"},{"location":"reference/module/modm-driver-l3gd20/#dependencies","text":"modm:driver:l3gd20 modm_driver_l3gd20 modm: driver: l3gd20 modm_architecture_register modm: architecture: register modm_driver_l3gd20->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_l3gd20->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_l3gd20->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_l3gd20->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lan8720a/","text":"LAN8720A Ethernet Transceiver \u00b6 lbuild module: modm:driver:lan8720a Microchip's LAN8720A/LAN8720Ai are high-performance, small-footprint, low-power 10BASE-T/100BASE-TX transceiver connected via an RMII interface.","title":":driver:lan8720a"},{"location":"reference/module/modm-driver-lan8720a/#lan8720a-ethernet-transceiver","text":"lbuild module: modm:driver:lan8720a Microchip's LAN8720A/LAN8720Ai are high-performance, small-footprint, low-power 10BASE-T/100BASE-TX transceiver connected via an RMII interface.","title":"LAN8720A Ethernet Transceiver"},{"location":"reference/module/modm-driver-lawicel/","text":"Lawicel Format Converter \u00b6 lbuild module: modm:driver:lawicel Converts modm::can::Message to and from the Lawicel string format ( char * ). Lawicel AB ( http://www.lawicel.com ) offers medium sized CAN to USB and CAN to RS232 converters. Their data format is widely used. This converter only understands messages of type 'r', 't', 'R' and 'T' which transmits CAN frames. It does not understand commands to change the baud rate. Dependencies \u00b6 modm:driver:lawicel modm_driver_lawicel modm: driver: lawicel modm_architecture_can modm: architecture: can modm_driver_lawicel->modm_architecture_can @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lawicel"},{"location":"reference/module/modm-driver-lawicel/#lawicel-format-converter","text":"lbuild module: modm:driver:lawicel Converts modm::can::Message to and from the Lawicel string format ( char * ). Lawicel AB ( http://www.lawicel.com ) offers medium sized CAN to USB and CAN to RS232 converters. Their data format is widely used. This converter only understands messages of type 'r', 't', 'R' and 'T' which transmits CAN frames. It does not understand commands to change the baud rate.","title":"Lawicel Format Converter"},{"location":"reference/module/modm-driver-lawicel/#dependencies","text":"modm:driver:lawicel modm_driver_lawicel modm: driver: lawicel modm_architecture_can modm: architecture: can modm_driver_lawicel->modm_architecture_can @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lis3-transport/","text":"LIS3xx Transport Layer \u00b6 lbuild module: modm:driver:lis3.transport Dependencies \u00b6 modm:driver:lis3.transport modm_driver_lis3_transport modm: driver: lis3.transport modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lis3_transport->modm_architecture_i2c_device modm_architecture_spi_device modm: architecture: spi.device modm_driver_lis3_transport->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_lis3_transport->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lis3.transport"},{"location":"reference/module/modm-driver-lis3-transport/#lis3xx-transport-layer","text":"lbuild module: modm:driver:lis3.transport","title":"LIS3xx Transport Layer"},{"location":"reference/module/modm-driver-lis3-transport/#dependencies","text":"modm:driver:lis3.transport modm_driver_lis3_transport modm: driver: lis3.transport modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lis3_transport->modm_architecture_i2c_device modm_architecture_spi_device modm: architecture: spi.device modm_driver_lis3_transport->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_lis3_transport->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lis302dl/","text":"LIS302DL 3-Axis Accelerometer \u00b6 lbuild module: modm:driver:lis302dl The LIS302DL is an ultra compact low-power three axes linear accelerometer. It includes a sensing element and an IC interface able to provide the measured acceleration to the external world through an I2C/SPI serial interface. Dependencies \u00b6 modm:driver:lis302dl modm_driver_lis302dl modm: driver: lis302dl modm_architecture_register modm: architecture: register modm_driver_lis302dl->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis302dl->modm_driver_lis3_transport modm_processing_resumable modm: processing: resumable modm_driver_lis302dl->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lis302dl"},{"location":"reference/module/modm-driver-lis302dl/#lis302dl-3-axis-accelerometer","text":"lbuild module: modm:driver:lis302dl The LIS302DL is an ultra compact low-power three axes linear accelerometer. It includes a sensing element and an IC interface able to provide the measured acceleration to the external world through an I2C/SPI serial interface.","title":"LIS302DL 3-Axis Accelerometer"},{"location":"reference/module/modm-driver-lis302dl/#dependencies","text":"modm:driver:lis302dl modm_driver_lis302dl modm: driver: lis302dl modm_architecture_register modm: architecture: register modm_driver_lis302dl->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis302dl->modm_driver_lis3_transport modm_processing_resumable modm: processing: resumable modm_driver_lis302dl->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lis3dsh/","text":"LIS3DSH 3-Axis Accelerometer \u00b6 lbuild module: modm:driver:lis3dsh The LIS3DSH is an ultra low-power high performance three-axis linear accelerometer belonging to the \"nano\" family with embedded state machine that can be programmed to implement autonomous applications. The LIS3DSH has dynamically selectable full scales of \u00b12g/\u00b14g/\u00b16g/\u00b18g/\u00b116g and it is capable of measuring accelerations with output data rates from 3.125 Hz to 1.6 kHz. Dependencies \u00b6 modm:driver:lis3dsh modm_driver_lis3dsh modm: driver: lis3dsh modm_architecture_register modm: architecture: register modm_driver_lis3dsh->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3dsh->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lis3dsh->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lis3dsh"},{"location":"reference/module/modm-driver-lis3dsh/#lis3dsh-3-axis-accelerometer","text":"lbuild module: modm:driver:lis3dsh The LIS3DSH is an ultra low-power high performance three-axis linear accelerometer belonging to the \"nano\" family with embedded state machine that can be programmed to implement autonomous applications. The LIS3DSH has dynamically selectable full scales of \u00b12g/\u00b14g/\u00b16g/\u00b18g/\u00b116g and it is capable of measuring accelerations with output data rates from 3.125 Hz to 1.6 kHz.","title":"LIS3DSH 3-Axis Accelerometer"},{"location":"reference/module/modm-driver-lis3dsh/#dependencies","text":"modm:driver:lis3dsh modm_driver_lis3dsh modm: driver: lis3dsh modm_architecture_register modm: architecture: register modm_driver_lis3dsh->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3dsh->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lis3dsh->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lis3mdl/","text":"LIS3MDL Magnetic Sensor \u00b6 lbuild module: modm:driver:lis3mdl The LIS3MDL is an ultra-low-power high-performance three-axis magnetic sensor. The sensor has user-selectable full scales of 4/ 8/ 12/ 16 gauss. The LIS3MDL includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz. Dependencies \u00b6 modm:driver:lis3mdl modm_driver_lis3mdl modm: driver: lis3mdl modm_architecture_register modm: architecture: register modm_driver_lis3mdl->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3mdl->modm_driver_lis3_transport modm_math_geometry modm: math: geometry modm_driver_lis3mdl->modm_math_geometry modm_math_utils modm: math: utils modm_driver_lis3mdl->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lis3mdl"},{"location":"reference/module/modm-driver-lis3mdl/#lis3mdl-magnetic-sensor","text":"lbuild module: modm:driver:lis3mdl The LIS3MDL is an ultra-low-power high-performance three-axis magnetic sensor. The sensor has user-selectable full scales of 4/ 8/ 12/ 16 gauss. The LIS3MDL includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz.","title":"LIS3MDL Magnetic Sensor"},{"location":"reference/module/modm-driver-lis3mdl/#dependencies","text":"modm:driver:lis3mdl modm_driver_lis3mdl modm: driver: lis3mdl modm_architecture_register modm: architecture: register modm_driver_lis3mdl->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lis3mdl->modm_driver_lis3_transport modm_math_geometry modm: math: geometry modm_driver_lis3mdl->modm_math_geometry modm_math_utils modm: math: utils modm_driver_lis3mdl->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lm75/","text":"LM75 Thermometer \u00b6 lbuild module: modm:driver:lm75 LM75 digital temperature sensor driver. The LM75 is a digital temperature sensor with an I2C interface and measures temperature over a range of -55 to +125 deg Celsius with a resolution of 0.5 deg C and an accuracy of up to 2 deg C. The sensor has a default refresh rate between 3Hz and 10Hz which is hardcoded into the sensor and cannot be changed. Dependencies \u00b6 modm:driver:lm75 modm_driver_lm75 modm: driver: lm75 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lm75->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_lm75->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lm75"},{"location":"reference/module/modm-driver-lm75/#lm75-thermometer","text":"lbuild module: modm:driver:lm75 LM75 digital temperature sensor driver. The LM75 is a digital temperature sensor with an I2C interface and measures temperature over a range of -55 to +125 deg Celsius with a resolution of 0.5 deg C and an accuracy of up to 2 deg C. The sensor has a default refresh rate between 3Hz and 10Hz which is hardcoded into the sensor and cannot be changed.","title":"LM75 Thermometer"},{"location":"reference/module/modm-driver-lm75/#dependencies","text":"modm:driver:lm75 modm_driver_lm75 modm: driver: lm75 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lm75->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_lm75->modm_architecture_register @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lp503x/","text":"LP503x 30/36 channel LED PWM driver \u00b6 lbuild module: modm:driver:lp503x LP5030/LP5036 30/36-channel, 12-bit PWM LED driver with I2C interface. Options \u00b6 multichannel_write \u00b6 Allow setting multiple channels in one I2C transaction. This feature requires additional 34 bytes of static storage. It can be disabled for very small devices Default: True Inputs: [True, False] Dependencies \u00b6 modm:driver:lp503x modm_driver_lp503x modm: driver: lp503x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lp503x->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lp503x"},{"location":"reference/module/modm-driver-lp503x/#lp503x-3036-channel-led-pwm-driver","text":"lbuild module: modm:driver:lp503x LP5030/LP5036 30/36-channel, 12-bit PWM LED driver with I2C interface.","title":"LP503x 30/36 channel LED PWM driver"},{"location":"reference/module/modm-driver-lp503x/#options","text":"","title":"Options"},{"location":"reference/module/modm-driver-lp503x/#multichannel_write","text":"Allow setting multiple channels in one I2C transaction. This feature requires additional 34 bytes of static storage. It can be disabled for very small devices Default: True Inputs: [True, False]","title":"multichannel_write"},{"location":"reference/module/modm-driver-lp503x/#dependencies","text":"modm:driver:lp503x modm_driver_lp503x modm: driver: lp503x modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_lp503x->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lsm303a/","text":"LSM303DLHC 3-Axis Accelerometer \u00b6 lbuild module: modm:driver:lsm303a The LSM303DLHC is a system-in-package featuring a 3D digital linear acceleration sensor and a 3D digital magnetic sensor. The sensor has linear acceleration full scales of \u00b12g/\u00b14g/\u00b18g/\u00b116g and a magnetic field full scale of \u00b11.3/\u00b11.9/\u00b12.5/\u00b14.0/\u00b14.7/\u00b15.6/\u00b18.1 gauss. The LSM303DLHC includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz. Since the device actually features two I2C devices which are just placed in the same package, this class only implements the acceleration sensor. Dependencies \u00b6 modm:driver:lsm303a modm_driver_lsm303a modm: driver: lsm303a modm_architecture_register modm: architecture: register modm_driver_lsm303a->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm303a->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lsm303a->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lsm303a"},{"location":"reference/module/modm-driver-lsm303a/#lsm303dlhc-3-axis-accelerometer","text":"lbuild module: modm:driver:lsm303a The LSM303DLHC is a system-in-package featuring a 3D digital linear acceleration sensor and a 3D digital magnetic sensor. The sensor has linear acceleration full scales of \u00b12g/\u00b14g/\u00b18g/\u00b116g and a magnetic field full scale of \u00b11.3/\u00b11.9/\u00b12.5/\u00b14.0/\u00b14.7/\u00b15.6/\u00b18.1 gauss. The LSM303DLHC includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz. Since the device actually features two I2C devices which are just placed in the same package, this class only implements the acceleration sensor.","title":"LSM303DLHC 3-Axis Accelerometer"},{"location":"reference/module/modm-driver-lsm303a/#dependencies","text":"modm:driver:lsm303a modm_driver_lsm303a modm: driver: lsm303a modm_architecture_register modm: architecture: register modm_driver_lsm303a->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm303a->modm_driver_lis3_transport modm_math_utils modm: math: utils modm_driver_lsm303a->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-lsm6ds33/","text":"LSM6DS33 always-on 3D accelerometer and 3D gyroscope \u00b6 lbuild module: modm:driver:lsm6ds33 The LSM6DS33 is a system-in-package featuring a 3D digital accelerometer and a 3D digital gyroscope performing at 1.25 mA (up to 1.6 kHz ODR) in high-performance mode. has a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and an angular rate range of \u00b1125/\u00b1245/\u00b1500/\u00b11000/\u00b12000 dps. The LSM6DS33 includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz. This driver only supports the raw data output of the sensor. Functions like tap recognition, step counter, free fall recogition, etc. are not supported Dependencies \u00b6 modm:driver:lsm6ds33 modm_driver_lsm6ds33 modm: driver: lsm6ds33 modm_architecture_register modm: architecture: register modm_driver_lsm6ds33->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm6ds33->modm_driver_lis3_transport modm_math_geometry modm: math: geometry modm_driver_lsm6ds33->modm_math_geometry modm_math_utils modm: math: utils modm_driver_lsm6ds33->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:lsm6ds33"},{"location":"reference/module/modm-driver-lsm6ds33/#lsm6ds33-always-on-3d-accelerometer-and-3d-gyroscope","text":"lbuild module: modm:driver:lsm6ds33 The LSM6DS33 is a system-in-package featuring a 3D digital accelerometer and a 3D digital gyroscope performing at 1.25 mA (up to 1.6 kHz ODR) in high-performance mode. has a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and an angular rate range of \u00b1125/\u00b1245/\u00b1500/\u00b11000/\u00b12000 dps. The LSM6DS33 includes an I2C serial bus interface that supports standard and fast mode 100 kHz and 400 kHz. This driver only supports the raw data output of the sensor. Functions like tap recognition, step counter, free fall recogition, etc. are not supported","title":"LSM6DS33 always-on 3D accelerometer and 3D gyroscope"},{"location":"reference/module/modm-driver-lsm6ds33/#dependencies","text":"modm:driver:lsm6ds33 modm_driver_lsm6ds33 modm: driver: lsm6ds33 modm_architecture_register modm: architecture: register modm_driver_lsm6ds33->modm_architecture_register modm_driver_lis3_transport modm: driver: lis3.transport modm_driver_lsm6ds33->modm_driver_lis3_transport modm_math_geometry modm: math: geometry modm_driver_lsm6ds33->modm_math_geometry modm_math_utils modm: math: utils modm_driver_lsm6ds33->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ltc2984/","text":"LTC298x Thermometer \u00b6 lbuild module: modm:driver:ltc2984 LTC2983/LTC2984: Integrated temperature measurement system (20 channel) The integrated EEPROM of the LTC2984 is not supported by now. LTC2984 and LTC2983 are 100%% compatible except the LTC2983 has no integrated EEPROM. Datasheet Dependencies \u00b6 modm:driver:ltc2984 modm_driver_ltc2984 modm: driver: ltc2984 modm_architecture_gpio modm: architecture: gpio modm_driver_ltc2984->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ltc2984->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ltc2984->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_ltc2984->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ltc2984"},{"location":"reference/module/modm-driver-ltc2984/#ltc298x-thermometer","text":"lbuild module: modm:driver:ltc2984 LTC2983/LTC2984: Integrated temperature measurement system (20 channel) The integrated EEPROM of the LTC2984 is not supported by now. LTC2984 and LTC2983 are 100%% compatible except the LTC2983 has no integrated EEPROM. Datasheet","title":"LTC298x Thermometer"},{"location":"reference/module/modm-driver-ltc2984/#dependencies","text":"modm:driver:ltc2984 modm_driver_ltc2984 modm: driver: ltc2984 modm_architecture_gpio modm: architecture: gpio modm_driver_ltc2984->modm_architecture_gpio modm_architecture_register modm: architecture: register modm_driver_ltc2984->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_ltc2984->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_ltc2984->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-max6966/","text":"MAX6966 8-bit PWM Driver \u00b6 lbuild module: modm:driver:max6966 10-channel, daisy-chainable, constant-current sink, 8bit PWM LED driver. Dependencies \u00b6 modm:driver:max6966 modm_driver_max6966 modm: driver: max6966 modm_architecture_delay modm: architecture: delay modm_driver_max6966->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_max6966->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_max6966->modm_architecture_spi @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:max6966"},{"location":"reference/module/modm-driver-max6966/#max6966-8-bit-pwm-driver","text":"lbuild module: modm:driver:max6966 10-channel, daisy-chainable, constant-current sink, 8bit PWM LED driver.","title":"MAX6966 8-bit PWM Driver"},{"location":"reference/module/modm-driver-max6966/#dependencies","text":"modm:driver:max6966 modm_driver_max6966 modm: driver: max6966 modm_architecture_delay modm: architecture: delay modm_driver_max6966->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_max6966->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_max6966->modm_architecture_spi @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-max7219/","text":"MAX7219 Display \u00b6 lbuild module: modm:driver:max7219 Dependencies \u00b6 modm:driver:max7219 modm_driver_max7219 modm: driver: max7219 modm_architecture_spi modm: architecture: spi modm_driver_max7219->modm_architecture_spi modm_ui_display modm: ui: display modm_driver_max7219->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:max7219"},{"location":"reference/module/modm-driver-max7219/#max7219-display","text":"lbuild module: modm:driver:max7219","title":"MAX7219 Display"},{"location":"reference/module/modm-driver-max7219/#dependencies","text":"modm:driver:max7219 modm_driver_max7219 modm: driver: max7219 modm_architecture_spi modm: architecture: spi modm_driver_max7219->modm_architecture_spi modm_ui_display modm: ui: display modm_driver_max7219->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-mcp23x17/","text":"MCP23x17 16-Bit I/O Expander \u00b6 lbuild module: modm:driver:mcp23x17 Port GPB is the high byte, GPA the low byte. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16bit, use the get(Inputs|Outputs|Directions|Polarities)() getters. Dependencies \u00b6 modm:driver:mcp23x17 modm_driver_mcp23x17 modm: driver: mcp23x17 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_mcp23x17->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mcp23x17->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mcp23x17->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_mcp23x17->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_mcp23x17->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:mcp23x17"},{"location":"reference/module/modm-driver-mcp23x17/#mcp23x17-16-bit-io-expander","text":"lbuild module: modm:driver:mcp23x17 Port GPB is the high byte, GPA the low byte. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16bit, use the get(Inputs|Outputs|Directions|Polarities)() getters.","title":"MCP23x17 16-Bit I/O Expander"},{"location":"reference/module/modm-driver-mcp23x17/#dependencies","text":"modm:driver:mcp23x17 modm_driver_mcp23x17 modm: driver: mcp23x17 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_mcp23x17->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mcp23x17->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mcp23x17->modm_architecture_register modm_architecture_spi_device modm: architecture: spi.device modm_driver_mcp23x17->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_mcp23x17->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-mcp2515/","text":"MPC2515 External CAN Controller \u00b6 lbuild module: modm:driver:mcp2515 Options \u00b6 clock \u00b6 Used clock for the MCP2515. The device configuration is selected according to the clock speed. Default: 16MHz Inputs: [16MHz, 20MHz] Dependencies \u00b6 modm:driver:mcp2515 modm_driver_mcp2515 modm: driver: mcp2515 modm_architecture_accessor modm: architecture: accessor modm_driver_mcp2515->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_driver_mcp2515->modm_architecture_assert modm_architecture_can modm: architecture: can modm_driver_mcp2515->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_driver_mcp2515->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_mcp2515->modm_architecture_delay modm_debug modm: debug modm_driver_mcp2515->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:mcp2515"},{"location":"reference/module/modm-driver-mcp2515/#mpc2515-external-can-controller","text":"lbuild module: modm:driver:mcp2515","title":"MPC2515 External CAN Controller"},{"location":"reference/module/modm-driver-mcp2515/#options","text":"","title":"Options"},{"location":"reference/module/modm-driver-mcp2515/#clock","text":"Used clock for the MCP2515. The device configuration is selected according to the clock speed. Default: 16MHz Inputs: [16MHz, 20MHz]","title":"clock"},{"location":"reference/module/modm-driver-mcp2515/#dependencies","text":"modm:driver:mcp2515 modm_driver_mcp2515 modm: driver: mcp2515 modm_architecture_accessor modm: architecture: accessor modm_driver_mcp2515->modm_architecture_accessor modm_architecture_assert modm: architecture: assert modm_driver_mcp2515->modm_architecture_assert modm_architecture_can modm: architecture: can modm_driver_mcp2515->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_driver_mcp2515->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_mcp2515->modm_architecture_delay modm_debug modm: debug modm_driver_mcp2515->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-memory_bus/","text":"Parallel Busses \u00b6 lbuild module: modm:driver:memory_bus Dependencies \u00b6 modm:driver:memory_bus modm_driver_memory_bus modm: driver: memory_bus modm_architecture_delay modm: architecture: delay modm_driver_memory_bus->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_memory_bus->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:memory_bus"},{"location":"reference/module/modm-driver-memory_bus/#parallel-busses","text":"lbuild module: modm:driver:memory_bus","title":"Parallel Busses"},{"location":"reference/module/modm-driver-memory_bus/#dependencies","text":"modm:driver:memory_bus modm_driver_memory_bus modm: driver: memory_bus modm_architecture_delay modm: architecture: delay modm_driver_memory_bus->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_memory_bus->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-mmc5603/","text":"MMC5603 3-Axis Digital Magnetometer \u00b6 lbuild module: modm:driver:mmc5603 The MMC5603NJ is a monolithic complete 3-axis AMR magnetic sensor with on-chip signal processing and integrated I2C bus. It can measure magnetic fields within the full scale range of \u00b130 Gauss (G), with up to 0.0625mG per LSB resolution at 20bits operation mode and 2mG total RMS noise level, enabling heading accuracy of \u00b11\u00b0 in electronic compass applications. An integrated SET/RESET function provides for the elimination of error due to Null Field output change with temperature. In addition it clears the sensors of any residual magnetic polarization resulting from exposure to strong external magnets. The SET/RESET function can be performed for each measurement or periodically as the specific application requires. The MMC5603NJ is in wafer level package with an ultra-small size of 0.8x0.8x0.4mm and with an operating temperature range from -40\u00b0C to +85\u00b0C. Dependencies \u00b6 modm:driver:mmc5603 modm_driver_mmc5603 modm: driver: mmc5603 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mmc5603->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mmc5603->modm_architecture_register modm_math_utils modm: math: utils modm_driver_mmc5603->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:mmc5603"},{"location":"reference/module/modm-driver-mmc5603/#mmc5603-3-axis-digital-magnetometer","text":"lbuild module: modm:driver:mmc5603 The MMC5603NJ is a monolithic complete 3-axis AMR magnetic sensor with on-chip signal processing and integrated I2C bus. It can measure magnetic fields within the full scale range of \u00b130 Gauss (G), with up to 0.0625mG per LSB resolution at 20bits operation mode and 2mG total RMS noise level, enabling heading accuracy of \u00b11\u00b0 in electronic compass applications. An integrated SET/RESET function provides for the elimination of error due to Null Field output change with temperature. In addition it clears the sensors of any residual magnetic polarization resulting from exposure to strong external magnets. The SET/RESET function can be performed for each measurement or periodically as the specific application requires. The MMC5603NJ is in wafer level package with an ultra-small size of 0.8x0.8x0.4mm and with an operating temperature range from -40\u00b0C to +85\u00b0C.","title":"MMC5603 3-Axis Digital Magnetometer"},{"location":"reference/module/modm-driver-mmc5603/#dependencies","text":"modm:driver:mmc5603 modm_driver_mmc5603 modm: driver: mmc5603 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_mmc5603->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_mmc5603->modm_architecture_register modm_math_utils modm: math: utils modm_driver_mmc5603->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-nokia5110/","text":"Nokia 5110 Displays \u00b6 lbuild module: modm:driver:nokia5110 Dependencies \u00b6 modm:driver:nokia5110 modm_driver_nokia5110 modm: driver: nokia5110 modm_architecture_spi modm: architecture: spi modm_driver_nokia5110->modm_architecture_spi modm_ui_display modm: ui: display modm_driver_nokia5110->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:nokia5110"},{"location":"reference/module/modm-driver-nokia5110/#nokia-5110-displays","text":"lbuild module: modm:driver:nokia5110","title":"Nokia 5110 Displays"},{"location":"reference/module/modm-driver-nokia5110/#dependencies","text":"modm:driver:nokia5110 modm_driver_nokia5110 modm: driver: nokia5110 modm_architecture_spi modm: architecture: spi modm_driver_nokia5110->modm_architecture_spi modm_ui_display modm: ui: display modm_driver_nokia5110->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-nrf24/","text":"NRF24 Drivers \u00b6 lbuild module: modm:driver:nrf24 Dependencies \u00b6 modm:driver:nrf24 modm_driver_nrf24 modm: driver: nrf24 modm_architecture_clock modm: architecture: clock modm_driver_nrf24->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_nrf24->modm_architecture_delay modm_architecture_register modm: architecture: register modm_driver_nrf24->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_driver_nrf24->modm_architecture_spi modm_debug modm: debug modm_driver_nrf24->modm_debug modm_math_utils modm: math: utils modm_driver_nrf24->modm_math_utils modm_processing_timer modm: processing: timer modm_driver_nrf24->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:nrf24"},{"location":"reference/module/modm-driver-nrf24/#nrf24-drivers","text":"lbuild module: modm:driver:nrf24","title":"NRF24 Drivers"},{"location":"reference/module/modm-driver-nrf24/#dependencies","text":"modm:driver:nrf24 modm_driver_nrf24 modm: driver: nrf24 modm_architecture_clock modm: architecture: clock modm_driver_nrf24->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_nrf24->modm_architecture_delay modm_architecture_register modm: architecture: register modm_driver_nrf24->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_driver_nrf24->modm_architecture_spi modm_debug modm: debug modm_driver_nrf24->modm_debug modm_math_utils modm: math: utils modm_driver_nrf24->modm_math_utils modm_processing_timer modm: processing: timer modm_driver_nrf24->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-parallel_tft_display/","text":"Parallel Bus TFT Display \u00b6 lbuild module: modm:driver:parallel_tft_display Dependencies \u00b6 modm:driver:parallel_tft_display modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_architecture_delay modm: architecture: delay modm_driver_parallel_tft_display->modm_architecture_delay modm_ui_display modm: ui: display modm_driver_parallel_tft_display->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:parallel_tft_display"},{"location":"reference/module/modm-driver-parallel_tft_display/#parallel-bus-tft-display","text":"lbuild module: modm:driver:parallel_tft_display","title":"Parallel Bus TFT Display"},{"location":"reference/module/modm-driver-parallel_tft_display/#dependencies","text":"modm:driver:parallel_tft_display modm_driver_parallel_tft_display modm: driver: parallel_tft_display modm_architecture_delay modm: architecture: delay modm_driver_parallel_tft_display->modm_architecture_delay modm_ui_display modm: ui: display modm_driver_parallel_tft_display->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-pat9125el/","text":"PAT9125EL Motion Sensor \u00b6 lbuild module: modm:driver:pat9125el Dependencies \u00b6 modm:driver:pat9125el modm_driver_pat9125el modm: driver: pat9125el modm_architecture_delay modm: architecture: delay modm_driver_pat9125el->modm_architecture_delay modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pat9125el->modm_architecture_i2c_device modm_architecture_spi modm: architecture: spi modm_driver_pat9125el->modm_architecture_spi modm_debug modm: debug modm_driver_pat9125el->modm_debug modm_math_geometry modm: math: geometry modm_driver_pat9125el->modm_math_geometry @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:pat9125el"},{"location":"reference/module/modm-driver-pat9125el/#pat9125el-motion-sensor","text":"lbuild module: modm:driver:pat9125el","title":"PAT9125EL Motion Sensor"},{"location":"reference/module/modm-driver-pat9125el/#dependencies","text":"modm:driver:pat9125el modm_driver_pat9125el modm: driver: pat9125el modm_architecture_delay modm: architecture: delay modm_driver_pat9125el->modm_architecture_delay modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pat9125el->modm_architecture_i2c_device modm_architecture_spi modm: architecture: spi modm_driver_pat9125el->modm_architecture_spi modm_debug modm: debug modm_driver_pat9125el->modm_debug modm_math_geometry modm: math: geometry modm_driver_pat9125el->modm_math_geometry @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-pca8574/","text":"PCA8574 8-Bit I/O Expander \u00b6 lbuild module: modm:driver:pca8574 Dependencies \u00b6 modm:driver:pca8574 modm_driver_pca8574 modm: driver: pca8574 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca8574->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca8574->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca8574->modm_architecture_register modm_processing_resumable modm: processing: resumable modm_driver_pca8574->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:pca8574"},{"location":"reference/module/modm-driver-pca8574/#pca8574-8-bit-io-expander","text":"lbuild module: modm:driver:pca8574","title":"PCA8574 8-Bit I/O Expander"},{"location":"reference/module/modm-driver-pca8574/#dependencies","text":"modm:driver:pca8574 modm_driver_pca8574 modm: driver: pca8574 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca8574->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca8574->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca8574->modm_architecture_register modm_processing_resumable modm: processing: resumable modm_driver_pca8574->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-pca9535/","text":"PCA9535 16-Bit I/O Expander \u00b6 lbuild module: modm:driver:pca9535 Also software-compatible with PCA9555. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16-bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16-bit, use the get(Inputs|Outputs|Directions|Polarities)() getters. using Pin = expander . Pin ; using Pins = expander . Pins ; RF_CALL_BLOCKING ( expander . setOutput ( Pins ( 0xff )); // set all lower 8 pins to output RF_CALL_BLOCKING ( expander . set ( Pin :: P0_0 )); // set only pin 00 high RF_CALL_BLOCKING ( expander . reset ( Pin :: P0_1 | Pin :: P0_2 )); // reset 2 pins RF_CALL_BLOCKING ( expander . toggle ( Pin :: P0_3 | Pin :: P0_4 | Pin :: P0_5 )); // toggle 3 pins RF_CALL_BLOCKING ( expander . readInput ()); // transfer input states from the external chip bool high = expander . read ( Pin :: P1_0 ); // check a single pin Pins input = expander . getInputs (); // get all 16 input states bool isAnyPinHigh = input . any ( Pin :: P1_1 | Pin :: P1_2 | Pin :: P1_3 ); // check if any of 3 pins is high Dependencies \u00b6 modm:driver:pca9535 modm_driver_pca9535 modm: driver: pca9535 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca9535->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9535->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca9535->modm_architecture_register modm_math_utils modm: math: utils modm_driver_pca9535->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_pca9535->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:pca9535"},{"location":"reference/module/modm-driver-pca9535/#pca9535-16-bit-io-expander","text":"lbuild module: modm:driver:pca9535 Also software-compatible with PCA9555. The lower three address bits can be configured: 0100abc . Notice that you can specify multiple pins at the same time for functions with argument type Pins , either by ORing the according pins, or converting a 16-bit value using the Pins(uint16_t) converting constructor. Other functions with argument type Pin can only take one pin. If you want to operate on all 16-bit, use the get(Inputs|Outputs|Directions|Polarities)() getters. using Pin = expander . Pin ; using Pins = expander . Pins ; RF_CALL_BLOCKING ( expander . setOutput ( Pins ( 0xff )); // set all lower 8 pins to output RF_CALL_BLOCKING ( expander . set ( Pin :: P0_0 )); // set only pin 00 high RF_CALL_BLOCKING ( expander . reset ( Pin :: P0_1 | Pin :: P0_2 )); // reset 2 pins RF_CALL_BLOCKING ( expander . toggle ( Pin :: P0_3 | Pin :: P0_4 | Pin :: P0_5 )); // toggle 3 pins RF_CALL_BLOCKING ( expander . readInput ()); // transfer input states from the external chip bool high = expander . read ( Pin :: P1_0 ); // check a single pin Pins input = expander . getInputs (); // get all 16 input states bool isAnyPinHigh = input . any ( Pin :: P1_1 | Pin :: P1_2 | Pin :: P1_3 ); // check if any of 3 pins is high","title":"PCA9535 16-Bit I/O Expander"},{"location":"reference/module/modm-driver-pca9535/#dependencies","text":"modm:driver:pca9535 modm_driver_pca9535 modm: driver: pca9535 modm_architecture_gpio_expander modm: architecture: gpio.expander modm_driver_pca9535->modm_architecture_gpio_expander modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9535->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_pca9535->modm_architecture_register modm_math_utils modm: math: utils modm_driver_pca9535->modm_math_utils modm_processing_resumable modm: processing: resumable modm_driver_pca9535->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-pca9548a/","text":"PCA9548A/TCA9548A I2C Switch \u00b6 lbuild module: modm:driver:pca9548a This bidirectional 8-channel switch with reset can be used to multiplex I2C busses. Dependencies \u00b6 modm:driver:pca9548a modm_driver_pca9548a modm: driver: pca9548a modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9548a->modm_architecture_i2c_device modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_driver_pca9548a->modm_architecture_i2c_multiplexer modm_processing_resumable modm: processing: resumable modm_driver_pca9548a->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:pca9548a"},{"location":"reference/module/modm-driver-pca9548a/#pca9548atca9548a-i2c-switch","text":"lbuild module: modm:driver:pca9548a This bidirectional 8-channel switch with reset can be used to multiplex I2C busses.","title":"PCA9548A/TCA9548A I2C Switch"},{"location":"reference/module/modm-driver-pca9548a/#dependencies","text":"modm:driver:pca9548a modm_driver_pca9548a modm: driver: pca9548a modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9548a->modm_architecture_i2c_device modm_architecture_i2c_multiplexer modm: architecture: i2c.multiplexer modm_driver_pca9548a->modm_architecture_i2c_multiplexer modm_processing_resumable modm: processing: resumable modm_driver_pca9548a->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-pca9685/","text":"PCA9685 12-bit PWM Driver \u00b6 lbuild module: modm:driver:pca9685 PCA9685 16-channel, 12-bit PWM LED controller via I2C-Bus. Dependencies \u00b6 modm:driver:pca9685 modm_driver_pca9685 modm: driver: pca9685 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9685->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:pca9685"},{"location":"reference/module/modm-driver-pca9685/#pca9685-12-bit-pwm-driver","text":"lbuild module: modm:driver:pca9685 PCA9685 16-channel, 12-bit PWM LED controller via I2C-Bus.","title":"PCA9685 12-bit PWM Driver"},{"location":"reference/module/modm-driver-pca9685/#dependencies","text":"modm:driver:pca9685 modm_driver_pca9685 modm: driver: pca9685 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_pca9685->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-siemens_s65/","text":"Siemens S65 Display \u00b6 lbuild module: modm:driver:siemens_s65 Dependencies \u00b6 modm:driver:siemens_s65 modm_driver_siemens_s65 modm: driver: siemens_s65 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s65->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_siemens_s65->modm_architecture_spi modm_ui_display modm: ui: display modm_driver_siemens_s65->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:siemens_s65"},{"location":"reference/module/modm-driver-siemens_s65/#siemens-s65-display","text":"lbuild module: modm:driver:siemens_s65","title":"Siemens S65 Display"},{"location":"reference/module/modm-driver-siemens_s65/#dependencies","text":"modm:driver:siemens_s65 modm_driver_siemens_s65 modm: driver: siemens_s65 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s65->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_driver_siemens_s65->modm_architecture_spi modm_ui_display modm: ui: display modm_driver_siemens_s65->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-siemens_s75/","text":"Siemens S75/CX75/C81/M75 Display \u00b6 lbuild module: modm:driver:siemens_s75 The controller in displays manufactured by Alps is a SOLOMON SYSTECH SSD1286 which can drive color displays of up to 132 x 176 pixels in 18 bit color. The portrait mode is a bit more 'native' for this display because modm::BufferedGraphicDisplay requests that the vertical resolution is divisible by 8. In portrait mode the connector is at the top. In landscapeLeft mode the connector is at the left border. In landscapeRight mode the connector is at the right border. Pinout at LCD: 1 IN CD Command / Data Low = Command (Register) High = Data. 2 IN RESET Resets the display. Active low. Low = Reset, High = No reset. 3 IN CS Chip select. Active low. Low = Chip is selected, High = Chip is not selected. 4 OUT VD Sync Output. Unused. 5 GND Supply 6 IN D0 Bit 0 of parallel data 7 3V3 (2V9) Supply 8 GND Supply 9 VLED + Supply Backlight 10 VLED - Supply Backlight 11 GND Supply 12 IN RD Read Strobe. Must be tied high. 13 IN WR Write Strobe. High-to-Low strobe write data to display memory. 14 IN D1 Bit 1 of parallel data. 15 IN D2 Bit 2 of parallel data. 16 IN D3 Bit 3 of parallel data. 17 IN D4 Bit 4 of parallel data. 18 IN D5 Bit 5 of parallel data. 19 IN D6 Bit 6 of parallel data. 20 IN D7 Bit 7 of parallel data. Pin 1 is unmarked. Pin 5 can be recognized by a thicker trace which is GND. The backlight (VLED +, VLED -) consists of four white LEDs in series. The forward voltage is about 12 volts. Dependencies \u00b6 modm:driver:siemens_s75 modm_driver_siemens_s75 modm: driver: siemens_s75 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s75->modm_architecture_delay modm_driver_memory_bus modm: driver: memory_bus modm_driver_siemens_s75->modm_driver_memory_bus modm_ui_display modm: ui: display modm_driver_siemens_s75->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:siemens_s75"},{"location":"reference/module/modm-driver-siemens_s75/#siemens-s75cx75c81m75-display","text":"lbuild module: modm:driver:siemens_s75 The controller in displays manufactured by Alps is a SOLOMON SYSTECH SSD1286 which can drive color displays of up to 132 x 176 pixels in 18 bit color. The portrait mode is a bit more 'native' for this display because modm::BufferedGraphicDisplay requests that the vertical resolution is divisible by 8. In portrait mode the connector is at the top. In landscapeLeft mode the connector is at the left border. In landscapeRight mode the connector is at the right border. Pinout at LCD: 1 IN CD Command / Data Low = Command (Register) High = Data. 2 IN RESET Resets the display. Active low. Low = Reset, High = No reset. 3 IN CS Chip select. Active low. Low = Chip is selected, High = Chip is not selected. 4 OUT VD Sync Output. Unused. 5 GND Supply 6 IN D0 Bit 0 of parallel data 7 3V3 (2V9) Supply 8 GND Supply 9 VLED + Supply Backlight 10 VLED - Supply Backlight 11 GND Supply 12 IN RD Read Strobe. Must be tied high. 13 IN WR Write Strobe. High-to-Low strobe write data to display memory. 14 IN D1 Bit 1 of parallel data. 15 IN D2 Bit 2 of parallel data. 16 IN D3 Bit 3 of parallel data. 17 IN D4 Bit 4 of parallel data. 18 IN D5 Bit 5 of parallel data. 19 IN D6 Bit 6 of parallel data. 20 IN D7 Bit 7 of parallel data. Pin 1 is unmarked. Pin 5 can be recognized by a thicker trace which is GND. The backlight (VLED +, VLED -) consists of four white LEDs in series. The forward voltage is about 12 volts.","title":"Siemens S75/CX75/C81/M75 Display"},{"location":"reference/module/modm-driver-siemens_s75/#dependencies","text":"modm:driver:siemens_s75 modm_driver_siemens_s75 modm: driver: siemens_s75 modm_architecture_delay modm: architecture: delay modm_driver_siemens_s75->modm_architecture_delay modm_driver_memory_bus modm: driver: memory_bus modm_driver_siemens_s75->modm_driver_memory_bus modm_ui_display modm: ui: display modm_driver_siemens_s75->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-sk6812/","text":"SK6812 RGBW Driver \u00b6 lbuild module: modm:driver:sk6812 Drives any number of chained SK6812 RGBW LEDs using a 3-bit SPI encoding (0 -> 100, 1 -> 110) running at 3 MHz. Thus, writing one LED takes 32\u00b5s and 12 bytes of memory. There are several caveats: This only provides a blocking write API, due to technical limitations. Atomicity is not enforced, this should be done externally if required. The memory footprint is 4x as large, due to the bit stuffing for SPI. There is no enforced reset period of at least 50\u00b5s after the write is finished, it is up to the user to not trigger another write too early. This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now. SystemClock Limitations This driver requires a 3 MHz \u00b110% SPI clock in order to get the protocol timing right. Depending on your device clock tree and the SPI prescalers, this might require lowering the frequency of the entire device! If this is unacceptable, consider using APA102. This module is only available for stm32. Dependencies \u00b6 modm:driver:sk6812 modm_driver_sk6812 modm: driver: sk6812 modm_architecture_spi modm: architecture: spi modm_driver_sk6812->modm_architecture_spi modm_architecture_unaligned modm: architecture: unaligned modm_driver_sk6812->modm_architecture_unaligned modm_math_units modm: math: units modm_driver_sk6812->modm_math_units modm_ui_color modm: ui: color modm_driver_sk6812->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":driver:sk6812"},{"location":"reference/module/modm-driver-sk6812/#sk6812-rgbw-driver","text":"lbuild module: modm:driver:sk6812 Drives any number of chained SK6812 RGBW LEDs using a 3-bit SPI encoding (0 -> 100, 1 -> 110) running at 3 MHz. Thus, writing one LED takes 32\u00b5s and 12 bytes of memory. There are several caveats: This only provides a blocking write API, due to technical limitations. Atomicity is not enforced, this should be done externally if required. The memory footprint is 4x as large, due to the bit stuffing for SPI. There is no enforced reset period of at least 50\u00b5s after the write is finished, it is up to the user to not trigger another write too early. This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now. SystemClock Limitations This driver requires a 3 MHz \u00b110% SPI clock in order to get the protocol timing right. Depending on your device clock tree and the SPI prescalers, this might require lowering the frequency of the entire device! If this is unacceptable, consider using APA102. This module is only available for stm32.","title":"SK6812 RGBW Driver"},{"location":"reference/module/modm-driver-sk6812/#dependencies","text":"modm:driver:sk6812 modm_driver_sk6812 modm: driver: sk6812 modm_architecture_spi modm: architecture: spi modm_driver_sk6812->modm_architecture_spi modm_architecture_unaligned modm: architecture: unaligned modm_driver_sk6812->modm_architecture_unaligned modm_math_units modm: math: units modm_driver_sk6812->modm_math_units modm_ui_color modm: ui: color modm_driver_sk6812->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-driver-sk9822/","text":"SK9822 RGB LED Driver \u00b6 lbuild module: modm:driver:sk9822 Drives any number of chained SK9822 RGB LEDs using SPI signals SCK and MOSI up to a few dozen MHz. Due to the synchronous clock, there are no special restrictions on protocol timing, making this driver safe to use with interrupts enabled and/or with an RTOS. The internal data buffer size is 4B for start of frame, 4B for every LED and 1B for every 16 LEDs as end of frame. References: \"SK9822 \u2013 a clone of the APA102?\" Dependencies \u00b6 modm:driver:sk9822 modm_driver_sk9822 modm: driver: sk9822 modm_driver_apa102 modm: driver: apa102 modm_driver_sk9822->modm_driver_apa102 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:sk9822"},{"location":"reference/module/modm-driver-sk9822/#sk9822-rgb-led-driver","text":"lbuild module: modm:driver:sk9822 Drives any number of chained SK9822 RGB LEDs using SPI signals SCK and MOSI up to a few dozen MHz. Due to the synchronous clock, there are no special restrictions on protocol timing, making this driver safe to use with interrupts enabled and/or with an RTOS. The internal data buffer size is 4B for start of frame, 4B for every LED and 1B for every 16 LEDs as end of frame. References: \"SK9822 \u2013 a clone of the APA102?\"","title":"SK9822 RGB LED Driver"},{"location":"reference/module/modm-driver-sk9822/#dependencies","text":"modm:driver:sk9822 modm_driver_sk9822 modm: driver: sk9822 modm_driver_apa102 modm: driver: apa102 modm_driver_sk9822->modm_driver_apa102 @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ssd1306/","text":"SSD1306 Display \u00b6 lbuild module: modm:driver:ssd1306 Dependencies \u00b6 modm:driver:ssd1306 modm_driver_ssd1306 modm: driver: ssd1306 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ssd1306->modm_architecture_i2c_device modm_processing_timer modm: processing: timer modm_driver_ssd1306->modm_processing_timer modm_ui_display modm: ui: display modm_driver_ssd1306->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:ssd1306"},{"location":"reference/module/modm-driver-ssd1306/#ssd1306-display","text":"lbuild module: modm:driver:ssd1306","title":"SSD1306 Display"},{"location":"reference/module/modm-driver-ssd1306/#dependencies","text":"modm:driver:ssd1306 modm_driver_ssd1306 modm: driver: ssd1306 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_ssd1306->modm_architecture_i2c_device modm_processing_timer modm: processing: timer modm_driver_ssd1306->modm_processing_timer modm_ui_display modm: ui: display modm_driver_ssd1306->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-stusb4500/","text":"STUSB4500 USB PD controller \u00b6 lbuild module: modm:driver:stusb4500 Standalone USB PD controller for power sinking devices \u00b6 The STUSB4500 is a USB power delivery controller for USB power sink devices. See https://www.st.com/en/interfaces-and-transceivers/stusb4500.html The STUSB4500 is connected via I2C to the microcontroller. This driver only implements basic functionality for now. Dependencies \u00b6 modm:driver:stusb4500 modm_driver_stusb4500 modm: driver: stusb4500 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_stusb4500->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:stusb4500"},{"location":"reference/module/modm-driver-stusb4500/#stusb4500-usb-pd-controller","text":"lbuild module: modm:driver:stusb4500","title":"STUSB4500 USB PD controller"},{"location":"reference/module/modm-driver-stusb4500/#standalone-usb-pd-controller-for-power-sinking-devices","text":"The STUSB4500 is a USB power delivery controller for USB power sink devices. See https://www.st.com/en/interfaces-and-transceivers/stusb4500.html The STUSB4500 is connected via I2C to the microcontroller. This driver only implements basic functionality for now.","title":"Standalone USB PD controller for power sinking devices"},{"location":"reference/module/modm-driver-stusb4500/#dependencies","text":"modm:driver:stusb4500 modm_driver_stusb4500 modm: driver: stusb4500 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_stusb4500->modm_architecture_i2c_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-sx1276/","text":"Semtech SX1276 Driver \u00b6 lbuild module: modm:driver:sx1276 Dependencies \u00b6 modm:driver:sx1276 modm_driver_sx1276 modm: driver: sx1276 modm_architecture_clock modm: architecture: clock modm_driver_sx1276->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_sx1276->modm_architecture_delay modm_architecture_register modm: architecture: register modm_driver_sx1276->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_driver_sx1276->modm_architecture_spi modm_architecture_spi_device modm: architecture: spi.device modm_driver_sx1276->modm_architecture_spi_device modm_debug modm: debug modm_driver_sx1276->modm_debug modm_processing_timer modm: processing: timer modm_driver_sx1276->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:sx1276"},{"location":"reference/module/modm-driver-sx1276/#semtech-sx1276-driver","text":"lbuild module: modm:driver:sx1276","title":"Semtech SX1276 Driver"},{"location":"reference/module/modm-driver-sx1276/#dependencies","text":"modm:driver:sx1276 modm_driver_sx1276 modm: driver: sx1276 modm_architecture_clock modm: architecture: clock modm_driver_sx1276->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_driver_sx1276->modm_architecture_delay modm_architecture_register modm: architecture: register modm_driver_sx1276->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_driver_sx1276->modm_architecture_spi modm_architecture_spi_device modm: architecture: spi.device modm_driver_sx1276->modm_architecture_spi_device modm_debug modm: debug modm_driver_sx1276->modm_debug modm_processing_timer modm: processing: timer modm_driver_sx1276->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-tcs3414/","text":"TCS3414 Digital Color Sensor \u00b6 lbuild module: modm:driver:tcs3414 Dependencies \u00b6 modm:driver:tcs3414 modm_driver_tcs3414 modm: driver: tcs3414 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3414->modm_architecture_i2c_device modm_ui_color modm: ui: color modm_driver_tcs3414->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:tcs3414"},{"location":"reference/module/modm-driver-tcs3414/#tcs3414-digital-color-sensor","text":"lbuild module: modm:driver:tcs3414","title":"TCS3414 Digital Color Sensor"},{"location":"reference/module/modm-driver-tcs3414/#dependencies","text":"modm:driver:tcs3414 modm_driver_tcs3414 modm: driver: tcs3414 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3414->modm_architecture_i2c_device modm_ui_color modm: ui: color modm_driver_tcs3414->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-tcs3472/","text":"TCS3472X Digital Color Sensor \u00b6 lbuild module: modm:driver:tcs3472 Dependencies \u00b6 modm:driver:tcs3472 modm_driver_tcs3472 modm: driver: tcs3472 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3472->modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_tcs3472->modm_math_utils modm_ui_color modm: ui: color modm_driver_tcs3472->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:tcs3472"},{"location":"reference/module/modm-driver-tcs3472/#tcs3472x-digital-color-sensor","text":"lbuild module: modm:driver:tcs3472","title":"TCS3472X Digital Color Sensor"},{"location":"reference/module/modm-driver-tcs3472/#dependencies","text":"modm:driver:tcs3472 modm_driver_tcs3472 modm: driver: tcs3472 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tcs3472->modm_architecture_i2c_device modm_math_utils modm: math: utils modm_driver_tcs3472->modm_math_utils modm_ui_color modm: ui: color modm_driver_tcs3472->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-terminal/","text":"Terminal Output \u00b6 lbuild module: modm:driver:terminal Dependencies \u00b6 modm:driver:terminal modm_driver_terminal modm: driver: terminal modm_io modm: io modm_driver_terminal->modm_io @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:terminal"},{"location":"reference/module/modm-driver-terminal/#terminal-output","text":"lbuild module: modm:driver:terminal","title":"Terminal Output"},{"location":"reference/module/modm-driver-terminal/#dependencies","text":"modm:driver:terminal modm_driver_terminal modm: driver: terminal modm_io modm: io modm_driver_terminal->modm_io @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-tlc594x/","text":"TLC594* 12-bit PWM Driver \u00b6 lbuild module: modm:driver:tlc594x TLC594* multi-channel, daisy-chainable, constant-current sink, 12bit PWM LED driver. Dependencies \u00b6 modm:driver:tlc594x modm_driver_tlc594x modm: driver: tlc594x modm_architecture_delay modm: architecture: delay modm_driver_tlc594x->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_tlc594x->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_tlc594x->modm_architecture_spi @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:tlc594x"},{"location":"reference/module/modm-driver-tlc594x/#tlc594-12-bit-pwm-driver","text":"lbuild module: modm:driver:tlc594x TLC594* multi-channel, daisy-chainable, constant-current sink, 12bit PWM LED driver.","title":"TLC594* 12-bit PWM Driver"},{"location":"reference/module/modm-driver-tlc594x/#dependencies","text":"modm:driver:tlc594x modm_driver_tlc594x modm: driver: tlc594x modm_architecture_delay modm: architecture: delay modm_driver_tlc594x->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_driver_tlc594x->modm_architecture_gpio modm_architecture_spi modm: architecture: spi modm_driver_tlc594x->modm_architecture_spi @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-tmp102/","text":"TMP102 Thermometer \u00b6 lbuild module: modm:driver:tmp102 The TMP102 is a digital temperature sensor with an I2C interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 0.5 deg C. The sensor has a default refresh rate of 4Hz but can be set from 0.25Hz up to 33Hz using setUpdateRate(rate) . The sensor will then read itself when calling the update() method frequently. However, you may manually start a conversion with startConversion() , wait for 30ms and then readTemperature() to achieve other (less frequent) update rates. Dependencies \u00b6 modm:driver:tmp102 modm_driver_tmp102 modm: driver: tmp102 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp102->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp102->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_tmp102->modm_driver_lm75 modm_math_utils modm: math: utils modm_driver_tmp102->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_tmp102->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:tmp102"},{"location":"reference/module/modm-driver-tmp102/#tmp102-thermometer","text":"lbuild module: modm:driver:tmp102 The TMP102 is a digital temperature sensor with an I2C interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 0.5 deg C. The sensor has a default refresh rate of 4Hz but can be set from 0.25Hz up to 33Hz using setUpdateRate(rate) . The sensor will then read itself when calling the update() method frequently. However, you may manually start a conversion with startConversion() , wait for 30ms and then readTemperature() to achieve other (less frequent) update rates.","title":"TMP102 Thermometer"},{"location":"reference/module/modm-driver-tmp102/#dependencies","text":"modm:driver:tmp102 modm_driver_tmp102 modm: driver: tmp102 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp102->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp102->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_tmp102->modm_driver_lm75 modm_math_utils modm: math: utils modm_driver_tmp102->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_tmp102->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-tmp175/","text":"TMP175 Thermometer \u00b6 lbuild module: modm:driver:tmp175 TMP175 digital temperature sensor driver. The TMP175 is a digital temperature sensor with a two-wire interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 1.5 deg C. The sensor has a default refresh rate of 4Hz but can be raised up to 30Hz by repeatedly manually starting a conversion (with startConversion()), which lasts between 30ms and 240ms depending on resolution. Dependencies \u00b6 modm:driver:tmp175 modm_driver_tmp175 modm: driver: tmp175 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp175->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp175->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_tmp175->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_tmp175->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:tmp175"},{"location":"reference/module/modm-driver-tmp175/#tmp175-thermometer","text":"lbuild module: modm:driver:tmp175 TMP175 digital temperature sensor driver. The TMP175 is a digital temperature sensor with a two-wire interface and measures temperature over a range of -40 to +125 deg Celsius with a resolution of 1/16 (0.0625) deg C and an accuracy of up to 1.5 deg C. The sensor has a default refresh rate of 4Hz but can be raised up to 30Hz by repeatedly manually starting a conversion (with startConversion()), which lasts between 30ms and 240ms depending on resolution.","title":"TMP175 Thermometer"},{"location":"reference/module/modm-driver-tmp175/#dependencies","text":"modm:driver:tmp175 modm_driver_tmp175 modm: driver: tmp175 modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_tmp175->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_tmp175->modm_architecture_register modm_driver_lm75 modm: driver: lm75 modm_driver_tmp175->modm_driver_lm75 modm_processing_protothread modm: processing: protothread modm_driver_tmp175->modm_processing_protothread @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-touch2046/","text":"TSC2046/x2046 Resistive Touch Controller \u00b6 lbuild module: modm:driver:touch2046 The TSC2046 by Texas Instruments is a popular touchscreen controller on cheap displays. https://www.ti.com/lit/ds/symlink/tsc2046.pdf There are many compatible devices from other manufacturers available, such as the XPT2046 by XPTEK or \"2046\" labeled chips from unknown manufacturers. All of these are compatible with the TSC2046. Dependencies \u00b6 modm:driver:touch2046 modm_driver_touch2046 modm: driver: touch2046 modm_architecture_spi_device modm: architecture: spi.device modm_driver_touch2046->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_touch2046->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:touch2046"},{"location":"reference/module/modm-driver-touch2046/#tsc2046x2046-resistive-touch-controller","text":"lbuild module: modm:driver:touch2046 The TSC2046 by Texas Instruments is a popular touchscreen controller on cheap displays. https://www.ti.com/lit/ds/symlink/tsc2046.pdf There are many compatible devices from other manufacturers available, such as the XPT2046 by XPTEK or \"2046\" labeled chips from unknown manufacturers. All of these are compatible with the TSC2046.","title":"TSC2046/x2046 Resistive Touch Controller"},{"location":"reference/module/modm-driver-touch2046/#dependencies","text":"modm:driver:touch2046 modm_driver_touch2046 modm: driver: touch2046 modm_architecture_spi_device modm: architecture: spi.device modm_driver_touch2046->modm_architecture_spi_device modm_processing_resumable modm: processing: resumable modm_driver_touch2046->modm_processing_resumable @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-vl53l0/","text":"VL53L0X Proximity Sensor \u00b6 lbuild module: modm:driver:vl53l0 Dependencies \u00b6 modm:driver:vl53l0 modm_driver_vl53l0 modm: driver: vl53l0 modm_architecture_accessor modm: architecture: accessor modm_driver_vl53l0->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl53l0->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl53l0->modm_architecture_register modm_debug modm: debug modm_driver_vl53l0->modm_debug modm_processing_timer modm: processing: timer modm_driver_vl53l0->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:vl53l0"},{"location":"reference/module/modm-driver-vl53l0/#vl53l0x-proximity-sensor","text":"lbuild module: modm:driver:vl53l0","title":"VL53L0X Proximity Sensor"},{"location":"reference/module/modm-driver-vl53l0/#dependencies","text":"modm:driver:vl53l0 modm_driver_vl53l0 modm: driver: vl53l0 modm_architecture_accessor modm: architecture: accessor modm_driver_vl53l0->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl53l0->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl53l0->modm_architecture_register modm_debug modm: debug modm_driver_vl53l0->modm_debug modm_processing_timer modm: processing: timer modm_driver_vl53l0->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-vl6180/","text":"VL6180X Proximity Sensor \u00b6 lbuild module: modm:driver:vl6180 Dependencies \u00b6 modm:driver:vl6180 modm_driver_vl6180 modm: driver: vl6180 modm_architecture_accessor modm: architecture: accessor modm_driver_vl6180->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl6180->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl6180->modm_architecture_register modm_architecture_unaligned modm: architecture: unaligned modm_driver_vl6180->modm_architecture_unaligned modm_debug modm: debug modm_driver_vl6180->modm_debug modm_math_utils modm: math: utils modm_driver_vl6180->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_vl6180->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_vl6180->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":driver:vl6180"},{"location":"reference/module/modm-driver-vl6180/#vl6180x-proximity-sensor","text":"lbuild module: modm:driver:vl6180","title":"VL6180X Proximity Sensor"},{"location":"reference/module/modm-driver-vl6180/#dependencies","text":"modm:driver:vl6180 modm_driver_vl6180 modm: driver: vl6180 modm_architecture_accessor modm: architecture: accessor modm_driver_vl6180->modm_architecture_accessor modm_architecture_i2c_device modm: architecture: i2c.device modm_driver_vl6180->modm_architecture_i2c_device modm_architecture_register modm: architecture: register modm_driver_vl6180->modm_architecture_register modm_architecture_unaligned modm: architecture: unaligned modm_driver_vl6180->modm_architecture_unaligned modm_debug modm: debug modm_driver_vl6180->modm_debug modm_math_utils modm: math: utils modm_driver_vl6180->modm_math_utils modm_processing_protothread modm: processing: protothread modm_driver_vl6180->modm_processing_protothread modm_processing_timer modm: processing: timer modm_driver_vl6180->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-driver-ws2812/","text":"WS2812 Driver \u00b6 lbuild module: modm:driver:ws2812 Drives any number of chained WS2812 LEDs using a 3-bit SPI encoding (0 -> 100, 1 -> 110) running at 3 MHz. Thus, writing one LED takes 24\u00b5s and 9 bytes of memory. There are several caveats: This only provides a blocking write API, due to technical limitations. Atomicity is not enforced, this should be done externally if required. The memory footprint is 3x as large, due to the bit stuffing for SPI. There is no enforced reset period of at least 50\u00b5s after the write is finished, it is up to the user to not trigger another write too early. This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now. SystemClock Limitations This driver requires a 3 MHz \u00b110% SPI clock in order to get the protocol timing right. Depending on your device clock tree and the SPI prescalers, this might require lowering the frequency of the entire device! If this is unacceptable, consider using APA102. This module is only available for stm32. Dependencies \u00b6 modm:driver:ws2812 modm_driver_ws2812 modm: driver: ws2812 modm_architecture_spi modm: architecture: spi modm_driver_ws2812->modm_architecture_spi modm_architecture_unaligned modm: architecture: unaligned modm_driver_ws2812->modm_architecture_unaligned modm_math_units modm: math: units modm_driver_ws2812->modm_math_units modm_ui_color modm: ui: color modm_driver_ws2812->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":driver:ws2812"},{"location":"reference/module/modm-driver-ws2812/#ws2812-driver","text":"lbuild module: modm:driver:ws2812 Drives any number of chained WS2812 LEDs using a 3-bit SPI encoding (0 -> 100, 1 -> 110) running at 3 MHz. Thus, writing one LED takes 24\u00b5s and 9 bytes of memory. There are several caveats: This only provides a blocking write API, due to technical limitations. Atomicity is not enforced, this should be done externally if required. The memory footprint is 3x as large, due to the bit stuffing for SPI. There is no enforced reset period of at least 50\u00b5s after the write is finished, it is up to the user to not trigger another write too early. This driver directly accesses the STM32 HAL to keep the transmit register full, due to a lack of DMA capability in modm, thus this driver is STM32-only for now. SystemClock Limitations This driver requires a 3 MHz \u00b110% SPI clock in order to get the protocol timing right. Depending on your device clock tree and the SPI prescalers, this might require lowering the frequency of the entire device! If this is unacceptable, consider using APA102. This module is only available for stm32.","title":"WS2812 Driver"},{"location":"reference/module/modm-driver-ws2812/#dependencies","text":"modm:driver:ws2812 modm_driver_ws2812 modm: driver: ws2812 modm_architecture_spi modm: architecture: spi modm_driver_ws2812->modm_architecture_spi modm_architecture_unaligned modm: architecture: unaligned modm_driver_ws2812->modm_architecture_unaligned modm_math_units modm: math: units modm_driver_ws2812->modm_math_units modm_ui_color modm: ui: color modm_driver_ws2812->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-driver/","text":"External Device Drivers \u00b6 lbuild module: modm:driver","title":":driver"},{"location":"reference/module/modm-driver/#external-device-drivers","text":"lbuild module: modm:driver","title":"External Device Drivers"},{"location":"reference/module/modm-fatfs-petit/","text":"Petit FatFs: Tiny FAT Filesystem \u00b6 lbuild module: modm:fatfs.petit Petit FatFs is a sub-set of FatFs module for tiny 8-bit microcontrollers. It can be incorporated into the tiny microcontrollers with limited memory even if the RAM size is less than sector size. See http://elm-chan.org/fsw/ff/00index_p.html . Configuration \u00b6 To configure Petit FatFs for your project, create a <pffconf_local.h> file, which is included at the beginning of the config, thus overwriting the default settings. Please see the modm/ext/fatfs-petit/pffconf.h file for the available configuration options and their default values. Example <pffconf_local.h> configuration: // Enable directories: pf_opendir(), pf_readdir() #define PF_USE_DIR 1 // Enabling writing: pf_write() #define PF_USE_WRITE 1 // Use FAT12 file system #define PF_FS_FAT12 1 #define PF_FS_FAT16 0 #define PF_FS_FAT32 0","title":":fatfs.petit"},{"location":"reference/module/modm-fatfs-petit/#petit-fatfs-tiny-fat-filesystem","text":"lbuild module: modm:fatfs.petit Petit FatFs is a sub-set of FatFs module for tiny 8-bit microcontrollers. It can be incorporated into the tiny microcontrollers with limited memory even if the RAM size is less than sector size. See http://elm-chan.org/fsw/ff/00index_p.html .","title":"Petit FatFs: Tiny FAT Filesystem"},{"location":"reference/module/modm-fatfs-petit/#configuration","text":"To configure Petit FatFs for your project, create a <pffconf_local.h> file, which is included at the beginning of the config, thus overwriting the default settings. Please see the modm/ext/fatfs-petit/pffconf.h file for the available configuration options and their default values. Example <pffconf_local.h> configuration: // Enable directories: pf_opendir(), pf_readdir() #define PF_USE_DIR 1 // Enabling writing: pf_write() #define PF_USE_WRITE 1 // Use FAT12 file system #define PF_FS_FAT12 1 #define PF_FS_FAT16 0 #define PF_FS_FAT32 0","title":"Configuration"},{"location":"reference/module/modm-fatfs/","text":"FatFs: FAT Filesystem \u00b6 lbuild module: modm:fatfs FatFs is a generic FAT/exFAT filesystem module for small embedded systems. See http://elm-chan.org/fsw/ff/00index_e.html . Configuration \u00b6 This module generates a ffconf.h config file for modm integration with these settings: FF_FS_NORTC = 1 : modm does not provide an accurate RTC timekeeping method, you must implement that yourself. ff_memalloc / ff_memfree : Forwarded to malloc and free as implemented by the modm:platform:heap module To configure FatFs for your project, create a <ffconf_local.h> file, which is included at the beginning of the config, thus overwriting the default settings. Please see the modm/ext/fatfs/ffconf.h file for the available configuration options and their default values. Example <ffconf_local.h> configuration: // Enable directory filtering: f_findfirst(), f_findnext() #define FF_USE_FIND 1 // Enable Volume Formatting: f_mkfs() #define FF_USE_MKFS 1 // Enable Volume Label: f_setlabel(), f_getlabel() #define FF_USE_LABEL 1 // Enable tiny sector buffers #define FF_FS_TINY 1","title":":fatfs"},{"location":"reference/module/modm-fatfs/#fatfs-fat-filesystem","text":"lbuild module: modm:fatfs FatFs is a generic FAT/exFAT filesystem module for small embedded systems. See http://elm-chan.org/fsw/ff/00index_e.html .","title":"FatFs: FAT Filesystem"},{"location":"reference/module/modm-fatfs/#configuration","text":"This module generates a ffconf.h config file for modm integration with these settings: FF_FS_NORTC = 1 : modm does not provide an accurate RTC timekeeping method, you must implement that yourself. ff_memalloc / ff_memfree : Forwarded to malloc and free as implemented by the modm:platform:heap module To configure FatFs for your project, create a <ffconf_local.h> file, which is included at the beginning of the config, thus overwriting the default settings. Please see the modm/ext/fatfs/ffconf.h file for the available configuration options and their default values. Example <ffconf_local.h> configuration: // Enable directory filtering: f_findfirst(), f_findnext() #define FF_USE_FIND 1 // Enable Volume Formatting: f_mkfs() #define FF_USE_MKFS 1 // Enable Volume Label: f_setlabel(), f_getlabel() #define FF_USE_LABEL 1 // Enable tiny sector buffers #define FF_FS_TINY 1","title":"Configuration"},{"location":"reference/module/modm-freertos-tcp-lan8720a/","text":"a:FreeRTOS-Plus-TCP Ethernet via LAN8720A \u00b6 lbuild module: modm:freertos:tcp:lan8720a This module implements TCP over Ethernet via the LAN8720A transceiver. This module is only available for stm32f7. Dependencies \u00b6 modm:freertos:tcp:lan8720a modm_freertos_tcp_lan8720a modm: freertos: tcp: lan8720a modm_driver_lan8720a modm: driver: lan8720a modm_freertos_tcp_lan8720a->modm_driver_lan8720a modm_platform_eth modm: platform: eth modm_freertos_tcp_lan8720a->modm_platform_eth @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":freertos:tcp:lan8720a"},{"location":"reference/module/modm-freertos-tcp-lan8720a/#afreertos-plus-tcp-ethernet-via-lan8720a","text":"lbuild module: modm:freertos:tcp:lan8720a This module implements TCP over Ethernet via the LAN8720A transceiver. This module is only available for stm32f7.","title":"a:FreeRTOS-Plus-TCP Ethernet via LAN8720A"},{"location":"reference/module/modm-freertos-tcp-lan8720a/#dependencies","text":"modm:freertos:tcp:lan8720a modm_freertos_tcp_lan8720a modm: freertos: tcp: lan8720a modm_driver_lan8720a modm: driver: lan8720a modm_freertos_tcp_lan8720a->modm_driver_lan8720a modm_platform_eth modm: platform: eth modm_freertos_tcp_lan8720a->modm_platform_eth @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-freertos-tcp/","text":"FreeRTOS+TCP \u00b6 lbuild module: modm:freertos:tcp Amazon FreeRTOS+TCP is a scalable, open source and thread safe TCP/IP stack for FreeRTOS. FreeRTOS+TCP's features and RAM footprint are fully scalable, making it equally applicable to smaller lower throughput microcontrollers as larger higher throughput microprocessors. This module provides the latest FreeRTOS+TCP LTS release integrated with modm: FreeRTOS_printf() and FreeRTOS_debug_printf() forwarded to modm:debug . Configuration \u00b6 This module generates a FreeRTOSIPConfig.h config file for modm integration with these overwritable settings: ipconfigIP_TASK_STACK_SIZE_WORDS = (configMINIMAL_STACK_SIZE * 4) ipconfigIP_TASK_PRIORITY = (configMAX_PRIORITIES - 2) FreeRTOS_printf(x) = MODM_LOG_INFO.printf(x) FreeRTOS_debug_printf(x) = MODM_LOG_DEBUG.printf(x) All other config settings are unchanged by modm and are defaulted by FreeRTOS itself, please refer to the FreeRTOS+TCP Config documentation to understand what each of these do. To change a configuration setting, define a <FreeRTOSIPConfigLocal.h> file, which is included before the optional settings, so you can overwrite them easily. An example <FreeRTOSIPConfigLocal.h> file: // Change IP task stack size #define ipconfigIP_TASK_STACK_SIZE_WORDS 1024 // Enable printing #define ipconfigHAS_PRINTF 1 #define ipconfigHAS_DEBUG_PRINTF 1 Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":freertos:tcp"},{"location":"reference/module/modm-freertos-tcp/#freertostcp","text":"lbuild module: modm:freertos:tcp Amazon FreeRTOS+TCP is a scalable, open source and thread safe TCP/IP stack for FreeRTOS. FreeRTOS+TCP's features and RAM footprint are fully scalable, making it equally applicable to smaller lower throughput microcontrollers as larger higher throughput microprocessors. This module provides the latest FreeRTOS+TCP LTS release integrated with modm: FreeRTOS_printf() and FreeRTOS_debug_printf() forwarded to modm:debug .","title":"FreeRTOS+TCP"},{"location":"reference/module/modm-freertos-tcp/#configuration","text":"This module generates a FreeRTOSIPConfig.h config file for modm integration with these overwritable settings: ipconfigIP_TASK_STACK_SIZE_WORDS = (configMINIMAL_STACK_SIZE * 4) ipconfigIP_TASK_PRIORITY = (configMAX_PRIORITIES - 2) FreeRTOS_printf(x) = MODM_LOG_INFO.printf(x) FreeRTOS_debug_printf(x) = MODM_LOG_DEBUG.printf(x) All other config settings are unchanged by modm and are defaulted by FreeRTOS itself, please refer to the FreeRTOS+TCP Config documentation to understand what each of these do. To change a configuration setting, define a <FreeRTOSIPConfigLocal.h> file, which is included before the optional settings, so you can overwrite them easily. An example <FreeRTOSIPConfigLocal.h> file: // Change IP task stack size #define ipconfigIP_TASK_STACK_SIZE_WORDS 1024 // Enable printing #define ipconfigHAS_PRINTF 1 #define ipconfigHAS_DEBUG_PRINTF 1 Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Configuration"},{"location":"reference/module/modm-freertos/","text":"FreeRTOS \u00b6 lbuild module: modm:freertos Amazon FreeRTOS is an open source, real-time operating system (RTOS) for microcontrollers in small, low-power devices. This module provides the latest FreeRTOS LTS release integrated with modm: Chooses the right Cortex-M port for the target. Variable tick rate integrated with modm::Clock via modm:platform:clock . Dynamic memory provided by the modm:platform:heap module with thread-safe locking of Newlib's malloc/free . Assertions integrated into the modm:architecture:assert interface. Interrupt handling integrated with CMSIS NVIC functions. Note that we recommend using the FreeRTOS API directly and only if you write threaded code that also runs on other platforms (x86 simulators for example) should you consider using the API defined in modm:processing:rtos module. Configuration \u00b6 This module generates a FreeRTOSConfig.h config file for modm integration with these settings: configASSERT(x) implemented with modm_assert(x, \"freertos\") . configCPU_CLOCK_HZ implemented with CMSIS SystemCoreClock . configTICK_RATE_HZ set to modm:freertos:frequency or 1kHz on Cortex-M0. configSUPPORT_DYNAMIC_ALLOCATION = 1 as implemented by modm:platform:heap . configUSE_TICK_HOOK = 1 used by modm:platform:clock to provide modm::Clock . In addition we define these overwritable default settings: configMAX_SYSCALL_INTERRUPT_PRIORITY = (__NVIC_PRIO_BITS << (8u - __NVIC_PRIO_BITS)) configMINIMAL_STACK_SIZE = 128 configMAX_PRIORITIES = 5 configUSE_PREEMPTION = 1 configUSE_IDLE_HOOK = 0 configUSE_16_BIT_TICKS = 0 configUSE_MUTEXES = 1 configUSE_RECURSIVE_MUTEXES = 1 configUSE_COUNTING_SEMAPHORES = 1 configQUEUE_REGISTRY_SIZE = 10 configNUM_THREAD_LOCAL_STORAGE_POINTERS = 5 configCHECK_FOR_STACK_OVERFLOW = 1 configUSE_TIMERS = 1 configTIMER_TASK_PRIORITY = 3 configTIMER_QUEUE_LENGTH = 10 configTIMER_TASK_STACK_DEPTH = configMINIMAL_STACK_SIZE All other config settings are unchanged by modm and are defaulted by FreeRTOS itself, please refer to the FreeRTOS Config documentation to understand what each of these do. To change a configuration setting, define a <FreeRTOSConfigLocal.h> file, which is included before the optional settings, so you can overwrite them easily. An example <FreeRTOSConfigLocal.h> file: // Use a bigger minimal stack size #define configMINIMAL_STACK_SIZE 256 // Longer timer queue #define configTIMER_QUEUE_LENGTH 20 This module is only available for sam, stm32. Options \u00b6 frequency \u00b6 Context switch frequency in Hz Default: 1000 Inputs: [4 ... 1000] Dependencies \u00b6 modm:freertos modm_freertos modm: freertos modm_architecture_assert modm: architecture: assert modm_freertos->modm_architecture_assert modm_cmsis_device modm: cmsis: device modm_freertos->modm_cmsis_device modm_platform_clock modm: platform: clock modm_freertos->modm_platform_clock modm_platform_heap modm: platform: heap modm_freertos->modm_platform_heap @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":freertos"},{"location":"reference/module/modm-freertos/#freertos","text":"lbuild module: modm:freertos Amazon FreeRTOS is an open source, real-time operating system (RTOS) for microcontrollers in small, low-power devices. This module provides the latest FreeRTOS LTS release integrated with modm: Chooses the right Cortex-M port for the target. Variable tick rate integrated with modm::Clock via modm:platform:clock . Dynamic memory provided by the modm:platform:heap module with thread-safe locking of Newlib's malloc/free . Assertions integrated into the modm:architecture:assert interface. Interrupt handling integrated with CMSIS NVIC functions. Note that we recommend using the FreeRTOS API directly and only if you write threaded code that also runs on other platforms (x86 simulators for example) should you consider using the API defined in modm:processing:rtos module.","title":"FreeRTOS"},{"location":"reference/module/modm-freertos/#configuration","text":"This module generates a FreeRTOSConfig.h config file for modm integration with these settings: configASSERT(x) implemented with modm_assert(x, \"freertos\") . configCPU_CLOCK_HZ implemented with CMSIS SystemCoreClock . configTICK_RATE_HZ set to modm:freertos:frequency or 1kHz on Cortex-M0. configSUPPORT_DYNAMIC_ALLOCATION = 1 as implemented by modm:platform:heap . configUSE_TICK_HOOK = 1 used by modm:platform:clock to provide modm::Clock . In addition we define these overwritable default settings: configMAX_SYSCALL_INTERRUPT_PRIORITY = (__NVIC_PRIO_BITS << (8u - __NVIC_PRIO_BITS)) configMINIMAL_STACK_SIZE = 128 configMAX_PRIORITIES = 5 configUSE_PREEMPTION = 1 configUSE_IDLE_HOOK = 0 configUSE_16_BIT_TICKS = 0 configUSE_MUTEXES = 1 configUSE_RECURSIVE_MUTEXES = 1 configUSE_COUNTING_SEMAPHORES = 1 configQUEUE_REGISTRY_SIZE = 10 configNUM_THREAD_LOCAL_STORAGE_POINTERS = 5 configCHECK_FOR_STACK_OVERFLOW = 1 configUSE_TIMERS = 1 configTIMER_TASK_PRIORITY = 3 configTIMER_QUEUE_LENGTH = 10 configTIMER_TASK_STACK_DEPTH = configMINIMAL_STACK_SIZE All other config settings are unchanged by modm and are defaulted by FreeRTOS itself, please refer to the FreeRTOS Config documentation to understand what each of these do. To change a configuration setting, define a <FreeRTOSConfigLocal.h> file, which is included before the optional settings, so you can overwrite them easily. An example <FreeRTOSConfigLocal.h> file: // Use a bigger minimal stack size #define configMINIMAL_STACK_SIZE 256 // Longer timer queue #define configTIMER_QUEUE_LENGTH 20 This module is only available for sam, stm32.","title":"Configuration"},{"location":"reference/module/modm-freertos/#options","text":"","title":"Options"},{"location":"reference/module/modm-freertos/#frequency","text":"Context switch frequency in Hz Default: 1000 Inputs: [4 ... 1000]","title":"frequency"},{"location":"reference/module/modm-freertos/#dependencies","text":"modm:freertos modm_freertos modm: freertos modm_architecture_assert modm: architecture: assert modm_freertos->modm_architecture_assert modm_cmsis_device modm: cmsis: device modm_freertos->modm_cmsis_device modm_platform_clock modm: platform: clock modm_freertos->modm_platform_clock modm_platform_heap modm: platform: heap modm_freertos->modm_platform_heap @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-io/","text":"Input/Output Streams \u00b6 lbuild module: modm:io The modm::IOStream class contains efficient formatting that supports both C++ std::basic_ostream -like formatting via operator << as well as implementing a reasonably large subset of printf . modm :: IOStream stream ( device ); stream << \"format number 8: \" << uint8_t ( 8 ) << \" or as signed -100: \" << int8_t ( -100 ); stream << modm :: endl ; stream . printf ( \"format number 8: %u or as signed -100: %d\" , 8 , -100 ); AVR supported features All expensive features incl. printf are disabled by default! Check the options. modm::endl does NOT implicitly flush! Flushing is extremely expensive on embedded systems, therefore modm::endl does not implicitly flush the stream. Please call modm::flush explicitly. Using printf \u00b6 This module uses the printf implementation from mpaland/printf . Format Specifiers \u00b6 A format specifier follows this prototype: %[flags][width][.precision][length]type The following format specifiers are supported: Supported Types \u00b6 Type Output d or i Signed decimal integer u Unsigned decimal integer b Unsigned binary o Unsigned octal x Unsigned hexadecimal integer (lowercase) X Unsigned hexadecimal integer (uppercase) f or F Decimal floating point ( with_float option) e or E Scientific-notation (exponential) floating point ( with_float option) g or G Scientific or decimal floating point ( with_float option) c Single character s String of characters p Pointer address % A % followed by another % character will write a single % Supported Flags \u00b6 Flags Description - Left-justify within the given field width; Right justification is the default. + Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign. (space) If no sign is going to be written, a blank space is inserted before the value. # Used with o, b, x or X specifiers the value is preceded with 0, 0b, 0x or 0X respectively for values different than zero. Used with f, F it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written. 0 Left-pads the number with zeros (0) instead of spaces when padding is specified (see width sub-specifier). Supported Width \u00b6 Width Description (number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger. * The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. Supported Precision \u00b6 Precision Description .number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0. For f and F specifiers: this is the number of digits to be printed after the decimal point. By default, this is 6, maximum is 9 . For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. If the period is specified without an explicit value for precision, 0 is assumed. .* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. Supported Length \u00b6 The length sub-specifier modifies the length of the data type. Length d i u o x X (none) int unsigned int hh char unsigned char h short int unsigned short int l long int unsigned long int ll long long int unsigned long long int ( with_long_long option) j intmax_t uintmax_t z size_t size_t t ptrdiff_t ptrdiff_t ( with_ptrdiff option) Redirecting IOStreams \u00b6 The modm::IODeviceWrapper transforms any peripheral device that provides static write() and read() functions into an IODevice . You have to decide what happens when the device buffer is full and you cannot write to it at the moment. There are two options: busy wait until the buffer is free, or discard the bytes that cannot be written. Option 1 has the advantage, that none of your data will be lost, however, busy-waiting can take a long time and can mess up your program timings. There is also a high risk of deadlock , when writing to a IODevice inside of an interrupt and then busy-waiting forever because the IODevice requires interrupts itself to send out the data. It is therefore highly recommended to use option 2, where surplus data will be discarded. You should increase the IODevice buffer size, if you experience missing data from your connection. This behavior is also deadlock safe when called from inside another interrupt, and your program timing is minimally affected (essentially only coping data into the buffer). There is no default template argument, so that you hopefully make a conscious decision and be aware of this behavior. Example: // configure a UART using Uart = Uart0 ; // wrap it into an IODevice modm :: IODeviceWrapper < Uart , modm :: IOBuffer :: DiscardIfFull > device ; // use this device to print a message device . write ( \"Hello\" ); // or create a IOStream and use the stream to print something modm :: IOStream stream ( device ); stream << \" World!\" ; Options \u00b6 with_float \u00b6 Support for floating point formatting On AVRs floating point values can be printed, however, the formatting cannot be specified and all values are printed as scientific-notation exponential floating point Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False] with_long_long \u00b6 Support for 64-bit integer formatting Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False] with_printf \u00b6 Support for printf-style formatting Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False] with_ptrdiff \u00b6 Support for pointer difference formatting Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False] Dependencies \u00b6 modm:io modm_io modm: io modm_architecture_accessor modm: architecture: accessor modm_io->modm_architecture_accessor modm_math_utils modm: math: utils modm_io->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":io"},{"location":"reference/module/modm-io/#inputoutput-streams","text":"lbuild module: modm:io The modm::IOStream class contains efficient formatting that supports both C++ std::basic_ostream -like formatting via operator << as well as implementing a reasonably large subset of printf . modm :: IOStream stream ( device ); stream << \"format number 8: \" << uint8_t ( 8 ) << \" or as signed -100: \" << int8_t ( -100 ); stream << modm :: endl ; stream . printf ( \"format number 8: %u or as signed -100: %d\" , 8 , -100 ); AVR supported features All expensive features incl. printf are disabled by default! Check the options. modm::endl does NOT implicitly flush! Flushing is extremely expensive on embedded systems, therefore modm::endl does not implicitly flush the stream. Please call modm::flush explicitly.","title":"Input/Output Streams"},{"location":"reference/module/modm-io/#using-printf","text":"This module uses the printf implementation from mpaland/printf .","title":"Using printf"},{"location":"reference/module/modm-io/#format-specifiers","text":"A format specifier follows this prototype: %[flags][width][.precision][length]type The following format specifiers are supported:","title":"Format Specifiers"},{"location":"reference/module/modm-io/#supported-types","text":"Type Output d or i Signed decimal integer u Unsigned decimal integer b Unsigned binary o Unsigned octal x Unsigned hexadecimal integer (lowercase) X Unsigned hexadecimal integer (uppercase) f or F Decimal floating point ( with_float option) e or E Scientific-notation (exponential) floating point ( with_float option) g or G Scientific or decimal floating point ( with_float option) c Single character s String of characters p Pointer address % A % followed by another % character will write a single %","title":"Supported Types"},{"location":"reference/module/modm-io/#supported-flags","text":"Flags Description - Left-justify within the given field width; Right justification is the default. + Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers. By default, only negative numbers are preceded with a - sign. (space) If no sign is going to be written, a blank space is inserted before the value. # Used with o, b, x or X specifiers the value is preceded with 0, 0b, 0x or 0X respectively for values different than zero. Used with f, F it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written. 0 Left-pads the number with zeros (0) instead of spaces when padding is specified (see width sub-specifier).","title":"Supported Flags"},{"location":"reference/module/modm-io/#supported-width","text":"Width Description (number) Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger. * The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.","title":"Supported Width"},{"location":"reference/module/modm-io/#supported-precision","text":"Precision Description .number For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0. For f and F specifiers: this is the number of digits to be printed after the decimal point. By default, this is 6, maximum is 9 . For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered. If the period is specified without an explicit value for precision, 0 is assumed. .* The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.","title":"Supported Precision"},{"location":"reference/module/modm-io/#supported-length","text":"The length sub-specifier modifies the length of the data type. Length d i u o x X (none) int unsigned int hh char unsigned char h short int unsigned short int l long int unsigned long int ll long long int unsigned long long int ( with_long_long option) j intmax_t uintmax_t z size_t size_t t ptrdiff_t ptrdiff_t ( with_ptrdiff option)","title":"Supported Length"},{"location":"reference/module/modm-io/#redirecting-iostreams","text":"The modm::IODeviceWrapper transforms any peripheral device that provides static write() and read() functions into an IODevice . You have to decide what happens when the device buffer is full and you cannot write to it at the moment. There are two options: busy wait until the buffer is free, or discard the bytes that cannot be written. Option 1 has the advantage, that none of your data will be lost, however, busy-waiting can take a long time and can mess up your program timings. There is also a high risk of deadlock , when writing to a IODevice inside of an interrupt and then busy-waiting forever because the IODevice requires interrupts itself to send out the data. It is therefore highly recommended to use option 2, where surplus data will be discarded. You should increase the IODevice buffer size, if you experience missing data from your connection. This behavior is also deadlock safe when called from inside another interrupt, and your program timing is minimally affected (essentially only coping data into the buffer). There is no default template argument, so that you hopefully make a conscious decision and be aware of this behavior. Example: // configure a UART using Uart = Uart0 ; // wrap it into an IODevice modm :: IODeviceWrapper < Uart , modm :: IOBuffer :: DiscardIfFull > device ; // use this device to print a message device . write ( \"Hello\" ); // or create a IOStream and use the stream to print something modm :: IOStream stream ( device ); stream << \" World!\" ;","title":"Redirecting IOStreams"},{"location":"reference/module/modm-io/#options","text":"","title":"Options"},{"location":"reference/module/modm-io/#with_float","text":"Support for floating point formatting On AVRs floating point values can be printed, however, the formatting cannot be specified and all values are printed as scientific-notation exponential floating point Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False]","title":"with_float"},{"location":"reference/module/modm-io/#with_long_long","text":"Support for 64-bit integer formatting Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False]","title":"with_long_long"},{"location":"reference/module/modm-io/#with_printf","text":"Support for printf-style formatting Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False]","title":"with_printf"},{"location":"reference/module/modm-io/#with_ptrdiff","text":"Support for pointer difference formatting Default: False avr Default: True hosted, sam, stm32 Inputs: [True, False]","title":"with_ptrdiff"},{"location":"reference/module/modm-io/#dependencies","text":"modm:io modm_io modm: io modm_architecture_accessor modm: architecture: accessor modm_io->modm_architecture_accessor modm_math_utils modm: math: utils modm_io->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-lvgl/","text":"LVGL graphics library \u00b6 lbuild module: modm:lvgl LVGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint. https://lvgl.io/ https://github.com/lvgl/lvgl Configuration \u00b6 LVGL defines defaults for all it's configuration settings, which you can find in the configuration template . This module generates a lv_conf.h file to define the options necessary for integration with modm which are: LV_MEM_CUSTOM = 1 : Heap is provided by the modm:platform:heap module. LV_TICK_CUSTOM = 1 : Tick is implemented via the modm:platform:clock module. LV_LOG_PRINTF = 0 : logging is redirected to MODM_LOG_* if the modm:debug module is included and LV_USE_LOG = 1 . typedef int16_t lv_coord_t; : Hardcoded choice for now. To add your own configuration you can create a <lv_conf_local.h> file which will automatically be included at the beginning of our lv_conf.h . Example <lv_conf_local.h> configuration: // Maximal resolutions #define LV_HOR_RES_MAX 240 #define LV_VER_RES_MAX 320 #define LV_DPI 200 /* Color depth: * - 1: 1 byte per pixel * - 8: RGB332 * - 16: RGB565 * - 32: ARGB8888 */ #define LV_COLOR_DEPTH 16 // Enable logging at INFO level #define LV_USE_LOG 1 #define LV_LOG_LEVEL LV_LOG_LEVEL_INFO // Disable anti-aliasing #define LV_ANTIALIAS 0 Dependencies \u00b6 modm:lvgl modm_lvgl modm: lvgl modm_architecture_clock modm: architecture: clock modm_lvgl->modm_architecture_clock modm_platform_heap modm: platform: heap modm_lvgl->modm_platform_heap @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":lvgl"},{"location":"reference/module/modm-lvgl/#lvgl-graphics-library","text":"lbuild module: modm:lvgl LVGL is a free and open-source graphics library providing everything you need to create embedded GUI with easy-to-use graphical elements, beautiful visual effects and low memory footprint. https://lvgl.io/ https://github.com/lvgl/lvgl","title":"LVGL graphics library"},{"location":"reference/module/modm-lvgl/#configuration","text":"LVGL defines defaults for all it's configuration settings, which you can find in the configuration template . This module generates a lv_conf.h file to define the options necessary for integration with modm which are: LV_MEM_CUSTOM = 1 : Heap is provided by the modm:platform:heap module. LV_TICK_CUSTOM = 1 : Tick is implemented via the modm:platform:clock module. LV_LOG_PRINTF = 0 : logging is redirected to MODM_LOG_* if the modm:debug module is included and LV_USE_LOG = 1 . typedef int16_t lv_coord_t; : Hardcoded choice for now. To add your own configuration you can create a <lv_conf_local.h> file which will automatically be included at the beginning of our lv_conf.h . Example <lv_conf_local.h> configuration: // Maximal resolutions #define LV_HOR_RES_MAX 240 #define LV_VER_RES_MAX 320 #define LV_DPI 200 /* Color depth: * - 1: 1 byte per pixel * - 8: RGB332 * - 16: RGB565 * - 32: ARGB8888 */ #define LV_COLOR_DEPTH 16 // Enable logging at INFO level #define LV_USE_LOG 1 #define LV_LOG_LEVEL LV_LOG_LEVEL_INFO // Disable anti-aliasing #define LV_ANTIALIAS 0","title":"Configuration"},{"location":"reference/module/modm-lvgl/#dependencies","text":"modm:lvgl modm_lvgl modm: lvgl modm_architecture_clock modm: architecture: clock modm_lvgl->modm_architecture_clock modm_platform_heap modm: platform: heap modm_lvgl->modm_platform_heap @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-algorithm/","text":"Math Algorithms \u00b6 lbuild module: modm:math:algorithm Dependencies \u00b6 modm:math:algorithm modm_math_algorithm modm: math: algorithm modm_math_units modm: math: units modm_math_algorithm->modm_math_units @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:algorithm"},{"location":"reference/module/modm-math-algorithm/#math-algorithms","text":"lbuild module: modm:math:algorithm","title":"Math Algorithms"},{"location":"reference/module/modm-math-algorithm/#dependencies","text":"modm:math:algorithm modm_math_algorithm modm: math: algorithm modm_math_units modm: math: units modm_math_algorithm->modm_math_units @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-filter/","text":"Filters \u00b6 lbuild module: modm:math:filter Dependencies \u00b6 modm:math:filter modm_math_filter modm: math: filter modm_architecture modm: architecture modm_math_filter->modm_architecture modm_math_utils modm: math: utils modm_math_filter->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:filter"},{"location":"reference/module/modm-math-filter/#filters","text":"lbuild module: modm:math:filter","title":"Filters"},{"location":"reference/module/modm-math-filter/#dependencies","text":"modm:math:filter modm_math_filter modm: math: filter modm_architecture modm: architecture modm_math_filter->modm_architecture modm_math_utils modm: math: utils modm_math_filter->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-geometry/","text":"Geometric Operations \u00b6 lbuild module: modm:math:geometry Dependencies \u00b6 modm:math:geometry modm_math_geometry modm: math: geometry modm_architecture modm: architecture modm_math_geometry->modm_architecture modm_container modm: container modm_math_geometry->modm_container modm_io modm: io modm_math_geometry->modm_io modm_math_matrix modm: math: matrix modm_math_geometry->modm_math_matrix modm_math_utils modm: math: utils modm_math_geometry->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:geometry"},{"location":"reference/module/modm-math-geometry/#geometric-operations","text":"lbuild module: modm:math:geometry","title":"Geometric Operations"},{"location":"reference/module/modm-math-geometry/#dependencies","text":"modm:math:geometry modm_math_geometry modm: math: geometry modm_architecture modm: architecture modm_math_geometry->modm_architecture modm_container modm: container modm_math_geometry->modm_container modm_io modm: io modm_math_geometry->modm_io modm_math_matrix modm: math: matrix modm_math_geometry->modm_math_matrix modm_math_utils modm: math: utils modm_math_geometry->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-interpolation/","text":"Interpolation Methods \u00b6 lbuild module: modm:math:interpolation Simple interpolation methods between a list of points. Linear Interpolation \u00b6 Example: // Definition of the supporting points. The first type is the // input type, the second the output type using Point = modm :: Pair < int8_t , int16_t > ; // Create a array of supporting points describing the curve. const Point supportingPoints [ 6 ] = { { 30 , -200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; modm :: interpolation :: Linear < Point > value ( supportingPoints , 6 ); // ... int8_t a = 40 ; int16_t b = value . interpolate ( a ); Example with supporting points read from flash: // Definition of a supporting point using Point = modm :: Pair < int8_t , int16_t > ; // Array of supporting points in flash FLASH_STORAGE ( Point supportingPoints [ 6 ]) = { { 30 , -200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; // Create an interpolator object which reads the // supporting points from flash. modm :: interpolation :: Linear < Point , modm :: accessor :: Flash > value ( modm :: accessor :: asFlash ( supportingPoints ), 6 ); // ... int8_t a = 20 ; int16_t b = value . interpolate ( a ); Lagrange Interpolation \u00b6 Example: using Point = modm :: Pair < float , float > ; // interpolate x^2 over the range of 1 <= x <= 3 Point points [ 3 ] = { { 1 , 1 }, { 2 , 4 }, { 3 , 9 } }; modm :: interpolation :: Lagrange < Point > value ( points , 3 ); // ... float output = value . interpolate ( 1.5f ); // output => 2.25; Warning Only floating points types are allowed as second type of modm::Pair , otherwise the calculation will deliver wrong results! See Wikipedia . Dependencies \u00b6 modm:math:interpolation modm_math_interpolation modm: math: interpolation modm_architecture_accessor modm: architecture: accessor modm_math_interpolation->modm_architecture_accessor modm_container modm: container modm_math_interpolation->modm_container modm_math_utils modm: math: utils modm_math_interpolation->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:interpolation"},{"location":"reference/module/modm-math-interpolation/#interpolation-methods","text":"lbuild module: modm:math:interpolation Simple interpolation methods between a list of points.","title":"Interpolation Methods"},{"location":"reference/module/modm-math-interpolation/#linear-interpolation","text":"Example: // Definition of the supporting points. The first type is the // input type, the second the output type using Point = modm :: Pair < int8_t , int16_t > ; // Create a array of supporting points describing the curve. const Point supportingPoints [ 6 ] = { { 30 , -200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; modm :: interpolation :: Linear < Point > value ( supportingPoints , 6 ); // ... int8_t a = 40 ; int16_t b = value . interpolate ( a ); Example with supporting points read from flash: // Definition of a supporting point using Point = modm :: Pair < int8_t , int16_t > ; // Array of supporting points in flash FLASH_STORAGE ( Point supportingPoints [ 6 ]) = { { 30 , -200 }, { 50 , 0 }, { 90 , 50 }, { 150 , 2050 }, { 200 , 3000 }, { 220 , 20000 } }; // Create an interpolator object which reads the // supporting points from flash. modm :: interpolation :: Linear < Point , modm :: accessor :: Flash > value ( modm :: accessor :: asFlash ( supportingPoints ), 6 ); // ... int8_t a = 20 ; int16_t b = value . interpolate ( a );","title":"Linear Interpolation"},{"location":"reference/module/modm-math-interpolation/#lagrange-interpolation","text":"Example: using Point = modm :: Pair < float , float > ; // interpolate x^2 over the range of 1 <= x <= 3 Point points [ 3 ] = { { 1 , 1 }, { 2 , 4 }, { 3 , 9 } }; modm :: interpolation :: Lagrange < Point > value ( points , 3 ); // ... float output = value . interpolate ( 1.5f ); // output => 2.25; Warning Only floating points types are allowed as second type of modm::Pair , otherwise the calculation will deliver wrong results! See Wikipedia .","title":"Lagrange Interpolation"},{"location":"reference/module/modm-math-interpolation/#dependencies","text":"modm:math:interpolation modm_math_interpolation modm: math: interpolation modm_architecture_accessor modm: architecture: accessor modm_math_interpolation->modm_architecture_accessor modm_container modm: container modm_math_interpolation->modm_container modm_math_utils modm: math: utils modm_math_interpolation->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-matrix/","text":"Matrix Math \u00b6 lbuild module: modm:math:matrix Dependencies \u00b6 modm:math:matrix modm_math_matrix modm: math: matrix modm_io modm: io modm_math_matrix->modm_io modm_math_geometry modm: math: geometry modm_math_matrix->modm_math_geometry modm_utils modm: utils modm_math_matrix->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:matrix"},{"location":"reference/module/modm-math-matrix/#matrix-math","text":"lbuild module: modm:math:matrix","title":"Matrix Math"},{"location":"reference/module/modm-math-matrix/#dependencies","text":"modm:math:matrix modm_math_matrix modm: math: matrix modm_io modm: io modm_math_matrix->modm_io modm_math_geometry modm: math: geometry modm_math_matrix->modm_math_geometry modm_utils modm: utils modm_math_matrix->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-saturated/","text":"Saturated Arithmetics \u00b6 lbuild module: modm:math:saturated Dependencies \u00b6 modm:math:saturated modm_math_saturated modm: math: saturated modm_math_utils modm: math: utils modm_math_saturated->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:saturated"},{"location":"reference/module/modm-math-saturated/#saturated-arithmetics","text":"lbuild module: modm:math:saturated","title":"Saturated Arithmetics"},{"location":"reference/module/modm-math-saturated/#dependencies","text":"modm:math:saturated modm_math_saturated modm: math: saturated modm_math_utils modm: math: utils modm_math_saturated->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-units/","text":"SI Units \u00b6 lbuild module: modm:math:units modm uses a couple of common SI units for configuration of peripherals: frequency_t in Hertz: Hz , kHz and MHz . baudrate_t in Baud: Bd , kBd , MBd . bitrate_t in bit/s, bps . These are integral units, so 1 Hz/Bd/bps cannot be split further, and are cast directly to uint32_t type, so they can be used as a non-type template argument. Conversion can be done via constexpr functions from any numerical type: modm::Hz(T value) , modm::kHz(T value) , modm::MHz(T value) . modm::Bd(T value) , modm::kBd(T value) , modm::MBd(T value) . modm::bps(T value) , modm::kbps(T value) , modm::Mbps(T value) . In addition, user-defined literals are provided in the modm::literals namespace: using namespace modm :: literals ; frequency_t frequency = modm :: Mhz ( 10.5 ); frequency = 10.5 _MHz ; baudrate_t baudrate = 115.2 _kBd ; baudrate = modm :: kBd ( 115.2 ); bitrate_t bitrate = modm :: kbps ( 125 ); bitrate = 125 _kbps ; frequency = 4295 _MHz ; // OVERFLOW at 2^32 units! Integral Percentages \u00b6 Since float cannot be used as a non-type template argument, an integer type for providing tolerances in percent_t is available. Note that percent_t is implemented as an enum class, which prevents implicit conversions, since the base for this is not 1. You must therefore use the modm::pct(T value) or _pct constructors. using namespace modm :: literals ; percent_t tolerance = modm :: pct ( 10 ); tolerance = 10 _pct ; // convert back to float. *internal use only* float percent = modm :: pct2f ( tolerance ); This type is not guaranteed to hold more than 100 percent! Dependencies \u00b6 modm:math:units modm_math_units modm: math: units modm_architecture modm: architecture modm_math_units->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:units"},{"location":"reference/module/modm-math-units/#si-units","text":"lbuild module: modm:math:units modm uses a couple of common SI units for configuration of peripherals: frequency_t in Hertz: Hz , kHz and MHz . baudrate_t in Baud: Bd , kBd , MBd . bitrate_t in bit/s, bps . These are integral units, so 1 Hz/Bd/bps cannot be split further, and are cast directly to uint32_t type, so they can be used as a non-type template argument. Conversion can be done via constexpr functions from any numerical type: modm::Hz(T value) , modm::kHz(T value) , modm::MHz(T value) . modm::Bd(T value) , modm::kBd(T value) , modm::MBd(T value) . modm::bps(T value) , modm::kbps(T value) , modm::Mbps(T value) . In addition, user-defined literals are provided in the modm::literals namespace: using namespace modm :: literals ; frequency_t frequency = modm :: Mhz ( 10.5 ); frequency = 10.5 _MHz ; baudrate_t baudrate = 115.2 _kBd ; baudrate = modm :: kBd ( 115.2 ); bitrate_t bitrate = modm :: kbps ( 125 ); bitrate = 125 _kbps ; frequency = 4295 _MHz ; // OVERFLOW at 2^32 units!","title":"SI Units"},{"location":"reference/module/modm-math-units/#integral-percentages","text":"Since float cannot be used as a non-type template argument, an integer type for providing tolerances in percent_t is available. Note that percent_t is implemented as an enum class, which prevents implicit conversions, since the base for this is not 1. You must therefore use the modm::pct(T value) or _pct constructors. using namespace modm :: literals ; percent_t tolerance = modm :: pct ( 10 ); tolerance = 10 _pct ; // convert back to float. *internal use only* float percent = modm :: pct2f ( tolerance ); This type is not guaranteed to hold more than 100 percent!","title":"Integral Percentages"},{"location":"reference/module/modm-math-units/#dependencies","text":"modm:math:units modm_math_units modm: math: units modm_architecture modm: architecture modm_math_units->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math-utils/","text":"Utilities \u00b6 lbuild module: modm:math:utils Dependencies \u00b6 modm:math:utils modm_math_utils modm: math: utils modm_architecture modm: architecture modm_math_utils->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math:utils"},{"location":"reference/module/modm-math-utils/#utilities","text":"lbuild module: modm:math:utils","title":"Utilities"},{"location":"reference/module/modm-math-utils/#dependencies","text":"modm:math:utils modm_math_utils modm: math: utils modm_architecture modm: architecture modm_math_utils->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-math/","text":"Math \u00b6 lbuild module: modm:math Dependencies \u00b6 modm:math modm_math modm: math modm_math_units modm: math: units modm_math->modm_math_units @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":math"},{"location":"reference/module/modm-math/#math","text":"lbuild module: modm:math","title":"Math"},{"location":"reference/module/modm-math/#dependencies","text":"modm:math modm_math modm: math modm_math_units modm: math: units modm_math->modm_math_units @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-platform-1-wire-bitbang/","text":"Software 1-Wire \u00b6 lbuild module: modm:platform:1-wire.bitbang Dependencies \u00b6 modm:platform:1-wire.bitbang modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_architecture_1_wire modm: architecture: 1-wire modm_platform_1_wire_bitbang->modm_architecture_1_wire modm_architecture_delay modm: architecture: delay modm_platform_1_wire_bitbang->modm_architecture_delay modm_platform_gpio modm: platform: gpio modm_platform_1_wire_bitbang->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":platform:1-wire.bitbang"},{"location":"reference/module/modm-platform-1-wire-bitbang/#software-1-wire","text":"lbuild module: modm:platform:1-wire.bitbang","title":"Software 1-Wire"},{"location":"reference/module/modm-platform-1-wire-bitbang/#dependencies","text":"modm:platform:1-wire.bitbang modm_platform_1_wire_bitbang modm: platform: 1-wire.bitbang modm_architecture_1_wire modm: architecture: 1-wire modm_platform_1_wire_bitbang->modm_architecture_1_wire modm_architecture_delay modm: architecture: delay modm_platform_1_wire_bitbang->modm_architecture_delay modm_platform_gpio modm: platform: gpio modm_platform_1_wire_bitbang->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-platform-adc-avr-mega-tiny/","text":"Analog-to-Digital Converter (ADC) \u00b6 lbuild module: modm:platform:adc This module is only available for avr{mega,tiny}. Dependencies \u00b6 modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_interrupt modm: architecture: interrupt modm_platform_adc->modm_architecture_interrupt modm_math_algorithm modm: math: algorithm modm_platform_adc->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_utils modm: utils modm_platform_adc->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:adc (avr{mega,tiny})"},{"location":"reference/module/modm-platform-adc-avr-mega-tiny/#analog-to-digital-converter-adc","text":"lbuild module: modm:platform:adc This module is only available for avr{mega,tiny}.","title":"Analog-to-Digital Converter (ADC)"},{"location":"reference/module/modm-platform-adc-avr-mega-tiny/#dependencies","text":"modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_interrupt modm: architecture: interrupt modm_platform_adc->modm_architecture_interrupt modm_math_algorithm modm: math: algorithm modm_platform_adc->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_utils modm: utils modm_platform_adc->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-adc-stm32-f0-g0/","text":"Analog-to-Digital Converter (ADC) \u00b6 lbuild module: modm:platform:adc This module is only available for stm32{f0,g0}. Dependencies \u00b6 modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_delay modm: architecture: delay modm_platform_adc->modm_architecture_delay modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:adc (stm32{f0,g0})"},{"location":"reference/module/modm-platform-adc-stm32-f0-g0/#analog-to-digital-converter-adc","text":"lbuild module: modm:platform:adc This module is only available for stm32{f0,g0}.","title":"Analog-to-Digital Converter (ADC)"},{"location":"reference/module/modm-platform-adc-stm32-f0-g0/#dependencies","text":"modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_delay modm: architecture: delay modm_platform_adc->modm_architecture_delay modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-adc-stm32-f1-f2-f3-f4-f7-l1/","text":"Analog-to-Digital Converter (ADC) \u00b6 lbuild module: modm:platform:adc This module is only available for stm32{f1,f2,f3,f4,f7,l1}. Dependencies \u00b6 modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc modm_utils modm: utils modm_platform_adc->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:adc (stm32{f1,f2,f3,f4,f7,l1})"},{"location":"reference/module/modm-platform-adc-stm32-f1-f2-f3-f4-f7-l1/#analog-to-digital-converter-adc","text":"lbuild module: modm:platform:adc This module is only available for stm32{f1,f2,f3,f4,f7,l1}.","title":"Analog-to-Digital Converter (ADC)"},{"location":"reference/module/modm-platform-adc-stm32-f1-f2-f3-f4-f7-l1/#dependencies","text":"modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_adc modm: architecture: adc modm_platform_adc->modm_architecture_adc modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_adc->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc modm_utils modm: utils modm_platform_adc->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-adc-stm32-f3-g4-l4/","text":"Analog-to-Digital Converter (ADC) \u00b6 lbuild module: modm:platform:adc This module is only available for stm32{f3,g4,l4}. Dependencies \u00b6 modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_delay modm: architecture: delay modm_platform_adc->modm_architecture_delay modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:adc (stm32{f3,g4,l4})"},{"location":"reference/module/modm-platform-adc-stm32-f3-g4-l4/#analog-to-digital-converter-adc","text":"lbuild module: modm:platform:adc This module is only available for stm32{f3,g4,l4}.","title":"Analog-to-Digital Converter (ADC)"},{"location":"reference/module/modm-platform-adc-stm32-f3-g4-l4/#dependencies","text":"modm:platform:adc modm_platform_adc modm: platform: adc modm_architecture_delay modm: architecture: delay modm_platform_adc->modm_architecture_delay modm_architecture_register modm: architecture: register modm_platform_adc->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_adc->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_adc->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_adc->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-can-common/","text":"CAN Common \u00b6 lbuild module: modm:platform:can.common Dependencies \u00b6 modm:platform:can.common modm_platform_can_common modm: platform: can.common modm_architecture_clock modm: architecture: clock modm_platform_can_common->modm_architecture_clock @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":platform:can.common"},{"location":"reference/module/modm-platform-can-common/#can-common","text":"lbuild module: modm:platform:can.common","title":"CAN Common"},{"location":"reference/module/modm-platform-can-common/#dependencies","text":"modm:platform:can.common modm_platform_can_common modm: platform: can.common modm_architecture_clock modm: architecture: clock modm_platform_can_common->modm_architecture_clock @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/","text":"Controller Area Network (CAN) \u00b6 lbuild module: modm:platform:can This module is only available for stm32{f0,f1,f2,f3,f4,f7,l4}. Options \u00b6 buffer.rx \u00b6 This option is only available for stm32{f0,f1,f3}. Default: 32 Inputs: [1 .. 32 .. 65534] buffer.tx \u00b6 This option is only available for stm32{f0,f1,f3}. Default: 32 Inputs: [1 .. 32 .. 65534] Dependencies \u00b6 modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can->modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can->modm_cmsis_device modm_debug modm: debug modm_platform_can->modm_debug modm_platform_can_common modm: platform: can.common modm_platform_can->modm_platform_can_common modm_platform_gpio modm: platform: gpio modm_platform_can->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can->modm_platform_rcc modm_utils modm: utils modm_platform_can->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:can (stm32{f0,f1,f2,f3,f4,f7,l4})"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#controller-area-network-can","text":"lbuild module: modm:platform:can This module is only available for stm32{f0,f1,f2,f3,f4,f7,l4}.","title":"Controller Area Network (CAN)"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#bufferrx","text":"This option is only available for stm32{f0,f1,f3}. Default: 32 Inputs: [1 .. 32 .. 65534]","title":"buffer.rx"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#buffertx","text":"This option is only available for stm32{f0,f1,f3}. Default: 32 Inputs: [1 .. 32 .. 65534]","title":"buffer.tx"},{"location":"reference/module/modm-platform-can-stm32-f0-f1-f2-f3-f4-f7-l4/#dependencies","text":"modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can->modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can->modm_cmsis_device modm_debug modm: debug modm_platform_can->modm_debug modm_platform_can_common modm: platform: can.common modm_platform_can->modm_platform_can_common modm_platform_gpio modm: platform: gpio modm_platform_can->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can->modm_platform_rcc modm_utils modm: utils modm_platform_can->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-can-stm32g4/","text":"Controller Area Network with Flexible Data-Rate (FDCAN) \u00b6 lbuild module: modm:platform:can This module is only available for stm32g4. Dependencies \u00b6 modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can->modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can->modm_cmsis_device modm_debug modm: debug modm_platform_can->modm_debug modm_platform_can_common modm: platform: can.common modm_platform_can->modm_platform_can_common modm_platform_gpio modm: platform: gpio modm_platform_can->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can->modm_platform_rcc modm_utils modm: utils modm_platform_can->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:can (stm32g4)"},{"location":"reference/module/modm-platform-can-stm32g4/#controller-area-network-with-flexible-data-rate-fdcan","text":"lbuild module: modm:platform:can This module is only available for stm32g4.","title":"Controller Area Network with Flexible Data-Rate (FDCAN)"},{"location":"reference/module/modm-platform-can-stm32g4/#dependencies","text":"modm:platform:can modm_platform_can modm: platform: can modm_architecture_assert modm: architecture: assert modm_platform_can->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_platform_can->modm_architecture_atomic modm_architecture_can modm: architecture: can modm_platform_can->modm_architecture_can modm_architecture_clock modm: architecture: clock modm_platform_can->modm_architecture_clock modm_architecture_delay modm: architecture: delay modm_platform_can->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_can->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_can->modm_cmsis_device modm_debug modm: debug modm_platform_can->modm_debug modm_platform_can_common modm: platform: can.common modm_platform_can->modm_platform_can_common modm_platform_gpio modm: platform: gpio modm_platform_can->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_can->modm_platform_rcc modm_utils modm: utils modm_platform_can->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-canusb/","text":"CANUSB Driver \u00b6 lbuild module: modm:platform:canusb This module is only available for hosted{darwin,linux}. Dependencies \u00b6 modm:platform:canusb modm_platform_canusb modm: platform: canusb modm_architecture_can modm: architecture: can modm_platform_canusb->modm_architecture_can modm_debug modm: debug modm_platform_canusb->modm_debug modm_driver_lawicel modm: driver: lawicel modm_platform_canusb->modm_driver_lawicel modm_processing_timer modm: processing: timer modm_platform_canusb->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:canusb"},{"location":"reference/module/modm-platform-canusb/#canusb-driver","text":"lbuild module: modm:platform:canusb This module is only available for hosted{darwin,linux}.","title":"CANUSB Driver"},{"location":"reference/module/modm-platform-canusb/#dependencies","text":"modm:platform:canusb modm_platform_canusb modm: platform: canusb modm_architecture_can modm: architecture: can modm_platform_canusb->modm_architecture_can modm_debug modm: debug modm_platform_canusb->modm_debug modm_driver_lawicel modm: driver: lawicel modm_platform_canusb->modm_driver_lawicel modm_processing_timer modm: processing: timer modm_platform_canusb->modm_processing_timer @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-clock-avr/","text":"System Clock via Timer/Counter 0 \u00b6 lbuild module: modm:platform:clock The TC0 timer is used to provide a time point at milli- and microsecond resolution to implement the modm::Clock::now() and modm::PreciseClock::now() interfaces defined in the modm:architecture:clock module. For this, the timer is configured to trigger a 1ms interrupt to increment the millisecond counter. To compute the microsecond counter, the 8-bit timer counter is used to interpolate between milliseconds via a 16x16=16-bit multiplication and shift to avoid a division. This is very fast, however, the resolution of the modm::PreciseClock is limited to at best ~4us (1000us/8-bit) and at worst ~32us ((2MHz/64)/1000us). This module is only available for avr. Dependencies \u00b6 modm:platform:clock modm_platform_clock modm: platform: clock modm_architecture_atomic modm: architecture: atomic modm_platform_clock->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_clock->modm_architecture_clock @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:clock (avr)"},{"location":"reference/module/modm-platform-clock-avr/#system-clock-via-timercounter-0","text":"lbuild module: modm:platform:clock The TC0 timer is used to provide a time point at milli- and microsecond resolution to implement the modm::Clock::now() and modm::PreciseClock::now() interfaces defined in the modm:architecture:clock module. For this, the timer is configured to trigger a 1ms interrupt to increment the millisecond counter. To compute the microsecond counter, the 8-bit timer counter is used to interpolate between milliseconds via a 16x16=16-bit multiplication and shift to avoid a division. This is very fast, however, the resolution of the modm::PreciseClock is limited to at best ~4us (1000us/8-bit) and at worst ~32us ((2MHz/64)/1000us). This module is only available for avr.","title":"System Clock via Timer/Counter 0"},{"location":"reference/module/modm-platform-clock-avr/#dependencies","text":"modm:platform:clock modm_platform_clock modm: platform: clock modm_architecture_atomic modm: architecture: atomic modm_platform_clock->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_clock->modm_architecture_clock @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-clock-sam--stm32/","text":"System Clock via Cortex-M SysTick \u00b6 lbuild module: modm:platform:clock The SysTick timer is used to provide a time point at milli- and microsecond resolution to implement the modm::Clock::now() and modm::PreciseClock::now() interfaces defined in the modm:architecture:clock module. For this, the timer is configured to run at \u215bth HCLK frequency and the 24-bit counter is loaded for an interrupt every 250ms (on ARMv7-M) or every 1ms (ARMv6-M). The interrupt increments the 32-bit counters by 250ms and 250'000us (or 1ms and 1000us) respectively. Since this comes nowhere near the 1us resolution we want, the SysTick->VAL counter is used to interpolate the time between interrupts with this algorithm: uint32_t milli_time { 0 }; uint32_t micro_time { 0 }; void SysTick_Handler () { milli_time += 250 ; micro_time += 250'000 ; } modm :: { Precise } Clock :: now () { float cycles_per_ms = ( SystemClock :: Frequency / 8 ) / 1e3 ; float cycles_per_us = ( SystemClock :: Frequency / 8 ) / 1e6 ; uint32_t val = SysTick -> LOAD - SysTick -> VAL ; // SysTick->VAL counts down milliseconds = milli_time + val / cycles_per_ms ; microseconds = micro_time + val / cycles_per_us ; } The actual algorithm avoids the floating point division and is instead approximated with a 32x32=64-bit multiplication and a bit shift without loosing accuracy. This computation is very, very fast on ARMv7-M. However, since ARMv6-M only has a 32x32=32-bit multiplication, the interrupt runs at 1ms, thus eliminating the multiplication for the millisecond clock, and allowing to fit into a 32-bit multiplication for the microsecond clock. This module is only available for sam, stm32. Dependencies \u00b6 modm:platform:clock modm_platform_clock modm: platform: clock modm_architecture_atomic modm: architecture: atomic modm_platform_clock->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_clock->modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_clock->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_clock->modm_math_algorithm @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:clock (sam, stm32)"},{"location":"reference/module/modm-platform-clock-sam--stm32/#system-clock-via-cortex-m-systick","text":"lbuild module: modm:platform:clock The SysTick timer is used to provide a time point at milli- and microsecond resolution to implement the modm::Clock::now() and modm::PreciseClock::now() interfaces defined in the modm:architecture:clock module. For this, the timer is configured to run at \u215bth HCLK frequency and the 24-bit counter is loaded for an interrupt every 250ms (on ARMv7-M) or every 1ms (ARMv6-M). The interrupt increments the 32-bit counters by 250ms and 250'000us (or 1ms and 1000us) respectively. Since this comes nowhere near the 1us resolution we want, the SysTick->VAL counter is used to interpolate the time between interrupts with this algorithm: uint32_t milli_time { 0 }; uint32_t micro_time { 0 }; void SysTick_Handler () { milli_time += 250 ; micro_time += 250'000 ; } modm :: { Precise } Clock :: now () { float cycles_per_ms = ( SystemClock :: Frequency / 8 ) / 1e3 ; float cycles_per_us = ( SystemClock :: Frequency / 8 ) / 1e6 ; uint32_t val = SysTick -> LOAD - SysTick -> VAL ; // SysTick->VAL counts down milliseconds = milli_time + val / cycles_per_ms ; microseconds = micro_time + val / cycles_per_us ; } The actual algorithm avoids the floating point division and is instead approximated with a 32x32=64-bit multiplication and a bit shift without loosing accuracy. This computation is very, very fast on ARMv7-M. However, since ARMv6-M only has a 32x32=32-bit multiplication, the interrupt runs at 1ms, thus eliminating the multiplication for the millisecond clock, and allowing to fit into a 32-bit multiplication for the microsecond clock. This module is only available for sam, stm32.","title":"System Clock via Cortex-M SysTick"},{"location":"reference/module/modm-platform-clock-sam--stm32/#dependencies","text":"modm:platform:clock modm_platform_clock modm: platform: clock modm_architecture_atomic modm: architecture: atomic modm_platform_clock->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_clock->modm_architecture_clock modm_cmsis_device modm: cmsis: device modm_platform_clock->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_clock->modm_math_algorithm @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-comp/","text":"Comparator (COMP) \u00b6 lbuild module: modm:platform:comp This module is only available for stm32{f3,g4,l4}. Dependencies \u00b6 modm:platform:comp modm_platform_comp modm: platform: comp modm_cmsis_device modm: cmsis: device modm_platform_comp->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:comp"},{"location":"reference/module/modm-platform-comp/#comparator-comp","text":"lbuild module: modm:platform:comp This module is only available for stm32{f3,g4,l4}.","title":"Comparator (COMP)"},{"location":"reference/module/modm-platform-comp/#dependencies","text":"modm:platform:comp modm_platform_comp modm: platform: comp modm_cmsis_device modm: cmsis: device modm_platform_comp->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-core-avr/","text":"AVR Core \u00b6 lbuild module: modm:platform:core Implements the interfaces defined in the :architecture modules. Adds the -mmcu={target} compile flag and the F_CPU={core frequency} define. Fuses \u00b6 You can define the fuse values in your source code via the FUSES struct ELF section mechanism, they are automatically used by avrdude. For fuse values see the AVR Fuse Calculator . #include <avr/io.h> FUSES = { LFUSE_DEFAULT , // .low HFUSE_DEFAULT , // .high EFUSE_DEFAULT , // .extended }; Blocking Delay \u00b6 The delay functions as defined by modm:architecture:delay and called with a constant value are implemented directly via GCC's __builtin_avr_delay_cycles(ns / (1e9 / F_CPU)) . Constant delays are therefore fairly accurate. For delays with a dynamic time, the following limitations apply for nanoseconds: The input is limited to 16-bit nanoseconds, so ~65 microseconds. The minimum delay is between 5-10 cycles, so even at the fastest clock rate of 32MHz a delay below ~250ns is not possible. At 8MHz delays less than 1us are not possible. For longer delays, the 3-cycle _delay_loop_1(loops) is used and the number of loops should be calculated by dividing the input value by ns_per_loop = 3e9/F_CPU . However, division is prohibitively slow and thus very coarsly approximated by shifting the input: ns >> ceil(log_2(ns_per_loop)) . This is only accurate for 3e9/2^7 = 23.4MHz, 11.7MHz, 5.8MHz, etc. For all other clock speeds the error is bound by a factor of 2, so the delay is at most twice as long as expected. For micro- and milliseconds delays with dynamic time: Microseconds delay is implemented fairly accurately in 1us steps with a maximum time delay of 65ms for clocks larger than 6MHz, or . Millisecond delay is implemented fairly accurately in 1ms steps on 32-bits of input time. This module is only available for avr. Options \u00b6 f_cpu \u00b6 CPU clock frequency Default: None Inputs: [1 ... 32000000] Dependencies \u00b6 modm:platform:core modm_platform_core modm: platform: core modm_architecture_interrupt modm: architecture: interrupt modm_platform_core->modm_architecture_interrupt modm_stdc++ modm: stdc++ modm_platform_core->modm_stdc++ @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:core (avr)"},{"location":"reference/module/modm-platform-core-avr/#avr-core","text":"lbuild module: modm:platform:core Implements the interfaces defined in the :architecture modules. Adds the -mmcu={target} compile flag and the F_CPU={core frequency} define.","title":"AVR Core"},{"location":"reference/module/modm-platform-core-avr/#fuses","text":"You can define the fuse values in your source code via the FUSES struct ELF section mechanism, they are automatically used by avrdude. For fuse values see the AVR Fuse Calculator . #include <avr/io.h> FUSES = { LFUSE_DEFAULT , // .low HFUSE_DEFAULT , // .high EFUSE_DEFAULT , // .extended };","title":"Fuses"},{"location":"reference/module/modm-platform-core-avr/#blocking-delay","text":"The delay functions as defined by modm:architecture:delay and called with a constant value are implemented directly via GCC's __builtin_avr_delay_cycles(ns / (1e9 / F_CPU)) . Constant delays are therefore fairly accurate. For delays with a dynamic time, the following limitations apply for nanoseconds: The input is limited to 16-bit nanoseconds, so ~65 microseconds. The minimum delay is between 5-10 cycles, so even at the fastest clock rate of 32MHz a delay below ~250ns is not possible. At 8MHz delays less than 1us are not possible. For longer delays, the 3-cycle _delay_loop_1(loops) is used and the number of loops should be calculated by dividing the input value by ns_per_loop = 3e9/F_CPU . However, division is prohibitively slow and thus very coarsly approximated by shifting the input: ns >> ceil(log_2(ns_per_loop)) . This is only accurate for 3e9/2^7 = 23.4MHz, 11.7MHz, 5.8MHz, etc. For all other clock speeds the error is bound by a factor of 2, so the delay is at most twice as long as expected. For micro- and milliseconds delays with dynamic time: Microseconds delay is implemented fairly accurately in 1us steps with a maximum time delay of 65ms for clocks larger than 6MHz, or . Millisecond delay is implemented fairly accurately in 1ms steps on 32-bits of input time. This module is only available for avr.","title":"Blocking Delay"},{"location":"reference/module/modm-platform-core-avr/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-core-avr/#f_cpu","text":"CPU clock frequency Default: None Inputs: [1 ... 32000000]","title":"f_cpu"},{"location":"reference/module/modm-platform-core-avr/#dependencies","text":"modm:platform:core modm_platform_core modm: platform: core modm_architecture_interrupt modm: architecture: interrupt modm_platform_core->modm_architecture_interrupt modm_stdc++ modm: stdc++ modm_platform_core->modm_stdc++ @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-core-hosted/","text":"Hosted Core \u00b6 lbuild module: modm:platform:core This module is only available for hosted. Dependencies \u00b6 modm:platform:core modm_platform_core modm: platform: core modm_architecture_memory modm: architecture: memory modm_platform_core->modm_architecture_memory modm_debug modm: debug modm_platform_core->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:core (hosted)"},{"location":"reference/module/modm-platform-core-hosted/#hosted-core","text":"lbuild module: modm:platform:core This module is only available for hosted.","title":"Hosted Core"},{"location":"reference/module/modm-platform-core-hosted/#dependencies","text":"modm:platform:core modm_platform_core modm: platform: core modm_architecture_memory modm: architecture: memory modm_platform_core->modm_architecture_memory modm_debug modm: debug modm_platform_core->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-core-sam/","text":"Microchip SAM core module \u00b6 lbuild module: modm:platform:core Provides SAM specific linkerscripts and startup code. This module is only available for sam. Dependencies \u00b6 modm:platform:core modm_platform_core modm: platform: core modm_platform_cortex_m modm: platform: cortex-m modm_platform_core->modm_platform_cortex_m @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:core (sam)"},{"location":"reference/module/modm-platform-core-sam/#microchip-sam-core-module","text":"lbuild module: modm:platform:core Provides SAM specific linkerscripts and startup code. This module is only available for sam.","title":"Microchip SAM core module"},{"location":"reference/module/modm-platform-core-sam/#dependencies","text":"modm:platform:core modm_platform_core modm: platform: core modm_platform_cortex_m modm: platform: cortex-m modm_platform_core->modm_platform_cortex_m @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-core-stm32/","text":"STM32 core module \u00b6 lbuild module: modm:platform:core Provides STM32 specific linkerscripts and startup code. This module is only available for stm32. Dependencies \u00b6 modm:platform:core modm_platform_core modm: platform: core modm_platform_cortex_m modm: platform: cortex-m modm_platform_core->modm_platform_cortex_m @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:core (stm32)"},{"location":"reference/module/modm-platform-core-stm32/#stm32-core-module","text":"lbuild module: modm:platform:core Provides STM32 specific linkerscripts and startup code. This module is only available for stm32.","title":"STM32 core module"},{"location":"reference/module/modm-platform-core-stm32/#dependencies","text":"modm:platform:core modm_platform_core modm: platform: core modm_platform_cortex_m modm: platform: cortex-m modm_platform_core->modm_platform_cortex_m @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-cortex-m/","text":"ARM Cortex-M Core \u00b6 lbuild module: modm:platform:cortex-m This module generates the startup code, vector table, linkerscript as well as initialize the heap, deal with assertions, provide blocking delay functions, atomic and unaligned access and the GNU build ID. Since this is only initializes the generic ARM Cortex-M parts, it delegates device-specific initialization to the modm:platform:core module. Please depend on that module directly instead of this one. Startup \u00b6 After reset, the ARM Cortex-M hardware jumps to the Reset_Handler() , which is implemented as follows: The main stack pointer (MSP) is initialized by hardware. Call __modm_initialize_platform() to initialize the device hardware. Copy data from internal flash to internal RAM. Zero sections in internal RAM. Initialize ARM Cortex-M core: enable FPU and relocate vector table. Execute shared hardware initialization functions. Copy data from internal flash to external RAM. Zero sections in external RAM. Initialize heap via __modm_initialize_memory() (implemented by the modm:platform:heap module). Call static constructors. Call main() application entry point. If main() returns, assert on main.exit (only in debug profile). Reboot if assertion returns. Device Initialization \u00b6 The __modm_initialize_platform() function is called directly after reset, and its purpose is to initialize the device specific hardware, such as enable internal memories or disable the hardware watchdog timer. It's important to understand that because the .data section has not yet been copied and the .bss section has not yet been zeroed, there exists no valid C environment yet in this function context ! This means you cannot use any global variables, not even \"local\" static ones defined in your function, and depending on your hardware you may not even access read-only data ( const variables, global OR local). In addition, if your linkerscript places the main stack pointer into a memory that is disabled on reset, you cannot even access the stack until you've enabled its backing memory. The Reset_Handler therefore calls this function in Assembly without accessing the stack. It is strongly recommended to only read/write registers in this function, and perhaps even write this function in Assembly if deemed necessary. Do not initialize the device clock, leave the default clock undisturbed ! Additional Initialization \u00b6 A few modules need to initialize additional hardware during booting. For example: your device has external memories connected that you want to use for the heap. You can create a function that configures the peripherals for these external memories and place a pointer to this function into a special linker section and the startup script will then call this function before heap initialization. Since the hardware init functions are called after internal data initialization, you have a valid C environment and thus can access the device normally, but since the calls happen before external data and heap initialization you cannot use the heap in these functions ! You can give a relative global order to your init functions. Ordered init functions are called first, then unordered init functions are called in any order. Please note that order numbers 0 - 999 are reserved for use by modm or other libraries! Unique init function names Init function names need to be globally unique for linking. Unfortunately there is no simple way of stringifying C++ functions, so you have to provide a name manually for now. void init_external_sdram () { // configure the hardware here } // Startup script calls this function in any order, *after* prioritized functions! MODM_HARDWARE_INIT ( init_external_sdram ); // If you need to pass a C++ function, you need to declare MODM_HARDWARE_INIT_NAME ( init_function_name , namespace :: init_function ); // If you need to initialize in a certain order use numbers >= 1000 MODM_HARDWARE_INIT_ORDER ( init_before_sdram1 , 1000 ); // called after init_before_sdram1, since it has a higher order number MODM_HARDWARE_INIT_NAME_ORDER ( init_before_sdram2 , namespace :: function , 1001 ); Interrupt Vector Table \u00b6 The Cortex-M vector table (VTOR) is target-specific and generated using data from modm-devices. The main stack pointer is allocated according to the linkerscript and the Reset_Handler is defined by the startup script. All handlers are weakly aliased to Undefined_Handler , which is called if an IRQ is enabled, but no handler is defined for it. This default handler determines the currectly active IRQ, sets its priority to the lowest level, and disables the IRQ from firing again and then asserts on nvic.undef with the (signed) IRQ number as context. The lowering of the priority is necessary, since the assertion handlers (see modm:architecture:assert ) are called from within this active IRQ and its priority should not prevent logging functionality (which might require a UART interrupt to flush data out) from working correctly. Linkerscript \u00b6 This module provides building blocks for GNU ld linkerscripts in the form of Jinja macros that the modm:platform:core module assembles into a linkerscript, depending on the memory architecture of the target chosen. The following macros are available: copyright() : Copyright notice. prefix() : Contains MEMORY sections, output format and entry symbol and stack size definitions section_vector_rom(memory) : place the read-only vector table at the beginning of ROM memory . section_vector_ram(memory) : place the volatile vector table into RAM memory . You must satisfy alignment requirements externally. section(memory, name) : place section .{name} into memory . section_stack(memory, start=None) : place the main stack into memory after moving the location counter to start . section_heap(memory, name, section=None) : Fill up remaining space in memory with heap section .{name} and add to section . section_rom(memory) : place all read-only sections ( .text , .rodata etc) into memory . section_ram(memory, rom) : place all volatile sections ( .data , .bss etc) into memory and load from rom . section_table_zero(memory, sections=[]) : place the zeroing table ( .bss plus sections ) into memory . section_table_copy(memory, sections=[]) : place the copying table ( .data , .fastdata , .vector_ram plus sections ) into memory . section_table_extern(memory) : place the zeroing and copying tables for external memories into memory . section_table_heap(memory, sections) : place heap tables containing sections into memory . section_rom_start(memory) : place at ROM start. section_rom_end(memory) : place at ROM end. section_debug() : place debug sections at the very end. Please consult the modm:platform:core documentation for the target-specific arrangement of these section macros and for potential limitations that the target's memory architecture poses. Section .fastdata \u00b6 For devices without data cache place the .fastdata section into the fastest RAM. Please note that the .fastdata section may need to be placed into RAM that is only accessable to the Cortex-M core, which can cause issues with DMA access. However, the .fastdata sections is not required to be DMA-able, and in such a case the developer needs to place the data into the generic .data section or choose a device with a DMA-able fast RAM. Section .fastcode \u00b6 For devices without an instruction cache or without a fast RAM connected to the I-bus, place .fastcode into ROM, which usually has a device-specific ROM cache. Please note that using a device with a dedicated instruction cache RAM yields much more predictable performance than executing from ROM, even with a ROM cache. From the Cortex-M3 Technical Reference Manual: 14.5 System Interface: The system interface is a 32-bit AHB-Lite bus. Instruction and vector fetches, and data and debug accesses to the System memory space, 0x20000000 - 0xDFFFFFFF, 0xE0100000 - 0xFFFFFFFF, are performed over this bus. 14.5.6 Pipelined instruction fetches: To provide a clean timing interface on the System bus, instruction and vector fetch requests to this bus are registered. This results in an additional cycle of latency because instructions fetched from the System bus take two cycles. This also means that back-to-back instruction fetches from the System bus are not possible. Note: Instruction fetch requests to the ICode bus are not registered. Performance critical code must run from the ICode interface. Adding Sections \u00b6 The default linkerscripts only describe the internal memory, however, they can be extended for external memories using the linkerscript.* collectors of this module. For example, to add an external 16MB SDRAM to your device and place a static data section there that is copied from flash and use the remainder for heap access, these steps need to be performed: Add the external SDRAM to the linkerscript's MEMORY statements in the project.xml configuration: <library> <collectors> <collect name= \"modm:platform:cortex-m:linkerscript.memory\" > SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M </collect> <collectors> </library> You can also declare this as Python code in a lbuild module.lb file (useful for board support packages modules, see modm:board ): env . collect ( \":platform:cortex-m:linkerscript.memory\" , \"SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M\" ) Add a partition of the new memory to the linkerscripts SECTION statements. Since collectors order is only preserved locally, make sure to add the sections that depend on this order in one value . Here the previous value of the SDRAM location counter is required to \"fill up\" the remaining memory with the external heap section: linkerscript_sections = \"\"\" .sdramdata : { __sdramdata_load = LOADADDR (.sdramdata); /* address in FLASH */ __sdramdata_start = .; /* address in RAM */ KEEP(*(.sdramdata)) . = ALIGN(4); __sdramdata_end = .; } >SDRAM AT >FLASH .heap_extern (NOLOAD) : ALIGN(4) { __heap_extern_start = .; . = ORIGIN(SDRAM) + LENGTH(SDRAM); __heap_extern_end = .; } >SDRAM \"\"\" env . collect ( \":platform:cortex-m:linkerscript.sections\" , linkerscript_sections ) Next, add the sections that need to be copied from ROM to RAM, here the contents of the .sdramdata section is stored in the internal FLASH memory and needs to be copied into SDRAM during the startup: linkerscript_copy = \"\"\" LONG(__sdramdata_load) LONG(__sdramdata_start) LONG(__sdramdata_end) \"\"\" env . collect ( \":platform:cortex-m:linkerscript.table_extern.copy\" , linkerscript_copy ) And finally, to register the remaining memory in SDRAM with the allocator, add the memory range to the heap table. Remember to use the correct memory traits for this memory, see modm:architecture:memory for the trait definitions: linkerscript_heap = \"\"\" LONG(0x801f) LONG(__heap_extern_start) LONG(__heap_extern_end) \"\"\" env . collect ( \":platform:cortex-m:linkerscript.table_extern.heap\" , linkerscript_heap ) Linkerscript collectors are plain text The collectors here only strip the leading/trailing whitespace and newlines and paste the result as is into the linkerscripts. No input validation is performed, so if you receive linker errors with your additions, please check the GNU LD documentation first. Blocking Delay \u00b6 The delay functions as defined by modm:architecture:delay are implemented via software loop or hardware cycle counter (via DWT->CYCCNT, not available on ARMv6-M devices) and have the following limitations: nanosecond delay is implemented as a tight loop with better than 100ns resolution and accuracy at any CPU frequency. microsecond delay has a maximum delay of 10 seconds. millisecond delay is implemented via modm::delay_us(ms * 1000) , thus also has a maximum delay of 10 seconds. Compiler Options \u00b6 This module adds these architecture specific compiler options : -mcpu=cortex-m{type} : the target to compile for. -mthumb : only Thumb2 instruction set is supported. -mfloat-abi={soft, softfp, hard} : the FPU ABI: hard is fastest. -mfpu=fpv{4, 5}-{sp}-d16 : single or double precision FPU. -fsingle-precision-constant : if SP-FPU, treat all FP constants as SP. -Wdouble-promotion : if SP-FPU, warn if FPs are promoted to doubles. In addition, these linker options are added: -nostartfiles : modm implements its own startup script. -wrap,_{calloc, malloc, realloc, free}_r : reimplemented Newlib with our own allocator. This module is only available for sam, stm32. Options \u00b6 float-abi \u00b6 Floating point ABI This option is only available for stm32{f3,f4,f7,g4,l4}. Default: hard Inputs: [hard, soft, softfp] linkerscript.flash_offset \u00b6 Offset of FLASH Section Origin Add an offset to the default start address of the flash memory. This might be required for bootloaders located there. Vector Table Relocation Not all offsets are compatible with the vector table relocation. Default: 0 Inputs: [0 ... 0x10000] sam, stm32{f0,f1,f3,f4,f7,g0,l0,l1,l4} Inputs: [0 ... 0x100000] stm32{f4,f7,l4} Inputs: [0 ... 0x180000] stm32f4 Inputs: [0 ... 0x2000] stm32l0 Inputs: [0 ... 0x20000] sam, stm32{f0,f1,f2,f3,f4,g0,g4,l0,l4} Inputs: [0 ... 0x200000] stm32{f4,f7,l4} Inputs: [0 ... 0x30000] stm32l0 Inputs: [0 ... 0x4000] stm32{f0,f1,f3,g0,l0} Inputs: [0 ... 0x40000] sam, stm32{f0,f1,f2,f3,f4,f7,g4,l1,l4} Inputs: [0 ... 0x60000] stm32{f3,l1} Inputs: [0 ... 0x8000] sam, stm32{f0,f3,g0,g4,l0,l1} Inputs: [0 ... 0x80000] stm32{f2,f3,f4,f7,g4,l1,l4} linkerscript.override \u00b6 Path to project provided linkerscript Default: [] Inputs: [Path] main_stack_size \u00b6 Minimum size of the application main stack The ARM Cortex-M uses a descending stack mechanism which is placed so that it grows towards the beginning of RAM. In case of a stack overflow the hardware then attempts to stack into invalid memory which triggers a HardFault. A stack overflow will therefore never overwrite any static or heap memory and this protection works without the MPU and therefore also on ARM Cortex-M0 devices. If the vector table is relocated into RAM, the start address needs to be aligned to the next highest power-of-two word depending on the total number of device interrupts. On devices where the table is relocated into the same memory as the main stack, an alignment buffer up to 1kB is added to the main stack. | ... | |---------------------------------| | Interrupt Vectors (in RAM) | | (if re-mapped) | <-- vector table origin |---------------------------------| <-- main stack top | Main Stack | | (grows downwards) | | | | | v | |---------------------------------| | Alignment buffer for vectors | | (overwritten by main stack!) | '---------------------------------' <-- RAM origin Default: 3*1024 (3072) Inputs: [256 .. 3*1024 .. 65536] vector_table_location \u00b6 Vector table location in ROM or RAM The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions: void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector) uint32_t NVIC_GetVector(IRQn_Type IRQn) For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory. By default, the fastest option is chosen depending on the target memory architecture. This does not always mean the table is copied into RAM, and therefore may not be modifiable with this option! From the ARM Cortex-M4 Technical Reference Manual on exception handling: Processor state is automatically stored to the stack on an exception, and automatically restored from the stack at the end of the Interrupt Service Routine. The vector is fetched in parallel to the state saving, enabling efficient interrupt entry. On Interrupt Latency Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port. This option is only available for stm32{f1,f2,f3,f4,f7,g4,l1,l4}. Default: ram stm32{f3,f7,g4,l4} Default: rom stm32{f1,f2,f3,f4,l1,l4} Inputs: [ram, rom] Collectors \u00b6 linkerscript.memory \u00b6 Additions to the linkerscript's 'MEMORY' Inputs: [String] linkerscript.process_stack_size \u00b6 Maximum required size of the process stack Inputs: [0 ... +Inf] linkerscript.sections \u00b6 Additions to the linkerscript's 'SECTIONS' Inputs: [String] linkerscript.table_extern.copy \u00b6 Additions to the linkerscript's '.table.copy.extern' section Inputs: [String] linkerscript.table_extern.heap \u00b6 Additions to the linkerscript's '.table.heap' section Inputs: [String] linkerscript.table_extern.zero \u00b6 Additions to the linkerscript's '.table.zero.extern' section Inputs: [String] Queries \u00b6 linkerscript \u00b6 Computes linkerscript properties (* post-build only ): process_stack_size : largest requested process stack size by any module vector_table_location : ram or rom Stripped and newline-joined collector values of: linkerscript_memory linkerscript_sections linkerscript_extern_zero linkerscript_extern_copy linkerscript_extern_heap Additional memory properties: memories : unfiltered memory regions regions : memory region names ram_origin : Lowest SRAM origin address ram_origin : Total size of all SRAM regions cont_ram : largest continuous internal SRAM section :returns: dictionary of linkerscript properties vector_table \u00b6 Computes vector table properties: vector_table : [position] = Full vector name (ie. with _Handler or _IRQHandler suffix) vector_table_location : rom or ram highest_irq : highest IRQ number + 1 core : cortex-m{0,3,4,7}{,+,f,fd} The system vectors start at -16, so you must add 16 to highest_irq to get the total number of vectors in the table! :returns: a dictionary of vector table properties Dependencies \u00b6 modm:platform:cortex-m modm_platform_cortex_m modm: platform: cortex-m modm_architecture_interrupt modm: architecture: interrupt modm_platform_cortex_m->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_cortex_m->modm_cmsis_device modm_stdc++ modm: stdc++ modm_platform_cortex_m->modm_stdc++ @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:cortex-m"},{"location":"reference/module/modm-platform-cortex-m/#arm-cortex-m-core","text":"lbuild module: modm:platform:cortex-m This module generates the startup code, vector table, linkerscript as well as initialize the heap, deal with assertions, provide blocking delay functions, atomic and unaligned access and the GNU build ID. Since this is only initializes the generic ARM Cortex-M parts, it delegates device-specific initialization to the modm:platform:core module. Please depend on that module directly instead of this one.","title":"ARM Cortex-M Core"},{"location":"reference/module/modm-platform-cortex-m/#startup","text":"After reset, the ARM Cortex-M hardware jumps to the Reset_Handler() , which is implemented as follows: The main stack pointer (MSP) is initialized by hardware. Call __modm_initialize_platform() to initialize the device hardware. Copy data from internal flash to internal RAM. Zero sections in internal RAM. Initialize ARM Cortex-M core: enable FPU and relocate vector table. Execute shared hardware initialization functions. Copy data from internal flash to external RAM. Zero sections in external RAM. Initialize heap via __modm_initialize_memory() (implemented by the modm:platform:heap module). Call static constructors. Call main() application entry point. If main() returns, assert on main.exit (only in debug profile). Reboot if assertion returns.","title":"Startup"},{"location":"reference/module/modm-platform-cortex-m/#device-initialization","text":"The __modm_initialize_platform() function is called directly after reset, and its purpose is to initialize the device specific hardware, such as enable internal memories or disable the hardware watchdog timer. It's important to understand that because the .data section has not yet been copied and the .bss section has not yet been zeroed, there exists no valid C environment yet in this function context ! This means you cannot use any global variables, not even \"local\" static ones defined in your function, and depending on your hardware you may not even access read-only data ( const variables, global OR local). In addition, if your linkerscript places the main stack pointer into a memory that is disabled on reset, you cannot even access the stack until you've enabled its backing memory. The Reset_Handler therefore calls this function in Assembly without accessing the stack. It is strongly recommended to only read/write registers in this function, and perhaps even write this function in Assembly if deemed necessary. Do not initialize the device clock, leave the default clock undisturbed !","title":"Device Initialization"},{"location":"reference/module/modm-platform-cortex-m/#additional-initialization","text":"A few modules need to initialize additional hardware during booting. For example: your device has external memories connected that you want to use for the heap. You can create a function that configures the peripherals for these external memories and place a pointer to this function into a special linker section and the startup script will then call this function before heap initialization. Since the hardware init functions are called after internal data initialization, you have a valid C environment and thus can access the device normally, but since the calls happen before external data and heap initialization you cannot use the heap in these functions ! You can give a relative global order to your init functions. Ordered init functions are called first, then unordered init functions are called in any order. Please note that order numbers 0 - 999 are reserved for use by modm or other libraries! Unique init function names Init function names need to be globally unique for linking. Unfortunately there is no simple way of stringifying C++ functions, so you have to provide a name manually for now. void init_external_sdram () { // configure the hardware here } // Startup script calls this function in any order, *after* prioritized functions! MODM_HARDWARE_INIT ( init_external_sdram ); // If you need to pass a C++ function, you need to declare MODM_HARDWARE_INIT_NAME ( init_function_name , namespace :: init_function ); // If you need to initialize in a certain order use numbers >= 1000 MODM_HARDWARE_INIT_ORDER ( init_before_sdram1 , 1000 ); // called after init_before_sdram1, since it has a higher order number MODM_HARDWARE_INIT_NAME_ORDER ( init_before_sdram2 , namespace :: function , 1001 );","title":"Additional Initialization"},{"location":"reference/module/modm-platform-cortex-m/#interrupt-vector-table","text":"The Cortex-M vector table (VTOR) is target-specific and generated using data from modm-devices. The main stack pointer is allocated according to the linkerscript and the Reset_Handler is defined by the startup script. All handlers are weakly aliased to Undefined_Handler , which is called if an IRQ is enabled, but no handler is defined for it. This default handler determines the currectly active IRQ, sets its priority to the lowest level, and disables the IRQ from firing again and then asserts on nvic.undef with the (signed) IRQ number as context. The lowering of the priority is necessary, since the assertion handlers (see modm:architecture:assert ) are called from within this active IRQ and its priority should not prevent logging functionality (which might require a UART interrupt to flush data out) from working correctly.","title":"Interrupt Vector Table"},{"location":"reference/module/modm-platform-cortex-m/#linkerscript","text":"This module provides building blocks for GNU ld linkerscripts in the form of Jinja macros that the modm:platform:core module assembles into a linkerscript, depending on the memory architecture of the target chosen. The following macros are available: copyright() : Copyright notice. prefix() : Contains MEMORY sections, output format and entry symbol and stack size definitions section_vector_rom(memory) : place the read-only vector table at the beginning of ROM memory . section_vector_ram(memory) : place the volatile vector table into RAM memory . You must satisfy alignment requirements externally. section(memory, name) : place section .{name} into memory . section_stack(memory, start=None) : place the main stack into memory after moving the location counter to start . section_heap(memory, name, section=None) : Fill up remaining space in memory with heap section .{name} and add to section . section_rom(memory) : place all read-only sections ( .text , .rodata etc) into memory . section_ram(memory, rom) : place all volatile sections ( .data , .bss etc) into memory and load from rom . section_table_zero(memory, sections=[]) : place the zeroing table ( .bss plus sections ) into memory . section_table_copy(memory, sections=[]) : place the copying table ( .data , .fastdata , .vector_ram plus sections ) into memory . section_table_extern(memory) : place the zeroing and copying tables for external memories into memory . section_table_heap(memory, sections) : place heap tables containing sections into memory . section_rom_start(memory) : place at ROM start. section_rom_end(memory) : place at ROM end. section_debug() : place debug sections at the very end. Please consult the modm:platform:core documentation for the target-specific arrangement of these section macros and for potential limitations that the target's memory architecture poses.","title":"Linkerscript"},{"location":"reference/module/modm-platform-cortex-m/#section-fastdata","text":"For devices without data cache place the .fastdata section into the fastest RAM. Please note that the .fastdata section may need to be placed into RAM that is only accessable to the Cortex-M core, which can cause issues with DMA access. However, the .fastdata sections is not required to be DMA-able, and in such a case the developer needs to place the data into the generic .data section or choose a device with a DMA-able fast RAM.","title":"Section .fastdata"},{"location":"reference/module/modm-platform-cortex-m/#section-fastcode","text":"For devices without an instruction cache or without a fast RAM connected to the I-bus, place .fastcode into ROM, which usually has a device-specific ROM cache. Please note that using a device with a dedicated instruction cache RAM yields much more predictable performance than executing from ROM, even with a ROM cache. From the Cortex-M3 Technical Reference Manual: 14.5 System Interface: The system interface is a 32-bit AHB-Lite bus. Instruction and vector fetches, and data and debug accesses to the System memory space, 0x20000000 - 0xDFFFFFFF, 0xE0100000 - 0xFFFFFFFF, are performed over this bus. 14.5.6 Pipelined instruction fetches: To provide a clean timing interface on the System bus, instruction and vector fetch requests to this bus are registered. This results in an additional cycle of latency because instructions fetched from the System bus take two cycles. This also means that back-to-back instruction fetches from the System bus are not possible. Note: Instruction fetch requests to the ICode bus are not registered. Performance critical code must run from the ICode interface.","title":"Section .fastcode"},{"location":"reference/module/modm-platform-cortex-m/#adding-sections","text":"The default linkerscripts only describe the internal memory, however, they can be extended for external memories using the linkerscript.* collectors of this module. For example, to add an external 16MB SDRAM to your device and place a static data section there that is copied from flash and use the remainder for heap access, these steps need to be performed: Add the external SDRAM to the linkerscript's MEMORY statements in the project.xml configuration: <library> <collectors> <collect name= \"modm:platform:cortex-m:linkerscript.memory\" > SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M </collect> <collectors> </library> You can also declare this as Python code in a lbuild module.lb file (useful for board support packages modules, see modm:board ): env . collect ( \":platform:cortex-m:linkerscript.memory\" , \"SDRAM (rwx) : ORIGIN = 0xC0000000, LENGTH = 16M\" ) Add a partition of the new memory to the linkerscripts SECTION statements. Since collectors order is only preserved locally, make sure to add the sections that depend on this order in one value . Here the previous value of the SDRAM location counter is required to \"fill up\" the remaining memory with the external heap section: linkerscript_sections = \"\"\" .sdramdata : { __sdramdata_load = LOADADDR (.sdramdata); /* address in FLASH */ __sdramdata_start = .; /* address in RAM */ KEEP(*(.sdramdata)) . = ALIGN(4); __sdramdata_end = .; } >SDRAM AT >FLASH .heap_extern (NOLOAD) : ALIGN(4) { __heap_extern_start = .; . = ORIGIN(SDRAM) + LENGTH(SDRAM); __heap_extern_end = .; } >SDRAM \"\"\" env . collect ( \":platform:cortex-m:linkerscript.sections\" , linkerscript_sections ) Next, add the sections that need to be copied from ROM to RAM, here the contents of the .sdramdata section is stored in the internal FLASH memory and needs to be copied into SDRAM during the startup: linkerscript_copy = \"\"\" LONG(__sdramdata_load) LONG(__sdramdata_start) LONG(__sdramdata_end) \"\"\" env . collect ( \":platform:cortex-m:linkerscript.table_extern.copy\" , linkerscript_copy ) And finally, to register the remaining memory in SDRAM with the allocator, add the memory range to the heap table. Remember to use the correct memory traits for this memory, see modm:architecture:memory for the trait definitions: linkerscript_heap = \"\"\" LONG(0x801f) LONG(__heap_extern_start) LONG(__heap_extern_end) \"\"\" env . collect ( \":platform:cortex-m:linkerscript.table_extern.heap\" , linkerscript_heap ) Linkerscript collectors are plain text The collectors here only strip the leading/trailing whitespace and newlines and paste the result as is into the linkerscripts. No input validation is performed, so if you receive linker errors with your additions, please check the GNU LD documentation first.","title":"Adding Sections"},{"location":"reference/module/modm-platform-cortex-m/#blocking-delay","text":"The delay functions as defined by modm:architecture:delay are implemented via software loop or hardware cycle counter (via DWT->CYCCNT, not available on ARMv6-M devices) and have the following limitations: nanosecond delay is implemented as a tight loop with better than 100ns resolution and accuracy at any CPU frequency. microsecond delay has a maximum delay of 10 seconds. millisecond delay is implemented via modm::delay_us(ms * 1000) , thus also has a maximum delay of 10 seconds.","title":"Blocking Delay"},{"location":"reference/module/modm-platform-cortex-m/#compiler-options","text":"This module adds these architecture specific compiler options : -mcpu=cortex-m{type} : the target to compile for. -mthumb : only Thumb2 instruction set is supported. -mfloat-abi={soft, softfp, hard} : the FPU ABI: hard is fastest. -mfpu=fpv{4, 5}-{sp}-d16 : single or double precision FPU. -fsingle-precision-constant : if SP-FPU, treat all FP constants as SP. -Wdouble-promotion : if SP-FPU, warn if FPs are promoted to doubles. In addition, these linker options are added: -nostartfiles : modm implements its own startup script. -wrap,_{calloc, malloc, realloc, free}_r : reimplemented Newlib with our own allocator. This module is only available for sam, stm32.","title":"Compiler Options"},{"location":"reference/module/modm-platform-cortex-m/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-cortex-m/#float-abi","text":"Floating point ABI This option is only available for stm32{f3,f4,f7,g4,l4}. Default: hard Inputs: [hard, soft, softfp]","title":"float-abi"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptflash_offset","text":"Offset of FLASH Section Origin Add an offset to the default start address of the flash memory. This might be required for bootloaders located there. Vector Table Relocation Not all offsets are compatible with the vector table relocation. Default: 0 Inputs: [0 ... 0x10000] sam, stm32{f0,f1,f3,f4,f7,g0,l0,l1,l4} Inputs: [0 ... 0x100000] stm32{f4,f7,l4} Inputs: [0 ... 0x180000] stm32f4 Inputs: [0 ... 0x2000] stm32l0 Inputs: [0 ... 0x20000] sam, stm32{f0,f1,f2,f3,f4,g0,g4,l0,l4} Inputs: [0 ... 0x200000] stm32{f4,f7,l4} Inputs: [0 ... 0x30000] stm32l0 Inputs: [0 ... 0x4000] stm32{f0,f1,f3,g0,l0} Inputs: [0 ... 0x40000] sam, stm32{f0,f1,f2,f3,f4,f7,g4,l1,l4} Inputs: [0 ... 0x60000] stm32{f3,l1} Inputs: [0 ... 0x8000] sam, stm32{f0,f3,g0,g4,l0,l1} Inputs: [0 ... 0x80000] stm32{f2,f3,f4,f7,g4,l1,l4}","title":"linkerscript.flash_offset"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptoverride","text":"Path to project provided linkerscript Default: [] Inputs: [Path]","title":"linkerscript.override"},{"location":"reference/module/modm-platform-cortex-m/#main_stack_size","text":"Minimum size of the application main stack The ARM Cortex-M uses a descending stack mechanism which is placed so that it grows towards the beginning of RAM. In case of a stack overflow the hardware then attempts to stack into invalid memory which triggers a HardFault. A stack overflow will therefore never overwrite any static or heap memory and this protection works without the MPU and therefore also on ARM Cortex-M0 devices. If the vector table is relocated into RAM, the start address needs to be aligned to the next highest power-of-two word depending on the total number of device interrupts. On devices where the table is relocated into the same memory as the main stack, an alignment buffer up to 1kB is added to the main stack. | ... | |---------------------------------| | Interrupt Vectors (in RAM) | | (if re-mapped) | <-- vector table origin |---------------------------------| <-- main stack top | Main Stack | | (grows downwards) | | | | | v | |---------------------------------| | Alignment buffer for vectors | | (overwritten by main stack!) | '---------------------------------' <-- RAM origin Default: 3*1024 (3072) Inputs: [256 .. 3*1024 .. 65536]","title":"main_stack_size"},{"location":"reference/module/modm-platform-cortex-m/#vector_table_location","text":"Vector table location in ROM or RAM The vector table is always stored in ROM and copied to RAM by the startup script if required. You can modify the RAM vector table using the CMSIS NVIC functions: void NVIC_SetVector(IRQn_Type IRQn, uint32_t vector) uint32_t NVIC_GetVector(IRQn_Type IRQn) For applications that do not modify the vector table at runtime, relocation to RAM is not necessary and can save a few hundred bytes of static memory. By default, the fastest option is chosen depending on the target memory architecture. This does not always mean the table is copied into RAM, and therefore may not be modifiable with this option! From the ARM Cortex-M4 Technical Reference Manual on exception handling: Processor state is automatically stored to the stack on an exception, and automatically restored from the stack at the end of the Interrupt Service Routine. The vector is fetched in parallel to the state saving, enabling efficient interrupt entry. On Interrupt Latency Placing main stack and vector table into the same memory can significantly slow down interrupt latency, since both I-Code and D-Code memory interface need to fetch from the same access port. This option is only available for stm32{f1,f2,f3,f4,f7,g4,l1,l4}. Default: ram stm32{f3,f7,g4,l4} Default: rom stm32{f1,f2,f3,f4,l1,l4} Inputs: [ram, rom]","title":"vector_table_location"},{"location":"reference/module/modm-platform-cortex-m/#collectors","text":"","title":"Collectors"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptmemory","text":"Additions to the linkerscript's 'MEMORY' Inputs: [String]","title":"linkerscript.memory"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptprocess_stack_size","text":"Maximum required size of the process stack Inputs: [0 ... +Inf]","title":"linkerscript.process_stack_size"},{"location":"reference/module/modm-platform-cortex-m/#linkerscriptsections","text":"Additions to the linkerscript's 'SECTIONS' Inputs: [String]","title":"linkerscript.sections"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externcopy","text":"Additions to the linkerscript's '.table.copy.extern' section Inputs: [String]","title":"linkerscript.table_extern.copy"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externheap","text":"Additions to the linkerscript's '.table.heap' section Inputs: [String]","title":"linkerscript.table_extern.heap"},{"location":"reference/module/modm-platform-cortex-m/#linkerscripttable_externzero","text":"Additions to the linkerscript's '.table.zero.extern' section Inputs: [String]","title":"linkerscript.table_extern.zero"},{"location":"reference/module/modm-platform-cortex-m/#queries","text":"","title":"Queries"},{"location":"reference/module/modm-platform-cortex-m/#linkerscript_1","text":"Computes linkerscript properties (* post-build only ): process_stack_size : largest requested process stack size by any module vector_table_location : ram or rom Stripped and newline-joined collector values of: linkerscript_memory linkerscript_sections linkerscript_extern_zero linkerscript_extern_copy linkerscript_extern_heap Additional memory properties: memories : unfiltered memory regions regions : memory region names ram_origin : Lowest SRAM origin address ram_origin : Total size of all SRAM regions cont_ram : largest continuous internal SRAM section :returns: dictionary of linkerscript properties","title":"linkerscript"},{"location":"reference/module/modm-platform-cortex-m/#vector_table","text":"Computes vector table properties: vector_table : [position] = Full vector name (ie. with _Handler or _IRQHandler suffix) vector_table_location : rom or ram highest_irq : highest IRQ number + 1 core : cortex-m{0,3,4,7}{,+,f,fd} The system vectors start at -16, so you must add 16 to highest_irq to get the total number of vectors in the table! :returns: a dictionary of vector table properties","title":"vector_table"},{"location":"reference/module/modm-platform-cortex-m/#dependencies","text":"modm:platform:cortex-m modm_platform_cortex_m modm: platform: cortex-m modm_architecture_interrupt modm: architecture: interrupt modm_platform_cortex_m->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_cortex_m->modm_cmsis_device modm_stdc++ modm: stdc++ modm_platform_cortex_m->modm_stdc++ @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-dac/","text":"Digital-to-Analog Converter (DAC) \u00b6 lbuild module: modm:platform:dac This module is only available for stm32f4. Dependencies \u00b6 modm:platform:dac modm_platform_dac modm: platform: dac modm_cmsis_device modm: cmsis: device modm_platform_dac->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:dac"},{"location":"reference/module/modm-platform-dac/#digital-to-analog-converter-dac","text":"lbuild module: modm:platform:dac This module is only available for stm32f4.","title":"Digital-to-Analog Converter (DAC)"},{"location":"reference/module/modm-platform-dac/#dependencies","text":"modm:platform:dac modm_platform_dac modm: platform: dac modm_cmsis_device modm: cmsis: device modm_platform_dac->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-dma/","text":"Direct Memory Access (DMA) \u00b6 lbuild module: modm:platform:dma This module is only available for stm32{f0,f1,f3,l0,l1,l4}. Dependencies \u00b6 modm:platform:dma modm_platform_dma modm: platform: dma modm_cmsis_device modm: cmsis: device modm_platform_dma->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_dma->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:dma"},{"location":"reference/module/modm-platform-dma/#direct-memory-access-dma","text":"lbuild module: modm:platform:dma This module is only available for stm32{f0,f1,f3,l0,l1,l4}.","title":"Direct Memory Access (DMA)"},{"location":"reference/module/modm-platform-dma/#dependencies","text":"modm:platform:dma modm_platform_dma modm: platform: dma modm_cmsis_device modm: cmsis: device modm_platform_dma->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_dma->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-eth/","text":"Ethernet \u00b6 lbuild module: modm:platform:eth This module is only available for stm32f7. Dependencies \u00b6 modm:platform:eth modm_platform_eth modm: platform: eth modm_architecture_assert modm: architecture: assert modm_platform_eth->modm_architecture_assert modm_architecture_delay modm: architecture: delay modm_platform_eth->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_eth->modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_eth->modm_architecture_register modm_math_utils modm: math: utils modm_platform_eth->modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_eth->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_eth->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:eth"},{"location":"reference/module/modm-platform-eth/#ethernet","text":"lbuild module: modm:platform:eth This module is only available for stm32f7.","title":"Ethernet"},{"location":"reference/module/modm-platform-eth/#dependencies","text":"modm:platform:eth modm_platform_eth modm: platform: eth modm_architecture_assert modm: architecture: assert modm_platform_eth->modm_architecture_assert modm_architecture_delay modm: architecture: delay modm_platform_eth->modm_architecture_delay modm_architecture_interrupt modm: architecture: interrupt modm_platform_eth->modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_eth->modm_architecture_register modm_math_utils modm: math: utils modm_platform_eth->modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_eth->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_eth->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-extint/","text":"External Interrupt \u00b6 lbuild module: modm:platform:extint This module is only available for sam. Dependencies \u00b6 modm:platform:extint modm_platform_extint modm: platform: extint modm_cmsis_device modm: cmsis: device modm_platform_extint->modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_extint->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_extint->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:extint"},{"location":"reference/module/modm-platform-extint/#external-interrupt","text":"lbuild module: modm:platform:extint This module is only available for sam.","title":"External Interrupt"},{"location":"reference/module/modm-platform-extint/#dependencies","text":"modm:platform:extint modm_platform_extint modm: platform: extint modm_cmsis_device modm: cmsis: device modm_platform_extint->modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_extint->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_extint->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-fault/","text":"ARM Cortex-M Fault Reporters \u00b6 lbuild module: modm:platform:fault This module manages data storage for core dumps provided by the :crashcatcher module to investigate HardFault events via offline post-mortem debugging. The data is stored in the volatile memory designated for the heap. This works as follows: A HardFault occurs and is intercepted by CrashCatcher. CrashCatcher calls into this module to store the core dump in the heap as defined by the linkerscript's .table.heap section, thus effectively overwriting the heap, then reboots the device. On reboot, only the remaining heap memory is initialized, leaving the core dump data intact. The application has no limitations other than a reduced total heap size! It may access the report data at any time and use all hardware to send out this report. After the application clears the report ands reboots, the heap will once again be fully available. Restrictions on HardFault Entry \u00b6 A HardFault is a serious bug and should it happen your application is most likely compromised in some way. Here are some important points to take note of. The HardFault has a hardcoded priority of -1 and only the NMI and the Reset exceptions have a higher priority (-2 and -3). This means ALL device interrupts have a LOWER priority! The HardFault is a synchronous exception, it will NOT wait for anything to complete, especially not the currently executing interrupt (if any). There are many reasons for the HardFault exception to be raised (e.g. accessing invalid memory, executing undefined instructions, dividing by zero) making it very difficult to recover in a generic way. It is therefore reasonable to abandon execution (=> reboot) rather than resuming execution in an increasingly unstable application. On HardFault entry, this module calls the function modm_hardfault_entry() which can be overwritten by the application to put the devices hardware in a safe mode. This can be as simple as disabling power to external components, however, its execution should be strictly time bound and NOT depend on other interrupts completing (they won't), which will cause a deadlock. void modm_hardfault_entry () { Board :: MotorDrivers :: disable (); // return from this function as fast as possible } After this function returns, this module will generate the coredump into the heap and reboot the device. Reporting the Fault \u00b6 In order to recover from the HardFault the device is rebooted with a smaller heap. Once the main() function is reached, the application code should check for FaultReporter::hasReport() and then only initialize the bare minimum of Hardware to send this report to the developer. To access the report, use the FaultReporter::begin() and FaultReporter::end() functions which return a const_iterator of the actual core dump data, that can be used in a range-based for loop. Remember to call FaultReporter::clearAndReboot() to clear the report, reboot the device and reclaim the full heap. int main () { if ( FaultReporter :: hasReport ()) // Check first after boot { Application :: partialInitialize (); // Initialize only the necessary reportBegin (); for ( const uint8_t data : FaultReporter :: buildId ()) reportBuildId ( data ); // send each byte of Build ID for ( const uint8_t data : FaultReporter ()) reportData ( data ); // send each byte of data reportEnd (); // end the report FaultReporter :: clearAndReboot (); // clear the report and reboot // never reached } // Normal initialization Application :: initialize (); } The application is able to use the heap, however, depending on the report size (controllable via the report_level option) the heap may be much smaller then normal. Make sure your application can deal with that. For complex applications which perhaps communicate asynchronously (CAN, Ethernet, Wireless) it may not be possible to send the report in one piece or at the same time. The report data remains available until you reboot, even after you've cleared the report. int main () { const bool faultReport { FaultReporter :: hasReport ()}; FaultReporter :: clear (); // only clear report but do not reboot Application :: initialize (); while ( true ) { doOtherStuff (); if ( faultReport and applicationReady ) { // Still valid AFTER clear, but BEFORE reboot const auto id = FaultReporter :: buildId (); auto begin = FaultReporter :: begin (); auto end = FaultReporter :: end (); // Application :: sendReport ( id , begin , end ); // reboot when report has been fully sent } } } Using the Fault Report \u00b6 The fault report contains a core dump generated by CrashCatcher and is supposed to be used by CrashDebug to present the memory view to the GDB debugger. For this, you must use the ELF file that corresponds to the devices firmware, as well as copy the coredump data formatted as hexadecimal values into a text file, then call the debugger like this: arm-none-eabi-gdb -tui executable.elf -ex \"set target-charset ASCII\" \\ -ex \"target remote | CrashDebug --elf executable.elf --dump coredump.txt\" Note that the FaultReporter::buildId() contains the GNU Build ID, which can help you find the right ELF file: arm-none-eabi-readelf -n executable.elf Displaying notes found in: .build_id Owner Data size Description GNU 0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring) Build ID: 59f08f7a37a7340799d9dba6b0c092bc3c9515c5 Post-Mortem Debugging with SCons \u00b6 The :build:scons module provides a few helper methods for working with fault reports. You still need to copy the coredump data manually, however, the firmware selection is automated. The SCons build system will automatically cache the ELF file for the build id for every firmware upload (using scons artifact ). When a fault is reported, you can tell SCons the firmware build id and it will use the corresponding ELF file automatically. # Copy data into coredump.txt touch coredump.txt # Start postmortem debugging of executable with this build id scons debug-coredump firmware = 59f08f7a37a7340799d9dba6b0c092bc3c9515c5 This module is only available for sam, stm32. Options \u00b6 report_level \u00b6 Fault Report Level This module will try to store as much data as is available in the heap and any leftover data will be discarded. This means the application may not have any heap available after a reboot. You can control how much data is generated by choosing the right report level: core: Just dumps the core registers, which describe where the fault occurred and why. This is usually less than 250 Bytes. stack: Dumps the main stack memory. This will get you a full backtrace, but may take a few kB of space. data: Dumps all memory sections containing static data: .data , .fastdata , .bss . This allows you to see data that isn't related to your current fault location, however, this can take several tens of kB of data. It is strongly recommended to choose the report level that generates less data than you heap size. The scons size output displays this very prominently, if the Data size is smaller than your Heap size, you're good to use the core+stack+data setting: Data: 5.2 KiB (26.0% used) = 2285 B static (11.2%) + 3040 B stack (14.8%) (.bss + .data + .fastdata + .noinit + .stack) Heap: 14.8 KiB (74.0% available) (.heap1) If Heap is smaller than the Data, you may need to switch to using only the core+stack setting: Data: 11.2 KiB (56.0% used) = 8429 B static (41.2%) + 3040 B stack (14.8%) (.bss + .data + .fastdata + .noinit + .stack) Heap: 8.8 KiB (44.0% available) (.heap1) Default: core+stack+data Inputs: [core, core+stack, core+stack+data] Dependencies \u00b6 modm:platform:fault modm_platform_fault modm: platform: fault modm_architecture_build_id modm: architecture: build_id modm_platform_fault->modm_architecture_build_id modm_cmsis_device modm: cmsis: device modm_platform_fault->modm_cmsis_device modm_crashcatcher modm: crashcatcher modm_platform_fault->modm_crashcatcher @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:fault"},{"location":"reference/module/modm-platform-fault/#arm-cortex-m-fault-reporters","text":"lbuild module: modm:platform:fault This module manages data storage for core dumps provided by the :crashcatcher module to investigate HardFault events via offline post-mortem debugging. The data is stored in the volatile memory designated for the heap. This works as follows: A HardFault occurs and is intercepted by CrashCatcher. CrashCatcher calls into this module to store the core dump in the heap as defined by the linkerscript's .table.heap section, thus effectively overwriting the heap, then reboots the device. On reboot, only the remaining heap memory is initialized, leaving the core dump data intact. The application has no limitations other than a reduced total heap size! It may access the report data at any time and use all hardware to send out this report. After the application clears the report ands reboots, the heap will once again be fully available.","title":"ARM Cortex-M Fault Reporters"},{"location":"reference/module/modm-platform-fault/#restrictions-on-hardfault-entry","text":"A HardFault is a serious bug and should it happen your application is most likely compromised in some way. Here are some important points to take note of. The HardFault has a hardcoded priority of -1 and only the NMI and the Reset exceptions have a higher priority (-2 and -3). This means ALL device interrupts have a LOWER priority! The HardFault is a synchronous exception, it will NOT wait for anything to complete, especially not the currently executing interrupt (if any). There are many reasons for the HardFault exception to be raised (e.g. accessing invalid memory, executing undefined instructions, dividing by zero) making it very difficult to recover in a generic way. It is therefore reasonable to abandon execution (=> reboot) rather than resuming execution in an increasingly unstable application. On HardFault entry, this module calls the function modm_hardfault_entry() which can be overwritten by the application to put the devices hardware in a safe mode. This can be as simple as disabling power to external components, however, its execution should be strictly time bound and NOT depend on other interrupts completing (they won't), which will cause a deadlock. void modm_hardfault_entry () { Board :: MotorDrivers :: disable (); // return from this function as fast as possible } After this function returns, this module will generate the coredump into the heap and reboot the device.","title":"Restrictions on HardFault Entry"},{"location":"reference/module/modm-platform-fault/#reporting-the-fault","text":"In order to recover from the HardFault the device is rebooted with a smaller heap. Once the main() function is reached, the application code should check for FaultReporter::hasReport() and then only initialize the bare minimum of Hardware to send this report to the developer. To access the report, use the FaultReporter::begin() and FaultReporter::end() functions which return a const_iterator of the actual core dump data, that can be used in a range-based for loop. Remember to call FaultReporter::clearAndReboot() to clear the report, reboot the device and reclaim the full heap. int main () { if ( FaultReporter :: hasReport ()) // Check first after boot { Application :: partialInitialize (); // Initialize only the necessary reportBegin (); for ( const uint8_t data : FaultReporter :: buildId ()) reportBuildId ( data ); // send each byte of Build ID for ( const uint8_t data : FaultReporter ()) reportData ( data ); // send each byte of data reportEnd (); // end the report FaultReporter :: clearAndReboot (); // clear the report and reboot // never reached } // Normal initialization Application :: initialize (); } The application is able to use the heap, however, depending on the report size (controllable via the report_level option) the heap may be much smaller then normal. Make sure your application can deal with that. For complex applications which perhaps communicate asynchronously (CAN, Ethernet, Wireless) it may not be possible to send the report in one piece or at the same time. The report data remains available until you reboot, even after you've cleared the report. int main () { const bool faultReport { FaultReporter :: hasReport ()}; FaultReporter :: clear (); // only clear report but do not reboot Application :: initialize (); while ( true ) { doOtherStuff (); if ( faultReport and applicationReady ) { // Still valid AFTER clear, but BEFORE reboot const auto id = FaultReporter :: buildId (); auto begin = FaultReporter :: begin (); auto end = FaultReporter :: end (); // Application :: sendReport ( id , begin , end ); // reboot when report has been fully sent } } }","title":"Reporting the Fault"},{"location":"reference/module/modm-platform-fault/#using-the-fault-report","text":"The fault report contains a core dump generated by CrashCatcher and is supposed to be used by CrashDebug to present the memory view to the GDB debugger. For this, you must use the ELF file that corresponds to the devices firmware, as well as copy the coredump data formatted as hexadecimal values into a text file, then call the debugger like this: arm-none-eabi-gdb -tui executable.elf -ex \"set target-charset ASCII\" \\ -ex \"target remote | CrashDebug --elf executable.elf --dump coredump.txt\" Note that the FaultReporter::buildId() contains the GNU Build ID, which can help you find the right ELF file: arm-none-eabi-readelf -n executable.elf Displaying notes found in: .build_id Owner Data size Description GNU 0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring) Build ID: 59f08f7a37a7340799d9dba6b0c092bc3c9515c5","title":"Using the Fault Report"},{"location":"reference/module/modm-platform-fault/#post-mortem-debugging-with-scons","text":"The :build:scons module provides a few helper methods for working with fault reports. You still need to copy the coredump data manually, however, the firmware selection is automated. The SCons build system will automatically cache the ELF file for the build id for every firmware upload (using scons artifact ). When a fault is reported, you can tell SCons the firmware build id and it will use the corresponding ELF file automatically. # Copy data into coredump.txt touch coredump.txt # Start postmortem debugging of executable with this build id scons debug-coredump firmware = 59f08f7a37a7340799d9dba6b0c092bc3c9515c5 This module is only available for sam, stm32.","title":"Post-Mortem Debugging with SCons"},{"location":"reference/module/modm-platform-fault/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-fault/#report_level","text":"Fault Report Level This module will try to store as much data as is available in the heap and any leftover data will be discarded. This means the application may not have any heap available after a reboot. You can control how much data is generated by choosing the right report level: core: Just dumps the core registers, which describe where the fault occurred and why. This is usually less than 250 Bytes. stack: Dumps the main stack memory. This will get you a full backtrace, but may take a few kB of space. data: Dumps all memory sections containing static data: .data , .fastdata , .bss . This allows you to see data that isn't related to your current fault location, however, this can take several tens of kB of data. It is strongly recommended to choose the report level that generates less data than you heap size. The scons size output displays this very prominently, if the Data size is smaller than your Heap size, you're good to use the core+stack+data setting: Data: 5.2 KiB (26.0% used) = 2285 B static (11.2%) + 3040 B stack (14.8%) (.bss + .data + .fastdata + .noinit + .stack) Heap: 14.8 KiB (74.0% available) (.heap1) If Heap is smaller than the Data, you may need to switch to using only the core+stack setting: Data: 11.2 KiB (56.0% used) = 8429 B static (41.2%) + 3040 B stack (14.8%) (.bss + .data + .fastdata + .noinit + .stack) Heap: 8.8 KiB (44.0% available) (.heap1) Default: core+stack+data Inputs: [core, core+stack, core+stack+data]","title":"report_level"},{"location":"reference/module/modm-platform-fault/#dependencies","text":"modm:platform:fault modm_platform_fault modm: platform: fault modm_architecture_build_id modm: architecture: build_id modm_platform_fault->modm_architecture_build_id modm_cmsis_device modm: cmsis: device modm_platform_fault->modm_cmsis_device modm_crashcatcher modm: crashcatcher modm_platform_fault->modm_crashcatcher @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-flash/","text":"Flash Memory \u00b6 lbuild module: modm:platform:flash This module is only available for stm32{f4,g0}. Dependencies \u00b6 modm:platform:flash modm_platform_flash modm: platform: flash modm_architecture_register modm: architecture: register modm_platform_flash->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_flash->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_flash->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:flash"},{"location":"reference/module/modm-platform-flash/#flash-memory","text":"lbuild module: modm:platform:flash This module is only available for stm32{f4,g0}.","title":"Flash Memory"},{"location":"reference/module/modm-platform-flash/#dependencies","text":"modm:platform:flash modm_platform_flash modm: platform: flash modm_architecture_register modm: architecture: register modm_platform_flash->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_flash->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_flash->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-fsmc/","text":"Flexible (Static) Memory Controller (FSMC/FMC) \u00b6 lbuild module: modm:platform:fsmc This module is only available for stm32{f1,f2,f4,l1}. Dependencies \u00b6 modm:platform:fsmc modm_platform_fsmc modm: platform: fsmc modm_cmsis_device modm: cmsis: device modm_platform_fsmc->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_fsmc->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:fsmc"},{"location":"reference/module/modm-platform-fsmc/#flexible-static-memory-controller-fsmcfmc","text":"lbuild module: modm:platform:fsmc This module is only available for stm32{f1,f2,f4,l1}.","title":"Flexible (Static) Memory Controller (FSMC/FMC)"},{"location":"reference/module/modm-platform-fsmc/#dependencies","text":"modm:platform:fsmc modm_platform_fsmc modm: platform: fsmc modm_cmsis_device modm: cmsis: device modm_platform_fsmc->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_fsmc->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-gclk/","text":"Generic Clock Controller (GCLK) \u00b6 lbuild module: modm:platform:gclk This module is only available for sam. Dependencies \u00b6 modm:platform:gclk modm_platform_gclk modm: platform: gclk modm_cmsis_device modm: cmsis: device modm_platform_gclk->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:gclk"},{"location":"reference/module/modm-platform-gclk/#generic-clock-controller-gclk","text":"lbuild module: modm:platform:gclk This module is only available for sam.","title":"Generic Clock Controller (GCLK)"},{"location":"reference/module/modm-platform-gclk/#dependencies","text":"modm:platform:gclk modm_platform_gclk modm: platform: gclk modm_cmsis_device modm: cmsis: device modm_platform_gclk->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-gpio-avr/","text":"General Purpose I/O (GPIO) \u00b6 lbuild module: modm:platform:gpio This module is only available for avr. Dependencies \u00b6 modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:gpio (avr)"},{"location":"reference/module/modm-platform-gpio-avr/#general-purpose-io-gpio","text":"lbuild module: modm:platform:gpio This module is only available for avr.","title":"General Purpose I/O (GPIO)"},{"location":"reference/module/modm-platform-gpio-avr/#dependencies","text":"modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-gpio-hosted-darwin-linux-windows/","text":"Hosted GPIO \u00b6 lbuild module: modm:platform:gpio This module is only available for hosted{darwin,linux,windows}. Dependencies \u00b6 modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:gpio (hosted{darwin,linux,windows})"},{"location":"reference/module/modm-platform-gpio-hosted-darwin-linux-windows/#hosted-gpio","text":"lbuild module: modm:platform:gpio This module is only available for hosted{darwin,linux,windows}.","title":"Hosted GPIO"},{"location":"reference/module/modm-platform-gpio-hosted-darwin-linux-windows/#dependencies","text":"modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-gpio-hosted-rpi/","text":"Hosted GPIO for Raspberry Pi \u00b6 lbuild module: modm:platform:gpio This module is only available for hosted-rpi. Dependencies \u00b6 modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:gpio (hosted-rpi)"},{"location":"reference/module/modm-platform-gpio-hosted-rpi/#hosted-gpio-for-raspberry-pi","text":"lbuild module: modm:platform:gpio This module is only available for hosted-rpi.","title":"Hosted GPIO for Raspberry Pi"},{"location":"reference/module/modm-platform-gpio-hosted-rpi/#dependencies","text":"modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-gpio-sam/","text":"General Purpose I/O (GPIO) \u00b6 lbuild module: modm:platform:gpio This module is only available for sam. Dependencies \u00b6 modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio->modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:gpio (sam)"},{"location":"reference/module/modm-platform-gpio-sam/#general-purpose-io-gpio","text":"lbuild module: modm:platform:gpio This module is only available for sam.","title":"General Purpose I/O (GPIO)"},{"location":"reference/module/modm-platform-gpio-sam/#dependencies","text":"modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio->modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-gpio-stm32/","text":"General Purpose I/O (GPIO) \u00b6 lbuild module: modm:platform:gpio This module is only available for stm32. Options \u00b6 enable_ports \u00b6 Enable clock for these GPIO ports during startup Default: {A, B, C, D, E, F, G, H, I, J, K} stm32{f4,f7} Default: {A, B, C, D, E, F, G, H, I} stm32{f2,f4,f7,l4} Default: {A, B, C, D, E, F, G, H} stm32{f2,f3,f4,f7,l1,l4} Default: {A, B, C, D, E, F, G} stm32{f1,g4} Default: {A, B, C, D, E, F} stm32{f0,f3} Default: {A, B, C, D, E, G, H} stm32l4 Default: {A, B, C, D, E, H, I} stm32f4 Default: {A, B, C, D, E, H} stm32{f2,f4,f7,l0,l1,l4} Default: {A, B, C, D, E} stm32f1 Default: {A, B, C, D, F, G} stm32g4 Default: {A, B, C, D, F} stm32{f0,f3,g0} Default: {A, B, C, D, G, H} stm32l4 Default: {A, B, C, D, H} stm32{f2,f4,f7,l0,l1,l4} Default: {A, B, C, D} stm32f1 Default: {A, B, C, F, G} stm32g4 Default: {A, B, C, F} stm32{f0,f3,g0} Default: {A, B, C, H} stm32{f4,l0,l1,l4} Default: {A, B, C} stm32{g0,l0} Default: {A, B, D} stm32f1 Default: {A, B, F, G} stm32g4 Default: {A, B, F} stm32{f0,f3} Default: {A, F} stm32f038f6p6 Inputs: [A, B, C] stm32{g0,l0} Inputs: [A, B, C, D] stm32f1 Inputs: [A, B, C, D, E] stm32f1 Inputs: [A, B, C, D, E, F] stm32{f0,f3} Inputs: [A, B, C, D, E, F, G] stm32{f1,g4} Inputs: [A, B, C, D, E, F, G, H] stm32{f2,f3,f4,f7,l1,l4} Inputs: [A, B, C, D, E, F, G, H, I] stm32{f2,f4,f7,l4} Inputs: [A, B, C, D, E, F, G, H, I, J, K] stm32{f4,f7} Inputs: [A, B, C, D, E, G, H] stm32l4 Inputs: [A, B, C, D, E, H] stm32{f2,f4,f7,l0,l1,l4} Inputs: [A, B, C, D, E, H, I] stm32f4 Inputs: [A, B, C, D, F] stm32{f0,f3,g0} Inputs: [A, B, C, D, F, G] stm32g4 Inputs: [A, B, C, D, G, H] stm32l4 Inputs: [A, B, C, D, H] stm32{f2,f4,f7,l0,l1,l4} Inputs: [A, B, C, F] stm32{f0,f3,g0} Inputs: [A, B, C, F, G] stm32g4 Inputs: [A, B, C, H] stm32{f4,l0,l1,l4} Inputs: [A, B, D] stm32f1 Inputs: [A, B, F] stm32{f0,f3} Inputs: [A, B, F, G] stm32g4 Inputs: [A, F] stm32f038f6p6 Dependencies \u00b6 modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio->modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils modm_platform_rcc modm: platform: rcc modm_platform_gpio->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:gpio (stm32)"},{"location":"reference/module/modm-platform-gpio-stm32/#general-purpose-io-gpio","text":"lbuild module: modm:platform:gpio This module is only available for stm32.","title":"General Purpose I/O (GPIO)"},{"location":"reference/module/modm-platform-gpio-stm32/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-gpio-stm32/#enable_ports","text":"Enable clock for these GPIO ports during startup Default: {A, B, C, D, E, F, G, H, I, J, K} stm32{f4,f7} Default: {A, B, C, D, E, F, G, H, I} stm32{f2,f4,f7,l4} Default: {A, B, C, D, E, F, G, H} stm32{f2,f3,f4,f7,l1,l4} Default: {A, B, C, D, E, F, G} stm32{f1,g4} Default: {A, B, C, D, E, F} stm32{f0,f3} Default: {A, B, C, D, E, G, H} stm32l4 Default: {A, B, C, D, E, H, I} stm32f4 Default: {A, B, C, D, E, H} stm32{f2,f4,f7,l0,l1,l4} Default: {A, B, C, D, E} stm32f1 Default: {A, B, C, D, F, G} stm32g4 Default: {A, B, C, D, F} stm32{f0,f3,g0} Default: {A, B, C, D, G, H} stm32l4 Default: {A, B, C, D, H} stm32{f2,f4,f7,l0,l1,l4} Default: {A, B, C, D} stm32f1 Default: {A, B, C, F, G} stm32g4 Default: {A, B, C, F} stm32{f0,f3,g0} Default: {A, B, C, H} stm32{f4,l0,l1,l4} Default: {A, B, C} stm32{g0,l0} Default: {A, B, D} stm32f1 Default: {A, B, F, G} stm32g4 Default: {A, B, F} stm32{f0,f3} Default: {A, F} stm32f038f6p6 Inputs: [A, B, C] stm32{g0,l0} Inputs: [A, B, C, D] stm32f1 Inputs: [A, B, C, D, E] stm32f1 Inputs: [A, B, C, D, E, F] stm32{f0,f3} Inputs: [A, B, C, D, E, F, G] stm32{f1,g4} Inputs: [A, B, C, D, E, F, G, H] stm32{f2,f3,f4,f7,l1,l4} Inputs: [A, B, C, D, E, F, G, H, I] stm32{f2,f4,f7,l4} Inputs: [A, B, C, D, E, F, G, H, I, J, K] stm32{f4,f7} Inputs: [A, B, C, D, E, G, H] stm32l4 Inputs: [A, B, C, D, E, H] stm32{f2,f4,f7,l0,l1,l4} Inputs: [A, B, C, D, E, H, I] stm32f4 Inputs: [A, B, C, D, F] stm32{f0,f3,g0} Inputs: [A, B, C, D, F, G] stm32g4 Inputs: [A, B, C, D, G, H] stm32l4 Inputs: [A, B, C, D, H] stm32{f2,f4,f7,l0,l1,l4} Inputs: [A, B, C, F] stm32{f0,f3,g0} Inputs: [A, B, C, F, G] stm32g4 Inputs: [A, B, C, H] stm32{f4,l0,l1,l4} Inputs: [A, B, D] stm32f1 Inputs: [A, B, F] stm32{f0,f3} Inputs: [A, B, F, G] stm32g4 Inputs: [A, F] stm32f038f6p6","title":"enable_ports"},{"location":"reference/module/modm-platform-gpio-stm32/#dependencies","text":"modm:platform:gpio modm_platform_gpio modm: platform: gpio modm_architecture_gpio modm: architecture: gpio modm_platform_gpio->modm_architecture_gpio modm_cmsis_device modm: cmsis: device modm_platform_gpio->modm_cmsis_device modm_math_utils modm: math: utils modm_platform_gpio->modm_math_utils modm_platform_rcc modm: platform: rcc modm_platform_gpio->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-heap-avr/","text":"Dynamic Memory \u00b6 lbuild module: modm:platform:heap This module is only available for avr. Options \u00b6 ram_block_length \u00b6 Default: 16 Inputs: [2, 4, 8, 16, 32, 64] ram_length \u00b6 Default: 1024 Inputs: [64 .. 1024 .. 32768] Dependencies \u00b6 modm:platform:heap modm_platform_heap modm: platform: heap modm_architecture_assert modm: architecture: assert modm_platform_heap->modm_architecture_assert modm_architecture_memory modm: architecture: memory modm_platform_heap->modm_architecture_memory @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:heap (avr)"},{"location":"reference/module/modm-platform-heap-avr/#dynamic-memory","text":"lbuild module: modm:platform:heap This module is only available for avr.","title":"Dynamic Memory"},{"location":"reference/module/modm-platform-heap-avr/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-heap-avr/#ram_block_length","text":"Default: 16 Inputs: [2, 4, 8, 16, 32, 64]","title":"ram_block_length"},{"location":"reference/module/modm-platform-heap-avr/#ram_length","text":"Default: 1024 Inputs: [64 .. 1024 .. 32768]","title":"ram_length"},{"location":"reference/module/modm-platform-heap-avr/#dependencies","text":"modm:platform:heap modm_platform_heap modm: platform: heap modm_architecture_assert modm: architecture: assert modm_platform_heap->modm_architecture_assert modm_architecture_memory modm: architecture: memory modm_platform_heap->modm_architecture_memory @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-heap-sam--stm32/","text":"Heap Memory \u00b6 lbuild module: modm:platform:heap Your applicaton is linked against the newlib-nano libc, which only requires the implementation of the void* sbrk(ptrdiff_t size) hook to use the heap. However, the sbrk mechanism can only grow and shrink forward and backwards in memory and in particular it does not support discontinuous jumps from one memory section to another. The limitation stems from being designed for use with a MMU which would simply map another physical page into the linear virtual address space so that the heap section appears continuous to sbrk . Since we do not have a MMU on Cortex-M, this strategy limits the use of the default newlib allocator to one continuous memory region. Therefore this module implements alternative allocators for devices with multiple memory regions with different traits and extends the C++ operator new to access them. See the modm:architecture:memory module for what kind of memory traits exist. Heap is not Implemented Error \u00b6 This module is not included by default, and any attempt to use the heap fails with one or multiple linker error messages similiar to this: `_sbrk_r' referenced in section `.text._malloc_r' of libc_nano.a(lib_a-nano-mallocr.o): defined in discarded section `.Heap_is_not_implemented!_ _Please_include_the__modm:platform:heap__module_in_your_project!' of libmodm.a(no_heap.o) This is to prevent you from accidentally using the heap, which may not be desirable for your application. If this occurs you have three choices. You can: find and remove calls to malloc/new in your application, or include this module with its predefined allocators, or implement your own allocator. Predefined Allocators \u00b6 There are several trade-offs to each allocator, however, as a rule of thumb, choose: newlib for devices with one large continuous RAM region. block for devices with one very small RAM region. tlsf for devices with multiple, different discontinuous RAM regions. Multi-SRAM regions For devices which contain separate memories laid out in a continuous way (often called SRAM1, SRAM2, SRAM3, etc.) the newlib and block strategies choose the largest continuous memory region, even though unaligned accesses across memory regions may not be supported in hardware and lead to a bus fault! Consider using the TLSF implementation, which does not suffer from this issue. Allocators are not interrupt- or thread-safe No locking is implemented by default, if you need this feature, consider implementing your own custom allocator algorithm! Newlib \u00b6 The newlib-nano allocator is a simple linked list, its overhead is therefore low, but the access time may not be good. Due to the limitations of the sbrk mechanism only the largest memory region is used as heap! Depending on the device memory architecture this can leave large memory regions unused. Consider using the TLSF allocator for devices with multiple discontinuous memories. Block \u00b6 For devices with very small memories, we recommend using the block allocator strategy, which uses a very light-weight and simple algorithm. This also only operates on one continuous memory region as heap. The Block allocator does not implement realloc! This is a bug in modm:driver:block.allocator and currently a modm_assert will fail. TLSF \u00b6 To use all non-statically allocated memory for heap, use the TLSF strategy, which natively supports multiple memory regions. This implementation treats all internal memories as separate regions, so unaligned access across memory boundaries is not an issue. To request heap memory of different traits, see the modm:architecture:memory module. TLSF has static overhead The TLSF implementation has a static overhead of about 1kB per memory trait group, however, these can then contain multiple discontinuous regions. The upside of this large static allocation is very fast allocation times of O(1), but we recommend using TLSF only for devices with multiple large memory regions. Custom Allocator \u00b6 To implement your own allocator do not include this module. Instead initialize your heap in the function __modm_initialize_memory() , which gets called by the startup script after hardware init, but before static constructors are called (see modm:platform:cortex-m for details). The simplest way to do so is to allocate a huge array into one of the heap sections and use this as your heap. Consult modm:platform:core for what heap sections your target provides! modm_section ( \".heap1\" ) // always the main heap section uint8_t heap_begin [ 10 * 1024 ]; // 10 kB heap const uint8_t * const heap_end { heap_begin + sizeof ( heap_begin )}; extern \"C\" void __modm_initialize_memory () { // Initialize your specific allocator algorithm here allocator . initialize (); } Static constructors are only called afterwards! Since constructors may call the heap, it must be initialized before static constructors are called. Only trivially constructed (POD) objects are already initialized! Using the HeapTable \u00b6 If you prefer a little more control, include the modm:architecture:memory module to get access to the internal modm::platform::HeapTable API, which lists memory regions by traits and sizes. For example to find the largest continuous memory section with default traits you can use this code: const uint8_t * heap_begin { nullptr }; const uint8_t * heap_end { nullptr }; extern \"C\" void __modm_initialize_memory () { bool success = HeapTable :: find_largest ( & heap_begin , & heap_end , modm :: MemoryDefault ); modm_assert ( success , \"heap.init\" , \"No default memory section found!\" ); } If you want to know more about the available memory regions, you can iterate over the heap table directly. This gives you full control over where you want to place you heap. You can print this table at runtime to get a feel for it: for ( const auto [ traits , start , end , size ] : modm :: platform :: HeapTable ()) { MODM_LOG_INFO . printf ( \"Memory section %#x @[0x%p,0x%p](%u) \\n \" , traits . value , start , end , size ); } Providing sbrk \u00b6 To use the builtin allocator from newlib, all you need to provide is an implementation of the sbrk function. A simple implementation for a [ heap_begin , heap_end ] memory region looks like this: const uint8_t * heap_top { heap_begin }; extern \"C\" void * _sbrk_r ( struct _reent * , ptrdiff_t size ) { const uint8_t * const heap = heap_top ; heap_top += size ; modm_assert ( heap_top < heap_end , \"heap.sbrk\" , \"Heap overflowed!\" ); return ( void * ) heap ; } Wrapping malloc \u00b6 To use a completely custom allocator, you need to replace the newlib allocator by wrapping the malloc , calloc , realloc and free functions via the linker by adding this to your project configuration: <library> <!-- repos, modules, options, etc... --> <collectors> <collect name= \":build:linkflags\" > -Wl,-wrap,_malloc_r </collect> <collect name= \":build:linkflags\" > -Wl,-wrap,_calloc_r </collect> <collect name= \":build:linkflags\" > -Wl,-wrap,_realloc_r </collect> <collect name= \":build:linkflags\" > -Wl,-wrap,_free_r </collect> </collectors> </library> And then implement the following functions with your custom allocator: extern \"C\" void * __wrap__malloc_r ( struct _reent * , size_t size ) { return allocator . malloc ( size ); } extern \"C\" void * __wrap__calloc_r ( struct _reent * , size_t size ) { return allocator . calloc ( size ); } extern \"C\" void * __wrap__realloc_r ( struct _reent * , void * ptr , size_t size ) { return allocator . realloc ( ptr , size ); } extern \"C\" void __wrap__free_r ( struct _reent * , void * p ) { allocator . free ( p ); } This is particularly recommended if you need a thread-safe malloc, which you implement here via the _reent struct. Consult newlib docs for details. sbrk is not called anymore When wrapping these malloc functions, _sbrk_r is not called anymore, and therefore is thrown away by the linker, thus the linker error disappears. You therefore do not need to implement it, not even as a stub. To also support memory traits, you need to overwrite the default implementation of malloc_traits(size, traits) which would otherwise just ignore the traits: extern \"C\" void * malloc_traits ( size_t size , uint32_t ctraits ) { // Convert back from C land to C++ land: const modm :: MemoryTraits traits { ctraits }; if ( traits & modm :: MemoryTrait :: AccessDMA ) { // check for space in DMA-able heap regions } else { // check other regions } return ptr ; } This module is only available for sam, stm32. Options \u00b6 allocator \u00b6 Heap allocator algorithms Default: tlsf Inputs: [block, newlib, tlsf] Input Dependency: block -> modm:driver:block.allocator Input Dependency: tlsf -> modm:tlsf Dependencies \u00b6 modm:platform:heap modm_platform_heap modm: platform: heap modm_architecture_assert modm: architecture: assert modm_platform_heap->modm_architecture_assert modm_architecture_memory modm: architecture: memory modm_platform_heap->modm_architecture_memory modm_driver_block_allocator modm: driver: block.allocator modm_platform_heap->modm_driver_block_allocator modm_tlsf modm: tlsf modm_platform_heap->modm_tlsf @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:heap (sam, stm32)"},{"location":"reference/module/modm-platform-heap-sam--stm32/#heap-memory","text":"lbuild module: modm:platform:heap Your applicaton is linked against the newlib-nano libc, which only requires the implementation of the void* sbrk(ptrdiff_t size) hook to use the heap. However, the sbrk mechanism can only grow and shrink forward and backwards in memory and in particular it does not support discontinuous jumps from one memory section to another. The limitation stems from being designed for use with a MMU which would simply map another physical page into the linear virtual address space so that the heap section appears continuous to sbrk . Since we do not have a MMU on Cortex-M, this strategy limits the use of the default newlib allocator to one continuous memory region. Therefore this module implements alternative allocators for devices with multiple memory regions with different traits and extends the C++ operator new to access them. See the modm:architecture:memory module for what kind of memory traits exist.","title":"Heap Memory"},{"location":"reference/module/modm-platform-heap-sam--stm32/#heap-is-not-implemented-error","text":"This module is not included by default, and any attempt to use the heap fails with one or multiple linker error messages similiar to this: `_sbrk_r' referenced in section `.text._malloc_r' of libc_nano.a(lib_a-nano-mallocr.o): defined in discarded section `.Heap_is_not_implemented!_ _Please_include_the__modm:platform:heap__module_in_your_project!' of libmodm.a(no_heap.o) This is to prevent you from accidentally using the heap, which may not be desirable for your application. If this occurs you have three choices. You can: find and remove calls to malloc/new in your application, or include this module with its predefined allocators, or implement your own allocator.","title":"Heap is not Implemented Error"},{"location":"reference/module/modm-platform-heap-sam--stm32/#predefined-allocators","text":"There are several trade-offs to each allocator, however, as a rule of thumb, choose: newlib for devices with one large continuous RAM region. block for devices with one very small RAM region. tlsf for devices with multiple, different discontinuous RAM regions. Multi-SRAM regions For devices which contain separate memories laid out in a continuous way (often called SRAM1, SRAM2, SRAM3, etc.) the newlib and block strategies choose the largest continuous memory region, even though unaligned accesses across memory regions may not be supported in hardware and lead to a bus fault! Consider using the TLSF implementation, which does not suffer from this issue. Allocators are not interrupt- or thread-safe No locking is implemented by default, if you need this feature, consider implementing your own custom allocator algorithm!","title":"Predefined Allocators"},{"location":"reference/module/modm-platform-heap-sam--stm32/#newlib","text":"The newlib-nano allocator is a simple linked list, its overhead is therefore low, but the access time may not be good. Due to the limitations of the sbrk mechanism only the largest memory region is used as heap! Depending on the device memory architecture this can leave large memory regions unused. Consider using the TLSF allocator for devices with multiple discontinuous memories.","title":"Newlib"},{"location":"reference/module/modm-platform-heap-sam--stm32/#block","text":"For devices with very small memories, we recommend using the block allocator strategy, which uses a very light-weight and simple algorithm. This also only operates on one continuous memory region as heap. The Block allocator does not implement realloc! This is a bug in modm:driver:block.allocator and currently a modm_assert will fail.","title":"Block"},{"location":"reference/module/modm-platform-heap-sam--stm32/#tlsf","text":"To use all non-statically allocated memory for heap, use the TLSF strategy, which natively supports multiple memory regions. This implementation treats all internal memories as separate regions, so unaligned access across memory boundaries is not an issue. To request heap memory of different traits, see the modm:architecture:memory module. TLSF has static overhead The TLSF implementation has a static overhead of about 1kB per memory trait group, however, these can then contain multiple discontinuous regions. The upside of this large static allocation is very fast allocation times of O(1), but we recommend using TLSF only for devices with multiple large memory regions.","title":"TLSF"},{"location":"reference/module/modm-platform-heap-sam--stm32/#custom-allocator","text":"To implement your own allocator do not include this module. Instead initialize your heap in the function __modm_initialize_memory() , which gets called by the startup script after hardware init, but before static constructors are called (see modm:platform:cortex-m for details). The simplest way to do so is to allocate a huge array into one of the heap sections and use this as your heap. Consult modm:platform:core for what heap sections your target provides! modm_section ( \".heap1\" ) // always the main heap section uint8_t heap_begin [ 10 * 1024 ]; // 10 kB heap const uint8_t * const heap_end { heap_begin + sizeof ( heap_begin )}; extern \"C\" void __modm_initialize_memory () { // Initialize your specific allocator algorithm here allocator . initialize (); } Static constructors are only called afterwards! Since constructors may call the heap, it must be initialized before static constructors are called. Only trivially constructed (POD) objects are already initialized!","title":"Custom Allocator"},{"location":"reference/module/modm-platform-heap-sam--stm32/#using-the-heaptable","text":"If you prefer a little more control, include the modm:architecture:memory module to get access to the internal modm::platform::HeapTable API, which lists memory regions by traits and sizes. For example to find the largest continuous memory section with default traits you can use this code: const uint8_t * heap_begin { nullptr }; const uint8_t * heap_end { nullptr }; extern \"C\" void __modm_initialize_memory () { bool success = HeapTable :: find_largest ( & heap_begin , & heap_end , modm :: MemoryDefault ); modm_assert ( success , \"heap.init\" , \"No default memory section found!\" ); } If you want to know more about the available memory regions, you can iterate over the heap table directly. This gives you full control over where you want to place you heap. You can print this table at runtime to get a feel for it: for ( const auto [ traits , start , end , size ] : modm :: platform :: HeapTable ()) { MODM_LOG_INFO . printf ( \"Memory section %#x @[0x%p,0x%p](%u) \\n \" , traits . value , start , end , size ); }","title":"Using the HeapTable"},{"location":"reference/module/modm-platform-heap-sam--stm32/#providing-sbrk","text":"To use the builtin allocator from newlib, all you need to provide is an implementation of the sbrk function. A simple implementation for a [ heap_begin , heap_end ] memory region looks like this: const uint8_t * heap_top { heap_begin }; extern \"C\" void * _sbrk_r ( struct _reent * , ptrdiff_t size ) { const uint8_t * const heap = heap_top ; heap_top += size ; modm_assert ( heap_top < heap_end , \"heap.sbrk\" , \"Heap overflowed!\" ); return ( void * ) heap ; }","title":"Providing sbrk"},{"location":"reference/module/modm-platform-heap-sam--stm32/#wrapping-malloc","text":"To use a completely custom allocator, you need to replace the newlib allocator by wrapping the malloc , calloc , realloc and free functions via the linker by adding this to your project configuration: <library> <!-- repos, modules, options, etc... --> <collectors> <collect name= \":build:linkflags\" > -Wl,-wrap,_malloc_r </collect> <collect name= \":build:linkflags\" > -Wl,-wrap,_calloc_r </collect> <collect name= \":build:linkflags\" > -Wl,-wrap,_realloc_r </collect> <collect name= \":build:linkflags\" > -Wl,-wrap,_free_r </collect> </collectors> </library> And then implement the following functions with your custom allocator: extern \"C\" void * __wrap__malloc_r ( struct _reent * , size_t size ) { return allocator . malloc ( size ); } extern \"C\" void * __wrap__calloc_r ( struct _reent * , size_t size ) { return allocator . calloc ( size ); } extern \"C\" void * __wrap__realloc_r ( struct _reent * , void * ptr , size_t size ) { return allocator . realloc ( ptr , size ); } extern \"C\" void __wrap__free_r ( struct _reent * , void * p ) { allocator . free ( p ); } This is particularly recommended if you need a thread-safe malloc, which you implement here via the _reent struct. Consult newlib docs for details. sbrk is not called anymore When wrapping these malloc functions, _sbrk_r is not called anymore, and therefore is thrown away by the linker, thus the linker error disappears. You therefore do not need to implement it, not even as a stub. To also support memory traits, you need to overwrite the default implementation of malloc_traits(size, traits) which would otherwise just ignore the traits: extern \"C\" void * malloc_traits ( size_t size , uint32_t ctraits ) { // Convert back from C land to C++ land: const modm :: MemoryTraits traits { ctraits }; if ( traits & modm :: MemoryTrait :: AccessDMA ) { // check for space in DMA-able heap regions } else { // check other regions } return ptr ; } This module is only available for sam, stm32.","title":"Wrapping malloc"},{"location":"reference/module/modm-platform-heap-sam--stm32/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-heap-sam--stm32/#allocator","text":"Heap allocator algorithms Default: tlsf Inputs: [block, newlib, tlsf] Input Dependency: block -> modm:driver:block.allocator Input Dependency: tlsf -> modm:tlsf","title":"allocator"},{"location":"reference/module/modm-platform-heap-sam--stm32/#dependencies","text":"modm:platform:heap modm_platform_heap modm: platform: heap modm_architecture_assert modm: architecture: assert modm_platform_heap->modm_architecture_assert modm_architecture_memory modm: architecture: memory modm_platform_heap->modm_architecture_memory modm_driver_block_allocator modm: driver: block.allocator modm_platform_heap->modm_driver_block_allocator modm_tlsf modm: tlsf modm_platform_heap->modm_tlsf @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-avr/","text":"Inter-Integrated Circuit (I\u00b2C) \u00b6 lbuild module: modm:platform:i2c This module is only available for avr. Dependencies \u00b6 modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:i2c (avr)"},{"location":"reference/module/modm-platform-i2c-avr/#inter-integrated-circuit-i2c","text":"lbuild module: modm:platform:i2c This module is only available for avr.","title":"Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-platform-i2c-avr/#dependencies","text":"modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-bitbang/","text":"Software Inter-Integrated Circuit (I\u00b2C) \u00b6 lbuild module: modm:platform:i2c.bitbang Dependencies \u00b6 modm:platform:i2c.bitbang modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_architecture_delay modm: architecture: delay modm_platform_i2c_bitbang->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_platform_i2c_bitbang->modm_architecture_gpio modm_architecture_i2c modm: architecture: i2c modm_platform_i2c_bitbang->modm_architecture_i2c modm_platform_gpio modm: platform: gpio modm_platform_i2c_bitbang->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":platform:i2c.bitbang"},{"location":"reference/module/modm-platform-i2c-bitbang/#software-inter-integrated-circuit-i2c","text":"lbuild module: modm:platform:i2c.bitbang","title":"Software Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-platform-i2c-bitbang/#dependencies","text":"modm:platform:i2c.bitbang modm_platform_i2c_bitbang modm: platform: i2c.bitbang modm_architecture_delay modm: architecture: delay modm_platform_i2c_bitbang->modm_architecture_delay modm_architecture_gpio modm: architecture: gpio modm_platform_i2c_bitbang->modm_architecture_gpio modm_architecture_i2c modm: architecture: i2c modm_platform_i2c_bitbang->modm_architecture_i2c modm_platform_gpio modm: platform: gpio modm_platform_i2c_bitbang->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-stm32-f0-f3-f7-g0-g4-l0-l4/","text":"Inter-Integrated Circuit (I\u00b2C) \u00b6 lbuild module: modm:platform:i2c This module is only available for stm32{f0,f3,f7,g0,g4,l0,l4}. Dependencies \u00b6 modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_i2c->modm_architecture_clock modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c->modm_cmsis_device modm_container modm: container modm_platform_i2c->modm_container modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:i2c (stm32{f0,f3,f7,g0,g4,l0,l4})"},{"location":"reference/module/modm-platform-i2c-stm32-f0-f3-f7-g0-g4-l0-l4/#inter-integrated-circuit-i2c","text":"lbuild module: modm:platform:i2c This module is only available for stm32{f0,f3,f7,g0,g4,l0,l4}.","title":"Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-platform-i2c-stm32-f0-f3-f7-g0-g4-l0-l4/#dependencies","text":"modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c->modm_architecture_atomic modm_architecture_clock modm: architecture: clock modm_platform_i2c->modm_architecture_clock modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c->modm_cmsis_device modm_container modm: container modm_platform_i2c->modm_container modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-i2c-stm32-f1-f2-f4-l1/","text":"Inter-Integrated Circuit (I\u00b2C) \u00b6 lbuild module: modm:platform:i2c This module is only available for stm32{f1,f2,f4,l1}. Dependencies \u00b6 modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c->modm_architecture_atomic modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c->modm_cmsis_device modm_container modm: container modm_platform_i2c->modm_container modm_math_algorithm modm: math: algorithm modm_platform_i2c->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:i2c (stm32{f1,f2,f4,l1})"},{"location":"reference/module/modm-platform-i2c-stm32-f1-f2-f4-l1/#inter-integrated-circuit-i2c","text":"lbuild module: modm:platform:i2c This module is only available for stm32{f1,f2,f4,l1}.","title":"Inter-Integrated Circuit (I\u00b2C)"},{"location":"reference/module/modm-platform-i2c-stm32-f1-f2-f4-l1/#dependencies","text":"modm:platform:i2c modm_platform_i2c modm: platform: i2c modm_architecture_accessor modm: architecture: accessor modm_platform_i2c->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_platform_i2c->modm_architecture_atomic modm_architecture_i2c modm: architecture: i2c modm_platform_i2c->modm_architecture_i2c modm_architecture_interrupt modm: architecture: interrupt modm_platform_i2c->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_i2c->modm_cmsis_device modm_container modm: container modm_platform_i2c->modm_container modm_math_algorithm modm: math: algorithm modm_platform_i2c->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_i2c->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-id/","text":"Unique ID \u00b6 lbuild module: modm:platform:id This module is only available for stm32. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:id"},{"location":"reference/module/modm-platform-id/#unique-id","text":"lbuild module: modm:platform:id This module is only available for stm32. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Unique ID"},{"location":"reference/module/modm-platform-itm/","text":"Instrumentation Trace Macrocell (ITM) \u00b6 lbuild module: modm:platform:itm This module provides the ITM port 0 as a (buffered) Uart interface. You can use this class as a transmit-only alternative for logging: modm :: IODeviceWrapper < modm :: platform :: Itm , modm :: IOBuffer :: DiscardIfFull > itm_device ; modm :: IOStream stream ( itm_device ); stream << \"Hello World\" << modm :: endl ; Caveats \u00b6 The ITM is part of the ARM Cortex-M debug functionality and forwards its data to the Trace Port Interface Unit (TPIU) which outputs over the trace pins. Only the SWO trace pin is currently supported (asynchronous tracing). The ITM is not a UART replacement! The TPIU only outputs data when a debugger is attached to the target! The Itm class will safely discard any data if a debugger is not attached, so you can use it for debugging without running the risk of a deadlock. The ITM requires polling! The hardware does not generate a \"buffer empty\" interrupt, so the buffered implementation requires you to call the update() function! By default the Itm class is non-buffered and therefore blocking. You must set the modm:platform:itm:buffer.tx option to non-zero to use the buffered version! Receiving Data \u00b6 You must use OpenOCD to configure your target's hardware, as well as capture the asynchronous trace stream. Is the SWO pin connected to your debugger? Check if your debugger supports trace output and if the SWO pin is actually connected to it on your development board! To log the output to a file called itm.fifo you can call the modm_log_itm command manually. openocd -f modm/openocd.cfg -c \"modm_log_itm itm.fifo 64000000\" You can then either use tail -f itm.fifo to display the raw data stream (which is often enough) or use the itmdump program for an advanced use-case (like de-multiplexing data streams). OpenOCD requires the CPU/HCLK frequency You must provide the CPU/HCLK frequency of your target, so that OpenOCD can correctly set the prescaler for the asynchronous SWO output. When using the modm:build:scons module, you can also use the convenience wrapper, which logs to a temporary file and displays it's contents on the terminal $ scons log-itm fcpu=64000000 \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Single Wire Viewer \u2570\u2500\u2500\u2500\u2500\u2500SWO\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt Hello from the SWO. debug info warning error loop 0 loop 1 loop 2 loop 3 loop 4 loop 5 This module is only available for stm32{f1,f2,f3,f4,f7,g4,l1,l4}. Options \u00b6 buffer.tx \u00b6 Transmit buffer size You must call the update() function repeatedly when a transmit buffer is used, otherwise you have to call flushWriteBuffer() to empty the buffer. Default: 0 Inputs: [0 ... 65534] Dependencies \u00b6 modm:platform:itm modm_platform_itm modm: platform: itm modm_architecture_uart modm: architecture: uart modm_platform_itm->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_itm->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:itm"},{"location":"reference/module/modm-platform-itm/#instrumentation-trace-macrocell-itm","text":"lbuild module: modm:platform:itm This module provides the ITM port 0 as a (buffered) Uart interface. You can use this class as a transmit-only alternative for logging: modm :: IODeviceWrapper < modm :: platform :: Itm , modm :: IOBuffer :: DiscardIfFull > itm_device ; modm :: IOStream stream ( itm_device ); stream << \"Hello World\" << modm :: endl ;","title":"Instrumentation Trace Macrocell (ITM)"},{"location":"reference/module/modm-platform-itm/#caveats","text":"The ITM is part of the ARM Cortex-M debug functionality and forwards its data to the Trace Port Interface Unit (TPIU) which outputs over the trace pins. Only the SWO trace pin is currently supported (asynchronous tracing). The ITM is not a UART replacement! The TPIU only outputs data when a debugger is attached to the target! The Itm class will safely discard any data if a debugger is not attached, so you can use it for debugging without running the risk of a deadlock. The ITM requires polling! The hardware does not generate a \"buffer empty\" interrupt, so the buffered implementation requires you to call the update() function! By default the Itm class is non-buffered and therefore blocking. You must set the modm:platform:itm:buffer.tx option to non-zero to use the buffered version!","title":"Caveats"},{"location":"reference/module/modm-platform-itm/#receiving-data","text":"You must use OpenOCD to configure your target's hardware, as well as capture the asynchronous trace stream. Is the SWO pin connected to your debugger? Check if your debugger supports trace output and if the SWO pin is actually connected to it on your development board! To log the output to a file called itm.fifo you can call the modm_log_itm command manually. openocd -f modm/openocd.cfg -c \"modm_log_itm itm.fifo 64000000\" You can then either use tail -f itm.fifo to display the raw data stream (which is often enough) or use the itmdump program for an advanced use-case (like de-multiplexing data streams). OpenOCD requires the CPU/HCLK frequency You must provide the CPU/HCLK frequency of your target, so that OpenOCD can correctly set the prescaler for the asynchronous SWO output. When using the modm:build:scons module, you can also use the convenience wrapper, which logs to a temporary file and displays it's contents on the terminal $ scons log-itm fcpu=64000000 \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Single Wire Viewer \u2570\u2500\u2500\u2500\u2500\u2500SWO\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt Hello from the SWO. debug info warning error loop 0 loop 1 loop 2 loop 3 loop 4 loop 5 This module is only available for stm32{f1,f2,f3,f4,f7,g4,l1,l4}.","title":"Receiving Data"},{"location":"reference/module/modm-platform-itm/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-itm/#buffertx","text":"Transmit buffer size You must call the update() function repeatedly when a transmit buffer is used, otherwise you have to call flushWriteBuffer() to empty the buffer. Default: 0 Inputs: [0 ... 65534]","title":"buffer.tx"},{"location":"reference/module/modm-platform-itm/#dependencies","text":"modm:platform:itm modm_platform_itm modm: platform: itm modm_architecture_uart modm: architecture: uart modm_platform_itm->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_itm->modm_cmsis_device @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-random/","text":"Random Number Generator (RNG) \u00b6 lbuild module: modm:platform:random This module is only available for stm32{f2,f4,f7,g0,g4,l0,l4}. Dependencies \u00b6 modm:platform:random modm_platform_random modm: platform: random modm_cmsis_device modm: cmsis: device modm_platform_random->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_random->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:random"},{"location":"reference/module/modm-platform-random/#random-number-generator-rng","text":"lbuild module: modm:platform:random This module is only available for stm32{f2,f4,f7,g0,g4,l0,l4}.","title":"Random Number Generator (RNG)"},{"location":"reference/module/modm-platform-random/#dependencies","text":"modm:platform:random modm_platform_random modm: platform: random modm_cmsis_device modm: cmsis: device modm_platform_random->modm_cmsis_device modm_platform_rcc modm: platform: rcc modm_platform_random->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-rcc/","text":"Reset and Clock Control (RCC) \u00b6 lbuild module: modm:platform:rcc This module is only available for stm32. Dependencies \u00b6 modm:platform:rcc modm_platform_rcc modm: platform: rcc modm_cmsis_device modm: cmsis: device modm_platform_rcc->modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_rcc->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_rcc->modm_platform_gpio modm_utils modm: utils modm_platform_rcc->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:rcc"},{"location":"reference/module/modm-platform-rcc/#reset-and-clock-control-rcc","text":"lbuild module: modm:platform:rcc This module is only available for stm32.","title":"Reset and Clock Control (RCC)"},{"location":"reference/module/modm-platform-rcc/#dependencies","text":"modm:platform:rcc modm_platform_rcc modm: platform: rcc modm_cmsis_device modm: cmsis: device modm_platform_rcc->modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_rcc->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_rcc->modm_platform_gpio modm_utils modm: utils modm_platform_rcc->modm_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-rtt/","text":"Real Time Transfer (RTT) \u00b6 lbuild module: modm:platform:rtt This module implements the RTT protocol compatible with OpenOCD. RTT works by placing multiple ring-buffers in RAM which the debugger read and writes using background memory accesses via SWD. It therefore works on any Cortex-M devices without extra pins except for the SWDCLK and SWDIO. See https://www.segger.com/jlink-rtt.html The RTT channels are exposed as a UART interface which you can use like so: modm :: platform :: Rtt rtt ( /* channel= */ 0 ); // Access data directly via UART interface: eg. loop back if ( uint8_t data ; rtt . read ( data )) { rtt . write ( data ); } // Or wrap into an IOStream for printing modm :: IODeviceObjectWrapper < modm :: platform :: Rtt , modm :: IOBuffer :: DiscardIfFull > rtt_device ( rtt ); modm :: IOStream stream ( rtt_device ); stream << \"Hello World\" << modm :: endl ; // Reading is more annoying char data ; stream . get ( data ); if ( data != modm :: IOStream :: eof ) { /* process new data */ } You can define the number of channels and their buffer size by setting the buffer.tx and buffer.rx set options. Note that you can define multiple buffer sizes indexed by channel. Here is an example of three channels: <!-- Channel0: TX only with 256B buffer --> <!-- Channel1: RX only with 128B buffer --> <!-- Channel2: TX with 512B and RX with 64B buffer --> <option name= \"modm:platform:rtt:buffer.tx\" > 256, 0, 512 </option> <option name= \"modm:platform:rtt:buffer.rx\" > 0, 128, 64 </option> You can set the buffer size to 0 if you don't want to use this channel direction. This won't allocate a buffer and save a little RAM. Accessing Data \u00b6 OpenOCD has built-in support for RTT and modm generates a config that opens each RTT channel as a TCP port starting at 9090 (ie. 9090=channel 0, 9091=channel 1, etc). openocd -f modm/openocd.cfg -c modm_rtt You can also call this from inside GDB via the monitor command: (gdb) monitor modm_rtt rtt: Searching for control block 'modm.rtt.modm' rtt: Control block found at 0x20001024 Listening on port 9090 for rtt connections (gdb) You can then use for example telnet 127.0.0.1 9090 to connect to the stream. Note that this connection does not halt the target, you should therefore be able to use this at any point during program execution. A simple telnet client is integrated into the build system generator, however, it can only connect to one stream at a time (disconnect with Ctrl+D). $ scons log-rtt \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Real Time Transfer \u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 Listening on port 9090 for rtt connections loop 51 loop 52 loop 53 ^D $ make log-rtt channel=0 Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 Listening on port 9090 for rtt connections loop 58 loop 60 loop 61 If you want to use this as a proper communication channel with a custom protocol you should implement the OpenOCD config yourself (with different ports). This module is only available for sam, stm32. Options \u00b6 buffer.rx \u00b6 Receive buffer sizes Default: {0} Inputs: [0 ... 65536] buffer.tx \u00b6 Transmit buffer sizes Default: {512} Inputs: [0 ... 65536] Dependencies \u00b6 modm:platform:rtt modm_platform_rtt modm: platform: rtt modm_architecture_uart modm: architecture: uart modm_platform_rtt->modm_architecture_uart @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:rtt"},{"location":"reference/module/modm-platform-rtt/#real-time-transfer-rtt","text":"lbuild module: modm:platform:rtt This module implements the RTT protocol compatible with OpenOCD. RTT works by placing multiple ring-buffers in RAM which the debugger read and writes using background memory accesses via SWD. It therefore works on any Cortex-M devices without extra pins except for the SWDCLK and SWDIO. See https://www.segger.com/jlink-rtt.html The RTT channels are exposed as a UART interface which you can use like so: modm :: platform :: Rtt rtt ( /* channel= */ 0 ); // Access data directly via UART interface: eg. loop back if ( uint8_t data ; rtt . read ( data )) { rtt . write ( data ); } // Or wrap into an IOStream for printing modm :: IODeviceObjectWrapper < modm :: platform :: Rtt , modm :: IOBuffer :: DiscardIfFull > rtt_device ( rtt ); modm :: IOStream stream ( rtt_device ); stream << \"Hello World\" << modm :: endl ; // Reading is more annoying char data ; stream . get ( data ); if ( data != modm :: IOStream :: eof ) { /* process new data */ } You can define the number of channels and their buffer size by setting the buffer.tx and buffer.rx set options. Note that you can define multiple buffer sizes indexed by channel. Here is an example of three channels: <!-- Channel0: TX only with 256B buffer --> <!-- Channel1: RX only with 128B buffer --> <!-- Channel2: TX with 512B and RX with 64B buffer --> <option name= \"modm:platform:rtt:buffer.tx\" > 256, 0, 512 </option> <option name= \"modm:platform:rtt:buffer.rx\" > 0, 128, 64 </option> You can set the buffer size to 0 if you don't want to use this channel direction. This won't allocate a buffer and save a little RAM.","title":"Real Time Transfer (RTT)"},{"location":"reference/module/modm-platform-rtt/#accessing-data","text":"OpenOCD has built-in support for RTT and modm generates a config that opens each RTT channel as a TCP port starting at 9090 (ie. 9090=channel 0, 9091=channel 1, etc). openocd -f modm/openocd.cfg -c modm_rtt You can also call this from inside GDB via the monitor command: (gdb) monitor modm_rtt rtt: Searching for control block 'modm.rtt.modm' rtt: Control block found at 0x20001024 Listening on port 9090 for rtt connections (gdb) You can then use for example telnet 127.0.0.1 9090 to connect to the stream. Note that this connection does not halt the target, you should therefore be able to use this at any point during program execution. A simple telnet client is integrated into the build system generator, however, it can only connect to one stream at a time (disconnect with Ctrl+D). $ scons log-rtt \u256d\u2500\u2500\u2500OpenOCD\u2500\u2500\u2500> Real Time Transfer \u2570\u2500\u2500\u2500\u2500\u2500RTT\u2500\u2500\u2500\u2500\u2500\u2500 stm32f103rbt Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 Listening on port 9090 for rtt connections loop 51 loop 52 loop 53 ^D $ make log-rtt channel=0 Info : rtt: Searching for control block 'modm.rtt.modm' Info : rtt: Control block found at 0x20000008 Listening on port 9090 for rtt connections loop 58 loop 60 loop 61 If you want to use this as a proper communication channel with a custom protocol you should implement the OpenOCD config yourself (with different ports). This module is only available for sam, stm32.","title":"Accessing Data"},{"location":"reference/module/modm-platform-rtt/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-rtt/#bufferrx","text":"Receive buffer sizes Default: {0} Inputs: [0 ... 65536]","title":"buffer.rx"},{"location":"reference/module/modm-platform-rtt/#buffertx","text":"Transmit buffer sizes Default: {512} Inputs: [0 ... 65536]","title":"buffer.tx"},{"location":"reference/module/modm-platform-rtt/#dependencies","text":"modm:platform:rtt modm_platform_rtt modm: platform: rtt modm_architecture_uart modm: architecture: uart modm_platform_rtt->modm_architecture_uart @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-socketcan/","text":"SocketCAN \u00b6 lbuild module: modm:platform:socketcan This module is only available for hosted-linux. Dependencies \u00b6 modm:platform:socketcan modm_platform_socketcan modm: platform: socketcan modm_architecture_can modm: architecture: can modm_platform_socketcan->modm_architecture_can modm_debug modm: debug modm_platform_socketcan->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:socketcan"},{"location":"reference/module/modm-platform-socketcan/#socketcan","text":"lbuild module: modm:platform:socketcan This module is only available for hosted-linux.","title":"SocketCAN"},{"location":"reference/module/modm-platform-socketcan/#dependencies","text":"modm:platform:socketcan modm_platform_socketcan modm: platform: socketcan modm_architecture_can modm: architecture: can modm_platform_socketcan->modm_architecture_can modm_debug modm: debug modm_platform_socketcan->modm_debug @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-avr/","text":"Serial Peripheral Interface (SPI) \u00b6 lbuild module: modm:platform:spi This module is only available for avr. Options \u00b6 busywait \u00b6 Default: False Inputs: [True, False] Dependencies \u00b6 modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_atomic modm: architecture: atomic modm_platform_spi->modm_architecture_atomic modm_architecture_spi modm: architecture: spi modm_platform_spi->modm_architecture_spi modm_math_algorithm modm: math: algorithm modm_platform_spi->modm_math_algorithm modm_math_utils modm: math: utils modm_platform_spi->modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_spi->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:spi (avr)"},{"location":"reference/module/modm-platform-spi-avr/#serial-peripheral-interface-spi","text":"lbuild module: modm:platform:spi This module is only available for avr.","title":"Serial Peripheral Interface (SPI)"},{"location":"reference/module/modm-platform-spi-avr/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-spi-avr/#busywait","text":"Default: False Inputs: [True, False]","title":"busywait"},{"location":"reference/module/modm-platform-spi-avr/#dependencies","text":"modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_atomic modm: architecture: atomic modm_platform_spi->modm_architecture_atomic modm_architecture_spi modm: architecture: spi modm_platform_spi->modm_architecture_spi modm_math_algorithm modm: math: algorithm modm_platform_spi->modm_math_algorithm modm_math_utils modm: math: utils modm_platform_spi->modm_math_utils modm_platform_gpio modm: platform: gpio modm_platform_spi->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-bitbang/","text":"Software Serial Peripheral Interface (SPI) \u00b6 lbuild module: modm:platform:spi.bitbang Dependencies \u00b6 modm:platform:spi.bitbang modm_platform_spi_bitbang modm: platform: spi.bitbang modm_architecture_delay modm: architecture: delay modm_platform_spi_bitbang->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_platform_spi_bitbang->modm_architecture_spi modm_platform_gpio modm: platform: gpio modm_platform_spi_bitbang->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":platform:spi.bitbang"},{"location":"reference/module/modm-platform-spi-bitbang/#software-serial-peripheral-interface-spi","text":"lbuild module: modm:platform:spi.bitbang","title":"Software Serial Peripheral Interface (SPI)"},{"location":"reference/module/modm-platform-spi-bitbang/#dependencies","text":"modm:platform:spi.bitbang modm_platform_spi_bitbang modm: platform: spi.bitbang modm_architecture_delay modm: architecture: delay modm_platform_spi_bitbang->modm_architecture_delay modm_architecture_spi modm: architecture: spi modm_platform_spi_bitbang->modm_architecture_spi modm_platform_gpio modm: platform: gpio modm_platform_spi_bitbang->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-platform-spi-stm32/","text":"Serial Peripheral Interface (SPI) \u00b6 lbuild module: modm:platform:spi This module is only available for stm32. Dependencies \u00b6 modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_register modm: architecture: register modm_platform_spi->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_spi->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_spi->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_spi->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:spi (stm32)"},{"location":"reference/module/modm-platform-spi-stm32/#serial-peripheral-interface-spi","text":"lbuild module: modm:platform:spi This module is only available for stm32.","title":"Serial Peripheral Interface (SPI)"},{"location":"reference/module/modm-platform-spi-stm32/#dependencies","text":"modm:platform:spi modm_platform_spi modm: platform: spi modm_architecture_register modm: architecture: register modm_platform_spi->modm_architecture_register modm_architecture_spi modm: architecture: spi modm_platform_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_spi->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_spi->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_spi->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_spi->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-timer/","text":"Timers (TIM) \u00b6 lbuild module: modm:platform:timer This module is only available for stm32. Dependencies \u00b6 modm:platform:timer modm_platform_timer modm: platform: timer modm_architecture_register modm: architecture: register modm_platform_timer->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_timer->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_timer->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_timer->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:timer"},{"location":"reference/module/modm-platform-timer/#timers-tim","text":"lbuild module: modm:platform:timer This module is only available for stm32.","title":"Timers (TIM)"},{"location":"reference/module/modm-platform-timer/#dependencies","text":"modm:platform:timer modm_platform_timer modm: platform: timer modm_architecture_register modm: architecture: register modm_platform_timer->modm_architecture_register modm_cmsis_device modm: cmsis: device modm_platform_timer->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_timer->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_timer->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-avr-90-mega/","text":"Universal Asynchronous Receiver Transmitter (UART) \u00b6 lbuild module: modm:platform:uart This module is only available for avr{90,mega}. Options \u00b6 buffer.rx \u00b6 This option is only available for avrmega. Default: 8 Inputs: [1 .. 8 .. 254] buffer.tx \u00b6 This option is only available for avrmega. Default: 64 Inputs: [1 .. 64 .. 254] Dependencies \u00b6 modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart->modm_architecture_atomic modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart->modm_architecture_interrupt modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_math_algorithm modm: math: algorithm modm_platform_uart->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:uart (avr{90,mega})"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#universal-asynchronous-receiver-transmitter-uart","text":"lbuild module: modm:platform:uart This module is only available for avr{90,mega}.","title":"Universal Asynchronous Receiver Transmitter (UART)"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#options","text":"","title":"Options"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#bufferrx","text":"This option is only available for avrmega. Default: 8 Inputs: [1 .. 8 .. 254]","title":"buffer.rx"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#buffertx","text":"This option is only available for avrmega. Default: 64 Inputs: [1 .. 64 .. 254]","title":"buffer.tx"},{"location":"reference/module/modm-platform-uart-avr-90-mega/#dependencies","text":"modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart->modm_architecture_atomic modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart->modm_architecture_interrupt modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_math_algorithm modm: math: algorithm modm_platform_uart->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-hosted-darwin-linux-rpi/","text":"UART and Serial \u00b6 lbuild module: modm:platform:uart This module is only available for hosted{darwin,linux,rpi}. Dependencies \u00b6 modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_debug modm: debug modm_platform_uart->modm_debug modm_io modm: io modm_platform_uart->modm_io @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:uart (hosted{darwin,linux,rpi})"},{"location":"reference/module/modm-platform-uart-hosted-darwin-linux-rpi/#uart-and-serial","text":"lbuild module: modm:platform:uart This module is only available for hosted{darwin,linux,rpi}.","title":"UART and Serial"},{"location":"reference/module/modm-platform-uart-hosted-darwin-linux-rpi/#dependencies","text":"modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_debug modm: debug modm_platform_uart->modm_debug modm_io modm: io modm_platform_uart->modm_io @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-sam/","text":"Universal Asynchronous Receiver Transmitter (UART) \u00b6 lbuild module: modm:platform:uart This module is only available for sam. Dependencies \u00b6 modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_uart->modm_math_algorithm modm_platform_gclk modm: platform: gclk modm_platform_uart->modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:uart (sam)"},{"location":"reference/module/modm-platform-uart-sam/#universal-asynchronous-receiver-transmitter-uart","text":"lbuild module: modm:platform:uart This module is only available for sam.","title":"Universal Asynchronous Receiver Transmitter (UART)"},{"location":"reference/module/modm-platform-uart-sam/#dependencies","text":"modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_uart->modm_math_algorithm modm_platform_gclk modm: platform: gclk modm_platform_uart->modm_platform_gclk modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-spi/","text":"USART in SPI Mode \u00b6 lbuild module: modm:platform:uart.spi This module is only available for stm32. Dependencies \u00b6 modm:platform:uart.spi modm_platform_uart_spi modm: platform: uart.spi modm_architecture_spi modm: architecture: spi modm_platform_uart_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_uart_spi->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_uart_spi->modm_platform_gpio modm_platform_uart modm: platform: uart modm_platform_uart_spi->modm_platform_uart @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:uart.spi"},{"location":"reference/module/modm-platform-uart-spi/#usart-in-spi-mode","text":"lbuild module: modm:platform:uart.spi This module is only available for stm32.","title":"USART in SPI Mode"},{"location":"reference/module/modm-platform-uart-spi/#dependencies","text":"modm:platform:uart.spi modm_platform_uart_spi modm: platform: uart.spi modm_architecture_spi modm: architecture: spi modm_platform_uart_spi->modm_architecture_spi modm_cmsis_device modm: cmsis: device modm_platform_uart_spi->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_uart_spi->modm_platform_gpio modm_platform_uart modm: platform: uart modm_platform_uart_spi->modm_platform_uart @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-uart-stm32/","text":"Universal Asynchronous Receiver Transmitter (UART) \u00b6 lbuild module: modm:platform:uart This module is only available for stm32. Dependencies \u00b6 modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart->modm_architecture_atomic modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart->modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_uart->modm_architecture_register modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_uart->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_uart->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:uart (stm32)"},{"location":"reference/module/modm-platform-uart-stm32/#universal-asynchronous-receiver-transmitter-uart","text":"lbuild module: modm:platform:uart This module is only available for stm32.","title":"Universal Asynchronous Receiver Transmitter (UART)"},{"location":"reference/module/modm-platform-uart-stm32/#dependencies","text":"modm:platform:uart modm_platform_uart modm: platform: uart modm_architecture_atomic modm: architecture: atomic modm_platform_uart->modm_architecture_atomic modm_architecture_interrupt modm: architecture: interrupt modm_platform_uart->modm_architecture_interrupt modm_architecture_register modm: architecture: register modm_platform_uart->modm_architecture_register modm_architecture_uart modm: architecture: uart modm_platform_uart->modm_architecture_uart modm_cmsis_device modm: cmsis: device modm_platform_uart->modm_cmsis_device modm_math_algorithm modm: math: algorithm modm_platform_uart->modm_math_algorithm modm_platform_gpio modm: platform: gpio modm_platform_uart->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_uart->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-usb-fs/","text":"Full Speed \u00b6 lbuild module: modm:platform:usb:fs This module is only available for stm32{f1,f2,f4,f7,l4}. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:usb:fs"},{"location":"reference/module/modm-platform-usb-fs/#full-speed","text":"lbuild module: modm:platform:usb:fs This module is only available for stm32{f1,f2,f4,f7,l4}. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Full Speed"},{"location":"reference/module/modm-platform-usb-hs/","text":"High Speed \u00b6 lbuild module: modm:platform:usb:hs This module is only available for stm32{f2,f4,f7}. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:usb:hs"},{"location":"reference/module/modm-platform-usb-hs/#high-speed","text":"lbuild module: modm:platform:usb:hs This module is only available for stm32{f2,f4,f7}. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"High Speed"},{"location":"reference/module/modm-platform-usb-sam/","text":"Universal Serial Bus (USB) \u00b6 lbuild module: modm:platform:usb This module is only available for sam. Dependencies \u00b6 modm:platform:usb modm_platform_usb modm: platform: usb modm_architecture_interrupt modm: architecture: interrupt modm_platform_usb->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_usb->modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_usb->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_usb->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:usb (sam)"},{"location":"reference/module/modm-platform-usb-sam/#universal-serial-bus-usb","text":"lbuild module: modm:platform:usb This module is only available for sam.","title":"Universal Serial Bus (USB)"},{"location":"reference/module/modm-platform-usb-sam/#dependencies","text":"modm:platform:usb modm_platform_usb modm: platform: usb modm_architecture_interrupt modm: architecture: interrupt modm_platform_usb->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_usb->modm_cmsis_device modm_platform_clock modm: platform: clock modm_platform_usb->modm_platform_clock modm_platform_gpio modm: platform: gpio modm_platform_usb->modm_platform_gpio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform-usb-stm32-f0-f1-f2-f3-f4-f7-g4-l0-l1-l4/","text":"Universal Serial Bus (USB) \u00b6 lbuild module: modm:platform:usb This module is only available for stm32{f0,f1,f2,f3,f4,f7,g4,l0,l1,l4}. Queries \u00b6 irqs \u00b6 Filters the USB interrupts by port: usb_irqs : All unfiltered USB interrupts port_irqs : Filtered USB interrupts categorized by port: fs or hs . is_remap : True when port_irqs contains remapped IRQs (specific to STM32F3) Interrupts used by USB FS: OTG_FS (no suffix) USB USBWakeUp (no suffix) USB_LP* (any suffix) USB_HP* (any suffix) Interrupts used by USB HS: OTG_HS (no suffix) :returns: a dictionary of USB interrupt properties Dependencies \u00b6 modm:platform:usb modm_platform_usb modm: platform: usb modm_architecture_interrupt modm: architecture: interrupt modm_platform_usb->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_usb->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_usb->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_usb->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":platform:usb (stm32{f0,f1,f2,f3,f4,f7,g4,l0,l1,l4})"},{"location":"reference/module/modm-platform-usb-stm32-f0-f1-f2-f3-f4-f7-g4-l0-l1-l4/#universal-serial-bus-usb","text":"lbuild module: modm:platform:usb This module is only available for stm32{f0,f1,f2,f3,f4,f7,g4,l0,l1,l4}.","title":"Universal Serial Bus (USB)"},{"location":"reference/module/modm-platform-usb-stm32-f0-f1-f2-f3-f4-f7-g4-l0-l1-l4/#queries","text":"","title":"Queries"},{"location":"reference/module/modm-platform-usb-stm32-f0-f1-f2-f3-f4-f7-g4-l0-l1-l4/#irqs","text":"Filters the USB interrupts by port: usb_irqs : All unfiltered USB interrupts port_irqs : Filtered USB interrupts categorized by port: fs or hs . is_remap : True when port_irqs contains remapped IRQs (specific to STM32F3) Interrupts used by USB FS: OTG_FS (no suffix) USB USBWakeUp (no suffix) USB_LP* (any suffix) USB_HP* (any suffix) Interrupts used by USB HS: OTG_HS (no suffix) :returns: a dictionary of USB interrupt properties","title":"irqs"},{"location":"reference/module/modm-platform-usb-stm32-f0-f1-f2-f3-f4-f7-g4-l0-l1-l4/#dependencies","text":"modm:platform:usb modm_platform_usb modm: platform: usb modm_architecture_interrupt modm: architecture: interrupt modm_platform_usb->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_platform_usb->modm_cmsis_device modm_platform_gpio modm: platform: gpio modm_platform_usb->modm_platform_gpio modm_platform_rcc modm: platform: rcc modm_platform_usb->modm_platform_rcc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-platform/","text":"Platform HAL \u00b6 lbuild module: modm:platform Target-specific implementation of the Hardware Abstraction Layer.","title":":platform"},{"location":"reference/module/modm-platform/#platform-hal","text":"lbuild module: modm:platform Target-specific implementation of the Hardware Abstraction Layer.","title":"Platform HAL"},{"location":"reference/module/modm-processing-protothread/","text":"Protothreads \u00b6 lbuild module: modm:processing:protothread Protothreads are extremely lightweight stackless threads designed for severely memory constrained systems, such as small embedded systems or wireless sensor network nodes. Protothreads provide linear code execution for event-driven systems implemented in C. Protothreads can be used with or without an underlying operating system to provide blocking event-handlers. Protothreads provide sequential flow of control without complex state machines or full multi-threading. Since they implement some kind of cooperative multi-threading, Protothreads are non-preemptable. Therefore, a context switch can only take place on blocking operations, which means you don't need complex synchronization. Protothreads are also stackless, so local variables are not preserved across context switches, and must instead become member variables of the modm::Protothread subclass A protothread runs within a single function ( modm::Protothread::run() ) and cannot span over other functions. A protothread may call normal functions, but cannot block inside a called function. Blocking inside nested function calls is instead made by spawning a separate protothread for each potentially blocking function. The protothread concept was developed by Adam Dunkels and Oliver Schmidt: http://dunkels.com/adam/pt Originally ported to C++ for use by Hamilton Jet ( www.hamiltonjet.co.nz ) by Ben Hoyt, but stripped down for public release. Example \u00b6 #include <modm/processing/protothread.hpp> using Led = GpioB0 ; class BlinkingLight : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { timeout . restart ( 100 ms ); Led :: set (); PT_WAIT_UNTIL ( timeout . isExpired ()); timeout . restart ( 200 ms ); Led :: reset (); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } private : modm :: ShortTimeout timeout ; }; // ... BlinkingLight light ; while ( true ) { light . run (); } Dependencies \u00b6 modm:processing:protothread modm_processing_protothread modm: processing: protothread modm_architecture modm: architecture modm_processing_protothread->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":processing:protothread"},{"location":"reference/module/modm-processing-protothread/#protothreads","text":"lbuild module: modm:processing:protothread Protothreads are extremely lightweight stackless threads designed for severely memory constrained systems, such as small embedded systems or wireless sensor network nodes. Protothreads provide linear code execution for event-driven systems implemented in C. Protothreads can be used with or without an underlying operating system to provide blocking event-handlers. Protothreads provide sequential flow of control without complex state machines or full multi-threading. Since they implement some kind of cooperative multi-threading, Protothreads are non-preemptable. Therefore, a context switch can only take place on blocking operations, which means you don't need complex synchronization. Protothreads are also stackless, so local variables are not preserved across context switches, and must instead become member variables of the modm::Protothread subclass A protothread runs within a single function ( modm::Protothread::run() ) and cannot span over other functions. A protothread may call normal functions, but cannot block inside a called function. Blocking inside nested function calls is instead made by spawning a separate protothread for each potentially blocking function. The protothread concept was developed by Adam Dunkels and Oliver Schmidt: http://dunkels.com/adam/pt Originally ported to C++ for use by Hamilton Jet ( www.hamiltonjet.co.nz ) by Ben Hoyt, but stripped down for public release.","title":"Protothreads"},{"location":"reference/module/modm-processing-protothread/#example","text":"#include <modm/processing/protothread.hpp> using Led = GpioB0 ; class BlinkingLight : public modm :: pt :: Protothread { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { timeout . restart ( 100 ms ); Led :: set (); PT_WAIT_UNTIL ( timeout . isExpired ()); timeout . restart ( 200 ms ); Led :: reset (); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } private : modm :: ShortTimeout timeout ; }; // ... BlinkingLight light ; while ( true ) { light . run (); }","title":"Example"},{"location":"reference/module/modm-processing-protothread/#dependencies","text":"modm:processing:protothread modm_processing_protothread modm: processing: protothread modm_architecture modm: architecture modm_processing_protothread->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-processing-resumable/","text":"Resumable Functions \u00b6 lbuild module: modm:processing:resumable An implementation of lightweight resumable functions which allow for nested calling. This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality. Note that you should call resumable functions within a protothreads, with the PT_CALL(group.resumable()) macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the RF_CALL(group.resumable()) . You may use the RF_CALL_BLOCKING(group.resumable()) macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended. Resumable functions are not thread-safe! Use an external mutex to arbitrate access if two Protothreads access the same resumable function. You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group's functions. So you need to inherit your group from modm::Resumable<#Functions> , and from modm::NestedResumable<#Functions> respectively. Independent operation \u00b6 You must begin each resumable function using RF_BEGIN(index) where index is the unique index of your resumable function starting at zero. You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) . Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the NestedResumable class for mutually exclusive resumable functions, which also require a little less memory. Nested operation \u00b6 You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the resumable.begin.nesting assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code. The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return modm::rf::WrongState . Using the RF_CALL(resumable()) macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases. You must begin each resumable function using RF_BEGIN() . You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) . Example \u00b6 Here is a (slightly over-engineered) example: #include <modm/platform/platform.hpp> #include <modm/processing/processing.hpp> using Led = GpioOutputB0 ; class BlinkingLight : public modm :: pt :: Protothread , private modm :: NestedResumable < 2 > { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { Led :: set (); PT_CALL ( waitForTimer ()); Led :: reset (); PT_CALL ( setTimer ( 200 )); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } modm :: ResumableResult < bool > waitForTimer () { RF_BEGIN (); // nested calling is allowed if ( RF_CALL ( setTimer ( 100 ))) { RF_WAIT_UNTIL ( timeout . isExpired ()); RF_RETURN ( true ); } RF_END_RETURN ( false ); } modm :: ResumableResult < bool > setTimer ( uint16_t new_timeout ) { RF_BEGIN (); timeout . restart ( std :: chrono :: milliseconds ( new_timeout )); if ( timeout . isArmed ()) { RF_RETURN ( true ); } // clean up code goes here RF_END_RETURN ( false ); } private : modm :: ShortTimeout timeout ; }; BlinkingLight light ; while ( true ) { light . run (); } For other examples take a look in the examples folder in the modm root folder. The given example is in modm/examples/generic/resumable . Options \u00b6 check_nesting_depth \u00b6 Check nesting call depth Nested resumable functions protect against memory corruption by checking if the nesting level is within the allocated nesting level depth, on first entry to the function. If the allocated nesting level is exceeded, the assertion resumable.begin.nesting fails. You may disable this behavior by disabling this check, then instead of the assertion, the function on entry returns the modm::rf::NestingError state value. PT_CALL() and RF_CALL() macros will respond to this error by stopping function polling and just continuing program execution. Performance Penalty This check is performed during the call to RF_BEGIN(N) , so exactly once on function entry and not during every polling call, so the performance penalty is relatively small. Default: True Inputs: [True, False] Dependencies \u00b6 modm:processing:resumable modm_processing_resumable modm: processing: resumable modm_architecture_assert modm: architecture: assert modm_processing_resumable->modm_architecture_assert @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":processing:resumable"},{"location":"reference/module/modm-processing-resumable/#resumable-functions","text":"lbuild module: modm:processing:resumable An implementation of lightweight resumable functions which allow for nested calling. This base class and its macros allows you to implement and use several resumable functions in one class. This allows you to modularize your code by placing it into its own resumable functions instead of the placing everything into one big method. It also allows you to call and run resumable functions within your resumables, so you can reuse their functionality. Note that you should call resumable functions within a protothreads, with the PT_CALL(group.resumable()) macro, which will return the result of the resumable function. To call a resumable function inside another resumable function, use the RF_CALL(group.resumable()) . You may use the RF_CALL_BLOCKING(group.resumable()) macro to execute a resumable function outside of a protothread, however, this which will force the CPU to busy-wait until the resumable function ended. Resumable functions are not thread-safe! Use an external mutex to arbitrate access if two Protothreads access the same resumable function. You can either run your group of resumable functions independently from each other, or only run one function at a time, but it may nest calls to its own group's functions. So you need to inherit your group from modm::Resumable<#Functions> , and from modm::NestedResumable<#Functions> respectively.","title":"Resumable Functions"},{"location":"reference/module/modm-processing-resumable/#independent-operation","text":"You must begin each resumable function using RF_BEGIN(index) where index is the unique index of your resumable function starting at zero. You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) . Be aware that this class keeps a separate state for each of your resumable functions. This allows each resumable function to be run at the same time. This might require the use of an internal semaphore or mutex if such dependencies exist in your use case. Take a look at the NestedResumable class for mutually exclusive resumable functions, which also require a little less memory.","title":"Independent operation"},{"location":"reference/module/modm-processing-resumable/#nested-operation","text":"You are responsible to choosing the right nesting depth! This class will guard itself against calling another resumable function at too deep a nesting level and fail the resumable.begin.nesting assertion! It is then up to you to recognize this in your program design and increase the nesting depth or rethink your code. The resumable functions of this class are mutually exclusive, so only one resumable function of the same object can run at the same time. Even if you call another resumable function, it will simply return modm::rf::WrongState . Using the RF_CALL(resumable()) macro, you can wait for these resumable functions to become available and then run them, so you usually do not need to worry about those cases. You must begin each resumable function using RF_BEGIN() . You may exit and return a value by using RF_RETURN(value) or return the result of another resumable function using RF_RETURN_CALL(resumable()) . This return value is wrapped in a modm::ResumableResult<Type> struct and transparently returned by the RF_CALL macro so it can be used to influence your program flow. If the resumable function reaches RF_END() it will exit automatically, with the result of 0 cast to the return type. Should you wish to return a value at the end, you may use RF_END_RETURN(value) . You may also return the result of another resumable function using RF_END_RETURN_CALL(resumable()) .","title":"Nested operation"},{"location":"reference/module/modm-processing-resumable/#example","text":"Here is a (slightly over-engineered) example: #include <modm/platform/platform.hpp> #include <modm/processing/processing.hpp> using Led = GpioOutputB0 ; class BlinkingLight : public modm :: pt :: Protothread , private modm :: NestedResumable < 2 > { public : bool run () { PT_BEGIN (); // set everything up Led :: setOutput (); Led :: set (); while ( true ) { Led :: set (); PT_CALL ( waitForTimer ()); Led :: reset (); PT_CALL ( setTimer ( 200 )); PT_WAIT_UNTIL ( timeout . isExpired ()); } PT_END (); } modm :: ResumableResult < bool > waitForTimer () { RF_BEGIN (); // nested calling is allowed if ( RF_CALL ( setTimer ( 100 ))) { RF_WAIT_UNTIL ( timeout . isExpired ()); RF_RETURN ( true ); } RF_END_RETURN ( false ); } modm :: ResumableResult < bool > setTimer ( uint16_t new_timeout ) { RF_BEGIN (); timeout . restart ( std :: chrono :: milliseconds ( new_timeout )); if ( timeout . isArmed ()) { RF_RETURN ( true ); } // clean up code goes here RF_END_RETURN ( false ); } private : modm :: ShortTimeout timeout ; }; BlinkingLight light ; while ( true ) { light . run (); } For other examples take a look in the examples folder in the modm root folder. The given example is in modm/examples/generic/resumable .","title":"Example"},{"location":"reference/module/modm-processing-resumable/#options","text":"","title":"Options"},{"location":"reference/module/modm-processing-resumable/#check_nesting_depth","text":"Check nesting call depth Nested resumable functions protect against memory corruption by checking if the nesting level is within the allocated nesting level depth, on first entry to the function. If the allocated nesting level is exceeded, the assertion resumable.begin.nesting fails. You may disable this behavior by disabling this check, then instead of the assertion, the function on entry returns the modm::rf::NestingError state value. PT_CALL() and RF_CALL() macros will respond to this error by stopping function polling and just continuing program execution. Performance Penalty This check is performed during the call to RF_BEGIN(N) , so exactly once on function entry and not during every polling call, so the performance penalty is relatively small. Default: True Inputs: [True, False]","title":"check_nesting_depth"},{"location":"reference/module/modm-processing-resumable/#dependencies","text":"modm:processing:resumable modm_processing_resumable modm: processing: resumable modm_architecture_assert modm: architecture: assert modm_processing_resumable->modm_architecture_assert @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-processing-rtos/","text":"RTOS Abstractions \u00b6 lbuild module: modm:processing:rtos Basic building blocks of an RTOS abstracted as C++ classes and implemented either with FreeRTOS or stdlibc++. This module is only available for hosted, stm32. Dependencies \u00b6 modm:processing:rtos modm_processing_rtos modm: processing: rtos modm_freertos modm: freertos modm_processing_rtos->modm_freertos @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":processing:rtos"},{"location":"reference/module/modm-processing-rtos/#rtos-abstractions","text":"lbuild module: modm:processing:rtos Basic building blocks of an RTOS abstracted as C++ classes and implemented either with FreeRTOS or stdlibc++. This module is only available for hosted, stm32.","title":"RTOS Abstractions"},{"location":"reference/module/modm-processing-rtos/#dependencies","text":"modm:processing:rtos modm_processing_rtos modm: processing: rtos modm_freertos modm: freertos modm_processing_rtos->modm_freertos @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-processing-scheduler/","text":"Generic Scheduler \u00b6 lbuild module: modm:processing:scheduler Priority task scheduling Dependencies \u00b6 modm:processing:scheduler modm_processing_scheduler modm: processing: scheduler modm_architecture_accessor modm: architecture: accessor modm_processing_scheduler->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_processing_scheduler->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":processing:scheduler"},{"location":"reference/module/modm-processing-scheduler/#generic-scheduler","text":"lbuild module: modm:processing:scheduler Priority task scheduling","title":"Generic Scheduler"},{"location":"reference/module/modm-processing-scheduler/#dependencies","text":"modm:processing:scheduler modm_processing_scheduler modm: processing: scheduler modm_architecture_accessor modm: architecture: accessor modm_processing_scheduler->modm_architecture_accessor modm_architecture_atomic modm: architecture: atomic modm_processing_scheduler->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-processing-timer/","text":"Software Timers \u00b6 lbuild module: modm:processing:timer This module provides polling based software timers for executing code after a delay or periodically in millisecond resolution via modm::Clock and in microsecond resolution via modm::PreciseClock . To delay or delegate execution to the future, you can use modm::Timeout to set a duration after which the timeout expires and executes your code: modm :: Timeout timeout { 100 ms }; while ( not timeout . isExpired ()) ; // your code after a delay However, this construct is not very useful, particularly since you could also simply use modm::delay(100ms) for this, so instead use the execute() method to poll non-blockingly for expiration: modm :: Timeout timeout { 100 ms }; void update () { if ( timeout . execute ()) { // your code after a expiration } } // You must call the update() function in your main loop now! int main () { while ( 1 ) { update (); } } The execute() method returns true only once after expiration, so it can be continuously polled somewhere in your code. A more comfortable use-case is to use a modm::Timeout inside a class that needs to provide some asynchronous method for timekeeping: class DelayEvents { modm :: Timeout timeout ; public : void event () { timeout . restart ( 100 ms ); } void update () { if ( timeout . execute ()) { // delegated code here } } } However, for more complex use-cases, these classes are intended to be used with Protothreads (from module modm:processing:protothread ) or Resumable Functions (from module modm:processing:resumable ) to implement non-blocking delays. class FancyDelayEvents : public modm :: pt :: Protothread { modm :: Timeout timeout ; public : void event () { this -> restart (); // restart entire protothread } bool update () { PT_BEGIN (); // pre-delay computation timeout . restart ( 100 ms ); PT_WAIT_UNTIL ( timeout . isExpired ()); // post-delay computation PT_END (); } } For periodic timeouts, you could simply restart the timeout, however, the restart() method schedules a timeout from the current time onwards: void update () { if ( timeout . execute ()) { // delayed code timeout . restart (); // restarts but with *current* time!!! } } This can lead to longer period than required, particularly in a system that has a lot to do and cannot service every timeout immediately. The solution is to use a modm::PeriodicTimer , which only reimplements the execute() method to automatically restart the timer, by adding the interval to the old time, thus keeping the period accurate: modm :: PeriodicTimer timer { 100 ms }; void update () { if ( timer . execute ()) // automatically restarts { // blink an LED or something } } The execute() method actually returns the number of missed periods, so that in a heavily congested system you do not need to keep track of time yourself. This can be particularly useful when dealing with soft-time physical systems like LED animations or control loops: modm :: PeriodicTimer timer { 1 ms }; // render at 1kHz ideally void update () { // call only once regarless of the number of periods if ( const size_t periods = timer . execute (); periods ) { animation . step ( periods ); // still compute the missing steps animation . render (); // but only render once please } // or alternatively to call the code the number of missed periods for ( auto periods { timer . execute ()}; periods ; periods -- ) { // periods is decreasing! } // This is fine, since execute() is evaluated only once! for ( auto periods : modm :: range ( timer . execute ())) { // periods is increasing! } // THIS WILL NOT WORK, since execute() reschedules itself immediately! for ( auto periods { 0 }; periods < timer . execute (); periods ++ ) { // called at most only once!!! periods == 0 always! } } DO NOT use for hard real time systems! You are responsible for polling these timers execute() methods as often as required. If you need to meed hard real time deadlines these are not the timers you are looking for! Timers are stopped by default! If you want to start a timer at construction time, give the constructor a duration. Duration Zero will expire the timer immediately Resolution \u00b6 Two timer resolutions are available, using modm::Clock for milliseconds and modm::PreciseClock for microseconds. They follow the same naming scheme: modm::Timeout , modm::PeriodicTimer : 49 days in milliseconds and 8 bytes. modm::PreciseTimeout , modm::PrecisePeriodicTimer : 71 mins in microseconds and 8 bytes. If you deal with short time periods, you can save a little memory by using the 16-bit versions of the same timers: modm::ShortTimeout , modm::ShortPeriodicTimer : 65 seconds in milliseconds and 4 bytes. modm::ShortPreciseTimeout , modm::ShortPrecisePeriodicTimer : 65 milliseconds in microseconds and 4 bytes. Dependencies \u00b6 modm:processing:timer modm_processing_timer modm: processing: timer modm_architecture_assert modm: architecture: assert modm_processing_timer->modm_architecture_assert modm_architecture_clock modm: architecture: clock modm_processing_timer->modm_architecture_clock modm_io modm: io modm_processing_timer->modm_io modm_math_utils modm: math: utils modm_processing_timer->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":processing:timer"},{"location":"reference/module/modm-processing-timer/#software-timers","text":"lbuild module: modm:processing:timer This module provides polling based software timers for executing code after a delay or periodically in millisecond resolution via modm::Clock and in microsecond resolution via modm::PreciseClock . To delay or delegate execution to the future, you can use modm::Timeout to set a duration after which the timeout expires and executes your code: modm :: Timeout timeout { 100 ms }; while ( not timeout . isExpired ()) ; // your code after a delay However, this construct is not very useful, particularly since you could also simply use modm::delay(100ms) for this, so instead use the execute() method to poll non-blockingly for expiration: modm :: Timeout timeout { 100 ms }; void update () { if ( timeout . execute ()) { // your code after a expiration } } // You must call the update() function in your main loop now! int main () { while ( 1 ) { update (); } } The execute() method returns true only once after expiration, so it can be continuously polled somewhere in your code. A more comfortable use-case is to use a modm::Timeout inside a class that needs to provide some asynchronous method for timekeeping: class DelayEvents { modm :: Timeout timeout ; public : void event () { timeout . restart ( 100 ms ); } void update () { if ( timeout . execute ()) { // delegated code here } } } However, for more complex use-cases, these classes are intended to be used with Protothreads (from module modm:processing:protothread ) or Resumable Functions (from module modm:processing:resumable ) to implement non-blocking delays. class FancyDelayEvents : public modm :: pt :: Protothread { modm :: Timeout timeout ; public : void event () { this -> restart (); // restart entire protothread } bool update () { PT_BEGIN (); // pre-delay computation timeout . restart ( 100 ms ); PT_WAIT_UNTIL ( timeout . isExpired ()); // post-delay computation PT_END (); } } For periodic timeouts, you could simply restart the timeout, however, the restart() method schedules a timeout from the current time onwards: void update () { if ( timeout . execute ()) { // delayed code timeout . restart (); // restarts but with *current* time!!! } } This can lead to longer period than required, particularly in a system that has a lot to do and cannot service every timeout immediately. The solution is to use a modm::PeriodicTimer , which only reimplements the execute() method to automatically restart the timer, by adding the interval to the old time, thus keeping the period accurate: modm :: PeriodicTimer timer { 100 ms }; void update () { if ( timer . execute ()) // automatically restarts { // blink an LED or something } } The execute() method actually returns the number of missed periods, so that in a heavily congested system you do not need to keep track of time yourself. This can be particularly useful when dealing with soft-time physical systems like LED animations or control loops: modm :: PeriodicTimer timer { 1 ms }; // render at 1kHz ideally void update () { // call only once regarless of the number of periods if ( const size_t periods = timer . execute (); periods ) { animation . step ( periods ); // still compute the missing steps animation . render (); // but only render once please } // or alternatively to call the code the number of missed periods for ( auto periods { timer . execute ()}; periods ; periods -- ) { // periods is decreasing! } // This is fine, since execute() is evaluated only once! for ( auto periods : modm :: range ( timer . execute ())) { // periods is increasing! } // THIS WILL NOT WORK, since execute() reschedules itself immediately! for ( auto periods { 0 }; periods < timer . execute (); periods ++ ) { // called at most only once!!! periods == 0 always! } } DO NOT use for hard real time systems! You are responsible for polling these timers execute() methods as often as required. If you need to meed hard real time deadlines these are not the timers you are looking for! Timers are stopped by default! If you want to start a timer at construction time, give the constructor a duration. Duration Zero will expire the timer immediately","title":"Software Timers"},{"location":"reference/module/modm-processing-timer/#resolution","text":"Two timer resolutions are available, using modm::Clock for milliseconds and modm::PreciseClock for microseconds. They follow the same naming scheme: modm::Timeout , modm::PeriodicTimer : 49 days in milliseconds and 8 bytes. modm::PreciseTimeout , modm::PrecisePeriodicTimer : 71 mins in microseconds and 8 bytes. If you deal with short time periods, you can save a little memory by using the 16-bit versions of the same timers: modm::ShortTimeout , modm::ShortPeriodicTimer : 65 seconds in milliseconds and 4 bytes. modm::ShortPreciseTimeout , modm::ShortPrecisePeriodicTimer : 65 milliseconds in microseconds and 4 bytes.","title":"Resolution"},{"location":"reference/module/modm-processing-timer/#dependencies","text":"modm:processing:timer modm_processing_timer modm: processing: timer modm_architecture_assert modm: architecture: assert modm_processing_timer->modm_architecture_assert modm_architecture_clock modm: architecture: clock modm_processing_timer->modm_architecture_clock modm_io modm: io modm_processing_timer->modm_io modm_math_utils modm: math: utils modm_processing_timer->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-processing/","text":"Processing \u00b6 lbuild module: modm:processing Constructs to influence program flow execution, timing, synchronization and delegation.","title":":processing"},{"location":"reference/module/modm-processing/#processing","text":"lbuild module: modm:processing Constructs to influence program flow execution, timing, synchronization and delegation.","title":"Processing"},{"location":"reference/module/modm-ros/","text":"ROS Library \u00b6 lbuild module: modm:ros Repository of generated messages headers for rosserial. See https://github.com/modm-io/ros-lib .","title":":ros"},{"location":"reference/module/modm-ros/#ros-library","text":"lbuild module: modm:ros Repository of generated messages headers for rosserial. See https://github.com/modm-io/ros-lib .","title":"ROS Library"},{"location":"reference/module/modm-stdc%2B%2B/","text":"C++ Standard Environment \u00b6 lbuild module: modm:stdc++ Refines the C++ language to make it easier to use on embedded targets. Depending on the module options, the compiler options are appended with either: -fno-exceptions : no C++ exceptions. -fno-rtti : no C++ run-time type information. or: -fexceptions : with C++ exceptions. -frtti : with C++ run-time type information. AVR \u00b6 A partial port of GCC 8 libstdc++ is provided: See https://github.com/modm-io/avr-libstdcpp . Options \u00b6 assert_on_exception \u00b6 Assert on exception in stdlib. Set to False to save flash. This option is only available for avr. Default: True Inputs: [True, False] exceptions \u00b6 C++ Exceptions Enables the full use of C++ exception handling. Check your code size The inclusion of the stack unwind tables will increase your code size quite a bit. Check whether your target has enough memory for this! This option is only available for sam, stm32. Default: False Inputs: [True, False] rtti \u00b6 C++ Runtime Type Information Enables the full use of C++ runtime type information. Check your code size The inclusion of the RTTI information will increase your code size quite a bit. Check whether your target has enough memory for this! This option is only available for sam, stm32. Default: False Inputs: [True, False] safe_statics \u00b6 C++ Safe Statics Initialization Enables safe initialization of statics inside functions and interrupts. In case of recursive initialization the debug assertion cxa.guard.recursion is raised. Further reading on this topic: C++ ABI for the ARM Architecture Adventures in Systems Programming: C++ Local Statics C++11 thread-safe static object initialization This option is only available for sam, stm32. Default: True Inputs: [True, False] Dependencies \u00b6 modm:stdc++ modm_stdc++ modm: stdc++ modm_architecture_assert modm: architecture: assert modm_stdc++->modm_architecture_assert modm_stdc modm: stdc modm_stdc++->modm_stdc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":stdc++"},{"location":"reference/module/modm-stdc%2B%2B/#c-standard-environment","text":"lbuild module: modm:stdc++ Refines the C++ language to make it easier to use on embedded targets. Depending on the module options, the compiler options are appended with either: -fno-exceptions : no C++ exceptions. -fno-rtti : no C++ run-time type information. or: -fexceptions : with C++ exceptions. -frtti : with C++ run-time type information.","title":"C++ Standard Environment"},{"location":"reference/module/modm-stdc%2B%2B/#avr","text":"A partial port of GCC 8 libstdc++ is provided: See https://github.com/modm-io/avr-libstdcpp .","title":"AVR"},{"location":"reference/module/modm-stdc%2B%2B/#options","text":"","title":"Options"},{"location":"reference/module/modm-stdc%2B%2B/#assert_on_exception","text":"Assert on exception in stdlib. Set to False to save flash. This option is only available for avr. Default: True Inputs: [True, False]","title":"assert_on_exception"},{"location":"reference/module/modm-stdc%2B%2B/#exceptions","text":"C++ Exceptions Enables the full use of C++ exception handling. Check your code size The inclusion of the stack unwind tables will increase your code size quite a bit. Check whether your target has enough memory for this! This option is only available for sam, stm32. Default: False Inputs: [True, False]","title":"exceptions"},{"location":"reference/module/modm-stdc%2B%2B/#rtti","text":"C++ Runtime Type Information Enables the full use of C++ runtime type information. Check your code size The inclusion of the RTTI information will increase your code size quite a bit. Check whether your target has enough memory for this! This option is only available for sam, stm32. Default: False Inputs: [True, False]","title":"rtti"},{"location":"reference/module/modm-stdc%2B%2B/#safe_statics","text":"C++ Safe Statics Initialization Enables safe initialization of statics inside functions and interrupts. In case of recursive initialization the debug assertion cxa.guard.recursion is raised. Further reading on this topic: C++ ABI for the ARM Architecture Adventures in Systems Programming: C++ Local Statics C++11 thread-safe static object initialization This option is only available for sam, stm32. Default: True Inputs: [True, False]","title":"safe_statics"},{"location":"reference/module/modm-stdc%2B%2B/#dependencies","text":"modm:stdc++ modm_stdc++ modm: stdc++ modm_architecture_assert modm: architecture: assert modm_stdc++->modm_architecture_assert modm_stdc modm: stdc modm_stdc++->modm_stdc @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-stdc/","text":"C Standard Environment \u00b6 lbuild module: modm:stdc Refines the C language to make it easier to use on embedded targets. ARM Cortex-M \u00b6 For ARMv6-M, C11 atomics are implemented via atomic lock. Additional compiler options: --specs=nano.specs : use Newlib Nano (when not using exceptions). --specs=nosys.specs : No additional C library features are implemented. Dependencies \u00b6 modm:stdc modm_stdc modm: stdc modm_architecture_assert modm: architecture: assert modm_stdc->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_stdc->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":stdc"},{"location":"reference/module/modm-stdc/#c-standard-environment","text":"lbuild module: modm:stdc Refines the C language to make it easier to use on embedded targets.","title":"C Standard Environment"},{"location":"reference/module/modm-stdc/#arm-cortex-m","text":"For ARMv6-M, C11 atomics are implemented via atomic lock. Additional compiler options: --specs=nano.specs : use Newlib Nano (when not using exceptions). --specs=nosys.specs : No additional C library features are implemented.","title":"ARM Cortex-M"},{"location":"reference/module/modm-stdc/#dependencies","text":"modm:stdc modm_stdc modm: stdc modm_architecture_assert modm: architecture: assert modm_stdc->modm_architecture_assert modm_architecture_atomic modm: architecture: atomic modm_stdc->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-audio/","text":"Device class AUDIO \u00b6 lbuild module: modm:tinyusb:device:audio Configuration options: CFG_TUD_AUDIO_CTRL_BUF_SIZE = [undef] CFG_TUD_AUDIO_ENABLE_FEEDBACK_EP = 0 CFG_TUD_AUDIO_EPSIZE_IN = 0 CFG_TUD_AUDIO_EPSIZE_OUT = 0 CFG_TUD_AUDIO_FORMAT_TYPE_I_RX = AUDIO_DATA_FORMAT_TYPE_I_PCM CFG_TUD_AUDIO_FORMAT_TYPE_I_TX = AUDIO_DATA_FORMAT_TYPE_I_PCM CFG_TUD_AUDIO_FORMAT_TYPE_RX = AUDIO_FORMAT_TYPE_UNDEFINED CFG_TUD_AUDIO_FORMAT_TYPE_TX = AUDIO_FORMAT_TYPE_UNDEFINED CFG_TUD_AUDIO_INT_CTR_BUFSIZE = 6 CFG_TUD_AUDIO_INT_CTR_EPSIZE_IN = 0 CFG_TUD_AUDIO_N_AS_INT = 0 CFG_TUD_AUDIO_N_BYTES_PER_SAMPLE_RX = 1 CFG_TUD_AUDIO_N_BYTES_PER_SAMPLE_TX = 1 CFG_TUD_AUDIO_N_CHANNELS_RX = 1 CFG_TUD_AUDIO_N_CHANNELS_TX = 1 CFG_TUD_AUDIO_RX_FIFO_COUNT = CFG_TUD_AUDIO_N_CHANNELS_RX CFG_TUD_AUDIO_RX_FIFO_SIZE = 0 CFG_TUD_AUDIO_TX_FIFO_COUNT = CFG_TUD_AUDIO_N_CHANNELS_TX CFG_TUD_AUDIO_TX_FIFO_SIZE = 0 Dependencies \u00b6 modm:tinyusb:device:audio modm_tinyusb_device_audio modm: tinyusb: device: audio modm_tinyusb modm: tinyusb modm_tinyusb_device_audio->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:audio"},{"location":"reference/module/modm-tinyusb-device-audio/#device-class-audio","text":"lbuild module: modm:tinyusb:device:audio Configuration options: CFG_TUD_AUDIO_CTRL_BUF_SIZE = [undef] CFG_TUD_AUDIO_ENABLE_FEEDBACK_EP = 0 CFG_TUD_AUDIO_EPSIZE_IN = 0 CFG_TUD_AUDIO_EPSIZE_OUT = 0 CFG_TUD_AUDIO_FORMAT_TYPE_I_RX = AUDIO_DATA_FORMAT_TYPE_I_PCM CFG_TUD_AUDIO_FORMAT_TYPE_I_TX = AUDIO_DATA_FORMAT_TYPE_I_PCM CFG_TUD_AUDIO_FORMAT_TYPE_RX = AUDIO_FORMAT_TYPE_UNDEFINED CFG_TUD_AUDIO_FORMAT_TYPE_TX = AUDIO_FORMAT_TYPE_UNDEFINED CFG_TUD_AUDIO_INT_CTR_BUFSIZE = 6 CFG_TUD_AUDIO_INT_CTR_EPSIZE_IN = 0 CFG_TUD_AUDIO_N_AS_INT = 0 CFG_TUD_AUDIO_N_BYTES_PER_SAMPLE_RX = 1 CFG_TUD_AUDIO_N_BYTES_PER_SAMPLE_TX = 1 CFG_TUD_AUDIO_N_CHANNELS_RX = 1 CFG_TUD_AUDIO_N_CHANNELS_TX = 1 CFG_TUD_AUDIO_RX_FIFO_COUNT = CFG_TUD_AUDIO_N_CHANNELS_RX CFG_TUD_AUDIO_RX_FIFO_SIZE = 0 CFG_TUD_AUDIO_TX_FIFO_COUNT = CFG_TUD_AUDIO_N_CHANNELS_TX CFG_TUD_AUDIO_TX_FIFO_SIZE = 0","title":"Device class AUDIO"},{"location":"reference/module/modm-tinyusb-device-audio/#dependencies","text":"modm:tinyusb:device:audio modm_tinyusb_device_audio modm: tinyusb: device: audio modm_tinyusb modm: tinyusb modm_tinyusb_device_audio->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-bth/","text":"Device class BTH \u00b6 lbuild module: modm:tinyusb:device:bth Configuration options: CFG_TUD_BTH_DATA_EPSIZE = 64 CFG_TUD_BTH_EVENT_EPSIZE = 16 CFG_TUD_BTH_ISO_ALT_COUNT = 0 Dependencies \u00b6 modm:tinyusb:device:bth modm_tinyusb_device_bth modm: tinyusb: device: bth modm_tinyusb modm: tinyusb modm_tinyusb_device_bth->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:bth"},{"location":"reference/module/modm-tinyusb-device-bth/#device-class-bth","text":"lbuild module: modm:tinyusb:device:bth Configuration options: CFG_TUD_BTH_DATA_EPSIZE = 64 CFG_TUD_BTH_EVENT_EPSIZE = 16 CFG_TUD_BTH_ISO_ALT_COUNT = 0","title":"Device class BTH"},{"location":"reference/module/modm-tinyusb-device-bth/#dependencies","text":"modm:tinyusb:device:bth modm_tinyusb_device_bth modm: tinyusb: device: bth modm_tinyusb modm: tinyusb modm_tinyusb_device_bth->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-cdc/","text":"Device class CDC \u00b6 lbuild module: modm:tinyusb:device:cdc Configuration options: CFG_TUD_CDC_EP_BUFSIZE = 64/512 (fs/hs) CFG_TUD_CDC_RX_BUFSIZE = [undef] modm default: 512 CFG_TUD_CDC_TX_BUFSIZE = [undef] modm default: 512 Dependencies \u00b6 modm:tinyusb:device:cdc modm_tinyusb_device_cdc modm: tinyusb: device: cdc modm_architecture_uart modm: architecture: uart modm_tinyusb_device_cdc->modm_architecture_uart modm_tinyusb modm: tinyusb modm_tinyusb_device_cdc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:cdc"},{"location":"reference/module/modm-tinyusb-device-cdc/#device-class-cdc","text":"lbuild module: modm:tinyusb:device:cdc Configuration options: CFG_TUD_CDC_EP_BUFSIZE = 64/512 (fs/hs) CFG_TUD_CDC_RX_BUFSIZE = [undef] modm default: 512 CFG_TUD_CDC_TX_BUFSIZE = [undef] modm default: 512","title":"Device class CDC"},{"location":"reference/module/modm-tinyusb-device-cdc/#dependencies","text":"modm:tinyusb:device:cdc modm_tinyusb_device_cdc modm: tinyusb: device: cdc modm_architecture_uart modm: architecture: uart modm_tinyusb_device_cdc->modm_architecture_uart modm_tinyusb modm: tinyusb modm_tinyusb_device_cdc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-dfu/","text":"Device class DFU \u00b6 lbuild module: modm:tinyusb:device:dfu Dependencies \u00b6 modm:tinyusb:device:dfu modm_tinyusb_device_dfu modm: tinyusb: device: dfu modm_tinyusb modm: tinyusb modm_tinyusb_device_dfu->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:dfu"},{"location":"reference/module/modm-tinyusb-device-dfu/#device-class-dfu","text":"lbuild module: modm:tinyusb:device:dfu","title":"Device class DFU"},{"location":"reference/module/modm-tinyusb-device-dfu/#dependencies","text":"modm:tinyusb:device:dfu modm_tinyusb_device_dfu modm: tinyusb: device: dfu modm_tinyusb modm: tinyusb modm_tinyusb_device_dfu->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-hid/","text":"Device class HID \u00b6 lbuild module: modm:tinyusb:device:hid Configuration options: CFG_TUD_HID_EP_BUFSIZE = 16 Dependencies \u00b6 modm:tinyusb:device:hid modm_tinyusb_device_hid modm: tinyusb: device: hid modm_tinyusb modm: tinyusb modm_tinyusb_device_hid->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:hid"},{"location":"reference/module/modm-tinyusb-device-hid/#device-class-hid","text":"lbuild module: modm:tinyusb:device:hid Configuration options: CFG_TUD_HID_EP_BUFSIZE = 16","title":"Device class HID"},{"location":"reference/module/modm-tinyusb-device-hid/#dependencies","text":"modm:tinyusb:device:hid modm_tinyusb_device_hid modm: tinyusb: device: hid modm_tinyusb modm: tinyusb modm_tinyusb_device_hid->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-midi/","text":"Device class MIDI \u00b6 lbuild module: modm:tinyusb:device:midi Configuration options: CFG_TUD_MIDI_EP_BUFSIZE = 64/512 (fs/hs) CFG_TUD_MIDI_RX_BUFSIZE = [undef] modm default: 64/512 (fs/hs) CFG_TUD_MIDI_TX_BUFSIZE = [undef] modm default: 64/512 (fs/hs) Dependencies \u00b6 modm:tinyusb:device:midi modm_tinyusb_device_midi modm: tinyusb: device: midi modm_tinyusb modm: tinyusb modm_tinyusb_device_midi->modm_tinyusb modm_tinyusb_device_audio modm: tinyusb: device: audio modm_tinyusb_device_midi->modm_tinyusb_device_audio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:midi"},{"location":"reference/module/modm-tinyusb-device-midi/#device-class-midi","text":"lbuild module: modm:tinyusb:device:midi Configuration options: CFG_TUD_MIDI_EP_BUFSIZE = 64/512 (fs/hs) CFG_TUD_MIDI_RX_BUFSIZE = [undef] modm default: 64/512 (fs/hs) CFG_TUD_MIDI_TX_BUFSIZE = [undef] modm default: 64/512 (fs/hs)","title":"Device class MIDI"},{"location":"reference/module/modm-tinyusb-device-midi/#dependencies","text":"modm:tinyusb:device:midi modm_tinyusb_device_midi modm: tinyusb: device: midi modm_tinyusb modm: tinyusb modm_tinyusb_device_midi->modm_tinyusb modm_tinyusb_device_audio modm: tinyusb: device: audio modm_tinyusb_device_midi->modm_tinyusb_device_audio @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-msc/","text":"Device class MSC \u00b6 lbuild module: modm:tinyusb:device:msc Configuration options: CFG_TUD_MSC_EP_BUFSIZE = [undef] modm default: 512 Dependencies \u00b6 modm:tinyusb:device:msc modm_tinyusb_device_msc modm: tinyusb: device: msc modm_tinyusb modm: tinyusb modm_tinyusb_device_msc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:msc"},{"location":"reference/module/modm-tinyusb-device-msc/#device-class-msc","text":"lbuild module: modm:tinyusb:device:msc Configuration options: CFG_TUD_MSC_EP_BUFSIZE = [undef] modm default: 512","title":"Device class MSC"},{"location":"reference/module/modm-tinyusb-device-msc/#dependencies","text":"modm:tinyusb:device:msc modm_tinyusb_device_msc modm: tinyusb: device: msc modm_tinyusb modm: tinyusb modm_tinyusb_device_msc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-net/","text":"Device class NET \u00b6 lbuild module: modm:tinyusb:device:net Configuration options: CFG_TUD_NET_ENDPOINT_SIZE = 64/512 (fs/hs) CFG_TUD_NET_MTU = 1514 Dependencies \u00b6 modm:tinyusb:device:net modm_tinyusb_device_net modm: tinyusb: device: net modm_tinyusb modm: tinyusb modm_tinyusb_device_net->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:net"},{"location":"reference/module/modm-tinyusb-device-net/#device-class-net","text":"lbuild module: modm:tinyusb:device:net Configuration options: CFG_TUD_NET_ENDPOINT_SIZE = 64/512 (fs/hs) CFG_TUD_NET_MTU = 1514","title":"Device class NET"},{"location":"reference/module/modm-tinyusb-device-net/#dependencies","text":"modm:tinyusb:device:net modm_tinyusb_device_net modm: tinyusb: device: net modm_tinyusb modm: tinyusb modm_tinyusb_device_net->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-usbtmc/","text":"Device class USBTMC \u00b6 lbuild module: modm:tinyusb:device:usbtmc Configuration options: CFG_TUD_USBTMC_ENABLE_488 = 1 Dependencies \u00b6 modm:tinyusb:device:usbtmc modm_tinyusb_device_usbtmc modm: tinyusb: device: usbtmc modm_tinyusb modm: tinyusb modm_tinyusb_device_usbtmc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:usbtmc"},{"location":"reference/module/modm-tinyusb-device-usbtmc/#device-class-usbtmc","text":"lbuild module: modm:tinyusb:device:usbtmc Configuration options: CFG_TUD_USBTMC_ENABLE_488 = 1","title":"Device class USBTMC"},{"location":"reference/module/modm-tinyusb-device-usbtmc/#dependencies","text":"modm:tinyusb:device:usbtmc modm_tinyusb_device_usbtmc modm: tinyusb: device: usbtmc modm_tinyusb modm: tinyusb modm_tinyusb_device_usbtmc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device-vendor/","text":"Device class VENDOR \u00b6 lbuild module: modm:tinyusb:device:vendor Configuration options: CFG_TUD_VENDOR_EPSIZE = 64 CFG_TUD_VENDOR_RX_BUFSIZE = [undef] modm default: 64/512 (fs/hs) CFG_TUD_VENDOR_TX_BUFSIZE = [undef] modm default: 64/512 (fs/hs) Dependencies \u00b6 modm:tinyusb:device:vendor modm_tinyusb_device_vendor modm: tinyusb: device: vendor modm_tinyusb modm: tinyusb modm_tinyusb_device_vendor->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device:vendor"},{"location":"reference/module/modm-tinyusb-device-vendor/#device-class-vendor","text":"lbuild module: modm:tinyusb:device:vendor Configuration options: CFG_TUD_VENDOR_EPSIZE = 64 CFG_TUD_VENDOR_RX_BUFSIZE = [undef] modm default: 64/512 (fs/hs) CFG_TUD_VENDOR_TX_BUFSIZE = [undef] modm default: 64/512 (fs/hs)","title":"Device class VENDOR"},{"location":"reference/module/modm-tinyusb-device-vendor/#dependencies","text":"modm:tinyusb:device:vendor modm_tinyusb_device_vendor modm: tinyusb: device: vendor modm_tinyusb modm: tinyusb modm_tinyusb_device_vendor->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-device/","text":"TinyUSB in Device Mode \u00b6 lbuild module: modm:tinyusb:device Configuration options: CFG_TUD_ENDPOINT0_SIZE = 64 CFG_TUD_TASK_QUEUE_SZ = 16 Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:device"},{"location":"reference/module/modm-tinyusb-device/#tinyusb-in-device-mode","text":"lbuild module: modm:tinyusb:device Configuration options: CFG_TUD_ENDPOINT0_SIZE = 64 CFG_TUD_TASK_QUEUE_SZ = 16 Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"TinyUSB in Device Mode"},{"location":"reference/module/modm-tinyusb-host-cdc/","text":"Host class CDC \u00b6 lbuild module: modm:tinyusb:host:cdc Dependencies \u00b6 modm:tinyusb:host:cdc modm_tinyusb_host_cdc modm: tinyusb: host: cdc modm_tinyusb modm: tinyusb modm_tinyusb_host_cdc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:host:cdc"},{"location":"reference/module/modm-tinyusb-host-cdc/#host-class-cdc","text":"lbuild module: modm:tinyusb:host:cdc","title":"Host class CDC"},{"location":"reference/module/modm-tinyusb-host-cdc/#dependencies","text":"modm:tinyusb:host:cdc modm_tinyusb_host_cdc modm: tinyusb: host: cdc modm_tinyusb modm: tinyusb modm_tinyusb_host_cdc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-host-hid/","text":"Host class HID \u00b6 lbuild module: modm:tinyusb:host:hid Dependencies \u00b6 modm:tinyusb:host:hid modm_tinyusb_host_hid modm: tinyusb: host: hid modm_tinyusb modm: tinyusb modm_tinyusb_host_hid->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:host:hid"},{"location":"reference/module/modm-tinyusb-host-hid/#host-class-hid","text":"lbuild module: modm:tinyusb:host:hid","title":"Host class HID"},{"location":"reference/module/modm-tinyusb-host-hid/#dependencies","text":"modm:tinyusb:host:hid modm_tinyusb_host_hid modm: tinyusb: host: hid modm_tinyusb modm: tinyusb modm_tinyusb_host_hid->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-host-msc/","text":"Host class MSC \u00b6 lbuild module: modm:tinyusb:host:msc Configuration options: CFG_TUH_MSC_MAXLUN = 4 Dependencies \u00b6 modm:tinyusb:host:msc modm_tinyusb_host_msc modm: tinyusb: host: msc modm_tinyusb modm: tinyusb modm_tinyusb_host_msc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:host:msc"},{"location":"reference/module/modm-tinyusb-host-msc/#host-class-msc","text":"lbuild module: modm:tinyusb:host:msc Configuration options: CFG_TUH_MSC_MAXLUN = 4","title":"Host class MSC"},{"location":"reference/module/modm-tinyusb-host-msc/#dependencies","text":"modm:tinyusb:host:msc modm_tinyusb_host_msc modm: tinyusb: host: msc modm_tinyusb modm: tinyusb modm_tinyusb_host_msc->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-host-vendor/","text":"Host class VENDOR \u00b6 lbuild module: modm:tinyusb:host:vendor Dependencies \u00b6 modm:tinyusb:host:vendor modm_tinyusb_host_vendor modm: tinyusb: host: vendor modm_tinyusb modm: tinyusb modm_tinyusb_host_vendor->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:host:vendor"},{"location":"reference/module/modm-tinyusb-host-vendor/#host-class-vendor","text":"lbuild module: modm:tinyusb:host:vendor","title":"Host class VENDOR"},{"location":"reference/module/modm-tinyusb-host-vendor/#dependencies","text":"modm:tinyusb:host:vendor modm_tinyusb_host_vendor modm: tinyusb: host: vendor modm_tinyusb modm: tinyusb modm_tinyusb_host_vendor->modm_tinyusb @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tinyusb-host/","text":"TinyUSB in Host Mode \u00b6 lbuild module: modm:tinyusb:host Configuration options: CFG_TUH_EP_MAX = 9 CFG_TUH_TASK_QUEUE_SZ = 16 This module is only available for stm32{f1,f2,f4,f7,l4}. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb:host"},{"location":"reference/module/modm-tinyusb-host/#tinyusb-in-host-mode","text":"lbuild module: modm:tinyusb:host Configuration options: CFG_TUH_EP_MAX = 9 CFG_TUH_TASK_QUEUE_SZ = 16 This module is only available for stm32{f1,f2,f4,f7,l4}. Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"TinyUSB in Host Mode"},{"location":"reference/module/modm-tinyusb/","text":"TinyUSB \u00b6 lbuild module: modm:tinyusb TinyUSB is an open-source cross-platform USB Host/Device stack for embedded system, designed to be memory-safe with no dynamic allocation and thread-safe with all interrupt events are deferred then handled in the non-ISR task function. This module provides a autogenerated port for TinyUSB, which includes the correct interrupt mapping, a serial number based on the UID of the device, as well as remapping the assertions of TinyUSB. Autogeneration of USB Descriptors \u00b6 You can select the device classes you want to use via the modm:tinyusb:config list option: device.cdc : Serial connection (uses two endpoints!) device.msc : Mass Storage class. device.midi : MIDI device. device.vendor : WebUSB device. device.dfu : DFU (runtime only). Note that you can add multiple devices at the same time, as long as there are enough endpoints and USB RAM available: <!-- Using the CDC and MSC classes together --> <option name= \"modm:tinyusb:config\" > device.cdc,device.msc </option> <!-- Using two CDC ports! --> <option name= \"modm:tinyusb:config\" > device.cdc,device.cdc </option> modm will generate the USB descriptors automatically for the set of device classes you've chosen. You can then implement your app via TinyUSB callbacks. Partial Customization \u00b6 You can overwrite or add configurations via a <tusb_config_local.h> file, which will be included at the very beginning of the modm-generated tusb_config.h file: // Overwrite the modm default #define CFG_TUD_CDC_TX_BUFSIZE 1024 // Overwrite the TinyUSB default #define CFG_TUD_CDC_EP_BUFSIZE 1024 You can also replace the following weakly linked descriptor functions and objects in case you want to update only a small part of the autogenerated descriptors: const uint8_t* tud_descriptor_device_cb(void) to replace the autogenerated tusb_desc_device_t descriptor. const uint8_t* tud_descriptor_configuration_cb(uint8_t index) to replace the endpoint descriptions. const char* string_desc_arr[] to replace the string descriptors. Manual USB Descriptors \u00b6 If you leave the modm:tinyusb:config option empty, no descriptors are generated, so you can implement them yourself. Note that you must also manually depend on the device classes you want to implement: <module> modm:tinyusb:device:audio </module> <module> modm:tinyusb:device:bth </module> <module> modm:tinyusb:device:hid </module> <module> modm:tinyusb:device:net </module> <module> modm:tinyusb:device:usbtmc </module> Some of these classes require a lot of configuration that you must provide via the <tusb_config_local.h> file. See the class module descriptions for these configurations and consult the TinyUSB documentation for their purpose. Initializing USB \u00b6 The modm:platform:usb module provides the correct way of initializing the USB peripheral, however, you must connect the right signals too: // USB is timing-sensitive, so prioritize the IRQs accordingly Usb :: initialize < SystemClock > ( /*priority=*/ 3 ); // For Device-Only USB implementations, this is enough Usb :: connect < GpioA11 :: Dm , GpioA12 :: Dp > (); // But for On-The-Go (OTG) USB implementations, you need more: Usb :: connect < GpioA11 :: Dm , GpioA12 :: Dp , GpioA10 :: Id > (); // Enable hardware Vbus sensing on GpioA9 (this can be tricky to get right!) USB_OTG_FS -> GCCFG |= USB_OTG_GCCFG_VBDEN ; Note that depending on your specific hardware setup, you may need to fiddle around to find the right VBus sensing mechanism. USB shares resources with CAN Note that on STM32F1 and STM32F3 the USB interrupts and RAM are shared with CAN, thus there are conflicts in IRQ definitions as well as resource limitions in hardware. On some STM32F3, the USB IRQs can be remapped, this is done automatically by our port. Debugging TinyUSB \u00b6 Since we've made it so easy to add multiple device classes, it's also easy to run out of endpoints or RAM. Therefore we reroute TinyUSBs assertions to modm_assert , so make sure you have implemented the modm_abandon handler! See the modm:architecture:assert module for details. A TinyUSB assertion failure in release mode is fairly cryptic: Assertion 'tu' failed! Abandoning... If you run this again in debug mode, you'll note a much more detailed assertion description. In this example you've exhaused the number of endpoints: Assertion 'tu' failed! modm/ext/tinyusb/portable/st/synopsys/dcd_synopsys.c:524 -> \"epnum < 4U\" Abandoning... To trace the TinyUSB core, you can add CFG_TUSB_DEBUG=2 to your CPP flags and the output will be forwarded to MODM_LOG_DEBUG . <collect name=\"modm:build:cppdefines\">CFG_TUSB_DEBUG=2</collect> This module is only available for sam, stm32{f0,f1,f2,f3,f4,f7,g4,l0,l1,l4}. Options \u00b6 config \u00b6 Endpoint Configuration Default: [] Inputs: [device.cdc, device.dfu, device.midi, device.msc, device.vendor] Input Dependency: device.cdc -> modm:tinyusb:device:cdc Input Dependency: device.dfu -> modm:tinyusb:device:dfu Input Dependency: device.midi -> modm:tinyusb:device:midi Input Dependency: device.msc -> modm:tinyusb:device:msc Input Dependency: device.vendor -> modm:tinyusb:device:vendor speed \u00b6 USB Port Speed This option is only available for stm32{f2,f4,f7}. Default: full Inputs: [full, high] Input Dependency: full -> modm:platform:usb:fs Input Dependency: high -> modm:platform:usb:hs Dependencies \u00b6 modm:tinyusb modm_tinyusb modm: tinyusb modm_architecture_interrupt modm: architecture: interrupt modm_tinyusb->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_tinyusb->modm_cmsis_device modm_platform_usb modm: platform: usb modm_tinyusb->modm_platform_usb modm_platform_usb_fs modm: platform: usb: fs modm_tinyusb->modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_tinyusb->modm_platform_usb_hs modm_tinyusb_device_cdc modm: tinyusb: device: cdc modm_tinyusb->modm_tinyusb_device_cdc modm_tinyusb_device_dfu modm: tinyusb: device: dfu modm_tinyusb->modm_tinyusb_device_dfu modm_tinyusb_device_midi modm: tinyusb: device: midi modm_tinyusb->modm_tinyusb_device_midi modm_tinyusb_device_msc modm: tinyusb: device: msc modm_tinyusb->modm_tinyusb_device_msc modm_tinyusb_device_vendor modm: tinyusb: device: vendor modm_tinyusb->modm_tinyusb_device_vendor @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tinyusb"},{"location":"reference/module/modm-tinyusb/#tinyusb","text":"lbuild module: modm:tinyusb TinyUSB is an open-source cross-platform USB Host/Device stack for embedded system, designed to be memory-safe with no dynamic allocation and thread-safe with all interrupt events are deferred then handled in the non-ISR task function. This module provides a autogenerated port for TinyUSB, which includes the correct interrupt mapping, a serial number based on the UID of the device, as well as remapping the assertions of TinyUSB.","title":"TinyUSB"},{"location":"reference/module/modm-tinyusb/#autogeneration-of-usb-descriptors","text":"You can select the device classes you want to use via the modm:tinyusb:config list option: device.cdc : Serial connection (uses two endpoints!) device.msc : Mass Storage class. device.midi : MIDI device. device.vendor : WebUSB device. device.dfu : DFU (runtime only). Note that you can add multiple devices at the same time, as long as there are enough endpoints and USB RAM available: <!-- Using the CDC and MSC classes together --> <option name= \"modm:tinyusb:config\" > device.cdc,device.msc </option> <!-- Using two CDC ports! --> <option name= \"modm:tinyusb:config\" > device.cdc,device.cdc </option> modm will generate the USB descriptors automatically for the set of device classes you've chosen. You can then implement your app via TinyUSB callbacks.","title":"Autogeneration of USB Descriptors"},{"location":"reference/module/modm-tinyusb/#partial-customization","text":"You can overwrite or add configurations via a <tusb_config_local.h> file, which will be included at the very beginning of the modm-generated tusb_config.h file: // Overwrite the modm default #define CFG_TUD_CDC_TX_BUFSIZE 1024 // Overwrite the TinyUSB default #define CFG_TUD_CDC_EP_BUFSIZE 1024 You can also replace the following weakly linked descriptor functions and objects in case you want to update only a small part of the autogenerated descriptors: const uint8_t* tud_descriptor_device_cb(void) to replace the autogenerated tusb_desc_device_t descriptor. const uint8_t* tud_descriptor_configuration_cb(uint8_t index) to replace the endpoint descriptions. const char* string_desc_arr[] to replace the string descriptors.","title":"Partial Customization"},{"location":"reference/module/modm-tinyusb/#manual-usb-descriptors","text":"If you leave the modm:tinyusb:config option empty, no descriptors are generated, so you can implement them yourself. Note that you must also manually depend on the device classes you want to implement: <module> modm:tinyusb:device:audio </module> <module> modm:tinyusb:device:bth </module> <module> modm:tinyusb:device:hid </module> <module> modm:tinyusb:device:net </module> <module> modm:tinyusb:device:usbtmc </module> Some of these classes require a lot of configuration that you must provide via the <tusb_config_local.h> file. See the class module descriptions for these configurations and consult the TinyUSB documentation for their purpose.","title":"Manual USB Descriptors"},{"location":"reference/module/modm-tinyusb/#initializing-usb","text":"The modm:platform:usb module provides the correct way of initializing the USB peripheral, however, you must connect the right signals too: // USB is timing-sensitive, so prioritize the IRQs accordingly Usb :: initialize < SystemClock > ( /*priority=*/ 3 ); // For Device-Only USB implementations, this is enough Usb :: connect < GpioA11 :: Dm , GpioA12 :: Dp > (); // But for On-The-Go (OTG) USB implementations, you need more: Usb :: connect < GpioA11 :: Dm , GpioA12 :: Dp , GpioA10 :: Id > (); // Enable hardware Vbus sensing on GpioA9 (this can be tricky to get right!) USB_OTG_FS -> GCCFG |= USB_OTG_GCCFG_VBDEN ; Note that depending on your specific hardware setup, you may need to fiddle around to find the right VBus sensing mechanism. USB shares resources with CAN Note that on STM32F1 and STM32F3 the USB interrupts and RAM are shared with CAN, thus there are conflicts in IRQ definitions as well as resource limitions in hardware. On some STM32F3, the USB IRQs can be remapped, this is done automatically by our port.","title":"Initializing USB"},{"location":"reference/module/modm-tinyusb/#debugging-tinyusb","text":"Since we've made it so easy to add multiple device classes, it's also easy to run out of endpoints or RAM. Therefore we reroute TinyUSBs assertions to modm_assert , so make sure you have implemented the modm_abandon handler! See the modm:architecture:assert module for details. A TinyUSB assertion failure in release mode is fairly cryptic: Assertion 'tu' failed! Abandoning... If you run this again in debug mode, you'll note a much more detailed assertion description. In this example you've exhaused the number of endpoints: Assertion 'tu' failed! modm/ext/tinyusb/portable/st/synopsys/dcd_synopsys.c:524 -> \"epnum < 4U\" Abandoning... To trace the TinyUSB core, you can add CFG_TUSB_DEBUG=2 to your CPP flags and the output will be forwarded to MODM_LOG_DEBUG . <collect name=\"modm:build:cppdefines\">CFG_TUSB_DEBUG=2</collect> This module is only available for sam, stm32{f0,f1,f2,f3,f4,f7,g4,l0,l1,l4}.","title":"Debugging TinyUSB"},{"location":"reference/module/modm-tinyusb/#options","text":"","title":"Options"},{"location":"reference/module/modm-tinyusb/#config","text":"Endpoint Configuration Default: [] Inputs: [device.cdc, device.dfu, device.midi, device.msc, device.vendor] Input Dependency: device.cdc -> modm:tinyusb:device:cdc Input Dependency: device.dfu -> modm:tinyusb:device:dfu Input Dependency: device.midi -> modm:tinyusb:device:midi Input Dependency: device.msc -> modm:tinyusb:device:msc Input Dependency: device.vendor -> modm:tinyusb:device:vendor","title":"config"},{"location":"reference/module/modm-tinyusb/#speed","text":"USB Port Speed This option is only available for stm32{f2,f4,f7}. Default: full Inputs: [full, high] Input Dependency: full -> modm:platform:usb:fs Input Dependency: high -> modm:platform:usb:hs","title":"speed"},{"location":"reference/module/modm-tinyusb/#dependencies","text":"modm:tinyusb modm_tinyusb modm: tinyusb modm_architecture_interrupt modm: architecture: interrupt modm_tinyusb->modm_architecture_interrupt modm_cmsis_device modm: cmsis: device modm_tinyusb->modm_cmsis_device modm_platform_usb modm: platform: usb modm_tinyusb->modm_platform_usb modm_platform_usb_fs modm: platform: usb: fs modm_tinyusb->modm_platform_usb_fs modm_platform_usb_hs modm: platform: usb: hs modm_tinyusb->modm_platform_usb_hs modm_tinyusb_device_cdc modm: tinyusb: device: cdc modm_tinyusb->modm_tinyusb_device_cdc modm_tinyusb_device_dfu modm: tinyusb: device: dfu modm_tinyusb->modm_tinyusb_device_dfu modm_tinyusb_device_midi modm: tinyusb: device: midi modm_tinyusb->modm_tinyusb_device_midi modm_tinyusb_device_msc modm: tinyusb: device: msc modm_tinyusb->modm_tinyusb_device_msc modm_tinyusb_device_vendor modm: tinyusb: device: vendor modm_tinyusb->modm_tinyusb_device_vendor @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}} Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"Dependencies"},{"location":"reference/module/modm-tlsf/","text":"TLSF Allocator \u00b6 lbuild module: modm:tlsf Two-Level Segregated Fit memory allocator implementation. Written by Matthew Conte ( matt@baisoku.org ). Released under the BSD license. https://github.com/mattconte/tlsf Features \u00b6 O(1) cost for malloc, free, realloc, memalign Extremely low overhead per allocation (4 bytes) Low overhead per TLSF management of pools (~3kB) Low fragmentation Compiles to only a few kB of code and data Support for adding and removing memory pool regions on the fly Caveats \u00b6 Currently, assumes architecture can make 4-byte aligned accesses Not designed to be thread safe; the user must provide this Notes \u00b6 This code was based on the TLSF 1.4 spec and documentation found at: http://rtportal.upv.es/rtmalloc/allocators/tlsf/index.shtml It also leverages the TLSF 2.0 improvement to shrink the per-block overhead from 8 to 4 bytes. History \u00b6 2016/04/10 - v3.1 * Code moved to github * tlsfbits.h rolled into tlsf.c * License changed to BSD 2014/02/08 - v3.0 * This version is based on improvements from 3DInteractive GmbH * Interface changed to allow more than one memory pool * Separated pool handling from control structure (adding, removing, debugging) * Control structure and pools can still be constructed in the same memory block * Memory blocks for control structure and pools are checked for alignment * Added functions to retrieve control structure size, alignment size, min and max block size, overhead of pool structure, and overhead of a single allocation * Minimal Pool size is tlsf_block_size_min() + tlsf_pool_overhead() * Pool must be empty when it is removed, in order to allow O(1) removal 2011/10/20 - v2.0 * 64-bit support * More compiler intrinsics for ffs/fls * ffs/fls verification during TLSF creation in debug builds 2008/04/04 - v1.9 * Add tlsf_heap_check, a heap integrity check * Support a predefined tlsf_assert macro * Fix realloc case where block should shrink; if adjacent block is in use, execution would go down the slow path 2007/02/08 - v1.8 * Fix for unnecessary reallocation in tlsf_realloc 2007/02/03 - v1.7 * tlsf_heap_walk takes a callback * tlsf_realloc now returns NULL on failure * tlsf_memalign optimization for 4-byte alignment * Usage of size_t where appropriate 2006/11/21 - v1.6 * ffs/fls broken out into tlsfbits.h * tlsf_overhead queries per-pool overhead 2006/11/07 - v1.5 * Smart realloc implementation * Smart memalign implementation 2006/10/11 - v1.4 * Add some ffs/fls implementations * Minor code footprint reduction 2006/09/14 - v1.3 * Profiling indicates heavy use of blocks of size 1-128, so implement small block handling * Reduce pool overhead by about 1kb * Reduce minimum block size from 32 to 12 bytes * Realloc bug fix 2006/09/09 - v1.2 * Add tlsf_block_size * Static assertion mechanism for invariants * Minor bugfixes 2006/09/01 - v1.1 * Add tlsf_realloc * Add tlsf_walk_heap 2006/08/25 - v1.0 * First release This module is only available for sam, stm32. Options \u00b6 minimum_pool_size \u00b6 Minimum pool size in byte Default: 10240 stm32{f1,l1} Default: 12288 stm32f3 Default: 131072 stm32{f2,f4,g4,l4} Default: 16384 sam, stm32{f0,f3,l1} Default: 163840 stm32l4 Default: 18432 stm32g0 Default: 196608 stm32f4 Default: 2048 stm32l0 Default: 20480 stm32{f1,l0} Default: 24576 stm32f100zct6 Default: 262144 stm32{f4,f7} Default: 32768 sam, stm32{f0,f1,f3,f4,g4,l1} Default: 327680 stm32{f4,l4} Default: 36864 stm32g0 Default: 393216 stm32f7 Default: 4096 sam, stm32{f0,f1,l1} Default: 40960 stm32{f3,l4} Default: 49152 stm32{f1,l1} Default: 524288 stm32f7 Default: 6144 stm32{f0,f1} Default: 65536 stm32{f1,f2,f3,f4,l4} Default: 655360 stm32l4 Default: 8192 sam, stm32{f0,f1,g0,l0,l1} Default: 81920 stm32l1 Default: 98304 stm32{f2,f4} Inputs: [4096 .. 10240 .. 536870912] stm32{f1,l1} Inputs: [4096 .. 12288 .. 536870912] stm32f3 Inputs: [4096 .. 131072 .. 536870912] stm32{f2,f4,g4,l4} Inputs: [4096 .. 16384 .. 536870912] sam, stm32{f0,f3,l1} Inputs: [4096 .. 163840 .. 536870912] stm32l4 Inputs: [4096 .. 18432 .. 536870912] stm32g0 Inputs: [4096 .. 196608 .. 536870912] stm32f4 Inputs: [4096 .. 2048 .. 536870912] stm32l0 Inputs: [4096 .. 20480 .. 536870912] stm32{f1,l0} Inputs: [4096 .. 24576 .. 536870912] stm32f100zct6 Inputs: [4096 .. 262144 .. 536870912] stm32{f4,f7} Inputs: [4096 .. 32768 .. 536870912] sam, stm32{f0,f1,f3,f4,g4,l1} Inputs: [4096 .. 327680 .. 536870912] stm32{f4,l4} Inputs: [4096 .. 36864 .. 536870912] stm32g0 Inputs: [4096 .. 393216 .. 536870912] stm32f7 Inputs: [4096 .. 40960 .. 536870912] stm32{f3,l4} Inputs: [4096 .. 49152 .. 536870912] stm32{f1,l1} Inputs: [4096 .. 524288 .. 536870912] stm32f7 Inputs: [4096 .. 6144 .. 536870912] stm32{f0,f1} Inputs: [4096 .. 65536 .. 536870912] stm32{f1,f2,f3,f4,l4} Inputs: [4096 .. 655360 .. 536870912] stm32l4 Inputs: [4096 .. 8192 .. 536870912] sam, stm32{f0,f1,g0,l0,l1} Inputs: [4096 .. 81920 .. 536870912] stm32l1 Inputs: [4096 .. 98304 .. 536870912] stm32{f2,f4} Inputs: [4096 ... 536870912] sam, stm32{f0,f1,l1} subdivisions \u00b6 Number of subdivisions per memory pool Default: 16 Inputs: [16, 32] Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":":tlsf"},{"location":"reference/module/modm-tlsf/#tlsf-allocator","text":"lbuild module: modm:tlsf Two-Level Segregated Fit memory allocator implementation. Written by Matthew Conte ( matt@baisoku.org ). Released under the BSD license. https://github.com/mattconte/tlsf","title":"TLSF Allocator"},{"location":"reference/module/modm-tlsf/#features","text":"O(1) cost for malloc, free, realloc, memalign Extremely low overhead per allocation (4 bytes) Low overhead per TLSF management of pools (~3kB) Low fragmentation Compiles to only a few kB of code and data Support for adding and removing memory pool regions on the fly","title":"Features"},{"location":"reference/module/modm-tlsf/#caveats","text":"Currently, assumes architecture can make 4-byte aligned accesses Not designed to be thread safe; the user must provide this","title":"Caveats"},{"location":"reference/module/modm-tlsf/#notes","text":"This code was based on the TLSF 1.4 spec and documentation found at: http://rtportal.upv.es/rtmalloc/allocators/tlsf/index.shtml It also leverages the TLSF 2.0 improvement to shrink the per-block overhead from 8 to 4 bytes.","title":"Notes"},{"location":"reference/module/modm-tlsf/#history","text":"2016/04/10 - v3.1 * Code moved to github * tlsfbits.h rolled into tlsf.c * License changed to BSD 2014/02/08 - v3.0 * This version is based on improvements from 3DInteractive GmbH * Interface changed to allow more than one memory pool * Separated pool handling from control structure (adding, removing, debugging) * Control structure and pools can still be constructed in the same memory block * Memory blocks for control structure and pools are checked for alignment * Added functions to retrieve control structure size, alignment size, min and max block size, overhead of pool structure, and overhead of a single allocation * Minimal Pool size is tlsf_block_size_min() + tlsf_pool_overhead() * Pool must be empty when it is removed, in order to allow O(1) removal 2011/10/20 - v2.0 * 64-bit support * More compiler intrinsics for ffs/fls * ffs/fls verification during TLSF creation in debug builds 2008/04/04 - v1.9 * Add tlsf_heap_check, a heap integrity check * Support a predefined tlsf_assert macro * Fix realloc case where block should shrink; if adjacent block is in use, execution would go down the slow path 2007/02/08 - v1.8 * Fix for unnecessary reallocation in tlsf_realloc 2007/02/03 - v1.7 * tlsf_heap_walk takes a callback * tlsf_realloc now returns NULL on failure * tlsf_memalign optimization for 4-byte alignment * Usage of size_t where appropriate 2006/11/21 - v1.6 * ffs/fls broken out into tlsfbits.h * tlsf_overhead queries per-pool overhead 2006/11/07 - v1.5 * Smart realloc implementation * Smart memalign implementation 2006/10/11 - v1.4 * Add some ffs/fls implementations * Minor code footprint reduction 2006/09/14 - v1.3 * Profiling indicates heavy use of blocks of size 1-128, so implement small block handling * Reduce pool overhead by about 1kb * Reduce minimum block size from 32 to 12 bytes * Realloc bug fix 2006/09/09 - v1.2 * Add tlsf_block_size * Static assertion mechanism for invariants * Minor bugfixes 2006/09/01 - v1.1 * Add tlsf_realloc * Add tlsf_walk_heap 2006/08/25 - v1.0 * First release This module is only available for sam, stm32.","title":"History"},{"location":"reference/module/modm-tlsf/#options","text":"","title":"Options"},{"location":"reference/module/modm-tlsf/#minimum_pool_size","text":"Minimum pool size in byte Default: 10240 stm32{f1,l1} Default: 12288 stm32f3 Default: 131072 stm32{f2,f4,g4,l4} Default: 16384 sam, stm32{f0,f3,l1} Default: 163840 stm32l4 Default: 18432 stm32g0 Default: 196608 stm32f4 Default: 2048 stm32l0 Default: 20480 stm32{f1,l0} Default: 24576 stm32f100zct6 Default: 262144 stm32{f4,f7} Default: 32768 sam, stm32{f0,f1,f3,f4,g4,l1} Default: 327680 stm32{f4,l4} Default: 36864 stm32g0 Default: 393216 stm32f7 Default: 4096 sam, stm32{f0,f1,l1} Default: 40960 stm32{f3,l4} Default: 49152 stm32{f1,l1} Default: 524288 stm32f7 Default: 6144 stm32{f0,f1} Default: 65536 stm32{f1,f2,f3,f4,l4} Default: 655360 stm32l4 Default: 8192 sam, stm32{f0,f1,g0,l0,l1} Default: 81920 stm32l1 Default: 98304 stm32{f2,f4} Inputs: [4096 .. 10240 .. 536870912] stm32{f1,l1} Inputs: [4096 .. 12288 .. 536870912] stm32f3 Inputs: [4096 .. 131072 .. 536870912] stm32{f2,f4,g4,l4} Inputs: [4096 .. 16384 .. 536870912] sam, stm32{f0,f3,l1} Inputs: [4096 .. 163840 .. 536870912] stm32l4 Inputs: [4096 .. 18432 .. 536870912] stm32g0 Inputs: [4096 .. 196608 .. 536870912] stm32f4 Inputs: [4096 .. 2048 .. 536870912] stm32l0 Inputs: [4096 .. 20480 .. 536870912] stm32{f1,l0} Inputs: [4096 .. 24576 .. 536870912] stm32f100zct6 Inputs: [4096 .. 262144 .. 536870912] stm32{f4,f7} Inputs: [4096 .. 32768 .. 536870912] sam, stm32{f0,f1,f3,f4,g4,l1} Inputs: [4096 .. 327680 .. 536870912] stm32{f4,l4} Inputs: [4096 .. 36864 .. 536870912] stm32g0 Inputs: [4096 .. 393216 .. 536870912] stm32f7 Inputs: [4096 .. 40960 .. 536870912] stm32{f3,l4} Inputs: [4096 .. 49152 .. 536870912] stm32{f1,l1} Inputs: [4096 .. 524288 .. 536870912] stm32f7 Inputs: [4096 .. 6144 .. 536870912] stm32{f0,f1} Inputs: [4096 .. 65536 .. 536870912] stm32{f1,f2,f3,f4,l4} Inputs: [4096 .. 655360 .. 536870912] stm32l4 Inputs: [4096 .. 8192 .. 536870912] sam, stm32{f0,f1,g0,l0,l1} Inputs: [4096 .. 81920 .. 536870912] stm32l1 Inputs: [4096 .. 98304 .. 536870912] stm32{f2,f4} Inputs: [4096 ... 536870912] sam, stm32{f0,f1,l1}","title":"minimum_pool_size"},{"location":"reference/module/modm-tlsf/#subdivisions","text":"Number of subdivisions per memory pool Default: 16 Inputs: [16, 32] Limited availability: Check with 'lbuild discover' if this module is available for your target!","title":"subdivisions"},{"location":"reference/module/modm-ui-animation/","text":"Animators \u00b6 lbuild module: modm:ui:animation Various classes for animating values. Dependencies \u00b6 modm:ui:animation modm_ui_animation modm: ui: animation modm_architecture_clock modm: architecture: clock modm_ui_animation->modm_architecture_clock modm_math_utils modm: math: utils modm_ui_animation->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:animation"},{"location":"reference/module/modm-ui-animation/#animators","text":"lbuild module: modm:ui:animation Various classes for animating values.","title":"Animators"},{"location":"reference/module/modm-ui-animation/#dependencies","text":"modm:ui:animation modm_ui_animation modm: ui: animation modm_architecture_clock modm: architecture: clock modm_ui_animation->modm_architecture_clock modm_math_utils modm: math: utils modm_ui_animation->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui-button/","text":"Debouncing Buttons \u00b6 lbuild module: modm:ui:button The modm::ButtonGroup class is able to debounce eight buttons at the same time. The buttons have to be low-active. If this isn't the case invert their signal before passing it to the update() method. The update() method needs to be called periodically for example every 10ms. Preferred in a timer interrupt function. The detection for long or repeated presses works only correctly for one key at a time. This constraint only applies to buttons listed in the mask variable. Mode 1: Timeline ----> __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressed() ----X-------X----------------------X------- isRepeated() --------------------X--X--X--X------------- isReleased() -------X----------------------X-------X---- | |__|__| |_______| \\ / \\ interval timeout Mode 2: __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressedShort() -------X------------------------------X---- isPressedLong() --------------------X---------------------- isReleased() -------X----------------------X-------X---- This implementation is based on the C functions written by Peter Dannegger (see http://www.mikrocontroller.net/topic/48465 ). Dependencies \u00b6 modm:ui:button modm_ui_button modm: ui: button modm_architecture_atomic modm: architecture: atomic modm_ui_button->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:button"},{"location":"reference/module/modm-ui-button/#debouncing-buttons","text":"lbuild module: modm:ui:button The modm::ButtonGroup class is able to debounce eight buttons at the same time. The buttons have to be low-active. If this isn't the case invert their signal before passing it to the update() method. The update() method needs to be called periodically for example every 10ms. Preferred in a timer interrupt function. The detection for long or repeated presses works only correctly for one key at a time. This constraint only applies to buttons listed in the mask variable. Mode 1: Timeline ----> __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressed() ----X-------X----------------------X------- isRepeated() --------------------X--X--X--X------------- isReleased() -------X----------------------X-------X---- | |__|__| |_______| \\ / \\ interval timeout Mode 2: __ _________________ __ getState() ____/ \\____/ \\____/ \\____ isPressedShort() -------X------------------------------X---- isPressedLong() --------------------X---------------------- isReleased() -------X----------------------X-------X---- This implementation is based on the C functions written by Peter Dannegger (see http://www.mikrocontroller.net/topic/48465 ).","title":"Debouncing Buttons"},{"location":"reference/module/modm-ui-button/#dependencies","text":"modm:ui:button modm_ui_button modm: ui: button modm_architecture_atomic modm: architecture: atomic modm_ui_button->modm_architecture_atomic @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui-color/","text":"Color \u00b6 lbuild module: modm:ui:color RGB and HSV containers and converters. Dependencies \u00b6 modm:ui:color modm_ui_color modm: ui: color modm_io modm: io modm_ui_color->modm_io modm_math_utils modm: math: utils modm_ui_color->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:color"},{"location":"reference/module/modm-ui-color/#color","text":"lbuild module: modm:ui:color RGB and HSV containers and converters.","title":"Color"},{"location":"reference/module/modm-ui-color/#dependencies","text":"modm:ui:color modm_ui_color modm: ui: color modm_io modm: io modm_ui_color->modm_io modm_math_utils modm: math: utils modm_ui_color->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui-display/","text":"Display Graphics \u00b6 lbuild module: modm:ui:display Code for writing and drawing on character and graphical displays. Coordinate System \u00b6 (0, 0) +---------------------+ | ----> X | | | | | | | | V Y | | | | | | | +---------------------+ e.g. (127, 63) The size (width and height) of a graphics primitive always correspond to its mathematical model, ignoring the rendered with. As everything is drawn one pixel wide, the pixels will be rendered to the right and below the mathematically defined points. Dependencies \u00b6 modm:ui:display modm_ui_display modm: ui: display modm_architecture_accessor modm: architecture: accessor modm_ui_display->modm_architecture_accessor modm_io modm: io modm_ui_display->modm_io modm_math_geometry modm: math: geometry modm_ui_display->modm_math_geometry modm_math_utils modm: math: utils modm_ui_display->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:display"},{"location":"reference/module/modm-ui-display/#display-graphics","text":"lbuild module: modm:ui:display Code for writing and drawing on character and graphical displays.","title":"Display Graphics"},{"location":"reference/module/modm-ui-display/#coordinate-system","text":"(0, 0) +---------------------+ | ----> X | | | | | | | | V Y | | | | | | | +---------------------+ e.g. (127, 63) The size (width and height) of a graphics primitive always correspond to its mathematical model, ignoring the rendered with. As everything is drawn one pixel wide, the pixels will be rendered to the right and below the mathematically defined points.","title":"Coordinate System"},{"location":"reference/module/modm-ui-display/#dependencies","text":"modm:ui:display modm_ui_display modm: ui: display modm_architecture_accessor modm: architecture: accessor modm_ui_display->modm_architecture_accessor modm_io modm: io modm_ui_display->modm_io modm_math_geometry modm: math: geometry modm_ui_display->modm_math_geometry modm_math_utils modm: math: utils modm_ui_display->modm_math_utils @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui-gui/","text":"Graphical User Interface \u00b6 lbuild module: modm:ui:gui Various classes for creating GUI applications. Dependencies \u00b6 modm:ui:gui modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_gui modm_container modm: container modm_ui_gui->modm_container modm_debug modm: debug modm_ui_gui->modm_debug modm_processing_timer modm: processing: timer modm_ui_gui->modm_processing_timer modm_ui_display modm: ui: display modm_ui_gui->modm_ui_display modm_ui_menu modm: ui: menu modm_ui_gui->modm_ui_menu @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:gui"},{"location":"reference/module/modm-ui-gui/#graphical-user-interface","text":"lbuild module: modm:ui:gui Various classes for creating GUI applications.","title":"Graphical User Interface"},{"location":"reference/module/modm-ui-gui/#dependencies","text":"modm:ui:gui modm_ui_gui modm: ui: gui modm_ui_gui->modm_ui_gui modm_container modm: container modm_ui_gui->modm_container modm_debug modm: debug modm_ui_gui->modm_debug modm_processing_timer modm: processing: timer modm_ui_gui->modm_processing_timer modm_ui_display modm: ui: display modm_ui_gui->modm_ui_display modm_ui_menu modm: ui: menu modm_ui_gui->modm_ui_menu @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui-led/","text":"LED Animation and Gamma Correction \u00b6 lbuild module: modm:ui:led Header: #include <modm/ui/led.hpp> This module provides abstractions for animating LEDs by wrapping the modm:ui:animation module and providing look-up tables for performing gamma correction of LED brightness. The main functionality is part of the modm::ui::Led class, which provides a basic interface to fade an LED with an 8-bit value. Note that this class does not do any gamma correction on it's own, it just wraps an 8-bit modm::ui::Animation and a 8-bit value. You must provide a function handler which gets called whenever the LED value needs updating, at most every 1ms, but only when the value has actually changed. The implementation of this function is up to you. void led_handler ( uint8_t brightness ) { // LED control implementation = brightness } modm :: ui :: Led led_function ( led_handler ); // You may also use a lambda function for brevity modm :: ui :: Led led_lambda ([]( uint8_t brightness ) { // LED control implementation = brightness }); Animating LEDs \u00b6 To animate the LED you need to call the modm::ui::Led::update() member function regularly. The function updates the LED value at most every 1ms, however you may call it more often than that. If the function is called less regularly, it will automatically catch up the skipped milliseconds, and execute the brightness handler at most once if the value has changed. Depending on how smooth you require your animation to be, you may call the update function with intervals of up to 250ms. You can also pass the modm::ui::Led class directly into the modm::ui::KeyFrameAnimation class and it's derivatives, to animate it's brightness by interpolating between key frames. Note that you only need to call the update() member of the animator! modm :: ui :: Led led ; modm :: ui :: Indicator < uint8_t > indicator ( led ); indicator . start (); while ( true ) { indicator . update (); } If you want to animate a lot of LEDs it is more efficient to execute all update methods inside a 1ms modm::PeriodicTimer : modm :: PeriodicTimer update_timer ( 1 ); while ( true ) { if ( update_timer . execute ()) { led1 . update (); led2 . update (); // ... ledN . update (); } } Using Gamma Correction \u00b6 In order to map the linearly animated brightness value to a gamma-corrected value, this module by default generates look-up tables for a gamma value of 2.2 mapping from a 256 input range to 7, 8, 10, 12 and 16 bit resolution output ranges. The generated tables have this naming schema: modm::ui::table{gamma}_{output_bits}_{input_range} . For example, you can set up a timer to output 16-bit PWM to drive your LED, and use the modm::ui::table22_16_256 table to map the linear LED animation values to a gamma corrected 16-bit value: modm :: ui :: Led led_timer ([]( uint8_t brightness ) { Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_256 [ brightness ]); }); You may also generate other tables using the module options, for example, if you want to map a percentage (0-100%) to LED brightness, without scaling this to the full 256 value range, you can also generate a 100 value look-up table: <option name= \"modm:ui:led:range\" > 100,256 </option> <option name= \"modm:ui:led:bit\" > 8,16 </option> This module generated the product of these options, in this case 4 look-up tables. The linker will throw out those you don't use. namespace modm :: ui { /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 100 steps at 100 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_100 ; /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 256 steps at 256 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_256 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 100 steps at 200 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_100 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 256 steps at 512 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_256 ; } You can then animate your LED in the 0-99 value range: modm :: ui :: Led led_percentage ([]( uint8_t brightness ) { if ( brightness >= 100 ) brightness = 99 ; Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_100 [ brightness ]); }); uint8_t percent = 50 ; // fade to 50% brightness within 1 second led_percentage . fadeTo ( percent , 1000 ); Note that you can also use the handler to animate LEDs which are connected externally, for example, via a WS2812 LED chain. Here you can use a helper function to map the values into an array which then transferred into the WS2812 LED chain. uint8_t ws2812_values [ 3 ]; void ws2812_setter ( uint8_t index , uint8_t brightness ) { ws2812_values [ index ] = modm :: ui :: table22_8_256 [ brightness ]; } // Construct an array of LED animators modm :: ui :: Led leds [ 3 ] = { { []( uint8_t b ) { ws2812_setter ( 0 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 1 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 2 , b ); } }, }; // Group them together as one RGB LED modm :: ui :: RgbLed rgb ( leds [ 1 ], leds [ 0 ], leds [ 2 ]); // animate to orange within 2 seconds rgb . fadeTo ( modm :: ui :: Rgb ( 95 , 177 , 147 ), 2000 ); Options \u00b6 bit \u00b6 Resolution of target values Default: {12, 16, 7, 8} Inputs: [2 ... 16] gamma \u00b6 Gamma correction of values Default: {2.2} Inputs: [1.0 ... 3.0] range \u00b6 Range of input values Default: {256} Inputs: [2 ... 1024] Dependencies \u00b6 modm:ui:led modm_ui_led modm: ui: led modm_architecture_accessor modm: architecture: accessor modm_ui_led->modm_architecture_accessor modm_architecture_clock modm: architecture: clock modm_ui_led->modm_architecture_clock modm_processing_timer modm: processing: timer modm_ui_led->modm_processing_timer modm_ui_animation modm: ui: animation modm_ui_led->modm_ui_animation modm_ui_color modm: ui: color modm_ui_led->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:led"},{"location":"reference/module/modm-ui-led/#led-animation-and-gamma-correction","text":"lbuild module: modm:ui:led Header: #include <modm/ui/led.hpp> This module provides abstractions for animating LEDs by wrapping the modm:ui:animation module and providing look-up tables for performing gamma correction of LED brightness. The main functionality is part of the modm::ui::Led class, which provides a basic interface to fade an LED with an 8-bit value. Note that this class does not do any gamma correction on it's own, it just wraps an 8-bit modm::ui::Animation and a 8-bit value. You must provide a function handler which gets called whenever the LED value needs updating, at most every 1ms, but only when the value has actually changed. The implementation of this function is up to you. void led_handler ( uint8_t brightness ) { // LED control implementation = brightness } modm :: ui :: Led led_function ( led_handler ); // You may also use a lambda function for brevity modm :: ui :: Led led_lambda ([]( uint8_t brightness ) { // LED control implementation = brightness });","title":"LED Animation and Gamma Correction"},{"location":"reference/module/modm-ui-led/#animating-leds","text":"To animate the LED you need to call the modm::ui::Led::update() member function regularly. The function updates the LED value at most every 1ms, however you may call it more often than that. If the function is called less regularly, it will automatically catch up the skipped milliseconds, and execute the brightness handler at most once if the value has changed. Depending on how smooth you require your animation to be, you may call the update function with intervals of up to 250ms. You can also pass the modm::ui::Led class directly into the modm::ui::KeyFrameAnimation class and it's derivatives, to animate it's brightness by interpolating between key frames. Note that you only need to call the update() member of the animator! modm :: ui :: Led led ; modm :: ui :: Indicator < uint8_t > indicator ( led ); indicator . start (); while ( true ) { indicator . update (); } If you want to animate a lot of LEDs it is more efficient to execute all update methods inside a 1ms modm::PeriodicTimer : modm :: PeriodicTimer update_timer ( 1 ); while ( true ) { if ( update_timer . execute ()) { led1 . update (); led2 . update (); // ... ledN . update (); } }","title":"Animating LEDs"},{"location":"reference/module/modm-ui-led/#using-gamma-correction","text":"In order to map the linearly animated brightness value to a gamma-corrected value, this module by default generates look-up tables for a gamma value of 2.2 mapping from a 256 input range to 7, 8, 10, 12 and 16 bit resolution output ranges. The generated tables have this naming schema: modm::ui::table{gamma}_{output_bits}_{input_range} . For example, you can set up a timer to output 16-bit PWM to drive your LED, and use the modm::ui::table22_16_256 table to map the linear LED animation values to a gamma corrected 16-bit value: modm :: ui :: Led led_timer ([]( uint8_t brightness ) { Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_256 [ brightness ]); }); You may also generate other tables using the module options, for example, if you want to map a percentage (0-100%) to LED brightness, without scaling this to the full 256 value range, you can also generate a 100 value look-up table: <option name= \"modm:ui:led:range\" > 100,256 </option> <option name= \"modm:ui:led:bit\" > 8,16 </option> This module generated the product of these options, in this case 4 look-up tables. The linker will throw out those you don't use. namespace modm :: ui { /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 100 steps at 100 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_100 ; /// 2.2 gamma correction with 8-bit resolution (0 to 255) in 256 steps at 256 bytes. extern modm :: accessor :: Flash < uint8_t > table22_8_256 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 100 steps at 200 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_100 ; /// 2.2 gamma correction with 16-bit resolution (0 to 65535) in 256 steps at 512 bytes. extern modm :: accessor :: Flash < uint16_t > table22_16_256 ; } You can then animate your LED in the 0-99 value range: modm :: ui :: Led led_percentage ([]( uint8_t brightness ) { if ( brightness >= 100 ) brightness = 99 ; Timer4 :: setCompareValue ( 1 , modm :: ui :: table22_16_100 [ brightness ]); }); uint8_t percent = 50 ; // fade to 50% brightness within 1 second led_percentage . fadeTo ( percent , 1000 ); Note that you can also use the handler to animate LEDs which are connected externally, for example, via a WS2812 LED chain. Here you can use a helper function to map the values into an array which then transferred into the WS2812 LED chain. uint8_t ws2812_values [ 3 ]; void ws2812_setter ( uint8_t index , uint8_t brightness ) { ws2812_values [ index ] = modm :: ui :: table22_8_256 [ brightness ]; } // Construct an array of LED animators modm :: ui :: Led leds [ 3 ] = { { []( uint8_t b ) { ws2812_setter ( 0 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 1 , b ); } }, { []( uint8_t b ) { ws2812_setter ( 2 , b ); } }, }; // Group them together as one RGB LED modm :: ui :: RgbLed rgb ( leds [ 1 ], leds [ 0 ], leds [ 2 ]); // animate to orange within 2 seconds rgb . fadeTo ( modm :: ui :: Rgb ( 95 , 177 , 147 ), 2000 );","title":"Using Gamma Correction"},{"location":"reference/module/modm-ui-led/#options","text":"","title":"Options"},{"location":"reference/module/modm-ui-led/#bit","text":"Resolution of target values Default: {12, 16, 7, 8} Inputs: [2 ... 16]","title":"bit"},{"location":"reference/module/modm-ui-led/#gamma","text":"Gamma correction of values Default: {2.2} Inputs: [1.0 ... 3.0]","title":"gamma"},{"location":"reference/module/modm-ui-led/#range","text":"Range of input values Default: {256} Inputs: [2 ... 1024]","title":"range"},{"location":"reference/module/modm-ui-led/#dependencies","text":"modm:ui:led modm_ui_led modm: ui: led modm_architecture_accessor modm: architecture: accessor modm_ui_led->modm_architecture_accessor modm_architecture_clock modm: architecture: clock modm_ui_led->modm_architecture_clock modm_processing_timer modm: processing: timer modm_ui_led->modm_processing_timer modm_ui_animation modm: ui: animation modm_ui_led->modm_ui_animation modm_ui_color modm: ui: color modm_ui_led->modm_ui_color @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui-menu/","text":"Display Menu \u00b6 lbuild module: modm:ui:menu Simple to use classes for implementing menu structures on graphic displays. Some convenience classes for implementing menus. The menus are using a stack to allow stepping forward and backwards through the screens. The menus are based on the usage of five buttons. Inside most of the screens these buttons have the following functions: Left: Go back one screen. Right: Go to next screen. Up: Go to previous selected entry on screen Down: Go to next entry on screen OK: Edit selected entry Warning Some classes currently only work with the font modm::font::FixedWidth5x8 ! Dependencies \u00b6 modm:ui:menu modm_ui_menu modm: ui: menu modm_communication_xpcc modm: communication: xpcc modm_ui_menu->modm_communication_xpcc modm_container modm: container modm_ui_menu->modm_container modm_processing_timer modm: processing: timer modm_ui_menu->modm_processing_timer modm_ui_display modm: ui: display modm_ui_menu->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:menu"},{"location":"reference/module/modm-ui-menu/#display-menu","text":"lbuild module: modm:ui:menu Simple to use classes for implementing menu structures on graphic displays. Some convenience classes for implementing menus. The menus are using a stack to allow stepping forward and backwards through the screens. The menus are based on the usage of five buttons. Inside most of the screens these buttons have the following functions: Left: Go back one screen. Right: Go to next screen. Up: Go to previous selected entry on screen Down: Go to next entry on screen OK: Edit selected entry Warning Some classes currently only work with the font modm::font::FixedWidth5x8 !","title":"Display Menu"},{"location":"reference/module/modm-ui-menu/#dependencies","text":"modm:ui:menu modm_ui_menu modm: ui: menu modm_communication_xpcc modm: communication: xpcc modm_ui_menu->modm_communication_xpcc modm_container modm: container modm_ui_menu->modm_container modm_processing_timer modm: processing: timer modm_ui_menu->modm_processing_timer modm_ui_display modm: ui: display modm_ui_menu->modm_ui_display @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui-time/","text":"Date and Time \u00b6 lbuild module: modm:ui:time Dependencies \u00b6 modm:ui:time modm_ui_time modm: ui: time modm_architecture_accessor modm: architecture: accessor modm_ui_time->modm_architecture_accessor @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":ui:time"},{"location":"reference/module/modm-ui-time/#date-and-time","text":"lbuild module: modm:ui:time","title":"Date and Time"},{"location":"reference/module/modm-ui-time/#dependencies","text":"modm:ui:time modm_ui_time modm: ui: time modm_architecture_accessor modm: architecture: accessor modm_ui_time->modm_architecture_accessor @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-ui/","text":"User interface \u00b6 lbuild module: modm:ui Interfacing with human users. Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures.","title":":ui"},{"location":"reference/module/modm-ui/#user-interface","text":"lbuild module: modm:ui Interfacing with human users. Contains code for Graphics, Buttons, LEDs, Animations, Menu Structures.","title":"User interface"},{"location":"reference/module/modm-unittest/","text":"Unit Tests \u00b6 lbuild module: modm:unittest Lightweight library for on-device unit testing. Dependencies \u00b6 modm:unittest modm_unittest modm: unittest modm_architecture_accessor modm: architecture: accessor modm_unittest->modm_architecture_accessor modm_io modm: io modm_unittest->modm_io @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":unittest"},{"location":"reference/module/modm-unittest/#unit-tests","text":"lbuild module: modm:unittest Lightweight library for on-device unit testing.","title":"Unit Tests"},{"location":"reference/module/modm-unittest/#dependencies","text":"modm:unittest modm_unittest modm: unittest modm_architecture_accessor modm: architecture: accessor modm_unittest->modm_architecture_accessor modm_io modm: io modm_unittest->modm_io @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"},{"location":"reference/module/modm-utils/","text":"Utilities \u00b6 lbuild module: modm:utils Dependencies \u00b6 modm:utils modm_utils modm: utils modm_architecture modm: architecture modm_utils->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":":utils"},{"location":"reference/module/modm-utils/#utilities","text":"lbuild module: modm:utils","title":"Utilities"},{"location":"reference/module/modm-utils/#dependencies","text":"modm:utils modm_utils modm: utils modm_architecture modm: architecture modm_utils->modm_architecture @media(prefers-color-scheme:dark){svg.deps{filter:invert(100%);}}","title":"Dependencies"}]}